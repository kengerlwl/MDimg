{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/matery/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"themes/matery/source/css/matery.css","path":"css/matery.css","modified":0,"renderable":1},{"_id":"themes/matery/source/css/gitment.css","path":"css/gitment.css","modified":0,"renderable":1},{"_id":"themes/matery/source/js/matery.js","path":"js/matery.js","modified":0,"renderable":1},{"_id":"themes/matery/source/css/my.css","path":"css/my.css","modified":0,"renderable":1},{"_id":"themes/matery/source/css/my-gitalk.css","path":"css/my-gitalk.css","modified":0,"renderable":1},{"_id":"themes/matery/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/contact.jpg","path":"medias/contact.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/logo.png","path":"medias/logo.png","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.css","path":"libs/aplayer/APlayer.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/aos/aos.js","path":"libs/aos/aos.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/aos/aos.css","path":"libs/aos/aos.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeCopy.js","path":"libs/codeBlock/codeCopy.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/clipboard.min.js","path":"libs/codeBlock/clipboard.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeBlockFuction.js","path":"libs/codeBlock/codeBlockFuction.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeLang.js","path":"libs/codeBlock/codeLang.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/codeBlock/codeShrink.js","path":"libs/codeBlock/codeShrink.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/animate/animate.min.css","path":"libs/animate/animate.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/gitalk/gitalk.css","path":"libs/gitalk/gitalk.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.css","path":"libs/dplayer/DPlayer.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/cryptojs/crypto-js.min.js","path":"libs/cryptojs/crypto-js.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/gitment/gitment-default.css","path":"libs/gitment/gitment-default.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/jqcloud/jqcloud.css","path":"libs/jqcloud/jqcloud.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","path":"libs/jqcloud/jqcloud-1.0.4.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/masonry/masonry.pkgd.min.js","path":"libs/masonry/masonry.pkgd.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/others/clicklove.js","path":"libs/others/clicklove.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/others/busuanzi.pure.mini.js","path":"libs/others/busuanzi.pure.mini.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/others/explosion.min.js","path":"libs/others/explosion.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/others/fireworks.js","path":"libs/others/fireworks.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/scrollprogress/scrollProgress.min.js","path":"libs/scrollprogress/scrollProgress.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/others/text.js","path":"libs/others/text.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/others/snow.js","path":"libs/others/snow.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/tocbot/tocbot.css","path":"libs/tocbot/tocbot.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/tocbot/tocbot.min.js","path":"libs/tocbot/tocbot.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/ajin.jpg","path":"medias/avatars/ajin.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/babyq.png","path":"medias/avatars/babyq.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/fun4go.png","path":"medias/avatars/fun4go.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/cww97.jpg","path":"medias/avatars/cww97.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/huaji.jpg","path":"medias/avatars/huaji.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/hael.jpg","path":"medias/avatars/hael.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/hzwer.jpg","path":"medias/avatars/hzwer.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/ids2.jpg","path":"medias/avatars/ids2.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/kewlgrl.jpg","path":"medias/avatars/kewlgrl.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/masterx.jpg","path":"medias/avatars/masterx.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/michael.jpg","path":"medias/avatars/michael.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/mpy634.png","path":"medias/avatars/mpy634.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/mouse.jpg","path":"medias/avatars/mouse.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/taotao.jpg","path":"medias/avatars/taotao.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/taowei.jpg","path":"medias/avatars/taowei.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/spacesac.png","path":"medias/avatars/spacesac.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/tawn.jpg","path":"medias/avatars/tawn.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.js","path":"libs/aplayer/APlayer.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/gitment/gitment.js","path":"libs/gitment/gitment.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/jquery/jquery-2.2.0.min.js","path":"libs/jquery/jquery-2.2.0.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/valine/Valine.min.js","path":"libs/valine/Valine.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/avatar.jpg","path":"medias/avatars/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/antnlp.ico","path":"medias/avatars/antnlp.ico","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/bytedtrans.png","path":"medias/avatars/bytedtrans.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/duyupei.jpg","path":"medias/avatars/duyupei.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/gsy.jpg","path":"medias/avatars/gsy.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/mizunashi.png","path":"medias/avatars/mizunashi.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/myzhihu.png","path":"medias/avatars/myzhihu.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/qiandongwei.jpg","path":"medias/avatars/qiandongwei.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/reward/wechat.png","path":"medias/reward/wechat.png","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/css/font-awesome.min.css","path":"libs/awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/gitalk/gitalk.min.js","path":"libs/gitalk/gitalk.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.js","path":"libs/dplayer/DPlayer.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.eot","path":"libs/lightGallery/fonts/lg.eot","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/css/lightgallery.min.css","path":"libs/lightGallery/css/lightgallery.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.woff","path":"libs/lightGallery/fonts/lg.woff","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.ttf","path":"libs/lightGallery/fonts/lg.ttf","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/loading.gif","path":"libs/lightGallery/img/loading.gif","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/video-play.png","path":"libs/lightGallery/img/video-play.png","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/materialize/materialize.min.css","path":"libs/materialize/materialize.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/vimeo-play.png","path":"libs/lightGallery/img/vimeo-play.png","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/youtube-play.png","path":"libs/lightGallery/img/youtube-play.png","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/css/share.min.css","path":"libs/share/css/share.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/js/lightgallery-all.min.js","path":"libs/lightGallery/js/lightgallery-all.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/materialize/materialize.min.js","path":"libs/materialize/materialize.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.svg","path":"libs/share/fonts/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.eot","path":"libs/share/fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/js/jquery.share.min.js","path":"libs/share/js/jquery.share.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.ttf","path":"libs/share/fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/valine/av-min.js","path":"libs/valine/av-min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/js/social-share.min.js","path":"libs/share/js/social-share.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.woff","path":"libs/share/fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/0xbird.png","path":"medias/avatars/0xbird.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/lzh.png","path":"medias/avatars/lzh.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/lyn-draw.jpg","path":"medias/avatars/lyn-draw.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/mashiro.jpg","path":"medias/avatars/mashiro.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/milyyy.jpg","path":"medias/avatars/milyyy.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/qianqian.png","path":"medias/avatars/qianqian.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/tiantangdemogui.jpg","path":"medias/music/avatars/tiantangdemogui.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/yequ.jpg","path":"medias/music/avatars/yequ.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/yiluxiangbei.jpg","path":"medias/music/avatars/yiluxiangbei.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff","path":"libs/awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff2","path":"libs/awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.svg","path":"libs/lightGallery/fonts/lg.svg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.ttf","path":"libs/awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/feibar.png","path":"medias/avatars/feibar.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/10.jpg","path":"medias/featureimages/10.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/4.jpg","path":"medias/featureimages/4.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/FontAwesome.otf","path":"libs/awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/4.jpg","path":"medias/banner/4.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.eot","path":"libs/awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatars/jingjing.jpg","path":"medias/avatars/jingjing.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/10.jpg","path":"medias/banner/10.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/music/avatars/daoshu.jpg","path":"medias/music/avatars/daoshu.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.svg","path":"libs/awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/14.png","path":"medias/featureimages/14.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/14.png","path":"medias/banner/14.png","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/echarts/echarts.min.js","path":"libs/echarts/echarts.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/8.png","path":"medias/banner/8.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/9.jpg","path":"medias/banner/9.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/8.png","path":"medias/featureimages/8.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/9.jpg","path":"medias/featureimages/9.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/3.png","path":"medias/featureimages/3.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/3.png","path":"medias/banner/3.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/7.jpg","path":"medias/featureimages/7.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/7.jpg","path":"medias/banner/7.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/13.jpg","path":"medias/banner/13.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/6.jpg","path":"medias/banner/6.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/13.jpg","path":"medias/featureimages/13.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/6.jpg","path":"medias/featureimages/6.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/11.jpg","path":"medias/featureimages/11.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/5.jpg","path":"medias/featureimages/5.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/11.jpg","path":"medias/banner/11.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/5.jpg","path":"medias/banner/5.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/0.jpg","path":"medias/banner/0.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/0.jpg","path":"medias/featureimages/0.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/2.jpg","path":"medias/featureimages/2.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/15.png","path":"medias/featureimages/15.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/1.jpg","path":"medias/banner/1.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/15.png","path":"medias/banner/15.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/1.jpg","path":"medias/featureimages/1.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/2.jpg","path":"medias/banner/2.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/12.jpg","path":"medias/featureimages/12.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/12.jpg","path":"medias/banner/12.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/matery/LICENSE","hash":"b314c7ebb7d599944981908b7f3ed33a30e78f3a","modified":1627563282000},{"_id":"themes/matery/.DS_Store","hash":"59527055eeaf78ffcfc8b288a40b67de71470653","modified":1677492041766},{"_id":"themes/matery/.gitignore","hash":"eaa3d84cb77d92a21b111fd1e37f53edc1ff9de0","modified":1627563282000},{"_id":"themes/matery/README.md","hash":"ed3803e5d71216cc8599a45786c71e15d1805399","modified":1677496728598},{"_id":"themes/matery/_config.yml","hash":"74126110779afbfad21d5d6cac0e824a0399c298","modified":1677496900606},{"_id":"source/404.md","hash":"7a6ed0ad472f8ee39a37fdebf467980cb2f5a6f7","modified":1677495522116},{"_id":"themes/matery/README_CN.md","hash":"3c9a5ed851a999171c7667e58a67a389014ea250","modified":1677496624045},{"_id":"source/CNAME","hash":"c0d2c0e3668168f4916226dd999a27dbfbdc8046","modified":1677495534610},{"_id":"themes/matery/layout/404.ejs","hash":"f08a0f507b36f3652520a41381f71167488405c7","modified":1627563282000},{"_id":"themes/matery/layout/about.ejs","hash":"e87752e59f021b5139b1155a264da11ab469a9aa","modified":1627563282000},{"_id":"themes/matery/layout/archive.ejs","hash":"1b5023571894404d75caffa28128fc9c49f9095d","modified":1627563282000},{"_id":"themes/matery/layout/category.ejs","hash":"2d421e10c3b8fd2c4f725e5eaa967c4a1429c707","modified":1627563282000},{"_id":"themes/matery/layout/contact.ejs","hash":"1513c5a40b7cc0b6e5854cf8c3253958bcb486cb","modified":1627563282000},{"_id":"themes/matery/layout/categories.ejs","hash":"c431e772d0f7700592228bbd9502793bdc28a893","modified":1627563282000},{"_id":"themes/matery/layout/friends.ejs","hash":"895e40a864796680fbef581e4b09f252fbdd963a","modified":1627563282000},{"_id":"themes/matery/layout/index.ejs","hash":"7fc5a6c4f0229c0be43b7d1315524c468346fbb8","modified":1627563282000},{"_id":"themes/matery/layout/layout.ejs","hash":"2ba4110dc596424b1220a259c8e594da774e7f59","modified":1627563282000},{"_id":"themes/matery/layout/post.ejs","hash":"f1a35f32e5901e167ae9a750e7cb3635549cea2e","modified":1627563282000},{"_id":"themes/matery/layout/tags.ejs","hash":"851c0ee599e91e7b1d657673859e8b6ff79cf50b","modified":1627563282000},{"_id":"themes/matery/layout/tag.ejs","hash":"5cdf3a1d72f54285ee9cb826fd0e4a0449093215","modified":1627563282000},{"_id":"themes/matery/source/.DS_Store","hash":"498a6ce7cc39bb225034f5b72c395a2bfbc89eb5","modified":1677492326504},{"_id":"themes/matery/languages/zh-CN.yml","hash":"d92db4b986bb6f0d228e9a8249383103bf56342d","modified":1627563282000},{"_id":"themes/matery/languages/default.yml","hash":"527c795b8c41fe62bf35603ffebfa6d4a7929a2c","modified":1627563282000},{"_id":"source/_data/musics.json","hash":"32bc061f34721b4ff55f880de1d0ec5787acd2f9","modified":1627563282000},{"_id":"source/_data/friends.json","hash":"324cd5856ee26613cc42da6eda447611de29fb65","modified":1677495406450},{"_id":"source/about/index.md","hash":"b3a20901649d892c89c81c8ad846d28223b3afee","modified":1677491866225},{"_id":"source/contact/index.md","hash":"3b158d6157e5adbe06feaf27466f278b0cbdb65d","modified":1677495509506},{"_id":"source/friends/index.md","hash":"1ac316eb35e6465e0d726edae2fc33123a991023","modified":1677495504315},{"_id":"source/categories/index.md","hash":"58129523463f83038832f7febed02a178ace9a43","modified":1677495456894},{"_id":"source/archives/index.md","hash":"00351583bc41cb8deff9ca13f799e7abb08f4964","modified":1677495450313},{"_id":"source/tags/index.md","hash":"bc2a151cb64f9ebc55eaad35131311641c9a6b29","modified":1677495498980},{"_id":"themes/matery/source/favicon.png","hash":"7f2a0ce94192eec2743b2dbae4cb2355b469ffa5","modified":1677489940420},{"_id":"source/_posts/dl/新建文件.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1677497673132},{"_id":"source/_posts/实验室维护/高效内网分流策略.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1677497673143},{"_id":"source/_posts/代理/代码批量测试.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1677497673134},{"_id":"themes/matery/layout/_widget/category-cloud.ejs","hash":"b2b22d4fc4e46b051f67216c391f629f4ff552b5","modified":1627563282000},{"_id":"themes/matery/layout/_widget/dream.ejs","hash":"6ae58a57b83a5999d0b6a737ec868f084d208f89","modified":1627563282000},{"_id":"themes/matery/layout/_widget/category-radar.ejs","hash":"5284712d84bbaa4f0d88026ac3ec5a8c13e00056","modified":1627563282000},{"_id":"themes/matery/layout/_widget/music.ejs","hash":"fc50cb4bbc1f4d0e4c9f5941f1c3c74bea742db7","modified":1627563282000},{"_id":"themes/matery/layout/_widget/my-gallery.ejs","hash":"9ea672db65f1e5b8fad1ffafb1614f25adc97e63","modified":1627563282000},{"_id":"themes/matery/layout/_widget/my-projects.ejs","hash":"785cb588a31215876f6737213054ba0e8552fff0","modified":1627563282000},{"_id":"themes/matery/layout/_widget/my-skills.ejs","hash":"c6f713316ce75ad08ac5d1587bd8ce42e894e9ae","modified":1627563282000},{"_id":"themes/matery/layout/_widget/post-calendar.ejs","hash":"4608af6151f0e32f668c89f09343748340021478","modified":1627563282000},{"_id":"themes/matery/layout/_widget/tag-cloud.ejs","hash":"6310903eb0e434d6f9a59ca669aab7fae38d4797","modified":1627563282000},{"_id":"themes/matery/layout/_widget/recommend.ejs","hash":"d439d86818de179d64965d4f7f5fa56147fd9221","modified":1627563282000},{"_id":"themes/matery/layout/_widget/video.ejs","hash":"05f5e2acace5730cdf7bed650375ad88f6b5d1b7","modified":1627563282000},{"_id":"themes/matery/layout/_widget/post-charts.ejs","hash":"0aaf0a111b9aa07ff37f6286eeac5506283f47f8","modified":1627563282000},{"_id":"themes/matery/layout/_widget/tag-wordcloud.ejs","hash":"bf604fe9c435f0fb9a559cac9c35772579b590e8","modified":1627563282000},{"_id":"themes/matery/layout/_partial/back-top.ejs","hash":"cb99dc352397ec5d0765794d7b8884972e61973b","modified":1627563282000},{"_id":"themes/matery/layout/_partial/bg-cover-content.ejs","hash":"ab610754bf6aea844b5ae0802ed37c73b5f1dc9f","modified":1627563282000},{"_id":"themes/matery/layout/_partial/disqus.ejs","hash":"42dda8e67f7f09d148347887e52f18aea546df26","modified":1627563282000},{"_id":"themes/matery/layout/_partial/bg-cover.ejs","hash":"d5a7b9bb96e04c0a3485dd873748f19c50a6a04f","modified":1627563282000},{"_id":"themes/matery/layout/_partial/github-link.ejs","hash":"fd4034bca2eb3987dcf113e6477260bee97eb1e7","modified":1627563282000},{"_id":"themes/matery/layout/_partial/gitment.ejs","hash":"d8c40dbc8106b5bc53ceb727ad968c1d8f234261","modified":1627563282000},{"_id":"themes/matery/layout/_partial/gitalk.ejs","hash":"a3a140e6aeeb6f289e4b821a577ef548267f3de1","modified":1627563282000},{"_id":"themes/matery/layout/_partial/google-analytics.ejs","hash":"890c8f04c1f4905dfceb3ea9fd6efdd040d79c01","modified":1627563282000},{"_id":"themes/matery/layout/_partial/header.ejs","hash":"821e1af65990521c9e0288178d8e5b18c73a9cab","modified":1627563282000},{"_id":"themes/matery/layout/_partial/livere.ejs","hash":"42728561c09589f79b698eb059ab4def53ed3642","modified":1627563282000},{"_id":"themes/matery/layout/_partial/mobile-nav.ejs","hash":"e761f0104fbf431671bbe6bebc91ca82f737f4d2","modified":1627563282000},{"_id":"themes/matery/layout/_partial/navigation.ejs","hash":"3a82fcb6f31d69971cb564985842c14ac02cdca0","modified":1627563282000},{"_id":"themes/matery/layout/_partial/footer.ejs","hash":"616ecd5f5619a00386c88833beb75aea103ef5da","modified":1677496571383},{"_id":"themes/matery/layout/_partial/head.ejs","hash":"fb572df037b5a6eb563912caa1f1967ca835a70a","modified":1627563282000},{"_id":"themes/matery/layout/_partial/index-cover.ejs","hash":"d4042e5521ceb5f3255cd4455ac7ccd227fee6df","modified":1627563282000},{"_id":"themes/matery/layout/_partial/post-cover.ejs","hash":"166c0b9753f3f913bd801e82ad5b268004be198d","modified":1627563282000},{"_id":"themes/matery/layout/_partial/post-statis.ejs","hash":"3b42900247d5ea4ea5b68e2be44420a0d54785ad","modified":1627563282000},{"_id":"themes/matery/layout/_partial/post-detail-toc.ejs","hash":"82cb8090cde663fa7ad67418a802997b3057e957","modified":1627563282000},{"_id":"themes/matery/layout/_partial/post-detail.ejs","hash":"3f208f33e4e12becdb8323e6e64e20ad60c3fb2a","modified":1627563282000},{"_id":"themes/matery/layout/_partial/search.ejs","hash":"e859fe6e0259e0c123cb7ceda6e4cac836318ffc","modified":1627563282000},{"_id":"themes/matery/layout/_partial/reward.ejs","hash":"73624d9db81e87ff0c12310bb873fbd0b5221021","modified":1627563282000},{"_id":"themes/matery/layout/_partial/prev-next.ejs","hash":"4e73f10eacb5d00a0681cb44fe5c039cd8ab03cd","modified":1627563282000},{"_id":"themes/matery/layout/_partial/social-link.ejs","hash":"e2865b3003ec07892e9112692e7ec786ee926ae8","modified":1627563282000},{"_id":"themes/matery/layout/_partial/reprint-statement.ejs","hash":"f85a222ec3f9bc27eb7978015e63a16514b38791","modified":1627563282000},{"_id":"themes/matery/layout/_partial/share.ejs","hash":"0f2e1e27d21492cf228e786daead985b1e1dcea4","modified":1627563282000},{"_id":"themes/matery/layout/_partial/paging.ejs","hash":"dfdeea9c59d157acb851d4bf44bf95f81787523c","modified":1627563282000},{"_id":"themes/matery/layout/_partial/valine.ejs","hash":"c3039180ddb2eb17e724b8441e5f93e79859aef7","modified":1627563282000},{"_id":"themes/matery/source/css/matery.css","hash":"0d345a72318fd7aadcb6fcaa6f3abac94b91001c","modified":1627563282000},{"_id":"themes/matery/source/css/gitment.css","hash":"d5ef623065d1fbc897119f7b70ccf7563e329917","modified":1627563282000},{"_id":"themes/matery/source/js/matery.js","hash":"208b7806caa943c115aa0825c9c72a0781404775","modified":1627563282000},{"_id":"themes/matery/source/css/my.css","hash":"37683a9f11c68903a53e2b8593ca8c095a721896","modified":1627563282000},{"_id":"themes/matery/source/css/my-gitalk.css","hash":"4e3e855767ac5a48b13af1d6a42df13d8975e03f","modified":1627563282000},{"_id":"themes/matery/source/js/search.js","hash":"77ecae23dd3edd8ad962c5b12954652bb2f7a1b6","modified":1627563282000},{"_id":"themes/matery/source/medias/.DS_Store","hash":"62d1df4aca3362daf5560c0d7eacf0eb0b8986b0","modified":1677492020440},{"_id":"themes/matery/source/medias/contact.jpg","hash":"ddcca26c52b203ad85330f094d802e51a04cfac8","modified":1677490303473},{"_id":"source/_posts/dl/dl环境cuda.md","hash":"3eee6cc5d653f00b2d1d6748d9c3f1cfef4e44a9","modified":1677497673132},{"_id":"source/_posts/dl/jupyter 的js控制使用摸索.md","hash":"d626e7ee6aa0b734697dddc22de6a3ff9f345442","modified":1677497673133},{"_id":"source/_posts/dl/neo4j知识图谱环境搭建.md","hash":"95d1d3621d170f06e0aaaddfa3f8c54d84c066ad","modified":1677497673130},{"_id":"source/_posts/dl/pytorch调参经验汇总.md","hash":"f83639502058612f1468c31902abe7294412725a","modified":1677497673131},{"_id":"source/_posts/dl/关于print与日志处理.md","hash":"a704627e38e77a4814fd87de4d2fe87cd2448ddc","modified":1677497673131},{"_id":"source/_posts/dl/数据加载器.md","hash":"2dec9c8d9b0fda1a366e5ba1ca41d10dfe2de045","modified":1677497673132},{"_id":"source/_posts/dl/样本失衡问题.md","hash":"48a1f92807232cd8bd0a2e186194909000dcca21","modified":1677497673132},{"_id":"source/_posts/dl/监督，无监督，半监督等学习方式.md","hash":"1d0ff89462d414ad0772b525a9482bc8aac3f5cc","modified":1677497673132},{"_id":"source/_posts/dl/记一次训练loss变成nan值.md","hash":"a9bc5355bef7541d983ca13722984a3ef8b89d5b","modified":1677497673131},{"_id":"source/_posts/dl/表格数据处理pandas与numpy.md","hash":"f25725ce893f019b3daa403212be8614e6378ce0","modified":1677497673131},{"_id":"source/_posts/实验室维护/openwrt mwan 配置多wan复制均衡.md","hash":"177a79fd9992769582e9543e0e3e5b9159ea17e3","modified":1677497673143},{"_id":"source/_posts/实验室维护/一些网络测试常用命令.md","hash":"ff362aeccb49cceeafe55c78502a055ded5d14b4","modified":1677497673143},{"_id":"source/_posts/实验室维护/交换机.md","hash":"9afff37a7ecebad9fd80efbc4600913feb2cc60b","modified":1677497673144},{"_id":"source/_posts/实验室维护/关于我在Ubuntu上配置route.md","hash":"eef681c57fd1637c88b2d4f88c4b3272a047b31a","modified":1677497673143},{"_id":"source/_posts/实验室维护/各种杂乱的知识点.md","hash":"cc61cf4eb1b14026cd9ab7c6c2520e27a76dc88a","modified":1677497673144},{"_id":"source/_posts/代理/openwrt docker旁路由.md","hash":"46e404b7b1dce17c794ab520632ccdb1ec071dab","modified":1677497673133},{"_id":"source/_posts/代理/v2ray与代理，多级代理.md","hash":"6662e117c99010377d5383fdf616d9e716be57e9","modified":1677497673133},{"_id":"source/_posts/代理/免费机场搭建.md","hash":"4b6cf3f3ba3eca1e512abcadcbd24153679337dc","modified":1677497673133},{"_id":"source/_posts/代理/靶机与代理.md","hash":"2d453cc029da4ec2fd7adec06b889a4d2a4c1f3a","modified":1677497673134},{"_id":"source/_posts/代理/自建机场之websocket+tls+cloudflare.md","hash":"302563b76c490f53b036949f9cc74316c40ea84c","modified":1677497673134},{"_id":"source/_posts/服务器相关/.DS_Store","hash":"9d8ab03a3f3e76e32aed88cd3085b3d924fabbd0","modified":1677497673145},{"_id":"source/_posts/服务器相关/Nginx配置.md","hash":"70d8ee09fd6d35b6abdd079bb17c997050834ace","modified":1677497673146},{"_id":"source/_posts/服务器相关/Samba用户管理.md","hash":"157e9148a9d7fd5f27a155885f43e09b7eca8808","modified":1677497673148},{"_id":"source/_posts/服务器相关/centos的yum源的配置.md","hash":"5892a60d4f0cf2c40b6ad6471f7066addb5cf8ef","modified":1677497673145},{"_id":"source/_posts/服务器相关/docker 容器权限管理.md","hash":"72d1198ed26fe9322e85a3bc015b94bb88f769a6","modified":1677497673148},{"_id":"source/_posts/服务器相关/linux同步身份认证.md","hash":"a25a4b39d3d02bf881f44bfe28abdc028621eb9e","modified":1677497673148},{"_id":"source/_posts/服务器相关/linux给每个用户限定存储空间大小.md","hash":"281b59634cdf89a7eae0a916bcdfbb201bd607fb","modified":1677497673144},{"_id":"source/_posts/服务器相关/docker 使用简单教程.md","hash":"7beeabfed41a3b6d775b0a27dd71c963fd1a4204","modified":1677497673146},{"_id":"source/_posts/服务器相关/linux查看系统架构.md","hash":"812207edf96027c3ad16c37549963d98224041dd","modified":1677497673147},{"_id":"source/_posts/服务器相关/shell将命令执行结果赋值给变量.md","hash":"e8c779db75fafe1082d6daf17bfb6c84378022d0","modified":1677497673148},{"_id":"source/_posts/服务器相关/shell小note.md","hash":"104341ff5250d03c561f4d71d30f872c3e3c9acd","modified":1677497673145},{"_id":"source/_posts/服务器相关/ssh连接服务器.md","hash":"8fee5d0871d78bfa57c4a6987f30e50a9a438e55","modified":1677497673146},{"_id":"source/_posts/服务器相关/openwrt防火墙使用.md","hash":"04c10e9ba6968bd0ec745145de9cdf01a9e49fd9","modified":1677497673147},{"_id":"source/_posts/服务器相关/sudo权限管理要记与提权.md","hash":"5e481ef48cb04fde2c291d536e275db056429797","modified":1677497673147},{"_id":"source/_posts/服务器相关/一些不那么常用的linux知识.md","hash":"ba42fdafd3e1e7a7b8bca482e5154bc4b6c6ecc3","modified":1677497673145},{"_id":"source/_posts/服务器相关/命令行浏览器w3m.md","hash":"7b0152e1a146df3b587c2f4cbdb6b50e72b0e790","modified":1677497673147},{"_id":"source/_posts/服务器相关/基于宝塔nginx的多站点管理.md","hash":"1ca8c8b1f5b9f78e5859ce3317d9f69628a13f8a","modified":1677497673147},{"_id":"source/_posts/服务器相关/如何使用docker搭建一套开发环境.md","hash":"4fce114dbb6f2e27290d4a05e0b8e5477463b5e2","modified":1677497673146},{"_id":"source/_posts/服务器相关/服务器挂载其他云盘，例如googledrive，onedrive.md","hash":"0a2037d90a329d016d02b7edc15c17b055c610c3","modified":1677497673147},{"_id":"source/_posts/服务器相关/趣味shell小脚本.md","hash":"797ec0375b5f6f9c16644ea29fa12285b2d54a19","modified":1677497673146},{"_id":"source/_posts/服务器相关/source命令---如何使用conda环境运行脚本（在一些乱七八糟的环境下）.md","hash":"91b568d966097a75d3f0ad96c68bec5c50dd4448","modified":1677497673148},{"_id":"source/_posts/综合/.DS_Store","hash":"dae7161b26cfe394b2d966c08e4299d6ee7d81aa","modified":1677497673137},{"_id":"source/_posts/综合/C++复习.md","hash":"d3e18b40734de80536b3279c52ae3589f10e1b88","modified":1677497673141},{"_id":"source/_posts/综合/Github Action学习CI:CD自动化.md","hash":"d19ef603eee8f4f85c0047f889d03823bde6e4ec","modified":1677497673138},{"_id":"source/_posts/综合/Python Redis，rabbitMQ以及Mysql使用操作教程.md","hash":"9706fb8340b83abd0d50ed8c01f01d5d558452fd","modified":1677497673141},{"_id":"source/_posts/综合/Syncthing多平台文件同步.md","hash":"bd7353212232b73fa8d092f3688eb5510bf41e55","modified":1677497673137},{"_id":"source/_posts/综合/echarts 网络图的绘制.md","hash":"ce575a371c6929cd7254137db8e7bd9b15ea38cb","modified":1677497673139},{"_id":"source/_posts/综合/hexo静态博客搭建.md","hash":"77eb54f1952c61b30e29a4e86cf4ad82f7d6d535","modified":1677497673140},{"_id":"source/_posts/综合/docker 使用简单教程.md","hash":"7beeabfed41a3b6d775b0a27dd71c963fd1a4204","modified":1677497673138},{"_id":"source/_posts/综合/opengl学习.md","hash":"fca3125676fc0542bbc9dda5a108207bf20c6e67","modified":1677497673140},{"_id":"source/_posts/综合/moonlight云电脑.md","hash":"bc6bfddb59e13191c7a60092859ebf6491245b9d","modified":1677497673138},{"_id":"source/_posts/综合/pipenv虚拟环境实用.md","hash":"2d72ba14db89ef569a9138a640943297fa99472a","modified":1677497673136},{"_id":"source/_posts/综合/python 请求重试机制tenacity.md","hash":"3b2ad95d40e19f41ca1058758897c86624c4886f","modified":1677497673135},{"_id":"source/_posts/综合/ps学习.md","hash":"9d39423824188ee202a37708b350f5fe967afa0e","modified":1677497673138},{"_id":"source/_posts/综合/python协程，进程与线程.md","hash":"10fd8c82464284c0ca0393896f04681261c2eb5f","modified":1677497673142},{"_id":"source/_posts/综合/qq机器人搭建.md","hash":"cdbf75277c9506d2261608a45db548260ac6da14","modified":1677497673136},{"_id":"source/_posts/综合/python错误异常处理.md","hash":"f2c451db06055e2f14c574d90df52c5cc128bed2","modified":1677497673142},{"_id":"source/_posts/综合/selenium新版本后如何定位元素.md","hash":"a8e6abbe6fdd08c8f0565621a385dc156d0eff4e","modified":1677497673141},{"_id":"source/_posts/综合/vscode使用入门与配置.md","hash":"edf7ad4323fcff256f3f415c97ad88c19eff8083","modified":1677497673136},{"_id":"source/_posts/综合/安卓root探索记录.md","hash":"c0d8120377eecd076ad7bcd9dbbfe7b9c0bc5e45","modified":1677497673140},{"_id":"source/_posts/综合/实验室网络.md","hash":"1cfeb0ce98580256cfc7d8c5ea52a20caddd7351","modified":1677497673139},{"_id":"source/_posts/综合/傅里叶级数 画初音 附底层代码.md","hash":"cf02dac4f50a6b122e8dafb3b23b39b39d03a5a3","modified":1677497673137},{"_id":"source/_posts/综合/数据库池子Python.md","hash":"00aa7b6e15c0a6b2644264dadf41d0a43af08d70","modified":1677497673139},{"_id":"source/_posts/综合/欧拉公式.md","hash":"2153e6135208b4c80ac39325294ba51f0327d903","modified":1677497673139},{"_id":"source/_posts/综合/爬虫.md","hash":"9add8395f7ffd9fdea8a8cf924e42cada955af16","modified":1677497673141},{"_id":"source/_posts/综合/电视盒子搭建方案.md","hash":"c2c5cb7b72280e1c3baf09ca48abf34e12f50dee","modified":1677497673141},{"_id":"source/_posts/综合/数字图像处理.md","hash":"97cd4bc483dc7ffb8d754a7ab1c34197dc3fb124","modified":1677497673142},{"_id":"source/_posts/综合/简单前后端分离项目部署.md","hash":"82e2c5678efc27e32e4bf44d741cea949f7bb6a5","modified":1677497673138},{"_id":"source/_posts/综合/算法比赛套路.md","hash":"e0c1625387e9314e40c1aa8b4d1d553c323f7a2c","modified":1677497673136},{"_id":"source/_posts/综合/论文规范要记.md","hash":"4949a3daaef3e2462c73452397cc054277f3032b","modified":1677497673135},{"_id":"source/_posts/综合/贝塞尔曲线.md","hash":"f9653cf5eac48daddda8672053f43c1082629957","modified":1677497673137},{"_id":"source/_posts/综合/长连接与短连接.md","hash":"228c912769f3094f54a6e8b0471b7f5b375a53bc","modified":1677497673139},{"_id":"themes/matery/source/medias/logo.png","hash":"7f2a0ce94192eec2743b2dbae4cb2355b469ffa5","modified":1677492228074},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.css","hash":"7f4f8913f2d46ade2def5134e2cc8684a4b87939","modified":1627563282000},{"_id":"themes/matery/source/libs/aos/aos.js","hash":"5a8e6d07ffa55642418ab3fd4b263aa08284b77a","modified":1627563282000},{"_id":"themes/matery/source/libs/aos/aos.css","hash":"ded9739f803d114c9168d3351fded72b3b478b4c","modified":1627563282000},{"_id":"themes/matery/source/libs/codeBlock/codeCopy.js","hash":"b74a381adf6ef8404d6a0452c2b9f44b47219c80","modified":1627563282000},{"_id":"themes/matery/source/libs/codeBlock/clipboard.min.js","hash":"9cd57c67fbd3e3067f80793ef8445f5ff7783563","modified":1627563282000},{"_id":"themes/matery/source/libs/codeBlock/codeBlockFuction.js","hash":"c7ab06d27a525b15b1eb69027135269e9b9132fb","modified":1627563282000},{"_id":"themes/matery/source/libs/codeBlock/codeLang.js","hash":"ea8b51e4d75e7b2cd63e4d5bcb8db2cf7f23f5db","modified":1627563282000},{"_id":"themes/matery/source/libs/codeBlock/codeShrink.js","hash":"215910dc8f63fd50b97957e5fcdc8480aa2728cb","modified":1627563282000},{"_id":"themes/matery/source/libs/animate/animate.min.css","hash":"5dfcbcee866e9dc564916416281885f3e320871e","modified":1627563282000},{"_id":"themes/matery/source/libs/gitalk/gitalk.css","hash":"021898a16279ac2ffe75af4f902fab2a0a39f11a","modified":1627563282000},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.css","hash":"5d52d3b34fceb9d7e11f1beaf7ed380b4249dec4","modified":1627563282000},{"_id":"themes/matery/source/libs/cryptojs/crypto-js.min.js","hash":"33810b2b757fc4327bc1d3b83bb5e0d3dc1fec5b","modified":1627563282000},{"_id":"themes/matery/source/libs/gitment/gitment-default.css","hash":"a0625d8b432af8bdc820f8768d36cde439e7257c","modified":1627563282000},{"_id":"themes/matery/source/libs/jqcloud/jqcloud.css","hash":"4e6538c8312aeeab845d361c37a8c1a0931241f0","modified":1627563282000},{"_id":"themes/matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"26849509f196a2d21bbfd15696e5d5153163b8f1","modified":1627563282000},{"_id":"themes/matery/source/libs/masonry/masonry.pkgd.min.js","hash":"f81cd7bfcf7aa2d043bd3e6077df42656fc44b82","modified":1627563282000},{"_id":"themes/matery/source/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1627563282000},{"_id":"themes/matery/source/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1627563282000},{"_id":"themes/matery/source/libs/others/explosion.min.js","hash":"417b68e2cf2c6de2119c57626f4412105a8457f5","modified":1627563282000},{"_id":"themes/matery/source/libs/others/fireworks.js","hash":"53981959bc6def4a85bbbb41b07e4b1474a2124d","modified":1627563282000},{"_id":"themes/matery/source/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1627563282000},{"_id":"themes/matery/source/libs/others/text.js","hash":"1791782cde0d1e4197f2ed58ecb7dd6aefddd169","modified":1627563282000},{"_id":"themes/matery/source/libs/others/snow.js","hash":"b393f069781eef788a0ae66b2681cece8fea2851","modified":1627563282000},{"_id":"themes/matery/source/libs/tocbot/tocbot.css","hash":"f646f2bb75bcd1eb65b2788ac7bf15d4fd243ce9","modified":1627563282000},{"_id":"themes/matery/source/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1627563282000},{"_id":"themes/matery/source/medias/avatars/ajin.jpg","hash":"76cb8e872472ff47a1b061c3bcff1c03f30c02b8","modified":1627563282000},{"_id":"themes/matery/source/medias/avatars/babyq.png","hash":"be5432588003e5a52c02e690622eec72b5f7346c","modified":1627563282000},{"_id":"themes/matery/source/medias/avatars/fun4go.png","hash":"0f4333973a972a629cfbabf601bc7c192b65376c","modified":1627563282000},{"_id":"themes/matery/source/medias/avatars/cww97.jpg","hash":"6af987cafc55d8d031534dd5e0f722fff19f70ec","modified":1627563282000},{"_id":"themes/matery/source/medias/avatars/huaji.jpg","hash":"86be7eed2a491455ccfe3e7da46366ff477765ca","modified":1627563282000},{"_id":"themes/matery/source/medias/avatars/hael.jpg","hash":"e66ccedab38bb2e8fc45fac024e234ab8e7b9d54","modified":1627563282000},{"_id":"themes/matery/source/medias/avatars/hzwer.jpg","hash":"53a66bb5e65d2abd5b7412edf094c1e0b1094492","modified":1627563282000},{"_id":"themes/matery/source/medias/avatars/ids2.jpg","hash":"2c8d3ac6ab5ac6196bac83766fde975daca91c32","modified":1627563282000},{"_id":"themes/matery/source/medias/avatars/kewlgrl.jpg","hash":"3af0fd1029a1511bb3c0e90871e41b35e714b01f","modified":1627563282000},{"_id":"themes/matery/source/medias/avatars/masterx.jpg","hash":"c9f7e83d895fa241cefd6e742f356106b35f1b89","modified":1627563282000},{"_id":"themes/matery/source/medias/avatars/michael.jpg","hash":"331a2ab20c299196f5a3089b8445fc8f55346cb6","modified":1627563282000},{"_id":"themes/matery/source/medias/avatars/mpy634.png","hash":"30f88e09c02b37c2dc684d4ee3237e327bb23f8b","modified":1627563282000},{"_id":"themes/matery/source/medias/avatars/mouse.jpg","hash":"2eae273885b9859150a1f98f74b3df12ca9a207c","modified":1627563282000},{"_id":"themes/matery/source/medias/avatars/taotao.jpg","hash":"e668254375ddd40a684ff4669c3421851bebd36e","modified":1627563282000},{"_id":"themes/matery/source/medias/avatars/taowei.jpg","hash":"e58b03b70656aa7a27238be38dac3896d9d16f10","modified":1627563282000},{"_id":"themes/matery/source/medias/banner/.DS_Store","hash":"33e20d0af4d381a00b3bfe6d7191680c085c5c14","modified":1677496774900},{"_id":"themes/matery/source/medias/avatars/spacesac.png","hash":"ff1bdb058f1f0499312da1a082ba97d78590db1a","modified":1627563282000},{"_id":"themes/matery/source/medias/avatars/tawn.jpg","hash":"68a1cbacbb2370912b000c9d8d2b16196c918a50","modified":1627563282000},{"_id":"themes/matery/source/medias/featureimages/.DS_Store","hash":"5b2ab742b0f26704cc4c39af252b566834b44e4a","modified":1677497316428},{"_id":"themes/matery/source/medias/files/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1677492003112},{"_id":"themes/matery/source/medias/music/.DS_Store","hash":"830df480ed031ecfbcbed68c25685b5f3b77a413","modified":1677492020439},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.js","hash":"70c0c4a9bf698747b7c058c21287ad617355e5dd","modified":1627563282000},{"_id":"themes/matery/source/libs/gitment/gitment.js","hash":"5a13983930b019450e4fe01a407c64b3dd316be4","modified":1627563282000},{"_id":"themes/matery/source/libs/jquery/jquery-2.2.0.min.js","hash":"7a551393b8360731104fdef1af36a6f3638f5855","modified":1627563282000},{"_id":"themes/matery/source/libs/valine/Valine.min.js","hash":"f1558f12d96a352e490166d543a8e821dd3bb2bc","modified":1627563282000},{"_id":"themes/matery/source/medias/avatars/avatar.jpg","hash":"7f2a0ce94192eec2743b2dbae4cb2355b469ffa5","modified":1677489982430},{"_id":"themes/matery/source/medias/avatars/antnlp.ico","hash":"29475f350b989331cebd702a315f020917d06ed8","modified":1627563282000},{"_id":"themes/matery/source/medias/avatars/bytedtrans.png","hash":"ce59d69e5106f20548f4ec9b6429c8fcc787ea08","modified":1627563282000},{"_id":"themes/matery/source/medias/avatars/duyupei.jpg","hash":"3c02ed4cf57dc37e4f4b8314bf5094833a854cb0","modified":1627563282000},{"_id":"themes/matery/source/medias/avatars/gsy.jpg","hash":"6a175e2ba56a2280d40a2e654b559be41c3a0a48","modified":1627563282000},{"_id":"themes/matery/source/medias/avatars/mizunashi.png","hash":"5fc300701d3b4250a307ed70e3a3aa0d5395c808","modified":1627563282000},{"_id":"themes/matery/source/medias/avatars/myzhihu.png","hash":"7f2a0ce94192eec2743b2dbae4cb2355b469ffa5","modified":1677490080375},{"_id":"themes/matery/source/medias/avatars/qiandongwei.jpg","hash":"6873551596a4513d01898ad866c4073c68270c57","modified":1627563282000},{"_id":"themes/matery/source/medias/reward/wechat.png","hash":"764b7b0cb45722f77869f2a242d4a3a0588c7ecf","modified":1677491431211},{"_id":"themes/matery/source/libs/awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1627563282000},{"_id":"themes/matery/source/libs/gitalk/gitalk.min.js","hash":"f63c7c489524ccb5d95e74fcd6618116c58fb305","modified":1627563282000},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.js","hash":"82276be41d2001e820020a219b90ad5b026302d1","modified":1627563282000},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1627563282000},{"_id":"themes/matery/source/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1627563282000},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1627563282000},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1627563282000},{"_id":"themes/matery/source/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1627563282000},{"_id":"themes/matery/source/libs/lightGallery/img/video-play.png","hash":"fbfdbe06aebf7d0c00da175a4810cf888d128f11","modified":1627563282000},{"_id":"themes/matery/source/libs/materialize/materialize.min.css","hash":"2c27939768606603bee3b5e6c8a722596a667e60","modified":1627563282000},{"_id":"themes/matery/source/libs/lightGallery/img/vimeo-play.png","hash":"1142b47de219dddfba2e712cd3189dec0c8b7bee","modified":1627563282000},{"_id":"themes/matery/source/libs/lightGallery/img/youtube-play.png","hash":"39150b45ec5fc03155b7ebeaa44f1829281788e2","modified":1627563282000},{"_id":"themes/matery/source/libs/share/css/share.min.css","hash":"7126de5cec8371e580b7b1f22512da0985cc39e5","modified":1627563282000},{"_id":"themes/matery/source/libs/lightGallery/js/lightgallery-all.min.js","hash":"f8cd48e1fff82ecd54a7ce3e69de8dba7c92d113","modified":1627563282000},{"_id":"themes/matery/source/libs/materialize/materialize.min.js","hash":"c843f0dc497314574c608ca28cc742bb041786d5","modified":1627563282000},{"_id":"themes/matery/source/libs/share/fonts/iconfont.svg","hash":"337b4f156f6d8f4beb32c32a3db46fef361cff74","modified":1627563282000},{"_id":"themes/matery/source/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1627563282000},{"_id":"themes/matery/source/libs/share/js/jquery.share.min.js","hash":"16ce82901ca0e302cf47a35fb10f59009a5e7eb9","modified":1627563282000},{"_id":"themes/matery/source/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1627563282000},{"_id":"themes/matery/source/libs/valine/av-min.js","hash":"04c6b2782ce4610c429563110f6a20a47432fc4c","modified":1627563282000},{"_id":"themes/matery/source/libs/share/js/social-share.min.js","hash":"4df722bafde2c5d8faaace0d1f894798385a8793","modified":1627563282000},{"_id":"themes/matery/source/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1627563282000},{"_id":"themes/matery/source/medias/avatars/0xbird.png","hash":"f9d597dfcb49e1e2be06138b24028291f5638610","modified":1627563282000},{"_id":"themes/matery/source/medias/avatars/lzh.png","hash":"8ffcbf19d6b38b891dbe408d9a4e9513b56f247e","modified":1627563282000},{"_id":"themes/matery/source/medias/avatars/lyn-draw.jpg","hash":"837d5d5df4dcb086d2da114d0d85084b4ec18768","modified":1627563282000},{"_id":"themes/matery/source/medias/avatars/mashiro.jpg","hash":"250e911c16eeb6acb1e6214ad3e6a3d762850a8e","modified":1627563282000},{"_id":"themes/matery/source/medias/avatars/milyyy.jpg","hash":"ac2826d9c28346efeb967df01465a2c74d9041fe","modified":1627563282000},{"_id":"themes/matery/source/medias/avatars/qianqian.png","hash":"fed254c4e7eb58ee22d647acb83f1d08f4508f8f","modified":1627563282000},{"_id":"themes/matery/source/medias/music/avatars/tiantangdemogui.jpg","hash":"f005578ddb4d3d731838db89a708f39f18d50e60","modified":1627563282000},{"_id":"themes/matery/source/medias/music/avatars/yequ.jpg","hash":"103beb9ab33434b434fa37a30aecdb29db633024","modified":1627563282000},{"_id":"themes/matery/source/medias/music/avatars/yiluxiangbei.jpg","hash":"01b12e3aca7385a88412c12539e1a608a78896fa","modified":1627563282000},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1627563282000},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1627563282000},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.svg","hash":"3480f00d284c812d623ed16a9e0ead3fb964c72e","modified":1627563282000},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1627563282000},{"_id":"themes/matery/source/medias/avatars/feibar.png","hash":"eceaefcbbca1bf49b582eaa649d311cf4fe69dd6","modified":1627563282000},{"_id":"themes/matery/source/medias/featureimages/10.jpg","hash":"59ecd3a562d44d7e64c8f36fbb28f6ae2b11e10e","modified":1637149938000},{"_id":"themes/matery/source/medias/featureimages/4.jpg","hash":"40f63fd8d9c9e5f969ce50b2bcc83aa0354f5a33","modified":1637575736000},{"_id":"themes/matery/source/libs/awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1627563282000},{"_id":"themes/matery/source/medias/banner/4.jpg","hash":"40f63fd8d9c9e5f969ce50b2bcc83aa0354f5a33","modified":1637575736000},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1627563282000},{"_id":"themes/matery/source/medias/avatars/jingjing.jpg","hash":"bfcab0139edb2509de984cb0a9b156879c355158","modified":1627563282000},{"_id":"themes/matery/source/medias/banner/10.jpg","hash":"59ecd3a562d44d7e64c8f36fbb28f6ae2b11e10e","modified":1637149938000},{"_id":"themes/matery/source/medias/music/avatars/daoshu.jpg","hash":"eee120fdf5ccbe86aa7d51826c4c773e76e6357f","modified":1627563282000},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1627563282000},{"_id":"themes/matery/source/medias/featureimages/14.png","hash":"f03845c3c10ab653685d5d071f4198b49b7585b1","modified":1637399818000},{"_id":"themes/matery/source/medias/banner/14.png","hash":"f03845c3c10ab653685d5d071f4198b49b7585b1","modified":1637399818000},{"_id":"themes/matery/source/libs/echarts/echarts.min.js","hash":"8789b5e4daf0029a6c88f238f10e54d01c4fce82","modified":1627563282000},{"_id":"themes/matery/source/medias/banner/8.png","hash":"81692c30d34e2df2f29a791887ba13fcd0c6a689","modified":1637399520000},{"_id":"themes/matery/source/medias/banner/9.jpg","hash":"5702d24e0e01a7439bcfdcbd338724c8e786426b","modified":1637229996000},{"_id":"themes/matery/source/medias/featureimages/8.png","hash":"81692c30d34e2df2f29a791887ba13fcd0c6a689","modified":1637399520000},{"_id":"themes/matery/source/medias/featureimages/9.jpg","hash":"5702d24e0e01a7439bcfdcbd338724c8e786426b","modified":1637229996000},{"_id":"themes/matery/source/medias/featureimages/3.png","hash":"db86e0f6de0f9a01e81d59fe165023e38fa4cad5","modified":1637403936000},{"_id":"themes/matery/source/medias/banner/3.png","hash":"db86e0f6de0f9a01e81d59fe165023e38fa4cad5","modified":1637403936000},{"_id":"themes/matery/source/medias/featureimages/7.jpg","hash":"466f65b9effd7d27a086567e366702d8a1e92b3d","modified":1637149884000},{"_id":"themes/matery/source/medias/banner/7.jpg","hash":"466f65b9effd7d27a086567e366702d8a1e92b3d","modified":1637149884000},{"_id":"themes/matery/source/medias/banner/13.jpg","hash":"1dbb186ada20d824361c5358ea4f7401630a1893","modified":1633667495000},{"_id":"themes/matery/source/medias/banner/6.jpg","hash":"6469b45fcc292902230d85865bcc91d4db00d304","modified":1633352008000},{"_id":"themes/matery/source/medias/featureimages/13.jpg","hash":"1dbb186ada20d824361c5358ea4f7401630a1893","modified":1633667495000},{"_id":"themes/matery/source/medias/featureimages/6.jpg","hash":"6469b45fcc292902230d85865bcc91d4db00d304","modified":1633352008000},{"_id":"themes/matery/source/medias/featureimages/11.jpg","hash":"a5225ee4280ffdf674b9cc44340584fa8d8a61d8","modified":1637404457000},{"_id":"themes/matery/source/medias/featureimages/5.jpg","hash":"c56e00ae297db6791a266182f8db10b0f39a53ba","modified":1633352122000},{"_id":"themes/matery/source/medias/banner/11.jpg","hash":"a5225ee4280ffdf674b9cc44340584fa8d8a61d8","modified":1637404457000},{"_id":"themes/matery/source/medias/banner/5.jpg","hash":"c56e00ae297db6791a266182f8db10b0f39a53ba","modified":1633352122000},{"_id":"themes/matery/source/medias/banner/0.jpg","hash":"7f62782d975e7ae80c16d53f87f373957623843e","modified":1633352131000},{"_id":"themes/matery/source/medias/featureimages/0.jpg","hash":"7f62782d975e7ae80c16d53f87f373957623843e","modified":1633352131000},{"_id":"themes/matery/source/medias/featureimages/2.jpg","hash":"9a7549249a56abb438a051f4fe2c54217e2d158f","modified":1637148359000},{"_id":"themes/matery/source/medias/featureimages/15.png","hash":"d9d314cf96a93793c379688e0fe7c24ff2053076","modified":1637310718000},{"_id":"themes/matery/source/medias/banner/1.jpg","hash":"9a7549249a56abb438a051f4fe2c54217e2d158f","modified":1637148359000},{"_id":"themes/matery/source/medias/banner/15.png","hash":"d9d314cf96a93793c379688e0fe7c24ff2053076","modified":1637310718000},{"_id":"themes/matery/source/medias/featureimages/1.jpg","hash":"84c8d260d468bd86ab977c57a4397f7076653ca3","modified":1633352057000},{"_id":"themes/matery/source/medias/banner/2.jpg","hash":"84c8d260d468bd86ab977c57a4397f7076653ca3","modified":1633352057000},{"_id":"themes/matery/source/medias/featureimages/12.jpg","hash":"8960cdbfb738ca8a604260f86859b40a361f4f51","modified":1633352104000},{"_id":"themes/matery/source/medias/banner/12.jpg","hash":"8960cdbfb738ca8a604260f86859b40a361f4f51","modified":1633352104000},{"_id":"public/baidu_urls.txt","hash":"b4308ec76ef57e0f3efbb50b5b8e884e94b565b2","modified":1677497677107},{"_id":"public/atom.xml","hash":"424a43e14a65e1aed93ceb106af6cbc317f41d2e","modified":1677497677111},{"_id":"public/sitemap.xml","hash":"d97c39907947bce0cc25664c5072d618ca0e0f89","modified":1677497678895},{"_id":"public/baidusitemap.xml","hash":"52cbfde2a602a380e447dcce0275dbe89aa87202","modified":1677497679040},{"_id":"public/search.xml","hash":"4b3a1fb57e9e1b1ec9e0deeb768647ee05292837","modified":1677497679041},{"_id":"public/404.html","hash":"ddad9b77e00cb4c2f99b35110d3c47c2dd7b5830","modified":1677497679086},{"_id":"public/about/index.html","hash":"de106ad55c55b313faf453108124f08f364ba17a","modified":1677497679086},{"_id":"public/friends/index.html","hash":"dbadd1237b01d0bf5f784ee8ad3f357166d408e8","modified":1677497679086},{"_id":"public/contact/index.html","hash":"e471c34721b5fa4a80091aa06ada6046227d53ca","modified":1677497679086},{"_id":"public/categories/index.html","hash":"896cc292bd44cea2622df5032a63c89a6705f21f","modified":1677497679086},{"_id":"public/archives/index.html","hash":"c060984a4a5886d0f9d391ecf9dc9f4f77052b8e","modified":1677497679086},{"_id":"public/tags/index.html","hash":"cb98909f8343c137947d0181f236f3825d41a4e0","modified":1677497679086},{"_id":"public/2023/02/27/fu-wu-qi-xiang-guan/samba-yong-hu-guan-li/index.html","hash":"292717a24b08c33b3cb1de049edd289bb9662742","modified":1677497679086},{"_id":"public/2023/02/27/fu-wu-qi-xiang-guan/docker-rong-qi-quan-xian-guan-li/index.html","hash":"b3ad71900df58bd657a801af11d6b7dac7af3e36","modified":1677497679086},{"_id":"public/2023/02/27/fu-wu-qi-xiang-guan/shell-jiang-ming-ling-zhi-xing-jie-guo-fu-zhi-gei-bian-liang/index.html","hash":"8304e1302d3544976e99cc8fdb3329726d9269e5","modified":1677497679086},{"_id":"public/2023/02/27/fu-wu-qi-xiang-guan/linux-tong-bu-shen-fen-ren-zheng/index.html","hash":"fd4614e34669ac550769ead42d4f30f7841e3649","modified":1677497679087},{"_id":"public/2023/02/27/fu-wu-qi-xiang-guan/source-ming-ling-ru-he-shi-yong-conda-huan-jing-yun-xing-jiao-ben-zai-yi-xie-luan-qi-ba-zao-de-huan-jing-xia/index.html","hash":"40438a3cae115e8e55b3ed2d10acce408a96432b","modified":1677497679087},{"_id":"public/2023/02/27/fu-wu-qi-xiang-guan/sudo-quan-xian-guan-li-yao-ji-yu-ti-quan/index.html","hash":"aec8b29d358cc108f581b23a57d59886c62208a3","modified":1677497679087},{"_id":"public/2023/02/27/fu-wu-qi-xiang-guan/ming-ling-xing-liu-lan-qi-w3m/index.html","hash":"6c4a1e8436bb83c22ae2874fb76813037f045f04","modified":1677497679087},{"_id":"public/2023/02/27/fu-wu-qi-xiang-guan/linux-cha-kan-xi-tong-jia-gou/index.html","hash":"3e41427022cdd8f1ab2d39089cdd08b19a6949ca","modified":1677497679087},{"_id":"public/2023/02/27/fu-wu-qi-xiang-guan/ji-yu-bao-ta-nginx-de-duo-zhan-dian-guan-li/index.html","hash":"ee281e97c7fc088cd8ba0c525cf2c14f8fd0f874","modified":1677497679087},{"_id":"public/2023/02/27/fu-wu-qi-xiang-guan/fu-wu-qi-gua-zai-qi-ta-yun-pan-li-ru-googledrive-onedrive/index.html","hash":"cc3702d435a0227e8d90b30a493a7e814cc17e82","modified":1677497679087},{"_id":"public/2023/02/27/fu-wu-qi-xiang-guan/openwrt-fang-huo-qiang-shi-yong/index.html","hash":"d41d604a40e070263da68076a83e16f352fc79d2","modified":1677497679087},{"_id":"public/2023/02/27/fu-wu-qi-xiang-guan/nginx-pei-zhi/index.html","hash":"48b09dd5b115b61a40cdff261d486dcc81577837","modified":1677497679087},{"_id":"public/2023/02/27/fu-wu-qi-xiang-guan/qu-wei-shell-xiao-jiao-ben/index.html","hash":"5b63bf93c66d7f0a6b67fc96f759d806d035ae6b","modified":1677497679087},{"_id":"public/2023/02/27/fu-wu-qi-xiang-guan/ru-he-shi-yong-docker-da-jian-yi-tao-kai-fa-huan-jing/index.html","hash":"9c31478adab978027afb137a33a77606248d30df","modified":1677497679087},{"_id":"public/2023/02/27/fu-wu-qi-xiang-guan/centos-de-yum-yuan-de-pei-zhi/index.html","hash":"ad5ba550ff36ca86ef53c30fc07c358186137536","modified":1677497679087},{"_id":"public/2023/02/27/fu-wu-qi-xiang-guan/ssh-lian-jie-fu-wu-qi/index.html","hash":"cc782a8697de4e258818195d55e2b9266b01c9f3","modified":1677497679087},{"_id":"public/2023/02/27/fu-wu-qi-xiang-guan/shell-xiao-note/index.html","hash":"2e31f6f42b9b50d15a5fa3f3c140b4412ed52c56","modified":1677497679087},{"_id":"public/2023/02/27/fu-wu-qi-xiang-guan/docker-shi-yong-jian-dan-jiao-cheng/index.html","hash":"5338ddac850900519b6690d416d21bcbf57f154b","modified":1677497679087},{"_id":"public/2023/02/27/fu-wu-qi-xiang-guan/linux-gei-mei-ge-yong-hu-xian-ding-cun-chu-kong-jian-da-xiao/index.html","hash":"0a00ddb33938d28b4fb2c526d73e6cce419e6abf","modified":1677497679087},{"_id":"public/2023/02/27/fu-wu-qi-xiang-guan/yi-xie-bu-na-me-chang-yong-de-linux-zhi-shi/index.html","hash":"32ff473614791b1da63014a9a445ed8e29fa1d7f","modified":1677497679088},{"_id":"public/2023/02/27/shi-yan-shi-wei-hu/gao-xiao-nei-wang-fen-liu-ce-lue/index.html","hash":"42283cea6118c18881f0d840c4f70bba66d24e42","modified":1677497679088},{"_id":"public/2023/02/27/shi-yan-shi-wei-hu/jiao-huan-ji/index.html","hash":"00fa48ce0f347f6c3937cfabd790ed362ab4a59b","modified":1677497679088},{"_id":"public/2023/02/27/shi-yan-shi-wei-hu/ge-chong-za-luan-de-zhi-shi-dian/index.html","hash":"c87414f73237d5eadbf2fd62125999f458e7a926","modified":1677497679088},{"_id":"public/2023/02/27/shi-yan-shi-wei-hu/yi-xie-wang-luo-ce-shi-chang-yong-ming-ling/index.html","hash":"9292e16f718628e98dc7e9b1aa395a244dec484f","modified":1677497679088},{"_id":"public/2023/02/27/shi-yan-shi-wei-hu/guan-yu-wo-zai-ubuntu-shang-pei-zhi-route/index.html","hash":"b51947e49df737ddaa0f4dc832784609635d5a98","modified":1677497679088},{"_id":"public/2023/02/27/zong-he/dian-shi-he-zi-da-jian-fang-an/index.html","hash":"0d25b03f6feba3658106bb649907a6ff1fd831e5","modified":1677497679088},{"_id":"public/2023/02/27/shi-yan-shi-wei-hu/openwrt-mwan-pei-zhi-duo-wan-fu-zhi-jun-heng/index.html","hash":"c1f672b582c60645c28f730945ab1854a4e4d63e","modified":1677497679088},{"_id":"public/2023/02/27/zong-he/shi-yan-shi-wang-luo/index.html","hash":"f217b4006bbadd7bca987fe825867cafd5274b38","modified":1677497679088},{"_id":"public/2023/02/27/zong-he/shu-ju-ku-chi-zi-python/index.html","hash":"a792a0bc33fba09ad1548618f93e9c263b90fb65","modified":1677497679088},{"_id":"public/2023/02/27/zong-he/ou-la-gong-shi/index.html","hash":"76d394d235c69c4fe3aead5c86feee05bdaab93e","modified":1677497679088},{"_id":"public/2023/02/27/zong-he/jian-dan-qian-hou-duan-fen-chi-xiang-mu-bu-shu/index.html","hash":"f351b9eda21a3e935ad5f5d1c4adc250ba729847","modified":1677497679088},{"_id":"public/2023/02/27/zong-he/bei-sai-er-qu-xian/index.html","hash":"47a32d2acf6915399cfefbc5302c227d4632082a","modified":1677497679088},{"_id":"public/2023/02/27/dai-li/openwrt-docker-pang-lu-you/index.html","hash":"2387fded642fd89ee49919024a3e927d8d75c2b8","modified":1677497679088},{"_id":"public/2023/02/27/dai-li/dai-ma-pi-liang-ce-shi/index.html","hash":"263c37261cde00d5e72a01556d78f324d11b816d","modified":1677497679088},{"_id":"public/2023/02/27/dai-li/zi-jian-ji-chang-zhi-websocket-tls-cloudflare/index.html","hash":"215282ef36992d9113a7ca08f6eb0dc12a1ec1e7","modified":1677497679088},{"_id":"public/2023/02/27/dai-li/mian-fei-ji-chang-da-jian/index.html","hash":"6ab9efd66a2163b3b021121e055036285d80413b","modified":1677497679088},{"_id":"public/2023/02/27/dai-li/ba-ji-yu-dai-li/index.html","hash":"a84a24fce524e2f8d62df4c40e1f85c244e2de4c","modified":1677497679088},{"_id":"public/2023/02/27/dl/xin-jian-wen-jian/index.html","hash":"44aa54a87da25130a38ccbe19b606ec3b8c48ab2","modified":1677497679088},{"_id":"public/2023/02/27/dl/jupyter-de-js-kong-zhi-shi-yong-mo-suo/index.html","hash":"0d7ae89105a09ff791a8d956a373f6aa1bab60aa","modified":1677497679088},{"_id":"public/2023/02/27/dl/shu-ju-jia-zai-qi/index.html","hash":"6d050a15ec9e61661802b7704dd07f3596b8b167","modified":1677497679088},{"_id":"public/2023/02/27/zong-he/fu-li-xie-ji-shu-hua-chu-yin-fu-di-ceng-dai-ma/index.html","hash":"648e8d56fbb303e88f5cde343f2958c819ef33da","modified":1677497679088},{"_id":"public/2023/02/27/dai-li/v2ray-yu-dai-li-duo-ji-dai-li/index.html","hash":"86ec28520fb56abe14d64a22df56ae285d7e6e4e","modified":1677497679088},{"_id":"public/2023/02/27/dl/dl-huan-jing-cuda/index.html","hash":"a7b11ced1f6583800850b5d9d15f131cc8742d26","modified":1677497679088},{"_id":"public/2023/02/27/dl/yang-ben-shi-heng-wen-ti/index.html","hash":"b880a5b485d76396a2701fa1e4f93fa1219f5ba0","modified":1677497679088},{"_id":"public/2023/02/27/dl/jian-du-wu-jian-du-ban-jian-du-deng-xue-xi-fang-shi/index.html","hash":"e098a7619e54fe9cd5727d8528e76abffff41fc2","modified":1677497679088},{"_id":"public/2023/02/27/dl/ji-yi-ci-xun-lian-loss-bian-cheng-nan-zhi/index.html","hash":"1c1cf0b7493fb12b33930fa3d4acbc61129b6f1b","modified":1677497679088},{"_id":"public/2023/02/27/dl/biao-ge-shu-ju-chu-li-pandas-yu-numpy/index.html","hash":"92e01be3a83fd083bbf3195651d82e2321cd18fe","modified":1677497679088},{"_id":"public/2023/02/27/dl/neo4j-zhi-shi-tu-pu-huan-jing-da-jian/index.html","hash":"541283e3ab4e0fce2b7c6a4447e1c1ac3a0d72ff","modified":1677497679088},{"_id":"public/2023/02/27/dl/pytorch-diao-can-jing-yan-hui-zong/index.html","hash":"e4ff805aa44787d298b5bc8ca255761a0ed91f39","modified":1677497679088},{"_id":"public/2023/02/27/dl/guan-yu-print-yu-ri-zhi-chu-li/index.html","hash":"d7c813d047473f8d05a7e4be1b3992e65f94a98c","modified":1677497679089},{"_id":"public/2023/02/26/zong-he/chang-lian-jie-yu-duan-lian-jie/index.html","hash":"b111c38aa602d974874bf2713d622f7a4b1871bf","modified":1677497679089},{"_id":"public/2023/02/26/zong-he/suan-fa-bi-sai-tao-lu/index.html","hash":"9a1dc42078d42b8a94e31154569acf34a6957132","modified":1677497679089},{"_id":"public/2023/02/26/zong-he/shu-zi-tu-xiang-chu-li/index.html","hash":"5de9552176b831d849c7f9207e8c30fdbaa47d23","modified":1677497679089},{"_id":"public/2023/02/26/zong-he/an-zhuo-root-tan-suo-ji-lu/index.html","hash":"520f49a1edc682ea075a537948df5299a8bc03fa","modified":1677497679089},{"_id":"public/2023/02/26/zong-he/lun-wen-gui-fan-yao-ji/index.html","hash":"b3c7f21e0bc84613991e105aa49a6309fd5f13f6","modified":1677497679089},{"_id":"public/2023/02/26/zong-he/vscode-shi-yong-ru-men-yu-pei-zhi/index.html","hash":"3f484d3fc62a55e9adc80b6040024f6a0d0adb65","modified":1677497679089},{"_id":"public/2023/02/26/zong-he/qq-ji-qi-ren-da-jian/index.html","hash":"784f88e9e27959602ac1f4ffcca1968458918e69","modified":1677497679089},{"_id":"public/2023/02/26/zong-he/selenium-xin-ban-ben-hou-ru-he-ding-wei-yuan-su/index.html","hash":"6647aab1c032a97dc80646e5df417e2e31c2890c","modified":1677497679089},{"_id":"public/2023/02/26/zong-he/python-xie-cheng-jin-cheng-yu-xian-cheng/index.html","hash":"7359d21bc08443e145e70966fecba363e5d081e0","modified":1677497679089},{"_id":"public/2023/02/26/zong-he/python-cuo-wu-yi-chang-chu-li/index.html","hash":"741d2a311284b6103c5b142c21ce9e39ebcb80cf","modified":1677497679089},{"_id":"public/2023/02/26/zong-he/pipenv-xu-ni-huan-jing-shi-yong/index.html","hash":"4d9382c8ce593eaf7ddf86436ed8f986030dfe01","modified":1677497679089},{"_id":"public/2023/02/26/zong-he/python-qing-qiu-chong-shi-ji-zhi-tenacity/index.html","hash":"024fc138fcdfd9bd28da425546c3deea4bbff29f","modified":1677497679089},{"_id":"public/2023/02/26/zong-he/ps-xue-xi/index.html","hash":"228433ce74303d1c03c4f0968b09b6c2edb4f648","modified":1677497679089},{"_id":"public/2023/02/26/zong-he/opengl-xue-xi/index.html","hash":"fa4fc52fc93b39e8ddf7e6620fd7d00c31c08f0d","modified":1677497679089},{"_id":"public/2023/02/26/zong-he/moonlight-yun-dian-nao/index.html","hash":"5b9ac8aa7125b6d70ef291b4ca0f8dbf88201480","modified":1677497679089},{"_id":"public/2023/02/26/zong-he/echarts-wang-luo-tu-de-hui-zhi/index.html","hash":"37f92e8b06dd5a4de3dec2925495910beb30fd8b","modified":1677497679089},{"_id":"public/2023/02/26/zong-he/hexo-jing-tai-bo-ke-da-jian/index.html","hash":"a27b2efc885cabf8647e7b20f8f01f05fabea078","modified":1677497679089},{"_id":"public/2023/02/26/zong-he/syncthing-duo-ping-tai-wen-jian-tong-bu/index.html","hash":"1b1790877c56e6068afa20df0b5e7a687ee2bd70","modified":1677497679089},{"_id":"public/2023/02/26/zong-he/docker-shi-yong-jian-dan-jiao-cheng/index.html","hash":"04c48c3f540325c17f972068521ff5c7f3cf447a","modified":1677497679089},{"_id":"public/2023/02/26/zong-he/python-redis-rabbitmq-yi-ji-mysql-shi-yong-cao-zuo-jiao-cheng/index.html","hash":"5ed67a36a3fe54a95cee099097ea9c79fd7c623a","modified":1677497679089},{"_id":"public/2023/02/26/zong-he/github-action-xue-xi-ci-cd-zi-dong-hua/index.html","hash":"031198fb8749324fd2dd0f93d74d562f64044bdd","modified":1677497679089},{"_id":"public/2023/02/26/zong-he/c-fu-xi/index.html","hash":"6bd046e4cad88208e6dbb9e9f9ebe549af22f7aa","modified":1677497679089},{"_id":"public/2020/01/15/zong-he/pa-chong/index.html","hash":"b53f1cd19aade1cde90b07d8386f11b7fe019d75","modified":1677497679089},{"_id":"public/archives/page/2/index.html","hash":"f55c99b5835ec87b7b276c28ffbdc9a66aab2b40","modified":1677497679089},{"_id":"public/archives/page/3/index.html","hash":"7883bfd3ddc58dc4fdf0426db9b0b1128768d33e","modified":1677497679089},{"_id":"public/archives/page/4/index.html","hash":"ccecb192b4e648dca6086a496583518b7c75dd8e","modified":1677497679089},{"_id":"public/archives/page/5/index.html","hash":"20d8e4c4cc51059a12e80178963aa70644d9c7a1","modified":1677497679089},{"_id":"public/archives/page/6/index.html","hash":"4be26d4abebd3a148f5a54f1c8b1db8d7c13da34","modified":1677497679089},{"_id":"public/archives/2020/index.html","hash":"11e21fc57a8726bb756ac56937d15aa14748211c","modified":1677497679089},{"_id":"public/archives/2020/01/index.html","hash":"d479cf6e06dddc1daaf7be0a19798c8725cdd67e","modified":1677497679089},{"_id":"public/archives/page/7/index.html","hash":"89b00558b001bb5ffcf8eb0ce07d042ccabfd3dc","modified":1677497679089},{"_id":"public/archives/2023/index.html","hash":"6e9e603125d5b34af9f0b7886ab3f51acc9e432b","modified":1677497679089},{"_id":"public/archives/2023/page/2/index.html","hash":"ec1657d0ebb553cbbd913e9874f6f0e46f74e3a4","modified":1677497679090},{"_id":"public/archives/2023/page/3/index.html","hash":"ba3af431f465155628a8a397fdf5b935ad3d9b52","modified":1677497679090},{"_id":"public/archives/2023/page/4/index.html","hash":"2a24ffcbbf3fea97d05b39878bf83a5ff693629d","modified":1677497679090},{"_id":"public/archives/2023/page/5/index.html","hash":"ebf27b40058f6375812727a64c7c0f571aa538f4","modified":1677497679090},{"_id":"public/archives/2023/page/6/index.html","hash":"077e90a136d2933a09b38b8ee079819c3b6a40e4","modified":1677497679090},{"_id":"public/archives/2023/02/index.html","hash":"3f24d27ae4bb74e6c2637476cbf7b33a2c91ee2e","modified":1677497679090},{"_id":"public/archives/2023/02/page/2/index.html","hash":"fde9af2602bc021248ec732a7add81913cc3fac6","modified":1677497679090},{"_id":"public/archives/2023/02/page/4/index.html","hash":"76ac334286fd76cb2a6fcfec455834449e99a5b1","modified":1677497679090},{"_id":"public/archives/2023/02/page/3/index.html","hash":"cbd9e9ad80f6984ab47f3a4967b3d6c3c3a52f26","modified":1677497679090},{"_id":"public/archives/2023/02/page/5/index.html","hash":"89d97e0dc8ebd2f62be0011fdaea795f1b90f60f","modified":1677497679090},{"_id":"public/archives/2023/02/page/6/index.html","hash":"fd2123761cbe493c0794d1e78cd6198cc50140d8","modified":1677497679090},{"_id":"public/index.html","hash":"4f4c8645aca87e7ba6c879c69011b554bd4acf70","modified":1677497679090},{"_id":"public/page/2/index.html","hash":"bc6e10e8d9d6209fe377c3a2c77edaae7c19604c","modified":1677497679090},{"_id":"public/page/3/index.html","hash":"e5db80fbaa8addf6196a12ac8c951bfec535ff9b","modified":1677497679090},{"_id":"public/page/4/index.html","hash":"53787778684045bfecb7d3154b44707b26cd965b","modified":1677497679090},{"_id":"public/page/5/index.html","hash":"023e24d01bedb0b959d25f2094645d3c8c06b934","modified":1677497679090},{"_id":"public/page/6/index.html","hash":"3894ef58e896e29148b2d5ed084054e8aae5ec48","modified":1677497679090},{"_id":"public/page/7/index.html","hash":"81ee745d938447936697d29532b517aca517cae4","modified":1677497679090},{"_id":"public/CNAME","hash":"c0d2c0e3668168f4916226dd999a27dbfbdc8046","modified":1677497679109},{"_id":"public/medias/contact.jpg","hash":"ddcca26c52b203ad85330f094d802e51a04cfac8","modified":1677497679110},{"_id":"public/medias/avatars/ajin.jpg","hash":"76cb8e872472ff47a1b061c3bcff1c03f30c02b8","modified":1677497679110},{"_id":"public/medias/avatars/babyq.png","hash":"be5432588003e5a52c02e690622eec72b5f7346c","modified":1677497679110},{"_id":"public/medias/avatars/fun4go.png","hash":"0f4333973a972a629cfbabf601bc7c192b65376c","modified":1677497679110},{"_id":"public/medias/avatars/huaji.jpg","hash":"86be7eed2a491455ccfe3e7da46366ff477765ca","modified":1677497679110},{"_id":"public/medias/avatars/hael.jpg","hash":"e66ccedab38bb2e8fc45fac024e234ab8e7b9d54","modified":1677497679110},{"_id":"public/medias/avatars/cww97.jpg","hash":"6af987cafc55d8d031534dd5e0f722fff19f70ec","modified":1677497679110},{"_id":"public/medias/avatars/hzwer.jpg","hash":"53a66bb5e65d2abd5b7412edf094c1e0b1094492","modified":1677497679110},{"_id":"public/medias/avatars/michael.jpg","hash":"331a2ab20c299196f5a3089b8445fc8f55346cb6","modified":1677497679110},{"_id":"public/medias/avatars/kewlgrl.jpg","hash":"3af0fd1029a1511bb3c0e90871e41b35e714b01f","modified":1677497679110},{"_id":"public/medias/avatars/mpy634.png","hash":"30f88e09c02b37c2dc684d4ee3237e327bb23f8b","modified":1677497679110},{"_id":"public/medias/avatars/masterx.jpg","hash":"c9f7e83d895fa241cefd6e742f356106b35f1b89","modified":1677497679110},{"_id":"public/medias/avatars/taotao.jpg","hash":"e668254375ddd40a684ff4669c3421851bebd36e","modified":1677497679110},{"_id":"public/medias/avatars/mouse.jpg","hash":"2eae273885b9859150a1f98f74b3df12ca9a207c","modified":1677497679110},{"_id":"public/medias/avatars/ids2.jpg","hash":"2c8d3ac6ab5ac6196bac83766fde975daca91c32","modified":1677497679110},{"_id":"public/medias/avatars/taowei.jpg","hash":"e58b03b70656aa7a27238be38dac3896d9d16f10","modified":1677497679110},{"_id":"public/medias/avatars/spacesac.png","hash":"ff1bdb058f1f0499312da1a082ba97d78590db1a","modified":1677497679110},{"_id":"public/medias/avatars/tawn.jpg","hash":"68a1cbacbb2370912b000c9d8d2b16196c918a50","modified":1677497679110},{"_id":"public/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1677497679110},{"_id":"public/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1677497679110},{"_id":"public/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1677497679110},{"_id":"public/libs/lightGallery/img/vimeo-play.png","hash":"1142b47de219dddfba2e712cd3189dec0c8b7bee","modified":1677497679110},{"_id":"public/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1677497679110},{"_id":"public/libs/lightGallery/img/youtube-play.png","hash":"39150b45ec5fc03155b7ebeaa44f1829281788e2","modified":1677497679110},{"_id":"public/libs/lightGallery/img/video-play.png","hash":"fbfdbe06aebf7d0c00da175a4810cf888d128f11","modified":1677497679110},{"_id":"public/libs/share/fonts/iconfont.svg","hash":"337b4f156f6d8f4beb32c32a3db46fef361cff74","modified":1677497679110},{"_id":"public/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1677497679110},{"_id":"public/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1677497679110},{"_id":"public/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1677497679110},{"_id":"public/medias/music/avatars/tiantangdemogui.jpg","hash":"f005578ddb4d3d731838db89a708f39f18d50e60","modified":1677497679110},{"_id":"public/medias/music/avatars/yequ.jpg","hash":"103beb9ab33434b434fa37a30aecdb29db633024","modified":1677497679110},{"_id":"public/medias/music/avatars/yiluxiangbei.jpg","hash":"01b12e3aca7385a88412c12539e1a608a78896fa","modified":1677497679110},{"_id":"public/libs/lightGallery/fonts/lg.svg","hash":"3480f00d284c812d623ed16a9e0ead3fb964c72e","modified":1677497679110},{"_id":"public/css/prism-line-numbers.css","hash":"e0db113a99e4a09d2161a539b1652d96e4a22fac","modified":1677497679110},{"_id":"public/css/prism-tomorrow.css","hash":"3b99487dfc9b4e51e9105a93743b92a761840e34","modified":1677497679110},{"_id":"public/medias/logo.png","hash":"7f2a0ce94192eec2743b2dbae4cb2355b469ffa5","modified":1677497679121},{"_id":"public/favicon.png","hash":"7f2a0ce94192eec2743b2dbae4cb2355b469ffa5","modified":1677497679122},{"_id":"public/medias/avatars/gsy.jpg","hash":"6a175e2ba56a2280d40a2e654b559be41c3a0a48","modified":1677497679126},{"_id":"public/medias/avatars/avatar.jpg","hash":"7f2a0ce94192eec2743b2dbae4cb2355b469ffa5","modified":1677497679126},{"_id":"public/medias/avatars/duyupei.jpg","hash":"3c02ed4cf57dc37e4f4b8314bf5094833a854cb0","modified":1677497679126},{"_id":"public/medias/avatars/bytedtrans.png","hash":"ce59d69e5106f20548f4ec9b6429c8fcc787ea08","modified":1677497679126},{"_id":"public/medias/avatars/myzhihu.png","hash":"7f2a0ce94192eec2743b2dbae4cb2355b469ffa5","modified":1677497679126},{"_id":"public/medias/avatars/qiandongwei.jpg","hash":"6873551596a4513d01898ad866c4073c68270c57","modified":1677497679127},{"_id":"public/medias/reward/wechat.png","hash":"764b7b0cb45722f77869f2a242d4a3a0588c7ecf","modified":1677497679127},{"_id":"public/medias/avatars/mizunashi.png","hash":"5fc300701d3b4250a307ed70e3a3aa0d5395c808","modified":1677497679127},{"_id":"public/medias/avatars/antnlp.ico","hash":"29475f350b989331cebd702a315f020917d06ed8","modified":1677497679127},{"_id":"public/medias/avatars/milyyy.jpg","hash":"ac2826d9c28346efeb967df01465a2c74d9041fe","modified":1677497679127},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1677497679127},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1677497679127},{"_id":"public/css/my.css","hash":"497e50351f7838f8546cac76850a42e7e380a110","modified":1677497679143},{"_id":"public/js/search.js","hash":"499e11786efbb04815b54a1de317cc8606a37555","modified":1677497679144},{"_id":"public/js/matery.js","hash":"92f07106944f5ef7cd72e84bb3534513d00eebe1","modified":1677497679148},{"_id":"public/css/gitment.css","hash":"2bd15cc17dca35ac3ecc0acf167a23a1dd362acd","modified":1677497679148},{"_id":"public/css/my-gitalk.css","hash":"eeda46a83d0db1cc239a9cd27d544faf663f9883","modified":1677497679148},{"_id":"public/libs/aos/aos.js","hash":"02bfb40b0c4b6e9b0b4081218357145cbb327d74","modified":1677497679148},{"_id":"public/libs/aplayer/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1677497679148},{"_id":"public/libs/codeBlock/codeBlockFuction.js","hash":"c7ab06d27a525b15b1eb69027135269e9b9132fb","modified":1677497679148},{"_id":"public/libs/codeBlock/codeShrink.js","hash":"215910dc8f63fd50b97957e5fcdc8480aa2728cb","modified":1677497679148},{"_id":"public/libs/codeBlock/codeCopy.js","hash":"b74a381adf6ef8404d6a0452c2b9f44b47219c80","modified":1677497679148},{"_id":"public/libs/codeBlock/codeLang.js","hash":"ea8b51e4d75e7b2cd63e4d5bcb8db2cf7f23f5db","modified":1677497679148},{"_id":"public/libs/jqcloud/jqcloud.css","hash":"20d9f11a19d95c70e27cb922e0d6dccbec4eae89","modified":1677497679148},{"_id":"public/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"257eaae3020599e4939f50d5008a743827f25b8c","modified":1677497679148},{"_id":"public/libs/others/explosion.min.js","hash":"417b68e2cf2c6de2119c57626f4412105a8457f5","modified":1677497679148},{"_id":"public/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1677497679148},{"_id":"public/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1677497679148},{"_id":"public/libs/others/fireworks.js","hash":"53981959bc6def4a85bbbb41b07e4b1474a2124d","modified":1677497679148},{"_id":"public/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1677497679148},{"_id":"public/libs/tocbot/tocbot.css","hash":"15601837bf8557c2fd111e4450ed4c8495fd11a0","modified":1677497679148},{"_id":"public/libs/others/text.js","hash":"1791782cde0d1e4197f2ed58ecb7dd6aefddd169","modified":1677497679148},{"_id":"public/libs/others/snow.js","hash":"7f3b1ad2f64d4473210a2c3218893649c73c980e","modified":1677497679148},{"_id":"public/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1677497679148},{"_id":"public/libs/share/css/share.min.css","hash":"8a778a86f3ce9a042df6be63a9f1039631e351a5","modified":1677497679148},{"_id":"public/css/matery.css","hash":"caa63c2c7908e45ebbbea0fbdc72d09b7b6d5b76","modified":1677497679148},{"_id":"public/libs/codeBlock/clipboard.min.js","hash":"9cd57c67fbd3e3067f80793ef8445f5ff7783563","modified":1677497679148},{"_id":"public/libs/animate/animate.min.css","hash":"97afa151569f046b2e01f27c1871646e9cd87caf","modified":1677497679148},{"_id":"public/libs/aos/aos.css","hash":"191a3705a8f63e589a50a0ff2f2c5559f1a1b6b2","modified":1677497679148},{"_id":"public/libs/dplayer/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1677497679148},{"_id":"public/libs/cryptojs/crypto-js.min.js","hash":"5989527a378b55011a59522f41eeb3981518325c","modified":1677497679148},{"_id":"public/libs/gitment/gitment-default.css","hash":"2903c59ee06b965bef32e937bd69f5b0b2190717","modified":1677497679148},{"_id":"public/libs/masonry/masonry.pkgd.min.js","hash":"ff940b4ea68368ca0e4d5560cbb79fb147dfc3c5","modified":1677497679149},{"_id":"public/libs/gitalk/gitalk.css","hash":"3aac1db83b0135c521187254ff302d125cc30706","modified":1677497679149},{"_id":"public/libs/aplayer/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1677497679149},{"_id":"public/libs/gitment/gitment.js","hash":"28c02c45ce568e084cd1041dc493f83f9c6c88c6","modified":1677497679149},{"_id":"public/libs/jquery/jquery-2.2.0.min.js","hash":"5d7e5bbfa540f0e53bd599e4305e1a4e815b5dd1","modified":1677497679149},{"_id":"public/libs/valine/Valine.min.js","hash":"4e34802ccbb59f1daa58a62241ff57f923e50600","modified":1677497679149},{"_id":"public/libs/awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1677497679149},{"_id":"public/libs/gitalk/gitalk.min.js","hash":"28bdb33c9eb609c2f30d431df1a4cf8ca70bf841","modified":1677497679149},{"_id":"public/libs/dplayer/DPlayer.min.js","hash":"c3bad7b265574fab0ae4d45867422ea1cb9d6599","modified":1677497679149},{"_id":"public/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1677497679149},{"_id":"public/libs/materialize/materialize.min.css","hash":"4d46df5f22cbc24eefa76228c7ee308dc3585594","modified":1677497679149},{"_id":"public/libs/lightGallery/js/lightgallery-all.min.js","hash":"9f5ef4bc8a0a3c746ca4f3c3e6d64493b1a977d8","modified":1677497679149},{"_id":"public/libs/materialize/materialize.min.js","hash":"c8b4c65651921d888cf5f27430dfe2ad190d35bf","modified":1677497679150},{"_id":"public/libs/share/js/jquery.share.min.js","hash":"16ce82901ca0e302cf47a35fb10f59009a5e7eb9","modified":1677497679150},{"_id":"public/libs/valine/av-min.js","hash":"2577e72b52b736d99649f9e95be8976d58563333","modified":1677497679150},{"_id":"public/libs/share/js/social-share.min.js","hash":"4df722bafde2c5d8faaace0d1f894798385a8793","modified":1677497679150},{"_id":"public/medias/avatars/0xbird.png","hash":"f9d597dfcb49e1e2be06138b24028291f5638610","modified":1677497679151},{"_id":"public/medias/avatars/lyn-draw.jpg","hash":"837d5d5df4dcb086d2da114d0d85084b4ec18768","modified":1677497679151},{"_id":"public/medias/avatars/lzh.png","hash":"8ffcbf19d6b38b891dbe408d9a4e9513b56f247e","modified":1677497679151},{"_id":"public/medias/avatars/mashiro.jpg","hash":"250e911c16eeb6acb1e6214ad3e6a3d762850a8e","modified":1677497679151},{"_id":"public/medias/avatars/qianqian.png","hash":"fed254c4e7eb58ee22d647acb83f1d08f4508f8f","modified":1677497679151},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1677497679151},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1677497679151},{"_id":"public/libs/awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1677497679151},{"_id":"public/libs/echarts/echarts.min.js","hash":"9496f386a0da4601cad22c479cc5543913a4d67f","modified":1677497679163},{"_id":"public/medias/avatars/feibar.png","hash":"eceaefcbbca1bf49b582eaa649d311cf4fe69dd6","modified":1677497679177},{"_id":"public/medias/avatars/jingjing.jpg","hash":"bfcab0139edb2509de984cb0a9b156879c355158","modified":1677497679177},{"_id":"public/medias/banner/10.jpg","hash":"59ecd3a562d44d7e64c8f36fbb28f6ae2b11e10e","modified":1677497679177},{"_id":"public/medias/featureimages/10.jpg","hash":"59ecd3a562d44d7e64c8f36fbb28f6ae2b11e10e","modified":1677497679184},{"_id":"public/medias/music/avatars/daoshu.jpg","hash":"eee120fdf5ccbe86aa7d51826c4c773e76e6357f","modified":1677497679184},{"_id":"public/medias/banner/4.jpg","hash":"40f63fd8d9c9e5f969ce50b2bcc83aa0354f5a33","modified":1677497679197},{"_id":"public/medias/featureimages/4.jpg","hash":"40f63fd8d9c9e5f969ce50b2bcc83aa0354f5a33","modified":1677497679208},{"_id":"public/libs/awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1677497679208},{"_id":"public/medias/featureimages/14.png","hash":"f03845c3c10ab653685d5d071f4198b49b7585b1","modified":1677497679256},{"_id":"public/medias/banner/14.png","hash":"f03845c3c10ab653685d5d071f4198b49b7585b1","modified":1677497679256},{"_id":"public/medias/banner/8.png","hash":"81692c30d34e2df2f29a791887ba13fcd0c6a689","modified":1677497679268},{"_id":"public/medias/featureimages/8.png","hash":"81692c30d34e2df2f29a791887ba13fcd0c6a689","modified":1677497679269},{"_id":"public/medias/featureimages/9.jpg","hash":"5702d24e0e01a7439bcfdcbd338724c8e786426b","modified":1677497679275},{"_id":"public/medias/banner/9.jpg","hash":"5702d24e0e01a7439bcfdcbd338724c8e786426b","modified":1677497679287},{"_id":"public/medias/featureimages/3.png","hash":"db86e0f6de0f9a01e81d59fe165023e38fa4cad5","modified":1677497679287},{"_id":"public/medias/banner/3.png","hash":"db86e0f6de0f9a01e81d59fe165023e38fa4cad5","modified":1677497679287},{"_id":"public/medias/banner/7.jpg","hash":"466f65b9effd7d27a086567e366702d8a1e92b3d","modified":1677497679291},{"_id":"public/medias/banner/13.jpg","hash":"1dbb186ada20d824361c5358ea4f7401630a1893","modified":1677497679298},{"_id":"public/medias/featureimages/13.jpg","hash":"1dbb186ada20d824361c5358ea4f7401630a1893","modified":1677497679298},{"_id":"public/medias/banner/6.jpg","hash":"6469b45fcc292902230d85865bcc91d4db00d304","modified":1677497679299},{"_id":"public/medias/featureimages/6.jpg","hash":"6469b45fcc292902230d85865bcc91d4db00d304","modified":1677497679301},{"_id":"public/medias/featureimages/7.jpg","hash":"466f65b9effd7d27a086567e366702d8a1e92b3d","modified":1677497679301},{"_id":"public/medias/banner/5.jpg","hash":"c56e00ae297db6791a266182f8db10b0f39a53ba","modified":1677497679307},{"_id":"public/medias/featureimages/5.jpg","hash":"c56e00ae297db6791a266182f8db10b0f39a53ba","modified":1677497679307},{"_id":"public/medias/banner/11.jpg","hash":"a5225ee4280ffdf674b9cc44340584fa8d8a61d8","modified":1677497679308},{"_id":"public/medias/featureimages/11.jpg","hash":"a5225ee4280ffdf674b9cc44340584fa8d8a61d8","modified":1677497679310},{"_id":"public/medias/featureimages/0.jpg","hash":"7f62782d975e7ae80c16d53f87f373957623843e","modified":1677497679332},{"_id":"public/medias/banner/0.jpg","hash":"7f62782d975e7ae80c16d53f87f373957623843e","modified":1677497679337},{"_id":"public/medias/banner/1.jpg","hash":"9a7549249a56abb438a051f4fe2c54217e2d158f","modified":1677497679385},{"_id":"public/medias/featureimages/2.jpg","hash":"9a7549249a56abb438a051f4fe2c54217e2d158f","modified":1677497679388},{"_id":"public/medias/banner/15.png","hash":"d9d314cf96a93793c379688e0fe7c24ff2053076","modified":1677497679391},{"_id":"public/medias/featureimages/15.png","hash":"d9d314cf96a93793c379688e0fe7c24ff2053076","modified":1677497679393},{"_id":"public/medias/banner/2.jpg","hash":"84c8d260d468bd86ab977c57a4397f7076653ca3","modified":1677497679424},{"_id":"public/medias/featureimages/1.jpg","hash":"84c8d260d468bd86ab977c57a4397f7076653ca3","modified":1677497679428},{"_id":"public/medias/banner/12.jpg","hash":"8960cdbfb738ca8a604260f86859b40a361f4f51","modified":1677497679440},{"_id":"public/medias/featureimages/12.jpg","hash":"8960cdbfb738ca8a604260f86859b40a361f4f51","modified":1677497679440}],"Category":[],"Data":[{"_id":"musics","data":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}]},{"_id":"friends","data":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}],"Page":[{"title":"404","date":"2020-07-19T08:41:10.000Z","type":"404","layout":"404","description":"你来到了没有知识的荒原 :(","_content":"","source":"404.md","raw":"---\ntitle: 404\ndate: 2020-07-19 16:41:10\ntype: \"404\"\nlayout: \"404\"\ndescription: \"你来到了没有知识的荒原 :(\"\n---\n","updated":"2023-02-27T10:58:42.116Z","path":"404.html","comments":1,"_id":"clemqsy7n00000gcnxp46709k","content":"","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":""},{"title":"about","date":"2019-07-19T08:41:10.000Z","type":"about","layout":"about","mathjax":true,"_content":"\n# 介绍\n还没毕业呢，先摆烂再说吧","source":"about/index.md","raw":"---\ntitle: about\ndate: 2019-07-19 16:41:10\ntype: \"about\"\nlayout: \"about\"\nmathjax: true\n---\n\n# 介绍\n还没毕业呢，先摆烂再说吧","updated":"2023-02-27T09:57:46.225Z","path":"about/index.html","comments":1,"_id":"clemqsy9w00010gcnj5c5q4a1","content":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>还没毕业呢，先摆烂再说吧</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>还没毕业呢，先摆烂再说吧</p>\n"},{"title":"friends","date":"2020-07-19T08:42:10.000Z","type":"friends","layout":"friends","_content":"\n# 友链交换\n想要交换友链的小伙伴，欢迎在留言板留言，留言格式：\n* **名称：**你的博客名称\n* **地址：**你的博客地址\n* **简介：**一句话简介\n* **头像：**你的头像地址\n","source":"friends/index.md","raw":"---\ntitle: friends\ndate: 2020-07-19 16:42:10\ntype: \"friends\"\nlayout: \"friends\"\n---\n\n# 友链交换\n想要交换友链的小伙伴，欢迎在留言板留言，留言格式：\n* **名称：**你的博客名称\n* **地址：**你的博客地址\n* **简介：**一句话简介\n* **头像：**你的头像地址\n","updated":"2023-02-27T10:58:24.315Z","path":"friends/index.html","comments":1,"_id":"clemqsya200030gcn25xhpej5","content":"<h1 id=\"友链交换\"><a href=\"#友链交换\" class=\"headerlink\" title=\"友链交换\"></a>友链交换</h1><p>想要交换友链的小伙伴，欢迎在留言板留言，留言格式：</p>\n<ul>\n<li><strong>名称：</strong>你的博客名称</li>\n<li><strong>地址：</strong>你的博客地址</li>\n<li><strong>简介：</strong>一句话简介</li>\n<li><strong>头像：</strong>你的头像地址</li>\n</ul>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"友链交换\"><a href=\"#友链交换\" class=\"headerlink\" title=\"友链交换\"></a>友链交换</h1><p>想要交换友链的小伙伴，欢迎在留言板留言，留言格式：</p>\n<ul>\n<li><strong>名称：</strong>你的博客名称</li>\n<li><strong>地址：</strong>你的博客地址</li>\n<li><strong>简介：</strong>一句话简介</li>\n<li><strong>头像：</strong>你的头像地址</li>\n</ul>\n"},{"title":"contact","date":"2020-07-26T09:17:02.000Z","type":"contact","layout":"contact","_content":"\n# 欢迎留言\n大家有任何问题，都可以在评论区给我留言，或者加 QQ \n","source":"contact/index.md","raw":"---\ntitle: contact\ndate: 2020-07-26 17:17:02\ntype: \"contact\"\nlayout: \"contact\"\n---\n\n# 欢迎留言\n大家有任何问题，都可以在评论区给我留言，或者加 QQ \n","updated":"2023-02-27T10:58:29.506Z","path":"contact/index.html","comments":1,"_id":"clemqsya400050gcnb6qdu7jc","content":"<h1 id=\"欢迎留言\"><a href=\"#欢迎留言\" class=\"headerlink\" title=\"欢迎留言\"></a>欢迎留言</h1><p>大家有任何问题，都可以在评论区给我留言，或者加 QQ </p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"欢迎留言\"><a href=\"#欢迎留言\" class=\"headerlink\" title=\"欢迎留言\"></a>欢迎留言</h1><p>大家有任何问题，都可以在评论区给我留言，或者加 QQ </p>\n"},{"title":"categories","date":"2020-07-19T08:39:20.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2020-07-19 16:39:20\ntype: \"categories\"\nlayout: \"categories\"\n---","updated":"2023-02-27T10:57:36.894Z","path":"categories/index.html","comments":1,"_id":"clemqsyab00060gcnzcd55fwz","content":"","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":""},{"title":"archives","date":"2020-07-19T08:39:20.000Z","type":"archives","layout":"archives","_content":"","source":"archives/index.md","raw":"---\ntitle: archives\ndate: 2020-07-19 16:39:20\ntype: \"archives\"\nlayout: \"archives\"\n---","updated":"2023-02-27T10:57:30.313Z","path":"archives/index.html","comments":1,"_id":"clemqsyac00070gcn48cn47kt","content":"","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":""},{"title":"tags","date":"2020-07-19T08:40:27.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2020-07-19 16:40:27\ntype: \"tags\"\nlayout: \"tags\"\n---","updated":"2023-02-27T10:58:18.980Z","path":"tags/index.html","comments":1,"_id":"clemqsyad00080gcn523sam01","content":"","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":""}],"Post":[{"_content":"","source":"_posts/dl/新建文件.md","raw":"","slug":"dl/新建文件","published":1,"date":"2023-02-27T11:33:23.573Z","updated":"2023-02-27T11:34:33.132Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsy9x00020gcn7myq98l0","content":"","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":""},{"_content":"","source":"_posts/实验室维护/高效内网分流策略.md","raw":"","slug":"实验室维护/高效内网分流策略","published":1,"date":"2023-02-27T11:33:23.584Z","updated":"2023-02-27T11:34:33.143Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsya200040gcnyuldgo44","content":"","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":""},{"_content":"","source":"_posts/代理/代码批量测试.md","raw":"","slug":"代理/代码批量测试","published":1,"date":"2023-02-27T11:33:23.575Z","updated":"2023-02-27T11:34:33.134Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsyb600090gcnppxruj9z","content":"","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":""},{"_content":"## cuda环境的配置\n\n分为不同的系统，把环境变量的搞好就行\n\n\n\n\n\n## cuda版本可以向下兼容\n\n比如我的cuda是11.0.\n\n如果我安装需要cuda11.1的库，那么肯定过不了。\n\n但是如果我安装cuda版本为10.1的，那么可以继续兼容安装\n\n\n\n\n\n## 基于docker 的nvida环境配置\n\n要配置好这个环境1，需要首先安装好NVIDIA Container Toolkit的这个容器。\n和配置cuda类似，主要需要注意cuda的版本要和自己的cuda版本兼容\n\n```\n# install NVIDIA Container Toolkit\n\ndistribution=$(. /etc/os-release;echo $ID$VERSION_ID) \\\n   && curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add - \\\n   && curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list\n   \ncurl -s -L https://nvidia.github.io/nvidia-container-runtime/experimental/$distribution/nvidia-container-runtime.list | sudo tee /etc/apt/sources.list.d/nvidia-container-runtime.list\n\nsudo apt-get update\n\nsudo apt-get install -y nvidia-docker2\n\nsudo systemctl restart docker\n\n\n# run a container with gpu\n\n# 一个基于Ubuntu的基础镜像\nsudo docker run --rm --gpus all nvidia/cuda:11.0.3-base-ubuntu20.04 nvidia-smi\n\n\n#sudo docker run --rm --gpus all nvidia/cuda:11.0-base nvidia-smi\n#or \n#nvidia-docker run --rm all nvidia/cuda:11.0-base nvidia-smi\n\n```\n\n\n\n\n\n**其他项目如果需要使用到NVIDIA环境，那么需要在启动时声明。**\n\n\n\n\n\n\n\n\n## mindspore 环境的安装\n\n我这里选择的是用docker去安装\n\n\n\n```bash\ndocker run -i -p 51020:22 -p 51180:8888 -v /dev/shm:/dev/shm -v $PWD/ms:/home --runtime=nvidia swr.cn-south-1.myhuaweicloud.com/mindspore/mindspore-gpu-cuda10.1:1.8.1 \n```\n\n\n\n\n\n\n\n## docker ssh服务\n\n\n\n设置root用户密码为admin\n\n```\npasswd\n```\n\n\n\n开启容器的ssh服务\n\nhttps://www.cnblogs.com/devilmaycry812839668/p/13691236.html\n\n\n\n```\n# update source\napt-get update\n\n# install ssh\napt-get install openssh-server\n\n# maybe need \nmkdir /run/sshd\n\n# start\n/usr/sbin/sshd -D &\n\n\n# 注意\n\nssh服务，可以设置为该环境的初始启动命令\n\n```\n\n\n\n打开root用户的登录权限\n\n```\n通过 cat 等指令查看 /etc/ssh/sshd_config 中是否包含类似如下配置：\nPermitRootLogin no\n改为yes\n```\n\n然后重启ssh服务就行\n\n\n\n\n\n## ref\n\nhttps://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html#docker\n\nhttps://juejin.cn/post/6999883472487596062","source":"_posts/dl/dl环境cuda.md","raw":"## cuda环境的配置\n\n分为不同的系统，把环境变量的搞好就行\n\n\n\n\n\n## cuda版本可以向下兼容\n\n比如我的cuda是11.0.\n\n如果我安装需要cuda11.1的库，那么肯定过不了。\n\n但是如果我安装cuda版本为10.1的，那么可以继续兼容安装\n\n\n\n\n\n## 基于docker 的nvida环境配置\n\n要配置好这个环境1，需要首先安装好NVIDIA Container Toolkit的这个容器。\n和配置cuda类似，主要需要注意cuda的版本要和自己的cuda版本兼容\n\n```\n# install NVIDIA Container Toolkit\n\ndistribution=$(. /etc/os-release;echo $ID$VERSION_ID) \\\n   && curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add - \\\n   && curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list\n   \ncurl -s -L https://nvidia.github.io/nvidia-container-runtime/experimental/$distribution/nvidia-container-runtime.list | sudo tee /etc/apt/sources.list.d/nvidia-container-runtime.list\n\nsudo apt-get update\n\nsudo apt-get install -y nvidia-docker2\n\nsudo systemctl restart docker\n\n\n# run a container with gpu\n\n# 一个基于Ubuntu的基础镜像\nsudo docker run --rm --gpus all nvidia/cuda:11.0.3-base-ubuntu20.04 nvidia-smi\n\n\n#sudo docker run --rm --gpus all nvidia/cuda:11.0-base nvidia-smi\n#or \n#nvidia-docker run --rm all nvidia/cuda:11.0-base nvidia-smi\n\n```\n\n\n\n\n\n**其他项目如果需要使用到NVIDIA环境，那么需要在启动时声明。**\n\n\n\n\n\n\n\n\n## mindspore 环境的安装\n\n我这里选择的是用docker去安装\n\n\n\n```bash\ndocker run -i -p 51020:22 -p 51180:8888 -v /dev/shm:/dev/shm -v $PWD/ms:/home --runtime=nvidia swr.cn-south-1.myhuaweicloud.com/mindspore/mindspore-gpu-cuda10.1:1.8.1 \n```\n\n\n\n\n\n\n\n## docker ssh服务\n\n\n\n设置root用户密码为admin\n\n```\npasswd\n```\n\n\n\n开启容器的ssh服务\n\nhttps://www.cnblogs.com/devilmaycry812839668/p/13691236.html\n\n\n\n```\n# update source\napt-get update\n\n# install ssh\napt-get install openssh-server\n\n# maybe need \nmkdir /run/sshd\n\n# start\n/usr/sbin/sshd -D &\n\n\n# 注意\n\nssh服务，可以设置为该环境的初始启动命令\n\n```\n\n\n\n打开root用户的登录权限\n\n```\n通过 cat 等指令查看 /etc/ssh/sshd_config 中是否包含类似如下配置：\nPermitRootLogin no\n改为yes\n```\n\n然后重启ssh服务就行\n\n\n\n\n\n## ref\n\nhttps://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html#docker\n\nhttps://juejin.cn/post/6999883472487596062","slug":"dl/dl环境cuda","published":1,"date":"2023-02-27T11:33:23.572Z","updated":"2023-02-27T11:34:33.132Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsyb9000a0gcntmqis031","content":"<h2 id=\"cuda环境的配置\"><a href=\"#cuda环境的配置\" class=\"headerlink\" title=\"cuda环境的配置\"></a>cuda环境的配置</h2><p>分为不同的系统，把环境变量的搞好就行</p>\n<h2 id=\"cuda版本可以向下兼容\"><a href=\"#cuda版本可以向下兼容\" class=\"headerlink\" title=\"cuda版本可以向下兼容\"></a>cuda版本可以向下兼容</h2><p>比如我的cuda是11.0.</p>\n<p>如果我安装需要cuda11.1的库，那么肯定过不了。</p>\n<p>但是如果我安装cuda版本为10.1的，那么可以继续兼容安装</p>\n<h2 id=\"基于docker-的nvida环境配置\"><a href=\"#基于docker-的nvida环境配置\" class=\"headerlink\" title=\"基于docker 的nvida环境配置\"></a>基于docker 的nvida环境配置</h2><p>要配置好这个环境1，需要首先安装好NVIDIA Container Toolkit的这个容器。<br>和配置cuda类似，主要需要注意cuda的版本要和自己的cuda版本兼容</p>\n<pre><code># install NVIDIA Container Toolkit\n\ndistribution=$(. /etc/os-release;echo $ID$VERSION_ID) \\\n   &amp;&amp; curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add - \\\n   &amp;&amp; curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list\n\ncurl -s -L https://nvidia.github.io/nvidia-container-runtime/experimental/$distribution/nvidia-container-runtime.list | sudo tee /etc/apt/sources.list.d/nvidia-container-runtime.list\n\nsudo apt-get update\n\nsudo apt-get install -y nvidia-docker2\n\nsudo systemctl restart docker\n\n\n# run a container with gpu\n\n# 一个基于Ubuntu的基础镜像\nsudo docker run --rm --gpus all nvidia/cuda:11.0.3-base-ubuntu20.04 nvidia-smi\n\n\n#sudo docker run --rm --gpus all nvidia/cuda:11.0-base nvidia-smi\n#or \n#nvidia-docker run --rm all nvidia/cuda:11.0-base nvidia-smi\n</code></pre><p><strong>其他项目如果需要使用到NVIDIA环境，那么需要在启动时声明。</strong></p>\n<h2 id=\"mindspore-环境的安装\"><a href=\"#mindspore-环境的安装\" class=\"headerlink\" title=\"mindspore 环境的安装\"></a>mindspore 环境的安装</h2><p>我这里选择的是用docker去安装</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\">docker run -i -p 51020:22 -p 51180:8888 -v /dev/shm:/dev/shm -v <span class=\"token variable\">$PWD</span>/ms:/home --runtime<span class=\"token operator\">=</span>nvidia swr.cn-south-1.myhuaweicloud.com/mindspore/mindspore-gpu-cuda10.1:1.8.1 <span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h2 id=\"docker-ssh服务\"><a href=\"#docker-ssh服务\" class=\"headerlink\" title=\"docker ssh服务\"></a>docker ssh服务</h2><p>设置root用户密码为admin</p>\n<pre><code>passwd</code></pre><p>开启容器的ssh服务</p>\n<p><a href=\"https://www.cnblogs.com/devilmaycry812839668/p/13691236.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/devilmaycry812839668/p/13691236.html</a></p>\n<pre><code># update source\napt-get update\n\n# install ssh\napt-get install openssh-server\n\n# maybe need \nmkdir /run/sshd\n\n# start\n/usr/sbin/sshd -D &amp;\n\n\n# 注意\n\nssh服务，可以设置为该环境的初始启动命令\n</code></pre><p>打开root用户的登录权限</p>\n<pre><code>通过 cat 等指令查看 /etc/ssh/sshd_config 中是否包含类似如下配置：\nPermitRootLogin no\n改为yes</code></pre><p>然后重启ssh服务就行</p>\n<h2 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h2><p><a href=\"https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html#docker\" target=\"_blank\" rel=\"noopener\">https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html#docker</a></p>\n<p><a href=\"https://juejin.cn/post/6999883472487596062\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6999883472487596062</a></p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h2 id=\"cuda环境的配置\"><a href=\"#cuda环境的配置\" class=\"headerlink\" title=\"cuda环境的配置\"></a>cuda环境的配置</h2><p>分为不同的系统，把环境变量的搞好就行</p>\n<h2 id=\"cuda版本可以向下兼容\"><a href=\"#cuda版本可以向下兼容\" class=\"headerlink\" title=\"cuda版本可以向下兼容\"></a>cuda版本可以向下兼容</h2><p>比如我的cuda是11.0.</p>\n<p>如果我安装需要cuda11.1的库，那么肯定过不了。</p>\n<p>但是如果我安装cuda版本为10.1的，那么可以继续兼容安装</p>\n<h2 id=\"基于docker-的nvida环境配置\"><a href=\"#基于docker-的nvida环境配置\" class=\"headerlink\" title=\"基于docker 的nvida环境配置\"></a>基于docker 的nvida环境配置</h2><p>要配置好这个环境1，需要首先安装好NVIDIA Container Toolkit的这个容器。<br>和配置cuda类似，主要需要注意cuda的版本要和自己的cuda版本兼容</p>\n<pre><code># install NVIDIA Container Toolkit\n\ndistribution=$(. /etc/os-release;echo $ID$VERSION_ID) \\\n   &amp;&amp; curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add - \\\n   &amp;&amp; curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list\n\ncurl -s -L https://nvidia.github.io/nvidia-container-runtime/experimental/$distribution/nvidia-container-runtime.list | sudo tee /etc/apt/sources.list.d/nvidia-container-runtime.list\n\nsudo apt-get update\n\nsudo apt-get install -y nvidia-docker2\n\nsudo systemctl restart docker\n\n\n# run a container with gpu\n\n# 一个基于Ubuntu的基础镜像\nsudo docker run --rm --gpus all nvidia/cuda:11.0.3-base-ubuntu20.04 nvidia-smi\n\n\n#sudo docker run --rm --gpus all nvidia/cuda:11.0-base nvidia-smi\n#or \n#nvidia-docker run --rm all nvidia/cuda:11.0-base nvidia-smi\n</code></pre><p><strong>其他项目如果需要使用到NVIDIA环境，那么需要在启动时声明。</strong></p>\n<h2 id=\"mindspore-环境的安装\"><a href=\"#mindspore-环境的安装\" class=\"headerlink\" title=\"mindspore 环境的安装\"></a>mindspore 环境的安装</h2><p>我这里选择的是用docker去安装</p>\n<pre><code class=\"bash\">docker run -i -p 51020:22 -p 51180:8888 -v /dev/shm:/dev/shm -v $PWD/ms:/home --runtime=nvidia swr.cn-south-1.myhuaweicloud.com/mindspore/mindspore-gpu-cuda10.1:1.8.1 </code></pre>\n<h2 id=\"docker-ssh服务\"><a href=\"#docker-ssh服务\" class=\"headerlink\" title=\"docker ssh服务\"></a>docker ssh服务</h2><p>设置root用户密码为admin</p>\n<pre><code>passwd</code></pre><p>开启容器的ssh服务</p>\n<p><a href=\"https://www.cnblogs.com/devilmaycry812839668/p/13691236.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/devilmaycry812839668/p/13691236.html</a></p>\n<pre><code># update source\napt-get update\n\n# install ssh\napt-get install openssh-server\n\n# maybe need \nmkdir /run/sshd\n\n# start\n/usr/sbin/sshd -D &amp;\n\n\n# 注意\n\nssh服务，可以设置为该环境的初始启动命令\n</code></pre><p>打开root用户的登录权限</p>\n<pre><code>通过 cat 等指令查看 /etc/ssh/sshd_config 中是否包含类似如下配置：\nPermitRootLogin no\n改为yes</code></pre><p>然后重启ssh服务就行</p>\n<h2 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h2><p><a href=\"https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html#docker\" target=\"_blank\" rel=\"noopener\">https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html#docker</a></p>\n<p><a href=\"https://juejin.cn/post/6999883472487596062\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6999883472487596062</a></p>\n"},{"_content":"# neo4j图数据库\n\n这是一个知识图谱搭建并可视化的优秀平台\n\n\n\n## 前置-------java环境安装\n\n不同的neo4j版本对应不同的java环境。\n\n**我这里选择的是neo4j 3.5 对应java版本java8**\n\n\n\n所以要去安装java8.\n\n以linux为例。\n\n我这里选择下载可执行文件。然后从bashrc文件配置环境。\n\n\n\n1、前往oracle Java官网下载JDK（http://www.oracle.com/technetwork/java/javase/downloads/index.html）\n\n推荐华为镜像地址：https://mirrors.huaweicloud.com/java/jdk/\n\n2、解压缩到指定目录（以jdk-8u191-linux-x64.tar.gz为例）\n\n下载后解压。cd进去加入环境变量中。\n\n```\n#set oracle jdk environment\nexport JAVA_HOME=/usr/lib/jvm/jdk1.8.0_191  ## 这里要注意目录要换成自己解压的jdk 目录\nexport JRE_HOME=${JAVA_HOME}/jre  \nexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib  \nexport PATH=${JAVA_HOME}/bin:$PATH \n```\n\n\n\n\n\n\n\n## 安装neo4j\n\n同样也是选择下载可执行文件的方式。\n\nliunx环境[Neo4j](https://so.csdn.net/so/search?q=Neo4j&spm=1001.2101.3001.7020)下载地址：https://neo4j.com/download/other-releases/#releases(社区版免费)\n\n解压\n\n运行\n\n```\n./bin/neo4j start\n```\n\n然后有结果。\n\n![image-20220905200159871](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/2970cc53434809d84eb89184b8668416/a3a551c9751930366f0511a069220dbe.png)\n\n停止\n\n进入bin目录执行./neo4j stop\n\n\n\n查看图数据库状态\n\n进入bin目录执行./neo4j status\n\n\n\n客户端访问\n\nhttp://服务器ip地址:7474/browser/\n\n**在浏览器访问图数据库所在的机器上的7474端口（第一次访问账号neo4j，密码neo4j，会提示修改初始密码）**\n\n","source":"_posts/dl/neo4j知识图谱环境搭建.md","raw":"# neo4j图数据库\n\n这是一个知识图谱搭建并可视化的优秀平台\n\n\n\n## 前置-------java环境安装\n\n不同的neo4j版本对应不同的java环境。\n\n**我这里选择的是neo4j 3.5 对应java版本java8**\n\n\n\n所以要去安装java8.\n\n以linux为例。\n\n我这里选择下载可执行文件。然后从bashrc文件配置环境。\n\n\n\n1、前往oracle Java官网下载JDK（http://www.oracle.com/technetwork/java/javase/downloads/index.html）\n\n推荐华为镜像地址：https://mirrors.huaweicloud.com/java/jdk/\n\n2、解压缩到指定目录（以jdk-8u191-linux-x64.tar.gz为例）\n\n下载后解压。cd进去加入环境变量中。\n\n```\n#set oracle jdk environment\nexport JAVA_HOME=/usr/lib/jvm/jdk1.8.0_191  ## 这里要注意目录要换成自己解压的jdk 目录\nexport JRE_HOME=${JAVA_HOME}/jre  \nexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib  \nexport PATH=${JAVA_HOME}/bin:$PATH \n```\n\n\n\n\n\n\n\n## 安装neo4j\n\n同样也是选择下载可执行文件的方式。\n\nliunx环境[Neo4j](https://so.csdn.net/so/search?q=Neo4j&spm=1001.2101.3001.7020)下载地址：https://neo4j.com/download/other-releases/#releases(社区版免费)\n\n解压\n\n运行\n\n```\n./bin/neo4j start\n```\n\n然后有结果。\n\n![image-20220905200159871](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/2970cc53434809d84eb89184b8668416/a3a551c9751930366f0511a069220dbe.png)\n\n停止\n\n进入bin目录执行./neo4j stop\n\n\n\n查看图数据库状态\n\n进入bin目录执行./neo4j status\n\n\n\n客户端访问\n\nhttp://服务器ip地址:7474/browser/\n\n**在浏览器访问图数据库所在的机器上的7474端口（第一次访问账号neo4j，密码neo4j，会提示修改初始密码）**\n\n","slug":"dl/neo4j知识图谱环境搭建","published":1,"date":"2023-02-27T11:33:23.570Z","updated":"2023-02-27T11:34:33.130Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsyba000b0gcnk2bihrl7","content":"<h1 id=\"neo4j图数据库\"><a href=\"#neo4j图数据库\" class=\"headerlink\" title=\"neo4j图数据库\"></a>neo4j图数据库</h1><p>这是一个知识图谱搭建并可视化的优秀平台</p>\n<h2 id=\"前置——-java环境安装\"><a href=\"#前置——-java环境安装\" class=\"headerlink\" title=\"前置——-java环境安装\"></a>前置——-java环境安装</h2><p>不同的neo4j版本对应不同的java环境。</p>\n<p><strong>我这里选择的是neo4j 3.5 对应java版本java8</strong></p>\n<p>所以要去安装java8.</p>\n<p>以linux为例。</p>\n<p>我这里选择下载可执行文件。然后从bashrc文件配置环境。</p>\n<p>1、前往oracle Java官网下载JDK（<a href=\"http://www.oracle.com/technetwork/java/javase/downloads/index.html）\" target=\"_blank\" rel=\"noopener\">http://www.oracle.com/technetwork/java/javase/downloads/index.html）</a></p>\n<p>推荐华为镜像地址：<a href=\"https://mirrors.huaweicloud.com/java/jdk/\" target=\"_blank\" rel=\"noopener\">https://mirrors.huaweicloud.com/java/jdk/</a></p>\n<p>2、解压缩到指定目录（以jdk-8u191-linux-x64.tar.gz为例）</p>\n<p>下载后解压。cd进去加入环境变量中。</p>\n<pre><code>#set oracle jdk environment\nexport JAVA_HOME=/usr/lib/jvm/jdk1.8.0_191  ## 这里要注意目录要换成自己解压的jdk 目录\nexport JRE_HOME=${JAVA_HOME}/jre  \nexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib  \nexport PATH=${JAVA_HOME}/bin:$PATH </code></pre><h2 id=\"安装neo4j\"><a href=\"#安装neo4j\" class=\"headerlink\" title=\"安装neo4j\"></a>安装neo4j</h2><p>同样也是选择下载可执行文件的方式。</p>\n<p>liunx环境<a href=\"https://so.csdn.net/so/search?q=Neo4j&spm=1001.2101.3001.7020\" target=\"_blank\" rel=\"noopener\">Neo4j</a>下载地址：<a href=\"https://neo4j.com/download/other-releases/#releases(社区版免费)\" target=\"_blank\" rel=\"noopener\">https://neo4j.com/download/other-releases/#releases(社区版免费)</a></p>\n<p>解压</p>\n<p>运行</p>\n<pre><code>./bin/neo4j start</code></pre><p>然后有结果。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/2970cc53434809d84eb89184b8668416/a3a551c9751930366f0511a069220dbe.png\" alt=\"image-20220905200159871\"></p>\n<p>停止</p>\n<p>进入bin目录执行./neo4j stop</p>\n<p>查看图数据库状态</p>\n<p>进入bin目录执行./neo4j status</p>\n<p>客户端访问</p>\n<p>http://服务器ip地址:7474/browser/</p>\n<p><strong>在浏览器访问图数据库所在的机器上的7474端口（第一次访问账号neo4j，密码neo4j，会提示修改初始密码）</strong></p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"neo4j图数据库\"><a href=\"#neo4j图数据库\" class=\"headerlink\" title=\"neo4j图数据库\"></a>neo4j图数据库</h1><p>这是一个知识图谱搭建并可视化的优秀平台</p>\n<h2 id=\"前置——-java环境安装\"><a href=\"#前置——-java环境安装\" class=\"headerlink\" title=\"前置——-java环境安装\"></a>前置——-java环境安装</h2><p>不同的neo4j版本对应不同的java环境。</p>\n<p><strong>我这里选择的是neo4j 3.5 对应java版本java8</strong></p>\n<p>所以要去安装java8.</p>\n<p>以linux为例。</p>\n<p>我这里选择下载可执行文件。然后从bashrc文件配置环境。</p>\n<p>1、前往oracle Java官网下载JDK（<a href=\"http://www.oracle.com/technetwork/java/javase/downloads/index.html）\" target=\"_blank\" rel=\"noopener\">http://www.oracle.com/technetwork/java/javase/downloads/index.html）</a></p>\n<p>推荐华为镜像地址：<a href=\"https://mirrors.huaweicloud.com/java/jdk/\" target=\"_blank\" rel=\"noopener\">https://mirrors.huaweicloud.com/java/jdk/</a></p>\n<p>2、解压缩到指定目录（以jdk-8u191-linux-x64.tar.gz为例）</p>\n<p>下载后解压。cd进去加入环境变量中。</p>\n<pre><code>#set oracle jdk environment\nexport JAVA_HOME=/usr/lib/jvm/jdk1.8.0_191  ## 这里要注意目录要换成自己解压的jdk 目录\nexport JRE_HOME=${JAVA_HOME}/jre  \nexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib  \nexport PATH=${JAVA_HOME}/bin:$PATH </code></pre><h2 id=\"安装neo4j\"><a href=\"#安装neo4j\" class=\"headerlink\" title=\"安装neo4j\"></a>安装neo4j</h2><p>同样也是选择下载可执行文件的方式。</p>\n<p>liunx环境<a href=\"https://so.csdn.net/so/search?q=Neo4j&spm=1001.2101.3001.7020\" target=\"_blank\" rel=\"noopener\">Neo4j</a>下载地址：<a href=\"https://neo4j.com/download/other-releases/#releases(社区版免费)\" target=\"_blank\" rel=\"noopener\">https://neo4j.com/download/other-releases/#releases(社区版免费)</a></p>\n<p>解压</p>\n<p>运行</p>\n<pre><code>./bin/neo4j start</code></pre><p>然后有结果。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/2970cc53434809d84eb89184b8668416/a3a551c9751930366f0511a069220dbe.png\" alt=\"image-20220905200159871\"></p>\n<p>停止</p>\n<p>进入bin目录执行./neo4j stop</p>\n<p>查看图数据库状态</p>\n<p>进入bin目录执行./neo4j status</p>\n<p>客户端访问</p>\n<p>http://服务器ip地址:7474/browser/</p>\n<p><strong>在浏览器访问图数据库所在的机器上的7474端口（第一次访问账号neo4j，密码neo4j，会提示修改初始密码）</strong></p>\n"},{"_content":"# jupyter\n\n为了方便在js里面实现一些例如goto之类的功能。\n\n比如我调参的时候，需要返回到某一行更改参数后重新开始往下执行。\n\n众所周知，python是不支持goto语句的。这里采取类似自动化的方式实现\n\n\n\n## js与jupyter\n\n一个显而易见的办法是使用selenium自动化协议个自动执行脚本。但是这样会比较麻烦。\n\n在查阅相关资料后。获悉，jupyter在浏览器里面会有一个jupyter对象。可以通过对这个对象执行函数，实现全部自动化操作。可以在控制台执行。\n\n![image-20221009193043155](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/536c1e5c631aea0dfc3c8ce5d0023b10/a80556c4920ffd60f5aec9fe4ce89f11.png)\n\n下面讲解一些实用的函数。\n\n\n\n### 方框是分类种类的。\n\n![image-20221009173853724](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/536c1e5c631aea0dfc3c8ce5d0023b10/fa0fdcf30c916680d10ff5ed3ef4bb7f.png)\n\n图里面，第一个是md框，第二个是代码执行框。\n\n\n\n### select选择\n\n第一种，是直接选择第一个框，无论它是什么类型\n\n```\nJupyter.notebook.select(0)\n```\n\n\n\n### 移动选择光标\n\n选择下一个框\n\n```\nJupyter.notebook.select_next()\n```\n\n\n\n### 获取当前选择框的index\n\n当然也可以获取其他属性\n\n```\nJupyter.notebook.get_selected_index()\n```\n\n\n\n### 执行当前选择的框\n\n执行完后并不会自动忘后跳\n\n```\nJupyter.notebook.execute_cell()\n```\n\n\n\n### 执行所有后面的框\n\n包括当前框，并且会自动跳到末尾\n\n```\nJupyter.notebook.execute_cells_below()\n```\n\n\n\n### 一个简单的goto demo\n\n````\nfor(var i=0; i<100; i++){\n  Jupyter.notebook.select(15);\n  Jupyter.notebook.execute_cells_below();\n}\n\n````\n\n","source":"_posts/dl/jupyter 的js控制使用摸索.md","raw":"# jupyter\n\n为了方便在js里面实现一些例如goto之类的功能。\n\n比如我调参的时候，需要返回到某一行更改参数后重新开始往下执行。\n\n众所周知，python是不支持goto语句的。这里采取类似自动化的方式实现\n\n\n\n## js与jupyter\n\n一个显而易见的办法是使用selenium自动化协议个自动执行脚本。但是这样会比较麻烦。\n\n在查阅相关资料后。获悉，jupyter在浏览器里面会有一个jupyter对象。可以通过对这个对象执行函数，实现全部自动化操作。可以在控制台执行。\n\n![image-20221009193043155](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/536c1e5c631aea0dfc3c8ce5d0023b10/a80556c4920ffd60f5aec9fe4ce89f11.png)\n\n下面讲解一些实用的函数。\n\n\n\n### 方框是分类种类的。\n\n![image-20221009173853724](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/536c1e5c631aea0dfc3c8ce5d0023b10/fa0fdcf30c916680d10ff5ed3ef4bb7f.png)\n\n图里面，第一个是md框，第二个是代码执行框。\n\n\n\n### select选择\n\n第一种，是直接选择第一个框，无论它是什么类型\n\n```\nJupyter.notebook.select(0)\n```\n\n\n\n### 移动选择光标\n\n选择下一个框\n\n```\nJupyter.notebook.select_next()\n```\n\n\n\n### 获取当前选择框的index\n\n当然也可以获取其他属性\n\n```\nJupyter.notebook.get_selected_index()\n```\n\n\n\n### 执行当前选择的框\n\n执行完后并不会自动忘后跳\n\n```\nJupyter.notebook.execute_cell()\n```\n\n\n\n### 执行所有后面的框\n\n包括当前框，并且会自动跳到末尾\n\n```\nJupyter.notebook.execute_cells_below()\n```\n\n\n\n### 一个简单的goto demo\n\n````\nfor(var i=0; i<100; i++){\n  Jupyter.notebook.select(15);\n  Jupyter.notebook.execute_cells_below();\n}\n\n````\n\n","slug":"dl/jupyter 的js控制使用摸索","published":1,"date":"2023-02-27T11:33:23.573Z","updated":"2023-02-27T11:34:33.133Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsybb000c0gcnafhwkvw4","content":"<h1 id=\"jupyter\"><a href=\"#jupyter\" class=\"headerlink\" title=\"jupyter\"></a>jupyter</h1><p>为了方便在js里面实现一些例如goto之类的功能。</p>\n<p>比如我调参的时候，需要返回到某一行更改参数后重新开始往下执行。</p>\n<p>众所周知，python是不支持goto语句的。这里采取类似自动化的方式实现</p>\n<h2 id=\"js与jupyter\"><a href=\"#js与jupyter\" class=\"headerlink\" title=\"js与jupyter\"></a>js与jupyter</h2><p>一个显而易见的办法是使用selenium自动化协议个自动执行脚本。但是这样会比较麻烦。</p>\n<p>在查阅相关资料后。获悉，jupyter在浏览器里面会有一个jupyter对象。可以通过对这个对象执行函数，实现全部自动化操作。可以在控制台执行。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/536c1e5c631aea0dfc3c8ce5d0023b10/a80556c4920ffd60f5aec9fe4ce89f11.png\" alt=\"image-20221009193043155\"></p>\n<p>下面讲解一些实用的函数。</p>\n<h3 id=\"方框是分类种类的。\"><a href=\"#方框是分类种类的。\" class=\"headerlink\" title=\"方框是分类种类的。\"></a>方框是分类种类的。</h3><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/536c1e5c631aea0dfc3c8ce5d0023b10/fa0fdcf30c916680d10ff5ed3ef4bb7f.png\" alt=\"image-20221009173853724\"></p>\n<p>图里面，第一个是md框，第二个是代码执行框。</p>\n<h3 id=\"select选择\"><a href=\"#select选择\" class=\"headerlink\" title=\"select选择\"></a>select选择</h3><p>第一种，是直接选择第一个框，无论它是什么类型</p>\n<pre><code>Jupyter.notebook.select(0)</code></pre><h3 id=\"移动选择光标\"><a href=\"#移动选择光标\" class=\"headerlink\" title=\"移动选择光标\"></a>移动选择光标</h3><p>选择下一个框</p>\n<pre><code>Jupyter.notebook.select_next()</code></pre><h3 id=\"获取当前选择框的index\"><a href=\"#获取当前选择框的index\" class=\"headerlink\" title=\"获取当前选择框的index\"></a>获取当前选择框的index</h3><p>当然也可以获取其他属性</p>\n<pre><code>Jupyter.notebook.get_selected_index()</code></pre><h3 id=\"执行当前选择的框\"><a href=\"#执行当前选择的框\" class=\"headerlink\" title=\"执行当前选择的框\"></a>执行当前选择的框</h3><p>执行完后并不会自动忘后跳</p>\n<pre><code>Jupyter.notebook.execute_cell()</code></pre><h3 id=\"执行所有后面的框\"><a href=\"#执行所有后面的框\" class=\"headerlink\" title=\"执行所有后面的框\"></a>执行所有后面的框</h3><p>包括当前框，并且会自动跳到末尾</p>\n<pre><code>Jupyter.notebook.execute_cells_below()</code></pre><h3 id=\"一个简单的goto-demo\"><a href=\"#一个简单的goto-demo\" class=\"headerlink\" title=\"一个简单的goto demo\"></a>一个简单的goto demo</h3><pre><code>for(var i=0; i&lt;100; i++){\n  Jupyter.notebook.select(15);\n  Jupyter.notebook.execute_cells_below();\n}\n</code></pre>","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"jupyter\"><a href=\"#jupyter\" class=\"headerlink\" title=\"jupyter\"></a>jupyter</h1><p>为了方便在js里面实现一些例如goto之类的功能。</p>\n<p>比如我调参的时候，需要返回到某一行更改参数后重新开始往下执行。</p>\n<p>众所周知，python是不支持goto语句的。这里采取类似自动化的方式实现</p>\n<h2 id=\"js与jupyter\"><a href=\"#js与jupyter\" class=\"headerlink\" title=\"js与jupyter\"></a>js与jupyter</h2><p>一个显而易见的办法是使用selenium自动化协议个自动执行脚本。但是这样会比较麻烦。</p>\n<p>在查阅相关资料后。获悉，jupyter在浏览器里面会有一个jupyter对象。可以通过对这个对象执行函数，实现全部自动化操作。可以在控制台执行。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/536c1e5c631aea0dfc3c8ce5d0023b10/a80556c4920ffd60f5aec9fe4ce89f11.png\" alt=\"image-20221009193043155\"></p>\n<p>下面讲解一些实用的函数。</p>\n<h3 id=\"方框是分类种类的。\"><a href=\"#方框是分类种类的。\" class=\"headerlink\" title=\"方框是分类种类的。\"></a>方框是分类种类的。</h3><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/536c1e5c631aea0dfc3c8ce5d0023b10/fa0fdcf30c916680d10ff5ed3ef4bb7f.png\" alt=\"image-20221009173853724\"></p>\n<p>图里面，第一个是md框，第二个是代码执行框。</p>\n<h3 id=\"select选择\"><a href=\"#select选择\" class=\"headerlink\" title=\"select选择\"></a>select选择</h3><p>第一种，是直接选择第一个框，无论它是什么类型</p>\n<pre><code>Jupyter.notebook.select(0)</code></pre><h3 id=\"移动选择光标\"><a href=\"#移动选择光标\" class=\"headerlink\" title=\"移动选择光标\"></a>移动选择光标</h3><p>选择下一个框</p>\n<pre><code>Jupyter.notebook.select_next()</code></pre><h3 id=\"获取当前选择框的index\"><a href=\"#获取当前选择框的index\" class=\"headerlink\" title=\"获取当前选择框的index\"></a>获取当前选择框的index</h3><p>当然也可以获取其他属性</p>\n<pre><code>Jupyter.notebook.get_selected_index()</code></pre><h3 id=\"执行当前选择的框\"><a href=\"#执行当前选择的框\" class=\"headerlink\" title=\"执行当前选择的框\"></a>执行当前选择的框</h3><p>执行完后并不会自动忘后跳</p>\n<pre><code>Jupyter.notebook.execute_cell()</code></pre><h3 id=\"执行所有后面的框\"><a href=\"#执行所有后面的框\" class=\"headerlink\" title=\"执行所有后面的框\"></a>执行所有后面的框</h3><p>包括当前框，并且会自动跳到末尾</p>\n<pre><code>Jupyter.notebook.execute_cells_below()</code></pre><h3 id=\"一个简单的goto-demo\"><a href=\"#一个简单的goto-demo\" class=\"headerlink\" title=\"一个简单的goto demo\"></a>一个简单的goto demo</h3><pre><code>for(var i=0; i&lt;100; i++){\n  Jupyter.notebook.select(15);\n  Jupyter.notebook.execute_cells_below();\n}\n</code></pre>"},{"_content":"## 关于train loss 降低不下去\n\n\n\n### 第一步简单的：更换各种参数\n\n**例如，lr, weight_decay, batch,  loss_fun, optim_fun**\n\n看看会不会有有效果的。\n\n\n\n**学习率**非常重要的参数\n\n```\n神经网络的优化器选取一般选取Adam，但是在有些情况下Adam难以训练，这时候需要使用如SGD之类的其他优化器。学习率决定了网络训练的速度，但学习率不是越大越好，当网络趋近于收敛时应该选择较小的学习率来保证找到更好的最优点。所以，我们需要手动调整学习率，首先选择一个合适的初始学习率，当训练不动之后，稍微降低学习率，然后再训练一段时间，这时候基本上就完全收敛了。一般学习率的调整是乘以/除以10的倍数。不过现在也有一些自动调整学习率的方案了，不过，我们也要知道如何手动调整到合适的学习率。\n```\n\n**batch过大不一定是好事**\n\n太小的size可能会导致难以收敏。但是太大的bantch坑你会使得loss过于平均，抗干扰能力差，泛化能力不行。\n\n\n\n如果没有，进一步思考。\n\n### 是不是网络本身有效性有问题\n\n一个简单的验证办法是，自己捏造一个肯定有用的数据集，然后将自己得网络放到自己的简单数据集上运行。\n\n看能否学习出一个模型。\n\n\n\n### 更换激活函数\n\n不同的激活函数，对模型影响挺大，\n\nRelu可以有效避免梯度消失。利于线性计算\n\n分类用softmax。\n\n\n\n\n\n### 是不是数据本身有问题\n\n如果数据本身有问题，那么无论如何也训练不出什么东西。\n\n\n\n### 查看是不是梯度消失了\n\n查看梯度的代码\n\n```\n    for name, parms in model.named_parameters(): \n        print(parms.grad)\n```\n\n这个是个细致活。不好办。\n\n\n\n\n\n## valid loss 降低不下去\n\n如果过拟合，就正则化。\n\n### 适当降低模型的规模\n\n模型复杂度太高，会导致模型容易学到噪声。\n\n\n\n\n## 关于torch的显存机制\n需要放入显存的并不是只有模型和数据。\n```\n1.模型定义：定义了模型的网络结构，产生模型参数；\nwhile(你想训练):\n    2.前向传播：执行模型的前向传播，产生中间激活值；\n    3.后向传播：执行模型的后向传播，产生梯度；\n    4.梯度更新：执行模型参数的更新，第一次执行的时候产生优化器状态。\n```\n所以在运行中，进程所占用的显存是会有一定波动的。所以最好不要一次性直接放满，不然可能导致会运行着突然溢出了。最好流出一定的显存给中间参数。\n\n\n\n\n# ref\n\nhttps://blog.ailemon.net/2019/02/26/solution-to-loss-doesnt-drop-in-nn-train/","source":"_posts/dl/pytorch调参经验汇总.md","raw":"## 关于train loss 降低不下去\n\n\n\n### 第一步简单的：更换各种参数\n\n**例如，lr, weight_decay, batch,  loss_fun, optim_fun**\n\n看看会不会有有效果的。\n\n\n\n**学习率**非常重要的参数\n\n```\n神经网络的优化器选取一般选取Adam，但是在有些情况下Adam难以训练，这时候需要使用如SGD之类的其他优化器。学习率决定了网络训练的速度，但学习率不是越大越好，当网络趋近于收敛时应该选择较小的学习率来保证找到更好的最优点。所以，我们需要手动调整学习率，首先选择一个合适的初始学习率，当训练不动之后，稍微降低学习率，然后再训练一段时间，这时候基本上就完全收敛了。一般学习率的调整是乘以/除以10的倍数。不过现在也有一些自动调整学习率的方案了，不过，我们也要知道如何手动调整到合适的学习率。\n```\n\n**batch过大不一定是好事**\n\n太小的size可能会导致难以收敏。但是太大的bantch坑你会使得loss过于平均，抗干扰能力差，泛化能力不行。\n\n\n\n如果没有，进一步思考。\n\n### 是不是网络本身有效性有问题\n\n一个简单的验证办法是，自己捏造一个肯定有用的数据集，然后将自己得网络放到自己的简单数据集上运行。\n\n看能否学习出一个模型。\n\n\n\n### 更换激活函数\n\n不同的激活函数，对模型影响挺大，\n\nRelu可以有效避免梯度消失。利于线性计算\n\n分类用softmax。\n\n\n\n\n\n### 是不是数据本身有问题\n\n如果数据本身有问题，那么无论如何也训练不出什么东西。\n\n\n\n### 查看是不是梯度消失了\n\n查看梯度的代码\n\n```\n    for name, parms in model.named_parameters(): \n        print(parms.grad)\n```\n\n这个是个细致活。不好办。\n\n\n\n\n\n## valid loss 降低不下去\n\n如果过拟合，就正则化。\n\n### 适当降低模型的规模\n\n模型复杂度太高，会导致模型容易学到噪声。\n\n\n\n\n## 关于torch的显存机制\n需要放入显存的并不是只有模型和数据。\n```\n1.模型定义：定义了模型的网络结构，产生模型参数；\nwhile(你想训练):\n    2.前向传播：执行模型的前向传播，产生中间激活值；\n    3.后向传播：执行模型的后向传播，产生梯度；\n    4.梯度更新：执行模型参数的更新，第一次执行的时候产生优化器状态。\n```\n所以在运行中，进程所占用的显存是会有一定波动的。所以最好不要一次性直接放满，不然可能导致会运行着突然溢出了。最好流出一定的显存给中间参数。\n\n\n\n\n# ref\n\nhttps://blog.ailemon.net/2019/02/26/solution-to-loss-doesnt-drop-in-nn-train/","slug":"dl/pytorch调参经验汇总","published":1,"date":"2023-02-27T11:33:23.570Z","updated":"2023-02-27T11:34:33.131Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsybc000d0gcn0tv629nd","content":"<h2 id=\"关于train-loss-降低不下去\"><a href=\"#关于train-loss-降低不下去\" class=\"headerlink\" title=\"关于train loss 降低不下去\"></a>关于train loss 降低不下去</h2><h3 id=\"第一步简单的：更换各种参数\"><a href=\"#第一步简单的：更换各种参数\" class=\"headerlink\" title=\"第一步简单的：更换各种参数\"></a>第一步简单的：更换各种参数</h3><p><strong>例如，lr, weight_decay, batch,  loss_fun, optim_fun</strong></p>\n<p>看看会不会有有效果的。</p>\n<p><strong>学习率</strong>非常重要的参数</p>\n<pre><code>神经网络的优化器选取一般选取Adam，但是在有些情况下Adam难以训练，这时候需要使用如SGD之类的其他优化器。学习率决定了网络训练的速度，但学习率不是越大越好，当网络趋近于收敛时应该选择较小的学习率来保证找到更好的最优点。所以，我们需要手动调整学习率，首先选择一个合适的初始学习率，当训练不动之后，稍微降低学习率，然后再训练一段时间，这时候基本上就完全收敛了。一般学习率的调整是乘以/除以10的倍数。不过现在也有一些自动调整学习率的方案了，不过，我们也要知道如何手动调整到合适的学习率。</code></pre><p><strong>batch过大不一定是好事</strong></p>\n<p>太小的size可能会导致难以收敏。但是太大的bantch坑你会使得loss过于平均，抗干扰能力差，泛化能力不行。</p>\n<p>如果没有，进一步思考。</p>\n<h3 id=\"是不是网络本身有效性有问题\"><a href=\"#是不是网络本身有效性有问题\" class=\"headerlink\" title=\"是不是网络本身有效性有问题\"></a>是不是网络本身有效性有问题</h3><p>一个简单的验证办法是，自己捏造一个肯定有用的数据集，然后将自己得网络放到自己的简单数据集上运行。</p>\n<p>看能否学习出一个模型。</p>\n<h3 id=\"更换激活函数\"><a href=\"#更换激活函数\" class=\"headerlink\" title=\"更换激活函数\"></a>更换激活函数</h3><p>不同的激活函数，对模型影响挺大，</p>\n<p>Relu可以有效避免梯度消失。利于线性计算</p>\n<p>分类用softmax。</p>\n<h3 id=\"是不是数据本身有问题\"><a href=\"#是不是数据本身有问题\" class=\"headerlink\" title=\"是不是数据本身有问题\"></a>是不是数据本身有问题</h3><p>如果数据本身有问题，那么无论如何也训练不出什么东西。</p>\n<h3 id=\"查看是不是梯度消失了\"><a href=\"#查看是不是梯度消失了\" class=\"headerlink\" title=\"查看是不是梯度消失了\"></a>查看是不是梯度消失了</h3><p>查看梯度的代码</p>\n<pre><code>    for name, parms in model.named_parameters(): \n        print(parms.grad)</code></pre><p>这个是个细致活。不好办。</p>\n<h2 id=\"valid-loss-降低不下去\"><a href=\"#valid-loss-降低不下去\" class=\"headerlink\" title=\"valid loss 降低不下去\"></a>valid loss 降低不下去</h2><p>如果过拟合，就正则化。</p>\n<h3 id=\"适当降低模型的规模\"><a href=\"#适当降低模型的规模\" class=\"headerlink\" title=\"适当降低模型的规模\"></a>适当降低模型的规模</h3><p>模型复杂度太高，会导致模型容易学到噪声。</p>\n<h2 id=\"关于torch的显存机制\"><a href=\"#关于torch的显存机制\" class=\"headerlink\" title=\"关于torch的显存机制\"></a>关于torch的显存机制</h2><p>需要放入显存的并不是只有模型和数据。</p>\n<pre><code>1.模型定义：定义了模型的网络结构，产生模型参数；\nwhile(你想训练):\n    2.前向传播：执行模型的前向传播，产生中间激活值；\n    3.后向传播：执行模型的后向传播，产生梯度；\n    4.梯度更新：执行模型参数的更新，第一次执行的时候产生优化器状态。</code></pre><p>所以在运行中，进程所占用的显存是会有一定波动的。所以最好不要一次性直接放满，不然可能导致会运行着突然溢出了。最好流出一定的显存给中间参数。</p>\n<h1 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h1><p><a href=\"https://blog.ailemon.net/2019/02/26/solution-to-loss-doesnt-drop-in-nn-train/\" target=\"_blank\" rel=\"noopener\">https://blog.ailemon.net/2019/02/26/solution-to-loss-doesnt-drop-in-nn-train/</a></p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h2 id=\"关于train-loss-降低不下去\"><a href=\"#关于train-loss-降低不下去\" class=\"headerlink\" title=\"关于train loss 降低不下去\"></a>关于train loss 降低不下去</h2><h3 id=\"第一步简单的：更换各种参数\"><a href=\"#第一步简单的：更换各种参数\" class=\"headerlink\" title=\"第一步简单的：更换各种参数\"></a>第一步简单的：更换各种参数</h3><p><strong>例如，lr, weight_decay, batch,  loss_fun, optim_fun</strong></p>\n<p>看看会不会有有效果的。</p>\n<p><strong>学习率</strong>非常重要的参数</p>\n<pre><code>神经网络的优化器选取一般选取Adam，但是在有些情况下Adam难以训练，这时候需要使用如SGD之类的其他优化器。学习率决定了网络训练的速度，但学习率不是越大越好，当网络趋近于收敛时应该选择较小的学习率来保证找到更好的最优点。所以，我们需要手动调整学习率，首先选择一个合适的初始学习率，当训练不动之后，稍微降低学习率，然后再训练一段时间，这时候基本上就完全收敛了。一般学习率的调整是乘以/除以10的倍数。不过现在也有一些自动调整学习率的方案了，不过，我们也要知道如何手动调整到合适的学习率。</code></pre><p><strong>batch过大不一定是好事</strong></p>\n<p>太小的size可能会导致难以收敏。但是太大的bantch坑你会使得loss过于平均，抗干扰能力差，泛化能力不行。</p>\n<p>如果没有，进一步思考。</p>\n<h3 id=\"是不是网络本身有效性有问题\"><a href=\"#是不是网络本身有效性有问题\" class=\"headerlink\" title=\"是不是网络本身有效性有问题\"></a>是不是网络本身有效性有问题</h3><p>一个简单的验证办法是，自己捏造一个肯定有用的数据集，然后将自己得网络放到自己的简单数据集上运行。</p>\n<p>看能否学习出一个模型。</p>\n<h3 id=\"更换激活函数\"><a href=\"#更换激活函数\" class=\"headerlink\" title=\"更换激活函数\"></a>更换激活函数</h3><p>不同的激活函数，对模型影响挺大，</p>\n<p>Relu可以有效避免梯度消失。利于线性计算</p>\n<p>分类用softmax。</p>\n<h3 id=\"是不是数据本身有问题\"><a href=\"#是不是数据本身有问题\" class=\"headerlink\" title=\"是不是数据本身有问题\"></a>是不是数据本身有问题</h3><p>如果数据本身有问题，那么无论如何也训练不出什么东西。</p>\n<h3 id=\"查看是不是梯度消失了\"><a href=\"#查看是不是梯度消失了\" class=\"headerlink\" title=\"查看是不是梯度消失了\"></a>查看是不是梯度消失了</h3><p>查看梯度的代码</p>\n<pre><code>    for name, parms in model.named_parameters(): \n        print(parms.grad)</code></pre><p>这个是个细致活。不好办。</p>\n<h2 id=\"valid-loss-降低不下去\"><a href=\"#valid-loss-降低不下去\" class=\"headerlink\" title=\"valid loss 降低不下去\"></a>valid loss 降低不下去</h2><p>如果过拟合，就正则化。</p>\n<h3 id=\"适当降低模型的规模\"><a href=\"#适当降低模型的规模\" class=\"headerlink\" title=\"适当降低模型的规模\"></a>适当降低模型的规模</h3><p>模型复杂度太高，会导致模型容易学到噪声。</p>\n<h2 id=\"关于torch的显存机制\"><a href=\"#关于torch的显存机制\" class=\"headerlink\" title=\"关于torch的显存机制\"></a>关于torch的显存机制</h2><p>需要放入显存的并不是只有模型和数据。</p>\n<pre><code>1.模型定义：定义了模型的网络结构，产生模型参数；\nwhile(你想训练):\n    2.前向传播：执行模型的前向传播，产生中间激活值；\n    3.后向传播：执行模型的后向传播，产生梯度；\n    4.梯度更新：执行模型参数的更新，第一次执行的时候产生优化器状态。</code></pre><p>所以在运行中，进程所占用的显存是会有一定波动的。所以最好不要一次性直接放满，不然可能导致会运行着突然溢出了。最好流出一定的显存给中间参数。</p>\n<h1 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h1><p><a href=\"https://blog.ailemon.net/2019/02/26/solution-to-loss-doesnt-drop-in-nn-train/\" target=\"_blank\" rel=\"noopener\">https://blog.ailemon.net/2019/02/26/solution-to-loss-doesnt-drop-in-nn-train/</a></p>\n"},{"_content":"# sklearn的库\n\n## 划分训练集，测试集，验证集\n\n```\nfrom sklearn.model_selection import train_test_split\n\ndef train_test_val_split(x,y, train_ratio = 0.8,validation_ratio = 0.1,test_ratio = 0.1,random_state=0):\n    # random_state for reproduction\n    # shuffle must be 'True'\n    [x_train, x_test, y_train, y_test] = train_test_split(\nx, y, test_size=validation_ratio+test_ratio, random_state=random_state, shuffle=True)\n\n    [x_val, x_test, y_val, y_test] = train_test_split(\n    x_test, y_test, test_size=test_ratio/(test_ratio + validation_ratio), random_state=random_state)\n    return x_train,y_train, x_test, y_test, x_val, y_val\n\n```\n\n## pytorch加载batch\n\n**先弄一个dataset类**\n\n```\nfrom __future__ import print_function\nimport torch.utils.data as data\nimport torch\n\nclass MyDataset(data.Dataset):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __getitem__(self, index):#返回的是tensor\n        x_i, y_i = self.x[index], self.y[index]\n        return x_i, y_i\n\n    def __len__(self):\n        return len(self.x)\n\ndataset = MyDataset(images, labels)\n```\n\n说明\n\n```\n在定义torch.utils.data.Dataset的子类时，必须重载的两个函数是__len__和__getitem__。\n__len__返回数据集的大小，\n__getitem__实现数据集的下标索引，返回对应的图像和标记（不一定非得返回图像和标记，返回元组的长度可以是任意长，这由网络需要的数据决定）。\n```\n\n然后可以使用**DataLoader**来载入batch\n\n```\nfrom torch.utils.data import DataLoader\ndataloader = DataLoader(MyDataset(images, labels), batch_size=4, shuffle=True, num_workers=0, drop_last=True)       \n```\n\n**参数说明**\n\n```\ndataset：Dataset类型，从其中加载数据\nbatch_size：int，可选。每个batch加载多少样本\nshuffle：bool，可选。为True时表示每个epoch都对数据进行洗牌\nsampler：Sampler，可选。从数据集中采样样本的方法。\nnum_workers：int，可选。加载数据时使用多少子进程。默认值为0，表示在主进程中加载数据。\ncollate_fn：callable，可选。\npin_memory：bool，可选\ndrop_last：bool，可选。True表示如果最后剩下不完全的batch,丢弃。False表示不丢弃。\n```\n\n\n\n**具体使用说明**\n\n```\nfor batch_x, batch_y in dataloader:\n\tprint(batch_x.shape, batch_y.shape)\n\n# 或者加入索引index\nfor step, (batch_x, batch_y) in enumerate(dataloader):\n\tprint(step, batch_x.shape, batch_y.shape)\n\tpass\n```\n\n\n\n\n\n\n\n\n\n# 利用index自制加载器\n\n```\nimport random\nimport copy\n\n\nclass My_Load():\n    \"\"\"\n    利用index索引自制的数据加载器\n    \"\"\"\n    def __init__(self, all_mask, ratio = [7, 2, 1]):\n        self.all_mask = all_mask\n        total = sum(ratio)\n        mid1 = (ratio[0]) / total\n        mid2 = mid1 + (ratio[1]) / total\n\n        mid1 = int(mid1 * len(all_mask))\n        mid2 = int(mid2 * len(all_mask))\n\n        # 利用打算函数，不重合的分割数据\n        new_all_mask = copy.deepcopy(all_mask)\n        random.shuffle(new_all_mask)\n        self.train_mask = new_all_mask[0:mid1]\n        self.valid_mask = new_all_mask[mid1:mid2]\n        self.test_mask = new_all_mask[mid2:]\n\n\n\n\n    # 随机采样一部分比例数据，相当于minibatch使用\n    def get_rand_mask(self,ratio=1,  num=1, mask = None):\n        \"\"\"\n        :param ratio: 0.7 随机选择70%的数据\n        :param mask: 如果为mask为None，返回all\n        :return:\n        \"\"\"\n        if ratio != 1:\n            len1 = len(mask)\n            num = int(len1 * ratio)\n            ans = random.sample(mask, num)\n            return ans\n        else:\n            ans = random.sample(mask, num)\n            return ans\n\n```\n\n\n\n\n\n\n\n# ref\n\n[pytorch官方](https://pytorch.org/docs/1.13/data.html)\n\ns\n","source":"_posts/dl/数据加载器.md","raw":"# sklearn的库\n\n## 划分训练集，测试集，验证集\n\n```\nfrom sklearn.model_selection import train_test_split\n\ndef train_test_val_split(x,y, train_ratio = 0.8,validation_ratio = 0.1,test_ratio = 0.1,random_state=0):\n    # random_state for reproduction\n    # shuffle must be 'True'\n    [x_train, x_test, y_train, y_test] = train_test_split(\nx, y, test_size=validation_ratio+test_ratio, random_state=random_state, shuffle=True)\n\n    [x_val, x_test, y_val, y_test] = train_test_split(\n    x_test, y_test, test_size=test_ratio/(test_ratio + validation_ratio), random_state=random_state)\n    return x_train,y_train, x_test, y_test, x_val, y_val\n\n```\n\n## pytorch加载batch\n\n**先弄一个dataset类**\n\n```\nfrom __future__ import print_function\nimport torch.utils.data as data\nimport torch\n\nclass MyDataset(data.Dataset):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __getitem__(self, index):#返回的是tensor\n        x_i, y_i = self.x[index], self.y[index]\n        return x_i, y_i\n\n    def __len__(self):\n        return len(self.x)\n\ndataset = MyDataset(images, labels)\n```\n\n说明\n\n```\n在定义torch.utils.data.Dataset的子类时，必须重载的两个函数是__len__和__getitem__。\n__len__返回数据集的大小，\n__getitem__实现数据集的下标索引，返回对应的图像和标记（不一定非得返回图像和标记，返回元组的长度可以是任意长，这由网络需要的数据决定）。\n```\n\n然后可以使用**DataLoader**来载入batch\n\n```\nfrom torch.utils.data import DataLoader\ndataloader = DataLoader(MyDataset(images, labels), batch_size=4, shuffle=True, num_workers=0, drop_last=True)       \n```\n\n**参数说明**\n\n```\ndataset：Dataset类型，从其中加载数据\nbatch_size：int，可选。每个batch加载多少样本\nshuffle：bool，可选。为True时表示每个epoch都对数据进行洗牌\nsampler：Sampler，可选。从数据集中采样样本的方法。\nnum_workers：int，可选。加载数据时使用多少子进程。默认值为0，表示在主进程中加载数据。\ncollate_fn：callable，可选。\npin_memory：bool，可选\ndrop_last：bool，可选。True表示如果最后剩下不完全的batch,丢弃。False表示不丢弃。\n```\n\n\n\n**具体使用说明**\n\n```\nfor batch_x, batch_y in dataloader:\n\tprint(batch_x.shape, batch_y.shape)\n\n# 或者加入索引index\nfor step, (batch_x, batch_y) in enumerate(dataloader):\n\tprint(step, batch_x.shape, batch_y.shape)\n\tpass\n```\n\n\n\n\n\n\n\n\n\n# 利用index自制加载器\n\n```\nimport random\nimport copy\n\n\nclass My_Load():\n    \"\"\"\n    利用index索引自制的数据加载器\n    \"\"\"\n    def __init__(self, all_mask, ratio = [7, 2, 1]):\n        self.all_mask = all_mask\n        total = sum(ratio)\n        mid1 = (ratio[0]) / total\n        mid2 = mid1 + (ratio[1]) / total\n\n        mid1 = int(mid1 * len(all_mask))\n        mid2 = int(mid2 * len(all_mask))\n\n        # 利用打算函数，不重合的分割数据\n        new_all_mask = copy.deepcopy(all_mask)\n        random.shuffle(new_all_mask)\n        self.train_mask = new_all_mask[0:mid1]\n        self.valid_mask = new_all_mask[mid1:mid2]\n        self.test_mask = new_all_mask[mid2:]\n\n\n\n\n    # 随机采样一部分比例数据，相当于minibatch使用\n    def get_rand_mask(self,ratio=1,  num=1, mask = None):\n        \"\"\"\n        :param ratio: 0.7 随机选择70%的数据\n        :param mask: 如果为mask为None，返回all\n        :return:\n        \"\"\"\n        if ratio != 1:\n            len1 = len(mask)\n            num = int(len1 * ratio)\n            ans = random.sample(mask, num)\n            return ans\n        else:\n            ans = random.sample(mask, num)\n            return ans\n\n```\n\n\n\n\n\n\n\n# ref\n\n[pytorch官方](https://pytorch.org/docs/1.13/data.html)\n\ns\n","slug":"dl/数据加载器","published":1,"date":"2023-02-27T11:33:23.573Z","updated":"2023-02-27T11:34:33.132Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsybd000e0gcnziurf8zn","content":"<h1 id=\"sklearn的库\"><a href=\"#sklearn的库\" class=\"headerlink\" title=\"sklearn的库\"></a>sklearn的库</h1><h2 id=\"划分训练集，测试集，验证集\"><a href=\"#划分训练集，测试集，验证集\" class=\"headerlink\" title=\"划分训练集，测试集，验证集\"></a>划分训练集，测试集，验证集</h2><pre><code>from sklearn.model_selection import train_test_split\n\ndef train_test_val_split(x,y, train_ratio = 0.8,validation_ratio = 0.1,test_ratio = 0.1,random_state=0):\n    # random_state for reproduction\n    # shuffle must be &#39;True&#39;\n    [x_train, x_test, y_train, y_test] = train_test_split(\nx, y, test_size=validation_ratio+test_ratio, random_state=random_state, shuffle=True)\n\n    [x_val, x_test, y_val, y_test] = train_test_split(\n    x_test, y_test, test_size=test_ratio/(test_ratio + validation_ratio), random_state=random_state)\n    return x_train,y_train, x_test, y_test, x_val, y_val\n</code></pre><h2 id=\"pytorch加载batch\"><a href=\"#pytorch加载batch\" class=\"headerlink\" title=\"pytorch加载batch\"></a>pytorch加载batch</h2><p><strong>先弄一个dataset类</strong></p>\n<pre><code>from __future__ import print_function\nimport torch.utils.data as data\nimport torch\n\nclass MyDataset(data.Dataset):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __getitem__(self, index):#返回的是tensor\n        x_i, y_i = self.x[index], self.y[index]\n        return x_i, y_i\n\n    def __len__(self):\n        return len(self.x)\n\ndataset = MyDataset(images, labels)</code></pre><p>说明</p>\n<pre><code>在定义torch.utils.data.Dataset的子类时，必须重载的两个函数是__len__和__getitem__。\n__len__返回数据集的大小，\n__getitem__实现数据集的下标索引，返回对应的图像和标记（不一定非得返回图像和标记，返回元组的长度可以是任意长，这由网络需要的数据决定）。</code></pre><p>然后可以使用<strong>DataLoader</strong>来载入batch</p>\n<pre><code>from torch.utils.data import DataLoader\ndataloader = DataLoader(MyDataset(images, labels), batch_size=4, shuffle=True, num_workers=0, drop_last=True)       </code></pre><p><strong>参数说明</strong></p>\n<pre><code>dataset：Dataset类型，从其中加载数据\nbatch_size：int，可选。每个batch加载多少样本\nshuffle：bool，可选。为True时表示每个epoch都对数据进行洗牌\nsampler：Sampler，可选。从数据集中采样样本的方法。\nnum_workers：int，可选。加载数据时使用多少子进程。默认值为0，表示在主进程中加载数据。\ncollate_fn：callable，可选。\npin_memory：bool，可选\ndrop_last：bool，可选。True表示如果最后剩下不完全的batch,丢弃。False表示不丢弃。</code></pre><p><strong>具体使用说明</strong></p>\n<pre><code>for batch_x, batch_y in dataloader:\n    print(batch_x.shape, batch_y.shape)\n\n# 或者加入索引index\nfor step, (batch_x, batch_y) in enumerate(dataloader):\n    print(step, batch_x.shape, batch_y.shape)\n    pass</code></pre><h1 id=\"利用index自制加载器\"><a href=\"#利用index自制加载器\" class=\"headerlink\" title=\"利用index自制加载器\"></a>利用index自制加载器</h1><pre><code>import random\nimport copy\n\n\nclass My_Load():\n    &quot;&quot;&quot;\n    利用index索引自制的数据加载器\n    &quot;&quot;&quot;\n    def __init__(self, all_mask, ratio = [7, 2, 1]):\n        self.all_mask = all_mask\n        total = sum(ratio)\n        mid1 = (ratio[0]) / total\n        mid2 = mid1 + (ratio[1]) / total\n\n        mid1 = int(mid1 * len(all_mask))\n        mid2 = int(mid2 * len(all_mask))\n\n        # 利用打算函数，不重合的分割数据\n        new_all_mask = copy.deepcopy(all_mask)\n        random.shuffle(new_all_mask)\n        self.train_mask = new_all_mask[0:mid1]\n        self.valid_mask = new_all_mask[mid1:mid2]\n        self.test_mask = new_all_mask[mid2:]\n\n\n\n\n    # 随机采样一部分比例数据，相当于minibatch使用\n    def get_rand_mask(self,ratio=1,  num=1, mask = None):\n        &quot;&quot;&quot;\n        :param ratio: 0.7 随机选择70%的数据\n        :param mask: 如果为mask为None，返回all\n        :return:\n        &quot;&quot;&quot;\n        if ratio != 1:\n            len1 = len(mask)\n            num = int(len1 * ratio)\n            ans = random.sample(mask, num)\n            return ans\n        else:\n            ans = random.sample(mask, num)\n            return ans\n</code></pre><h1 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h1><p><a href=\"https://pytorch.org/docs/1.13/data.html\" target=\"_blank\" rel=\"noopener\">pytorch官方</a></p>\n<p>s</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"sklearn的库\"><a href=\"#sklearn的库\" class=\"headerlink\" title=\"sklearn的库\"></a>sklearn的库</h1><h2 id=\"划分训练集，测试集，验证集\"><a href=\"#划分训练集，测试集，验证集\" class=\"headerlink\" title=\"划分训练集，测试集，验证集\"></a>划分训练集，测试集，验证集</h2><pre><code>from sklearn.model_selection import train_test_split\n\ndef train_test_val_split(x,y, train_ratio = 0.8,validation_ratio = 0.1,test_ratio = 0.1,random_state=0):\n    # random_state for reproduction\n    # shuffle must be &#39;True&#39;\n    [x_train, x_test, y_train, y_test] = train_test_split(\nx, y, test_size=validation_ratio+test_ratio, random_state=random_state, shuffle=True)\n\n    [x_val, x_test, y_val, y_test] = train_test_split(\n    x_test, y_test, test_size=test_ratio/(test_ratio + validation_ratio), random_state=random_state)\n    return x_train,y_train, x_test, y_test, x_val, y_val\n</code></pre><h2 id=\"pytorch加载batch\"><a href=\"#pytorch加载batch\" class=\"headerlink\" title=\"pytorch加载batch\"></a>pytorch加载batch</h2><p><strong>先弄一个dataset类</strong></p>\n<pre><code>from __future__ import print_function\nimport torch.utils.data as data\nimport torch\n\nclass MyDataset(data.Dataset):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def __getitem__(self, index):#返回的是tensor\n        x_i, y_i = self.x[index], self.y[index]\n        return x_i, y_i\n\n    def __len__(self):\n        return len(self.x)\n\ndataset = MyDataset(images, labels)</code></pre><p>说明</p>\n<pre><code>在定义torch.utils.data.Dataset的子类时，必须重载的两个函数是__len__和__getitem__。\n__len__返回数据集的大小，\n__getitem__实现数据集的下标索引，返回对应的图像和标记（不一定非得返回图像和标记，返回元组的长度可以是任意长，这由网络需要的数据决定）。</code></pre><p>然后可以使用<strong>DataLoader</strong>来载入batch</p>\n<pre><code>from torch.utils.data import DataLoader\ndataloader = DataLoader(MyDataset(images, labels), batch_size=4, shuffle=True, num_workers=0, drop_last=True)       </code></pre><p><strong>参数说明</strong></p>\n<pre><code>dataset：Dataset类型，从其中加载数据\nbatch_size：int，可选。每个batch加载多少样本\nshuffle：bool，可选。为True时表示每个epoch都对数据进行洗牌\nsampler：Sampler，可选。从数据集中采样样本的方法。\nnum_workers：int，可选。加载数据时使用多少子进程。默认值为0，表示在主进程中加载数据。\ncollate_fn：callable，可选。\npin_memory：bool，可选\ndrop_last：bool，可选。True表示如果最后剩下不完全的batch,丢弃。False表示不丢弃。</code></pre><p><strong>具体使用说明</strong></p>\n<pre><code>for batch_x, batch_y in dataloader:\n    print(batch_x.shape, batch_y.shape)\n\n# 或者加入索引index\nfor step, (batch_x, batch_y) in enumerate(dataloader):\n    print(step, batch_x.shape, batch_y.shape)\n    pass</code></pre><h1 id=\"利用index自制加载器\"><a href=\"#利用index自制加载器\" class=\"headerlink\" title=\"利用index自制加载器\"></a>利用index自制加载器</h1><pre><code>import random\nimport copy\n\n\nclass My_Load():\n    &quot;&quot;&quot;\n    利用index索引自制的数据加载器\n    &quot;&quot;&quot;\n    def __init__(self, all_mask, ratio = [7, 2, 1]):\n        self.all_mask = all_mask\n        total = sum(ratio)\n        mid1 = (ratio[0]) / total\n        mid2 = mid1 + (ratio[1]) / total\n\n        mid1 = int(mid1 * len(all_mask))\n        mid2 = int(mid2 * len(all_mask))\n\n        # 利用打算函数，不重合的分割数据\n        new_all_mask = copy.deepcopy(all_mask)\n        random.shuffle(new_all_mask)\n        self.train_mask = new_all_mask[0:mid1]\n        self.valid_mask = new_all_mask[mid1:mid2]\n        self.test_mask = new_all_mask[mid2:]\n\n\n\n\n    # 随机采样一部分比例数据，相当于minibatch使用\n    def get_rand_mask(self,ratio=1,  num=1, mask = None):\n        &quot;&quot;&quot;\n        :param ratio: 0.7 随机选择70%的数据\n        :param mask: 如果为mask为None，返回all\n        :return:\n        &quot;&quot;&quot;\n        if ratio != 1:\n            len1 = len(mask)\n            num = int(len1 * ratio)\n            ans = random.sample(mask, num)\n            return ans\n        else:\n            ans = random.sample(mask, num)\n            return ans\n</code></pre><h1 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h1><p><a href=\"https://pytorch.org/docs/1.13/data.html\" target=\"_blank\" rel=\"noopener\">pytorch官方</a></p>\n<p>s</p>\n"},{"_content":"# logging\n\n通过使用日志模块重载print函数，既保留print的输出，同时又实现logging\n\n\n\n```\nimport logging\nimport builtins\n\nlr = 0.001\nweight_decay=0.001\n\nlog_name =\"log/\"+'{}, lr is {}, weight_decay is {}.log'.format(Platform_name, lr, weight_decay)\n\n# 先情清空文件内容\nimport os\nfile = open(log_name,'w');\nfile = open(log_name, 'w').close()\n\n\nimport datetime\nnow = datetime.datetime.now()\n\n\nlogger = logging.getLogger()\nlogger.handlers = []\n# print(logger.handlers)\n\n# 如果已经有handler了，那么不用新增新的\nif not logger.handlers:\n    \n    \n    # 日志输出格式\n    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n    # Setup file handler\n    fhandler = logging.FileHandler(log_name)\n    fhandler.setLevel(logging.INFO)\n    fhandler.setFormatter(formatter)\n\n    logger.addHandler(fhandler)\n    logger.setLevel(logging.INFO)\n\n\n# 重载print函数到输出为日志\ndef print(msg):\n#     builtins.print(logger.handlers)\n    logger.info('\\n{}'.format(msg))\n    # 使用系统自带的print函数\n    builtins.print(msg)\n\n\n# 输出一些参数数据\nprint(graph)\nprint(logger.handlers)\n\n```\n\n","source":"_posts/dl/关于print与日志处理.md","raw":"# logging\n\n通过使用日志模块重载print函数，既保留print的输出，同时又实现logging\n\n\n\n```\nimport logging\nimport builtins\n\nlr = 0.001\nweight_decay=0.001\n\nlog_name =\"log/\"+'{}, lr is {}, weight_decay is {}.log'.format(Platform_name, lr, weight_decay)\n\n# 先情清空文件内容\nimport os\nfile = open(log_name,'w');\nfile = open(log_name, 'w').close()\n\n\nimport datetime\nnow = datetime.datetime.now()\n\n\nlogger = logging.getLogger()\nlogger.handlers = []\n# print(logger.handlers)\n\n# 如果已经有handler了，那么不用新增新的\nif not logger.handlers:\n    \n    \n    # 日志输出格式\n    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n    # Setup file handler\n    fhandler = logging.FileHandler(log_name)\n    fhandler.setLevel(logging.INFO)\n    fhandler.setFormatter(formatter)\n\n    logger.addHandler(fhandler)\n    logger.setLevel(logging.INFO)\n\n\n# 重载print函数到输出为日志\ndef print(msg):\n#     builtins.print(logger.handlers)\n    logger.info('\\n{}'.format(msg))\n    # 使用系统自带的print函数\n    builtins.print(msg)\n\n\n# 输出一些参数数据\nprint(graph)\nprint(logger.handlers)\n\n```\n\n","slug":"dl/关于print与日志处理","published":1,"date":"2023-02-27T11:33:23.570Z","updated":"2023-02-27T11:34:33.131Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsybd000f0gcnvb9mb8qk","content":"<h1 id=\"logging\"><a href=\"#logging\" class=\"headerlink\" title=\"logging\"></a>logging</h1><p>通过使用日志模块重载print函数，既保留print的输出，同时又实现logging</p>\n<pre><code>import logging\nimport builtins\n\nlr = 0.001\nweight_decay=0.001\n\nlog_name =&quot;log/&quot;+&#39;{}, lr is {}, weight_decay is {}.log&#39;.format(Platform_name, lr, weight_decay)\n\n# 先情清空文件内容\nimport os\nfile = open(log_name,&#39;w&#39;);\nfile = open(log_name, &#39;w&#39;).close()\n\n\nimport datetime\nnow = datetime.datetime.now()\n\n\nlogger = logging.getLogger()\nlogger.handlers = []\n# print(logger.handlers)\n\n# 如果已经有handler了，那么不用新增新的\nif not logger.handlers:\n\n\n    # 日志输出格式\n    formatter = logging.Formatter(&#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#39;)\n    # Setup file handler\n    fhandler = logging.FileHandler(log_name)\n    fhandler.setLevel(logging.INFO)\n    fhandler.setFormatter(formatter)\n\n    logger.addHandler(fhandler)\n    logger.setLevel(logging.INFO)\n\n\n# 重载print函数到输出为日志\ndef print(msg):\n#     builtins.print(logger.handlers)\n    logger.info(&#39;\\n{}&#39;.format(msg))\n    # 使用系统自带的print函数\n    builtins.print(msg)\n\n\n# 输出一些参数数据\nprint(graph)\nprint(logger.handlers)\n</code></pre>","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"logging\"><a href=\"#logging\" class=\"headerlink\" title=\"logging\"></a>logging</h1><p>通过使用日志模块重载print函数，既保留print的输出，同时又实现logging</p>\n<pre><code>import logging\nimport builtins\n\nlr = 0.001\nweight_decay=0.001\n\nlog_name =&quot;log/&quot;+&#39;{}, lr is {}, weight_decay is {}.log&#39;.format(Platform_name, lr, weight_decay)\n\n# 先情清空文件内容\nimport os\nfile = open(log_name,&#39;w&#39;);\nfile = open(log_name, &#39;w&#39;).close()\n\n\nimport datetime\nnow = datetime.datetime.now()\n\n\nlogger = logging.getLogger()\nlogger.handlers = []\n# print(logger.handlers)\n\n# 如果已经有handler了，那么不用新增新的\nif not logger.handlers:\n\n\n    # 日志输出格式\n    formatter = logging.Formatter(&#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#39;)\n    # Setup file handler\n    fhandler = logging.FileHandler(log_name)\n    fhandler.setLevel(logging.INFO)\n    fhandler.setFormatter(formatter)\n\n    logger.addHandler(fhandler)\n    logger.setLevel(logging.INFO)\n\n\n# 重载print函数到输出为日志\ndef print(msg):\n#     builtins.print(logger.handlers)\n    logger.info(&#39;\\n{}&#39;.format(msg))\n    # 使用系统自带的print函数\n    builtins.print(msg)\n\n\n# 输出一些参数数据\nprint(graph)\nprint(logger.handlers)\n</code></pre>"},{"_content":"# 问题\n\n在机器学习中，我们经常碰到一些样本比例分布不均衡的情况，例如考公上岸比例就达到了100:1. 针对这种正负样本严重失衡的模型，如何做出一些应对处理就显得很重要\n\n\n\n# 采样---让样本均衡\n\n既然样本失衡了，那么久通过欠采样，或者过采样来均衡一下样本。\n\n这个办法不是万能的\n\n# 修改损失函数\n\nloss损失函数可以修改各类别的损失函数权重\n\n# 其他\n\n以上办法不是万能的，例如图神经网络中，采样法效果就不是很好。\n\n\n\n# 关于指标选取\n\n既然样本比例失衡了，我们在训练中如何选取最好的模型的指标就需要灵活变化。\n\n如果一味的选取准确率，那么如果样本失衡严重，样本整体的准确率依然会很高，但是这很有可能是样本什么都没学到，全部分为了一类。\n\n**先科普RUC曲线与AUC值**\n\n```\n   ROC的全名叫做Receiver Operating Characteristic，中文名字叫“受试者工作特征曲线”，其主要分析工具是一个画在二维平面上的曲线——ROC 曲线。平面的横坐标是false positive rate(FPR)，纵坐标是true positive rate(TPR)。对某个分类器而言，我们可以根据其在测试样本上的表现得到一个TPR和FPR点对。这样，此分类器就可以映射成ROC平面上的一个点。调整这个分类器分类时候使用的阈值，我们就可以得到一个经过(0, 0)，(1, 1)的曲线，这就是此分类器的ROC曲线。\n     一般情况下，这个曲线都应该处于(0, 0)和(1, 1)连线的上方。因为(0, 0)和(1, 1)连线形成的ROC曲线实际上代表的是一个随机分类器。如果很不幸，你得到一个位于此直线下方的分类器的话，一个直观的补救办法就是把所有的预测结果反向，即：分类器输出结果为正类，则最终分类的结果为负类，反之，则为正类。虽然，用ROC 曲线来表示分类器的性能很直观好用。可是，人们总是希望能有一个数值来标志分类器的好坏。于是Area Under roc Curve(AUC)就出现了。顾名思义，AUC的值就是处于ROC 曲线下方的那部分面积的大小。通常，AUC的值介于0.5到1.0之间，较大的AUC代表了较好的性能。AUC（Area Under roc Curve）是一种用来度量分类模型好坏的一个标准。\n```\n\n![image-20230208233439602](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/0277f6d2ba1fc17e277b915ebf0a5632/6372c74e57bb14fd916771a7877dbe6d.png)\n\n**Area Under roc Curve(AUC)：顾名思义，AUC的值就是处于ROC 曲线下方的那部分面积的大小。**\n\n**ROC曲线有个很好的特性：当测试集中的正负样本的分布变化的时候，ROC曲线能够保持不变。在面对正负样本数量不均衡的场景下，ROC曲线（AUC的值）会是一个更加稳定能反映模型好坏的指标。**\n\n\n\n\n\n# ref\n\nhttps://zhuanlan.zhihu.com/p/354853593\n\n","source":"_posts/dl/样本失衡问题.md","raw":"# 问题\n\n在机器学习中，我们经常碰到一些样本比例分布不均衡的情况，例如考公上岸比例就达到了100:1. 针对这种正负样本严重失衡的模型，如何做出一些应对处理就显得很重要\n\n\n\n# 采样---让样本均衡\n\n既然样本失衡了，那么久通过欠采样，或者过采样来均衡一下样本。\n\n这个办法不是万能的\n\n# 修改损失函数\n\nloss损失函数可以修改各类别的损失函数权重\n\n# 其他\n\n以上办法不是万能的，例如图神经网络中，采样法效果就不是很好。\n\n\n\n# 关于指标选取\n\n既然样本比例失衡了，我们在训练中如何选取最好的模型的指标就需要灵活变化。\n\n如果一味的选取准确率，那么如果样本失衡严重，样本整体的准确率依然会很高，但是这很有可能是样本什么都没学到，全部分为了一类。\n\n**先科普RUC曲线与AUC值**\n\n```\n   ROC的全名叫做Receiver Operating Characteristic，中文名字叫“受试者工作特征曲线”，其主要分析工具是一个画在二维平面上的曲线——ROC 曲线。平面的横坐标是false positive rate(FPR)，纵坐标是true positive rate(TPR)。对某个分类器而言，我们可以根据其在测试样本上的表现得到一个TPR和FPR点对。这样，此分类器就可以映射成ROC平面上的一个点。调整这个分类器分类时候使用的阈值，我们就可以得到一个经过(0, 0)，(1, 1)的曲线，这就是此分类器的ROC曲线。\n     一般情况下，这个曲线都应该处于(0, 0)和(1, 1)连线的上方。因为(0, 0)和(1, 1)连线形成的ROC曲线实际上代表的是一个随机分类器。如果很不幸，你得到一个位于此直线下方的分类器的话，一个直观的补救办法就是把所有的预测结果反向，即：分类器输出结果为正类，则最终分类的结果为负类，反之，则为正类。虽然，用ROC 曲线来表示分类器的性能很直观好用。可是，人们总是希望能有一个数值来标志分类器的好坏。于是Area Under roc Curve(AUC)就出现了。顾名思义，AUC的值就是处于ROC 曲线下方的那部分面积的大小。通常，AUC的值介于0.5到1.0之间，较大的AUC代表了较好的性能。AUC（Area Under roc Curve）是一种用来度量分类模型好坏的一个标准。\n```\n\n![image-20230208233439602](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/0277f6d2ba1fc17e277b915ebf0a5632/6372c74e57bb14fd916771a7877dbe6d.png)\n\n**Area Under roc Curve(AUC)：顾名思义，AUC的值就是处于ROC 曲线下方的那部分面积的大小。**\n\n**ROC曲线有个很好的特性：当测试集中的正负样本的分布变化的时候，ROC曲线能够保持不变。在面对正负样本数量不均衡的场景下，ROC曲线（AUC的值）会是一个更加稳定能反映模型好坏的指标。**\n\n\n\n\n\n# ref\n\nhttps://zhuanlan.zhihu.com/p/354853593\n\n","slug":"dl/样本失衡问题","published":1,"date":"2023-02-27T11:33:23.572Z","updated":"2023-02-27T11:34:33.132Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsybe000g0gcn494dn3er","content":"<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p>在机器学习中，我们经常碰到一些样本比例分布不均衡的情况，例如考公上岸比例就达到了100:1. 针对这种正负样本严重失衡的模型，如何做出一些应对处理就显得很重要</p>\n<h1 id=\"采样—让样本均衡\"><a href=\"#采样—让样本均衡\" class=\"headerlink\" title=\"采样—让样本均衡\"></a>采样—让样本均衡</h1><p>既然样本失衡了，那么久通过欠采样，或者过采样来均衡一下样本。</p>\n<p>这个办法不是万能的</p>\n<h1 id=\"修改损失函数\"><a href=\"#修改损失函数\" class=\"headerlink\" title=\"修改损失函数\"></a>修改损失函数</h1><p>loss损失函数可以修改各类别的损失函数权重</p>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><p>以上办法不是万能的，例如图神经网络中，采样法效果就不是很好。</p>\n<h1 id=\"关于指标选取\"><a href=\"#关于指标选取\" class=\"headerlink\" title=\"关于指标选取\"></a>关于指标选取</h1><p>既然样本比例失衡了，我们在训练中如何选取最好的模型的指标就需要灵活变化。</p>\n<p>如果一味的选取准确率，那么如果样本失衡严重，样本整体的准确率依然会很高，但是这很有可能是样本什么都没学到，全部分为了一类。</p>\n<p><strong>先科普RUC曲线与AUC值</strong></p>\n<pre><code>   ROC的全名叫做Receiver Operating Characteristic，中文名字叫“受试者工作特征曲线”，其主要分析工具是一个画在二维平面上的曲线——ROC 曲线。平面的横坐标是false positive rate(FPR)，纵坐标是true positive rate(TPR)。对某个分类器而言，我们可以根据其在测试样本上的表现得到一个TPR和FPR点对。这样，此分类器就可以映射成ROC平面上的一个点。调整这个分类器分类时候使用的阈值，我们就可以得到一个经过(0, 0)，(1, 1)的曲线，这就是此分类器的ROC曲线。\n     一般情况下，这个曲线都应该处于(0, 0)和(1, 1)连线的上方。因为(0, 0)和(1, 1)连线形成的ROC曲线实际上代表的是一个随机分类器。如果很不幸，你得到一个位于此直线下方的分类器的话，一个直观的补救办法就是把所有的预测结果反向，即：分类器输出结果为正类，则最终分类的结果为负类，反之，则为正类。虽然，用ROC 曲线来表示分类器的性能很直观好用。可是，人们总是希望能有一个数值来标志分类器的好坏。于是Area Under roc Curve(AUC)就出现了。顾名思义，AUC的值就是处于ROC 曲线下方的那部分面积的大小。通常，AUC的值介于0.5到1.0之间，较大的AUC代表了较好的性能。AUC（Area Under roc Curve）是一种用来度量分类模型好坏的一个标准。</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/0277f6d2ba1fc17e277b915ebf0a5632/6372c74e57bb14fd916771a7877dbe6d.png\" alt=\"image-20230208233439602\"></p>\n<p><strong>Area Under roc Curve(AUC)：顾名思义，AUC的值就是处于ROC 曲线下方的那部分面积的大小。</strong></p>\n<p><strong>ROC曲线有个很好的特性：当测试集中的正负样本的分布变化的时候，ROC曲线能够保持不变。在面对正负样本数量不均衡的场景下，ROC曲线（AUC的值）会是一个更加稳定能反映模型好坏的指标。</strong></p>\n<h1 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h1><p><a href=\"https://zhuanlan.zhihu.com/p/354853593\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/354853593</a></p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p>在机器学习中，我们经常碰到一些样本比例分布不均衡的情况，例如考公上岸比例就达到了100:1. 针对这种正负样本严重失衡的模型，如何做出一些应对处理就显得很重要</p>\n<h1 id=\"采样—让样本均衡\"><a href=\"#采样—让样本均衡\" class=\"headerlink\" title=\"采样—让样本均衡\"></a>采样—让样本均衡</h1><p>既然样本失衡了，那么久通过欠采样，或者过采样来均衡一下样本。</p>\n<p>这个办法不是万能的</p>\n<h1 id=\"修改损失函数\"><a href=\"#修改损失函数\" class=\"headerlink\" title=\"修改损失函数\"></a>修改损失函数</h1><p>loss损失函数可以修改各类别的损失函数权重</p>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><p>以上办法不是万能的，例如图神经网络中，采样法效果就不是很好。</p>\n<h1 id=\"关于指标选取\"><a href=\"#关于指标选取\" class=\"headerlink\" title=\"关于指标选取\"></a>关于指标选取</h1><p>既然样本比例失衡了，我们在训练中如何选取最好的模型的指标就需要灵活变化。</p>\n<p>如果一味的选取准确率，那么如果样本失衡严重，样本整体的准确率依然会很高，但是这很有可能是样本什么都没学到，全部分为了一类。</p>\n<p><strong>先科普RUC曲线与AUC值</strong></p>\n<pre><code>   ROC的全名叫做Receiver Operating Characteristic，中文名字叫“受试者工作特征曲线”，其主要分析工具是一个画在二维平面上的曲线——ROC 曲线。平面的横坐标是false positive rate(FPR)，纵坐标是true positive rate(TPR)。对某个分类器而言，我们可以根据其在测试样本上的表现得到一个TPR和FPR点对。这样，此分类器就可以映射成ROC平面上的一个点。调整这个分类器分类时候使用的阈值，我们就可以得到一个经过(0, 0)，(1, 1)的曲线，这就是此分类器的ROC曲线。\n     一般情况下，这个曲线都应该处于(0, 0)和(1, 1)连线的上方。因为(0, 0)和(1, 1)连线形成的ROC曲线实际上代表的是一个随机分类器。如果很不幸，你得到一个位于此直线下方的分类器的话，一个直观的补救办法就是把所有的预测结果反向，即：分类器输出结果为正类，则最终分类的结果为负类，反之，则为正类。虽然，用ROC 曲线来表示分类器的性能很直观好用。可是，人们总是希望能有一个数值来标志分类器的好坏。于是Area Under roc Curve(AUC)就出现了。顾名思义，AUC的值就是处于ROC 曲线下方的那部分面积的大小。通常，AUC的值介于0.5到1.0之间，较大的AUC代表了较好的性能。AUC（Area Under roc Curve）是一种用来度量分类模型好坏的一个标准。</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/0277f6d2ba1fc17e277b915ebf0a5632/6372c74e57bb14fd916771a7877dbe6d.png\" alt=\"image-20230208233439602\"></p>\n<p><strong>Area Under roc Curve(AUC)：顾名思义，AUC的值就是处于ROC 曲线下方的那部分面积的大小。</strong></p>\n<p><strong>ROC曲线有个很好的特性：当测试集中的正负样本的分布变化的时候，ROC曲线能够保持不变。在面对正负样本数量不均衡的场景下，ROC曲线（AUC的值）会是一个更加稳定能反映模型好坏的指标。</strong></p>\n<h1 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h1><p><a href=\"https://zhuanlan.zhihu.com/p/354853593\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/354853593</a></p>\n"},{"_content":"# 有监督\n\n有x，也有y。建立一个x->y的映射模型。\n\n最常见的模型\n\n\n\n# 无监督\n\n只有x，无y。\n\n一般是利用x自身的数据来做一些聚类啥的。\n\n例如：k-means\n\n\n\n# 半监督学习（Semi-supervised Learning）\n\n在**有标签数据+无标签数据混合成的训练数据**中使用的机器学习算法。\n\n一般假设，**无标签数据比有标签数据多，甚至多得多。**\n\n## 需要的原因\n\n- 有标记样本难以获取：需要专门的人员，特别的设备，额外的开销......\n- 无标记的样本相对而言是很廉价的\n\n\n\n## 用法\n\n很多半监督学习算法中用的训练数据还有挺多要求的，一般默认的有：无标签数据一般是有标签数据中的某一个类别的（不要不属于的，也不要属于多个类别的）；有标签数据的标签应该都是对的；无标签数据一般是类别平衡的（即每一类的样本数差不多）；无标签数据的分布应该和有标签的相同或类似 等等。\n\n\n\n简单介绍如下：\n\n1.**简单自训练**（simple self-training）：用有标签数据训练一个分类器，然后用这个分类器对无标签数据进行分类，这样就会产生伪标签（pseudo label）或软标签（soft label），挑选你认为分类正确的无标签样本（此处应该有一个**挑选准则**），把选出来的无标签样本用来训练分类器。\n\n2.**协同训练**（co-training）：其实也是 self-training 的一种，但其思想是好的。假设每个数据可以从不同的角度（view）进行分类，不同角度可以训练出不同的分类器，然后用这些从不同角度训练出来的分类器对无标签样本进行分类，再选出认为可信的无标签样本加入训练集中。由于这些分类器从不同角度训练出来的，可以形成一种互补，而提高分类精度；就如同从不同角度可以更好地理解事物一样。\n\n3.**半监督字典学习**：其实也是 self-training 的一种，先是用有标签数据作为字典，对无标签数据进行分类，挑选出你认为分类正确的无标签样本，加入字典中（此时的字典就变成了半监督字典了）\n\n4.**标签传播算法**（Label Propagation Algorithm）：是一种基于图的半监督算法，通过构造图结构（数据点为顶点，点之间的相似性为边）来寻找**训练数据**中有标签数据和无标签数据的关系。是的，只是训练数据中，这是一种直推式的半监督算法，即只对训练集中的无标签数据进行分类，这其实感觉很像一个有监督分类算法...，但其实并不是，因为其标签传播的过程，会流经无标签数据，即有些无标签数据的标签的信息，是从另一些无标签数据中流过来的，这就用到了无标签数据之间的联系\n\n\n\n\n\n# 自监督 (self-supervised)\n\n**从大规模的无监督数据中挖掘自身的监督信息**，通过这种构造的监督信息对网络进行训练，从而可以学习到对下游任务有价值的表征。（也就是说自监督学习的监督信息不是人工标注的，而是算法在大规模无监督数据中自动构造监督信息，来进行监督学习或训练。因此，大多数时候，我们称之为无监督预训练方法或无监督学习方法，严格上讲，他应该叫自监督学习）。\n\n## 特点\n\n- **从数据x，y上来说**，属于无监督学习，因为没有标签数据y\n- **从训练过程来说**，属于有监督学习，因为自动构造了loss。\n\n\n\n# 弱监督学习\n\n 机器学习，深度学习在很多任务中获得很大的成功，尤其是在监督学习中，深度学习，机器学习取得了突破性的进展。 例如分类和回归的监督任务中，预测模型需要从大量有标注训练样本中学习，训练样本包含两部分：第一部分是对象的特征向量，第二部分是真值标签。在分类任务中，label表示训练样本的类别，在回归任务中，标签是一个与样本相对应的实数值。这些模型依赖强监督信息，例如深度学习模型依赖大量的标注数据，在实际生产中，数据的标注成本很高，获取大量的有标注样本难度大。 因此利用弱监督学习，利用大量无标注或者粗糙标注的样本来进行模型的学习，这样能够有效的利用数据，提升模型的性能\n","source":"_posts/dl/监督，无监督，半监督等学习方式.md","raw":"# 有监督\n\n有x，也有y。建立一个x->y的映射模型。\n\n最常见的模型\n\n\n\n# 无监督\n\n只有x，无y。\n\n一般是利用x自身的数据来做一些聚类啥的。\n\n例如：k-means\n\n\n\n# 半监督学习（Semi-supervised Learning）\n\n在**有标签数据+无标签数据混合成的训练数据**中使用的机器学习算法。\n\n一般假设，**无标签数据比有标签数据多，甚至多得多。**\n\n## 需要的原因\n\n- 有标记样本难以获取：需要专门的人员，特别的设备，额外的开销......\n- 无标记的样本相对而言是很廉价的\n\n\n\n## 用法\n\n很多半监督学习算法中用的训练数据还有挺多要求的，一般默认的有：无标签数据一般是有标签数据中的某一个类别的（不要不属于的，也不要属于多个类别的）；有标签数据的标签应该都是对的；无标签数据一般是类别平衡的（即每一类的样本数差不多）；无标签数据的分布应该和有标签的相同或类似 等等。\n\n\n\n简单介绍如下：\n\n1.**简单自训练**（simple self-training）：用有标签数据训练一个分类器，然后用这个分类器对无标签数据进行分类，这样就会产生伪标签（pseudo label）或软标签（soft label），挑选你认为分类正确的无标签样本（此处应该有一个**挑选准则**），把选出来的无标签样本用来训练分类器。\n\n2.**协同训练**（co-training）：其实也是 self-training 的一种，但其思想是好的。假设每个数据可以从不同的角度（view）进行分类，不同角度可以训练出不同的分类器，然后用这些从不同角度训练出来的分类器对无标签样本进行分类，再选出认为可信的无标签样本加入训练集中。由于这些分类器从不同角度训练出来的，可以形成一种互补，而提高分类精度；就如同从不同角度可以更好地理解事物一样。\n\n3.**半监督字典学习**：其实也是 self-training 的一种，先是用有标签数据作为字典，对无标签数据进行分类，挑选出你认为分类正确的无标签样本，加入字典中（此时的字典就变成了半监督字典了）\n\n4.**标签传播算法**（Label Propagation Algorithm）：是一种基于图的半监督算法，通过构造图结构（数据点为顶点，点之间的相似性为边）来寻找**训练数据**中有标签数据和无标签数据的关系。是的，只是训练数据中，这是一种直推式的半监督算法，即只对训练集中的无标签数据进行分类，这其实感觉很像一个有监督分类算法...，但其实并不是，因为其标签传播的过程，会流经无标签数据，即有些无标签数据的标签的信息，是从另一些无标签数据中流过来的，这就用到了无标签数据之间的联系\n\n\n\n\n\n# 自监督 (self-supervised)\n\n**从大规模的无监督数据中挖掘自身的监督信息**，通过这种构造的监督信息对网络进行训练，从而可以学习到对下游任务有价值的表征。（也就是说自监督学习的监督信息不是人工标注的，而是算法在大规模无监督数据中自动构造监督信息，来进行监督学习或训练。因此，大多数时候，我们称之为无监督预训练方法或无监督学习方法，严格上讲，他应该叫自监督学习）。\n\n## 特点\n\n- **从数据x，y上来说**，属于无监督学习，因为没有标签数据y\n- **从训练过程来说**，属于有监督学习，因为自动构造了loss。\n\n\n\n# 弱监督学习\n\n 机器学习，深度学习在很多任务中获得很大的成功，尤其是在监督学习中，深度学习，机器学习取得了突破性的进展。 例如分类和回归的监督任务中，预测模型需要从大量有标注训练样本中学习，训练样本包含两部分：第一部分是对象的特征向量，第二部分是真值标签。在分类任务中，label表示训练样本的类别，在回归任务中，标签是一个与样本相对应的实数值。这些模型依赖强监督信息，例如深度学习模型依赖大量的标注数据，在实际生产中，数据的标注成本很高，获取大量的有标注样本难度大。 因此利用弱监督学习，利用大量无标注或者粗糙标注的样本来进行模型的学习，这样能够有效的利用数据，提升模型的性能\n","slug":"dl/监督，无监督，半监督等学习方式","published":1,"date":"2023-02-27T11:33:23.572Z","updated":"2023-02-27T11:34:33.132Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsybf000h0gcniptux3g9","content":"<h1 id=\"有监督\"><a href=\"#有监督\" class=\"headerlink\" title=\"有监督\"></a>有监督</h1><p>有x，也有y。建立一个x-&gt;y的映射模型。</p>\n<p>最常见的模型</p>\n<h1 id=\"无监督\"><a href=\"#无监督\" class=\"headerlink\" title=\"无监督\"></a>无监督</h1><p>只有x，无y。</p>\n<p>一般是利用x自身的数据来做一些聚类啥的。</p>\n<p>例如：k-means</p>\n<h1 id=\"半监督学习（Semi-supervised-Learning）\"><a href=\"#半监督学习（Semi-supervised-Learning）\" class=\"headerlink\" title=\"半监督学习（Semi-supervised Learning）\"></a>半监督学习（Semi-supervised Learning）</h1><p>在<strong>有标签数据+无标签数据混合成的训练数据</strong>中使用的机器学习算法。</p>\n<p>一般假设，<strong>无标签数据比有标签数据多，甚至多得多。</strong></p>\n<h2 id=\"需要的原因\"><a href=\"#需要的原因\" class=\"headerlink\" title=\"需要的原因\"></a>需要的原因</h2><ul>\n<li>有标记样本难以获取：需要专门的人员，特别的设备，额外的开销……</li>\n<li>无标记的样本相对而言是很廉价的</li>\n</ul>\n<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><p>很多半监督学习算法中用的训练数据还有挺多要求的，一般默认的有：无标签数据一般是有标签数据中的某一个类别的（不要不属于的，也不要属于多个类别的）；有标签数据的标签应该都是对的；无标签数据一般是类别平衡的（即每一类的样本数差不多）；无标签数据的分布应该和有标签的相同或类似 等等。</p>\n<p>简单介绍如下：</p>\n<p>1.<strong>简单自训练</strong>（simple self-training）：用有标签数据训练一个分类器，然后用这个分类器对无标签数据进行分类，这样就会产生伪标签（pseudo label）或软标签（soft label），挑选你认为分类正确的无标签样本（此处应该有一个<strong>挑选准则</strong>），把选出来的无标签样本用来训练分类器。</p>\n<p>2.<strong>协同训练</strong>（co-training）：其实也是 self-training 的一种，但其思想是好的。假设每个数据可以从不同的角度（view）进行分类，不同角度可以训练出不同的分类器，然后用这些从不同角度训练出来的分类器对无标签样本进行分类，再选出认为可信的无标签样本加入训练集中。由于这些分类器从不同角度训练出来的，可以形成一种互补，而提高分类精度；就如同从不同角度可以更好地理解事物一样。</p>\n<p>3.<strong>半监督字典学习</strong>：其实也是 self-training 的一种，先是用有标签数据作为字典，对无标签数据进行分类，挑选出你认为分类正确的无标签样本，加入字典中（此时的字典就变成了半监督字典了）</p>\n<p>4.<strong>标签传播算法</strong>（Label Propagation Algorithm）：是一种基于图的半监督算法，通过构造图结构（数据点为顶点，点之间的相似性为边）来寻找<strong>训练数据</strong>中有标签数据和无标签数据的关系。是的，只是训练数据中，这是一种直推式的半监督算法，即只对训练集中的无标签数据进行分类，这其实感觉很像一个有监督分类算法…，但其实并不是，因为其标签传播的过程，会流经无标签数据，即有些无标签数据的标签的信息，是从另一些无标签数据中流过来的，这就用到了无标签数据之间的联系</p>\n<h1 id=\"自监督-self-supervised\"><a href=\"#自监督-self-supervised\" class=\"headerlink\" title=\"自监督 (self-supervised)\"></a>自监督 (self-supervised)</h1><p><strong>从大规模的无监督数据中挖掘自身的监督信息</strong>，通过这种构造的监督信息对网络进行训练，从而可以学习到对下游任务有价值的表征。（也就是说自监督学习的监督信息不是人工标注的，而是算法在大规模无监督数据中自动构造监督信息，来进行监督学习或训练。因此，大多数时候，我们称之为无监督预训练方法或无监督学习方法，严格上讲，他应该叫自监督学习）。</p>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ul>\n<li><strong>从数据x，y上来说</strong>，属于无监督学习，因为没有标签数据y</li>\n<li><strong>从训练过程来说</strong>，属于有监督学习，因为自动构造了loss。</li>\n</ul>\n<h1 id=\"弱监督学习\"><a href=\"#弱监督学习\" class=\"headerlink\" title=\"弱监督学习\"></a>弱监督学习</h1><p> 机器学习，深度学习在很多任务中获得很大的成功，尤其是在监督学习中，深度学习，机器学习取得了突破性的进展。 例如分类和回归的监督任务中，预测模型需要从大量有标注训练样本中学习，训练样本包含两部分：第一部分是对象的特征向量，第二部分是真值标签。在分类任务中，label表示训练样本的类别，在回归任务中，标签是一个与样本相对应的实数值。这些模型依赖强监督信息，例如深度学习模型依赖大量的标注数据，在实际生产中，数据的标注成本很高，获取大量的有标注样本难度大。 因此利用弱监督学习，利用大量无标注或者粗糙标注的样本来进行模型的学习，这样能够有效的利用数据，提升模型的性能</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"有监督\"><a href=\"#有监督\" class=\"headerlink\" title=\"有监督\"></a>有监督</h1><p>有x，也有y。建立一个x-&gt;y的映射模型。</p>\n<p>最常见的模型</p>\n<h1 id=\"无监督\"><a href=\"#无监督\" class=\"headerlink\" title=\"无监督\"></a>无监督</h1><p>只有x，无y。</p>\n<p>一般是利用x自身的数据来做一些聚类啥的。</p>\n<p>例如：k-means</p>\n<h1 id=\"半监督学习（Semi-supervised-Learning）\"><a href=\"#半监督学习（Semi-supervised-Learning）\" class=\"headerlink\" title=\"半监督学习（Semi-supervised Learning）\"></a>半监督学习（Semi-supervised Learning）</h1><p>在<strong>有标签数据+无标签数据混合成的训练数据</strong>中使用的机器学习算法。</p>\n<p>一般假设，<strong>无标签数据比有标签数据多，甚至多得多。</strong></p>\n<h2 id=\"需要的原因\"><a href=\"#需要的原因\" class=\"headerlink\" title=\"需要的原因\"></a>需要的原因</h2><ul>\n<li>有标记样本难以获取：需要专门的人员，特别的设备，额外的开销……</li>\n<li>无标记的样本相对而言是很廉价的</li>\n</ul>\n<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><p>很多半监督学习算法中用的训练数据还有挺多要求的，一般默认的有：无标签数据一般是有标签数据中的某一个类别的（不要不属于的，也不要属于多个类别的）；有标签数据的标签应该都是对的；无标签数据一般是类别平衡的（即每一类的样本数差不多）；无标签数据的分布应该和有标签的相同或类似 等等。</p>\n<p>简单介绍如下：</p>\n<p>1.<strong>简单自训练</strong>（simple self-training）：用有标签数据训练一个分类器，然后用这个分类器对无标签数据进行分类，这样就会产生伪标签（pseudo label）或软标签（soft label），挑选你认为分类正确的无标签样本（此处应该有一个<strong>挑选准则</strong>），把选出来的无标签样本用来训练分类器。</p>\n<p>2.<strong>协同训练</strong>（co-training）：其实也是 self-training 的一种，但其思想是好的。假设每个数据可以从不同的角度（view）进行分类，不同角度可以训练出不同的分类器，然后用这些从不同角度训练出来的分类器对无标签样本进行分类，再选出认为可信的无标签样本加入训练集中。由于这些分类器从不同角度训练出来的，可以形成一种互补，而提高分类精度；就如同从不同角度可以更好地理解事物一样。</p>\n<p>3.<strong>半监督字典学习</strong>：其实也是 self-training 的一种，先是用有标签数据作为字典，对无标签数据进行分类，挑选出你认为分类正确的无标签样本，加入字典中（此时的字典就变成了半监督字典了）</p>\n<p>4.<strong>标签传播算法</strong>（Label Propagation Algorithm）：是一种基于图的半监督算法，通过构造图结构（数据点为顶点，点之间的相似性为边）来寻找<strong>训练数据</strong>中有标签数据和无标签数据的关系。是的，只是训练数据中，这是一种直推式的半监督算法，即只对训练集中的无标签数据进行分类，这其实感觉很像一个有监督分类算法…，但其实并不是，因为其标签传播的过程，会流经无标签数据，即有些无标签数据的标签的信息，是从另一些无标签数据中流过来的，这就用到了无标签数据之间的联系</p>\n<h1 id=\"自监督-self-supervised\"><a href=\"#自监督-self-supervised\" class=\"headerlink\" title=\"自监督 (self-supervised)\"></a>自监督 (self-supervised)</h1><p><strong>从大规模的无监督数据中挖掘自身的监督信息</strong>，通过这种构造的监督信息对网络进行训练，从而可以学习到对下游任务有价值的表征。（也就是说自监督学习的监督信息不是人工标注的，而是算法在大规模无监督数据中自动构造监督信息，来进行监督学习或训练。因此，大多数时候，我们称之为无监督预训练方法或无监督学习方法，严格上讲，他应该叫自监督学习）。</p>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ul>\n<li><strong>从数据x，y上来说</strong>，属于无监督学习，因为没有标签数据y</li>\n<li><strong>从训练过程来说</strong>，属于有监督学习，因为自动构造了loss。</li>\n</ul>\n<h1 id=\"弱监督学习\"><a href=\"#弱监督学习\" class=\"headerlink\" title=\"弱监督学习\"></a>弱监督学习</h1><p> 机器学习，深度学习在很多任务中获得很大的成功，尤其是在监督学习中，深度学习，机器学习取得了突破性的进展。 例如分类和回归的监督任务中，预测模型需要从大量有标注训练样本中学习，训练样本包含两部分：第一部分是对象的特征向量，第二部分是真值标签。在分类任务中，label表示训练样本的类别，在回归任务中，标签是一个与样本相对应的实数值。这些模型依赖强监督信息，例如深度学习模型依赖大量的标注数据，在实际生产中，数据的标注成本很高，获取大量的有标注样本难度大。 因此利用弱监督学习，利用大量无标注或者粗糙标注的样本来进行模型的学习，这样能够有效的利用数据，提升模型的性能</p>\n"},{"_content":"# ping\n\nping 命令每秒发送一个数据报并且为每个接收到的响应显示一行输出。\n\nping既可以是域名，也可以是ip。\n\n**使用 ICMP 传输协议**\n\n所以，ping不通可能并不是主机不存在，可能是\n\n- 可能是dns问题\n- 防火墙过滤了ping发出的ICMP数据包\n\n\n\n\n\n# dig\n\ndig 命令主要用来**从 DNS 域名服务器查询主机地址信息**。\n\n```\n~ ❯ dig kengerbirthday.xyz                                              Py base\n\n; <<>> DiG 9.10.6 <<>> kengerbirthday.xyz\n;; global options: +cmd\n;; Got answer:\n;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 64689\n;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1\n\n;; OPT PSEUDOSECTION:\n; EDNS: version: 0, flags:; udp: 512\n;; QUESTION SECTION:\n;kengerbirthday.xyz.\t\tIN\tA\n\n;; ANSWER SECTION:\nkengerbirthday.xyz.\t600\tIN\tA\t110.40.204.239\n\n;; Query time: 77 msec\n;; SERVER: 8.8.8.8#53(8.8.8.8)\n;; WHEN: Wed Dec 21 10:49:55 CST 2022\n;; MSG SIZE  rcvd: 63\n```\n\n\n\n\n\n\n\n# telent\n\ntelnet命令：主要用于测试到某台机器的某个端口是否畅通，Centos是默认没有这个命令的，需要安装 \n\n`talent ip地址 + 80   查看80端口是否畅通     （80可以改） `\n\n telnet这个命令是依赖于 xinetd服务于telnet-server服务 \n\n telnet命令的安装：\n\n`yum -y install xinetd telnet telnet-server （确认联网状态）`","source":"_posts/实验室维护/一些网络测试常用命令.md","raw":"# ping\n\nping 命令每秒发送一个数据报并且为每个接收到的响应显示一行输出。\n\nping既可以是域名，也可以是ip。\n\n**使用 ICMP 传输协议**\n\n所以，ping不通可能并不是主机不存在，可能是\n\n- 可能是dns问题\n- 防火墙过滤了ping发出的ICMP数据包\n\n\n\n\n\n# dig\n\ndig 命令主要用来**从 DNS 域名服务器查询主机地址信息**。\n\n```\n~ ❯ dig kengerbirthday.xyz                                              Py base\n\n; <<>> DiG 9.10.6 <<>> kengerbirthday.xyz\n;; global options: +cmd\n;; Got answer:\n;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 64689\n;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1\n\n;; OPT PSEUDOSECTION:\n; EDNS: version: 0, flags:; udp: 512\n;; QUESTION SECTION:\n;kengerbirthday.xyz.\t\tIN\tA\n\n;; ANSWER SECTION:\nkengerbirthday.xyz.\t600\tIN\tA\t110.40.204.239\n\n;; Query time: 77 msec\n;; SERVER: 8.8.8.8#53(8.8.8.8)\n;; WHEN: Wed Dec 21 10:49:55 CST 2022\n;; MSG SIZE  rcvd: 63\n```\n\n\n\n\n\n\n\n# telent\n\ntelnet命令：主要用于测试到某台机器的某个端口是否畅通，Centos是默认没有这个命令的，需要安装 \n\n`talent ip地址 + 80   查看80端口是否畅通     （80可以改） `\n\n telnet这个命令是依赖于 xinetd服务于telnet-server服务 \n\n telnet命令的安装：\n\n`yum -y install xinetd telnet telnet-server （确认联网状态）`","slug":"实验室维护/一些网络测试常用命令","published":1,"date":"2023-02-27T11:33:23.583Z","updated":"2023-02-27T11:34:33.143Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsybf000i0gcn32gjmkyx","content":"<h1 id=\"ping\"><a href=\"#ping\" class=\"headerlink\" title=\"ping\"></a>ping</h1><p>ping 命令每秒发送一个数据报并且为每个接收到的响应显示一行输出。</p>\n<p>ping既可以是域名，也可以是ip。</p>\n<p><strong>使用 ICMP 传输协议</strong></p>\n<p>所以，ping不通可能并不是主机不存在，可能是</p>\n<ul>\n<li>可能是dns问题</li>\n<li>防火墙过滤了ping发出的ICMP数据包</li>\n</ul>\n<h1 id=\"dig\"><a href=\"#dig\" class=\"headerlink\" title=\"dig\"></a>dig</h1><p>dig 命令主要用来<strong>从 DNS 域名服务器查询主机地址信息</strong>。</p>\n<pre><code>~ ❯ dig kengerbirthday.xyz                                              Py base\n\n; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; kengerbirthday.xyz\n;; global options: +cmd\n;; Got answer:\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 64689\n;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1\n\n;; OPT PSEUDOSECTION:\n; EDNS: version: 0, flags:; udp: 512\n;; QUESTION SECTION:\n;kengerbirthday.xyz.        IN    A\n\n;; ANSWER SECTION:\nkengerbirthday.xyz.    600    IN    A    110.40.204.239\n\n;; Query time: 77 msec\n;; SERVER: 8.8.8.8#53(8.8.8.8)\n;; WHEN: Wed Dec 21 10:49:55 CST 2022\n;; MSG SIZE  rcvd: 63</code></pre><h1 id=\"telent\"><a href=\"#telent\" class=\"headerlink\" title=\"telent\"></a>telent</h1><p>telnet命令：主要用于测试到某台机器的某个端口是否畅通，Centos是默认没有这个命令的，需要安装 </p>\n<p><code>talent ip地址 + 80   查看80端口是否畅通     （80可以改）</code></p>\n<p> telnet这个命令是依赖于 xinetd服务于telnet-server服务 </p>\n<p> telnet命令的安装：</p>\n<p><code>yum -y install xinetd telnet telnet-server （确认联网状态）</code></p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"ping\"><a href=\"#ping\" class=\"headerlink\" title=\"ping\"></a>ping</h1><p>ping 命令每秒发送一个数据报并且为每个接收到的响应显示一行输出。</p>\n<p>ping既可以是域名，也可以是ip。</p>\n<p><strong>使用 ICMP 传输协议</strong></p>\n<p>所以，ping不通可能并不是主机不存在，可能是</p>\n<ul>\n<li>可能是dns问题</li>\n<li>防火墙过滤了ping发出的ICMP数据包</li>\n</ul>\n<h1 id=\"dig\"><a href=\"#dig\" class=\"headerlink\" title=\"dig\"></a>dig</h1><p>dig 命令主要用来<strong>从 DNS 域名服务器查询主机地址信息</strong>。</p>\n<pre><code>~ ❯ dig kengerbirthday.xyz                                              Py base\n\n; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; kengerbirthday.xyz\n;; global options: +cmd\n;; Got answer:\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 64689\n;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1\n\n;; OPT PSEUDOSECTION:\n; EDNS: version: 0, flags:; udp: 512\n;; QUESTION SECTION:\n;kengerbirthday.xyz.        IN    A\n\n;; ANSWER SECTION:\nkengerbirthday.xyz.    600    IN    A    110.40.204.239\n\n;; Query time: 77 msec\n;; SERVER: 8.8.8.8#53(8.8.8.8)\n;; WHEN: Wed Dec 21 10:49:55 CST 2022\n;; MSG SIZE  rcvd: 63</code></pre><h1 id=\"telent\"><a href=\"#telent\" class=\"headerlink\" title=\"telent\"></a>telent</h1><p>telnet命令：主要用于测试到某台机器的某个端口是否畅通，Centos是默认没有这个命令的，需要安装 </p>\n<p><code>talent ip地址 + 80   查看80端口是否畅通     （80可以改）</code></p>\n<p> telnet这个命令是依赖于 xinetd服务于telnet-server服务 </p>\n<p> telnet命令的安装：</p>\n<p><code>yum -y install xinetd telnet telnet-server （确认联网状态）</code></p>\n"},{"_content":"## openwrt新建多个wan口\n\n- 可以采取多线多口的方式。多个物理接口对应多个wan口\n- 或者采取单线多拨的方式，但是运行商不一定支持。\n  - 在单个网卡上虚拟出多个网卡\n  - 不同网卡不同的ip，mac\n\n\n\n\n\n## mwan配置复载均衡\n\nmwan是一个openwrt上的插件，可以实现多wan口的上网流量管理。\n\n\n\n**前置wan注意点**\n\n![image-20221123161720081](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/daa0b5992d6a9fb3beceed9958bce7d2/eda6e16df827df14aad0155101d03f09.png)\n\n- 网关跳跃点必须要有且不能重复\n\n\n\n\n\n**配置mwan**\n\n主要分为\n\n![230293745_2_20210913102146914](/Users/lwl/Desktop/230293745_2_20210913102146914.jpg)\n\n\n\n\n\n中文界面如图\n\n![image-20221123162109769](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/daa0b5992d6a9fb3beceed9958bce7d2/edb606a7224ab98ef8d1f4882b10fa20.png)\n\n\n\n\n\n**如何查看mwan的界面情况**\n\n![image-20221123162154984](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/daa0b5992d6a9fb3beceed9958bce7d2/5a80cbdc331c819ef110d686b3e7077d.png)\n\n在这个界面可以看到各个接口的在线情况\n\n\n\n\n\n## 一套成熟的校园网多wan部署方案\n\n### 需求\n\n- 实现多个wan口\n- 每个wan口都需要账号登录脚本使用指定参数做断开重连\n- 将多个wan口聚合，做负载均衡提高网速\n\n\n\n\n\n### 1先弄出多个wan口\n\n\n\n\n\n### 2配置mwan的基本参数\n\n包括接口，成员，策略\n\n\n\n**不过这里策略多出了一些单wan口直连的，用于后序的网络断开重连维护**\n\n![image-20221123162711423](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/daa0b5992d6a9fb3beceed9958bce7d2/6a0de772c0c3d8ef3ba274aa238c7f57.png)\n\n\n\n\n\n### 3配置流量规则\n\n**为了实现不同的wan口分别发起请求做断开重连维护。**\n\n**我们需要将断开重连的的请求分别从不同的脚本发出去。**\n\n**一个思路是，一台lan口下面的linux主机上，配置不同的ip。将不同的ip通过不同的wan口发送出去。**\n\n**要做到这点，需要mwan配置openwrt上的流量规则。同时也要在linux上通过脚本指定ip发起请求。**\n\n**我这里用的python指定发送脚本。后序程序会贴在附录。**\n\n\n\n**主要分为以下规则**\n\n- 从某个ip发送出的请求只走某个wan口。\n- 将正常ip下的请求全部负载均衡。\n\n如图\n\n![image-20221124131230129](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/daa0b5992d6a9fb3beceed9958bce7d2/739fa6efefb433250b8cb44812f60ff6.png)\n\n\n\n\n\n\n\n## 坑点\n\n因为我这里需要另外一台局域网内的linux主机来通过指定wan口发起请求来实现断网重连。\n\n那么意味着需要在断网情况下也能通过wan口访问。\n\n但是mwan有个问题，就是如果断网时候，该wan口会自动下线，也就是说不能访问，这个坑我踩了好久。\n\n**所以要么关闭wan口下线的功能**\n\n**要么设置让两个wan口永远在线**\n\n\n\n### 坑点之-------python的requests访问百度做判断并不准确\n\n所以实用ping指定ip做判断\n\n```\ndef net_check_ping(ip):\n\n    cmd = 'ping -I {} -c 5 baidu.com'.format(ip)\n\n    ans = os.system(cmd)\n    if ans == 0:\n        return True\n    else:\n        return False\n```\n\n\n\n\n\n\n\n\n\n## 附录\n\n\n\n### python指定ip发起请求脚本\n\n```python\nimport json\nimport http.client\nimport urllib.parse\n\n\ndef http_client():\n    params = {\"a\": \"123\"}\n    headers = {\"Content-type\": \"application/json\"}\n    conn = http.client.HTTPConnection(\n        \"目标ip或者域名\", 5000, source_address=(\"指定本地的ip\", 0))\n    conn.request(\"GET\", \"/\") #发起特定请求\n    response = conn.getresponse()\n    print(response.status, response.reason)\n    data = response.read().decode()\n    print(data)\n    conn.close()\n\n\ndef main():\n    http_client()\n\n\nif name == 'main':\n    main()\n```\n\n**或者用requests**\n\n```\nimport random\nimport requests\nfrom requests_toolbelt import SourceAddressAdapter\n\n\nclass SourceAddressRequests(object):\n    def __init__(self):\n        self.session = requests.session()\n        self.ips = ['192.168.1.209', '192.168.1.210']\n\n    def adapter_requests(self, ip):\n        \"\"\"随机绑定一个本机ip\"\"\"\n        bind_address = ip\n        print(\"请求ip：\", bind_address)\n        new_source = SourceAddressAdapter(bind_address)\n        self.session.mount('http://', new_source)\n        self.session.mount('https://', new_source)\n\n    def test_requests(self):\n        \"\"\"测试请求\"\"\"\n        url = \"http://httpbin.org/get\"\n        response = self.session.get(url=url)\n        origin = response.json()[\"origin\"]\n        print(\"检测到ip：\", origin)\n\n    def main(self):\n\n        for i in range(len(self.ips)):\n            self.adapter_requests(self.ips[i])\n            self.test_requests()\n\n\n    # 使用指定ip发起get请求\n    def get_by_ip(self, url, headers):\n        response = self.session.get(url=url, headers=headers)\n        return response\n\n\nif __name__ == '__main__':\n    test = SourceAddressRequests()\n    test.main()\n```\n\n**可以用重写直接替换get，在一定程度上达到无缝衔接的效果。**\n\n```\n# ip bind get write again\nadapter = SourceAddressRequests()\nrequests.get = adapter.get_by_ip\n```\n\n\n\n### 在宿舍内的一些openwrt上需要配置的路由表\n\n\n在宿舍内，如果openwrt某个wan断网了，那么当重新连接时，目标验证网站10.1.1.1根本ping不通。我猜是openwrt上没搞清楚这个要走那个口出去，初步判定，因为我这里涉及不通的运营商，所以导致不同的运营商网关不通，需要针对性的做出判断。\n\n配置\n- 注意这俩的metric一定要高，否则会走默认网关\n- 不通的ip WAN口设备一定要对应起来。\n```\nip route append 10.1.1.1 via 100.69.255.254 dev br-WAN1 proto static src 100.69.211.72 metric 1\n\nip route append 10.1.1.1 via 100.64.255.254 dev wlan0 proto static src 100.64.249.177 metric 2\n```\n\n\n\n\n\n\n\n一个小技巧\n\n**ping指令带上参数就可以指定源ip去ping目的ip。**\n\n```\n形式如下：ping -I 192.168.195.130 192.168.195.132\n```\n\n","source":"_posts/实验室维护/openwrt mwan 配置多wan复制均衡.md","raw":"## openwrt新建多个wan口\n\n- 可以采取多线多口的方式。多个物理接口对应多个wan口\n- 或者采取单线多拨的方式，但是运行商不一定支持。\n  - 在单个网卡上虚拟出多个网卡\n  - 不同网卡不同的ip，mac\n\n\n\n\n\n## mwan配置复载均衡\n\nmwan是一个openwrt上的插件，可以实现多wan口的上网流量管理。\n\n\n\n**前置wan注意点**\n\n![image-20221123161720081](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/daa0b5992d6a9fb3beceed9958bce7d2/eda6e16df827df14aad0155101d03f09.png)\n\n- 网关跳跃点必须要有且不能重复\n\n\n\n\n\n**配置mwan**\n\n主要分为\n\n![230293745_2_20210913102146914](/Users/lwl/Desktop/230293745_2_20210913102146914.jpg)\n\n\n\n\n\n中文界面如图\n\n![image-20221123162109769](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/daa0b5992d6a9fb3beceed9958bce7d2/edb606a7224ab98ef8d1f4882b10fa20.png)\n\n\n\n\n\n**如何查看mwan的界面情况**\n\n![image-20221123162154984](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/daa0b5992d6a9fb3beceed9958bce7d2/5a80cbdc331c819ef110d686b3e7077d.png)\n\n在这个界面可以看到各个接口的在线情况\n\n\n\n\n\n## 一套成熟的校园网多wan部署方案\n\n### 需求\n\n- 实现多个wan口\n- 每个wan口都需要账号登录脚本使用指定参数做断开重连\n- 将多个wan口聚合，做负载均衡提高网速\n\n\n\n\n\n### 1先弄出多个wan口\n\n\n\n\n\n### 2配置mwan的基本参数\n\n包括接口，成员，策略\n\n\n\n**不过这里策略多出了一些单wan口直连的，用于后序的网络断开重连维护**\n\n![image-20221123162711423](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/daa0b5992d6a9fb3beceed9958bce7d2/6a0de772c0c3d8ef3ba274aa238c7f57.png)\n\n\n\n\n\n### 3配置流量规则\n\n**为了实现不同的wan口分别发起请求做断开重连维护。**\n\n**我们需要将断开重连的的请求分别从不同的脚本发出去。**\n\n**一个思路是，一台lan口下面的linux主机上，配置不同的ip。将不同的ip通过不同的wan口发送出去。**\n\n**要做到这点，需要mwan配置openwrt上的流量规则。同时也要在linux上通过脚本指定ip发起请求。**\n\n**我这里用的python指定发送脚本。后序程序会贴在附录。**\n\n\n\n**主要分为以下规则**\n\n- 从某个ip发送出的请求只走某个wan口。\n- 将正常ip下的请求全部负载均衡。\n\n如图\n\n![image-20221124131230129](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/daa0b5992d6a9fb3beceed9958bce7d2/739fa6efefb433250b8cb44812f60ff6.png)\n\n\n\n\n\n\n\n## 坑点\n\n因为我这里需要另外一台局域网内的linux主机来通过指定wan口发起请求来实现断网重连。\n\n那么意味着需要在断网情况下也能通过wan口访问。\n\n但是mwan有个问题，就是如果断网时候，该wan口会自动下线，也就是说不能访问，这个坑我踩了好久。\n\n**所以要么关闭wan口下线的功能**\n\n**要么设置让两个wan口永远在线**\n\n\n\n### 坑点之-------python的requests访问百度做判断并不准确\n\n所以实用ping指定ip做判断\n\n```\ndef net_check_ping(ip):\n\n    cmd = 'ping -I {} -c 5 baidu.com'.format(ip)\n\n    ans = os.system(cmd)\n    if ans == 0:\n        return True\n    else:\n        return False\n```\n\n\n\n\n\n\n\n\n\n## 附录\n\n\n\n### python指定ip发起请求脚本\n\n```python\nimport json\nimport http.client\nimport urllib.parse\n\n\ndef http_client():\n    params = {\"a\": \"123\"}\n    headers = {\"Content-type\": \"application/json\"}\n    conn = http.client.HTTPConnection(\n        \"目标ip或者域名\", 5000, source_address=(\"指定本地的ip\", 0))\n    conn.request(\"GET\", \"/\") #发起特定请求\n    response = conn.getresponse()\n    print(response.status, response.reason)\n    data = response.read().decode()\n    print(data)\n    conn.close()\n\n\ndef main():\n    http_client()\n\n\nif name == 'main':\n    main()\n```\n\n**或者用requests**\n\n```\nimport random\nimport requests\nfrom requests_toolbelt import SourceAddressAdapter\n\n\nclass SourceAddressRequests(object):\n    def __init__(self):\n        self.session = requests.session()\n        self.ips = ['192.168.1.209', '192.168.1.210']\n\n    def adapter_requests(self, ip):\n        \"\"\"随机绑定一个本机ip\"\"\"\n        bind_address = ip\n        print(\"请求ip：\", bind_address)\n        new_source = SourceAddressAdapter(bind_address)\n        self.session.mount('http://', new_source)\n        self.session.mount('https://', new_source)\n\n    def test_requests(self):\n        \"\"\"测试请求\"\"\"\n        url = \"http://httpbin.org/get\"\n        response = self.session.get(url=url)\n        origin = response.json()[\"origin\"]\n        print(\"检测到ip：\", origin)\n\n    def main(self):\n\n        for i in range(len(self.ips)):\n            self.adapter_requests(self.ips[i])\n            self.test_requests()\n\n\n    # 使用指定ip发起get请求\n    def get_by_ip(self, url, headers):\n        response = self.session.get(url=url, headers=headers)\n        return response\n\n\nif __name__ == '__main__':\n    test = SourceAddressRequests()\n    test.main()\n```\n\n**可以用重写直接替换get，在一定程度上达到无缝衔接的效果。**\n\n```\n# ip bind get write again\nadapter = SourceAddressRequests()\nrequests.get = adapter.get_by_ip\n```\n\n\n\n### 在宿舍内的一些openwrt上需要配置的路由表\n\n\n在宿舍内，如果openwrt某个wan断网了，那么当重新连接时，目标验证网站10.1.1.1根本ping不通。我猜是openwrt上没搞清楚这个要走那个口出去，初步判定，因为我这里涉及不通的运营商，所以导致不同的运营商网关不通，需要针对性的做出判断。\n\n配置\n- 注意这俩的metric一定要高，否则会走默认网关\n- 不通的ip WAN口设备一定要对应起来。\n```\nip route append 10.1.1.1 via 100.69.255.254 dev br-WAN1 proto static src 100.69.211.72 metric 1\n\nip route append 10.1.1.1 via 100.64.255.254 dev wlan0 proto static src 100.64.249.177 metric 2\n```\n\n\n\n\n\n\n\n一个小技巧\n\n**ping指令带上参数就可以指定源ip去ping目的ip。**\n\n```\n形式如下：ping -I 192.168.195.130 192.168.195.132\n```\n\n","slug":"实验室维护/openwrt mwan 配置多wan复制均衡","published":1,"date":"2023-02-27T11:33:23.583Z","updated":"2023-02-27T11:34:33.143Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsybg000j0gcns8bs4wbr","content":"<h2 id=\"openwrt新建多个wan口\"><a href=\"#openwrt新建多个wan口\" class=\"headerlink\" title=\"openwrt新建多个wan口\"></a>openwrt新建多个wan口</h2><ul>\n<li>可以采取多线多口的方式。多个物理接口对应多个wan口</li>\n<li>或者采取单线多拨的方式，但是运行商不一定支持。<ul>\n<li>在单个网卡上虚拟出多个网卡</li>\n<li>不同网卡不同的ip，mac</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"mwan配置复载均衡\"><a href=\"#mwan配置复载均衡\" class=\"headerlink\" title=\"mwan配置复载均衡\"></a>mwan配置复载均衡</h2><p>mwan是一个openwrt上的插件，可以实现多wan口的上网流量管理。</p>\n<p><strong>前置wan注意点</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/daa0b5992d6a9fb3beceed9958bce7d2/eda6e16df827df14aad0155101d03f09.png\" alt=\"image-20221123161720081\"></p>\n<ul>\n<li>网关跳跃点必须要有且不能重复</li>\n</ul>\n<p><strong>配置mwan</strong></p>\n<p>主要分为</p>\n<p><img src=\"/Users/lwl/Desktop/230293745_2_20210913102146914.jpg\" alt=\"230293745_2_20210913102146914\"></p>\n<p>中文界面如图</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/daa0b5992d6a9fb3beceed9958bce7d2/edb606a7224ab98ef8d1f4882b10fa20.png\" alt=\"image-20221123162109769\"></p>\n<p><strong>如何查看mwan的界面情况</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/daa0b5992d6a9fb3beceed9958bce7d2/5a80cbdc331c819ef110d686b3e7077d.png\" alt=\"image-20221123162154984\"></p>\n<p>在这个界面可以看到各个接口的在线情况</p>\n<h2 id=\"一套成熟的校园网多wan部署方案\"><a href=\"#一套成熟的校园网多wan部署方案\" class=\"headerlink\" title=\"一套成熟的校园网多wan部署方案\"></a>一套成熟的校园网多wan部署方案</h2><h3 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h3><ul>\n<li>实现多个wan口</li>\n<li>每个wan口都需要账号登录脚本使用指定参数做断开重连</li>\n<li>将多个wan口聚合，做负载均衡提高网速</li>\n</ul>\n<h3 id=\"1先弄出多个wan口\"><a href=\"#1先弄出多个wan口\" class=\"headerlink\" title=\"1先弄出多个wan口\"></a>1先弄出多个wan口</h3><h3 id=\"2配置mwan的基本参数\"><a href=\"#2配置mwan的基本参数\" class=\"headerlink\" title=\"2配置mwan的基本参数\"></a>2配置mwan的基本参数</h3><p>包括接口，成员，策略</p>\n<p><strong>不过这里策略多出了一些单wan口直连的，用于后序的网络断开重连维护</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/daa0b5992d6a9fb3beceed9958bce7d2/6a0de772c0c3d8ef3ba274aa238c7f57.png\" alt=\"image-20221123162711423\"></p>\n<h3 id=\"3配置流量规则\"><a href=\"#3配置流量规则\" class=\"headerlink\" title=\"3配置流量规则\"></a>3配置流量规则</h3><p><strong>为了实现不同的wan口分别发起请求做断开重连维护。</strong></p>\n<p><strong>我们需要将断开重连的的请求分别从不同的脚本发出去。</strong></p>\n<p><strong>一个思路是，一台lan口下面的linux主机上，配置不同的ip。将不同的ip通过不同的wan口发送出去。</strong></p>\n<p><strong>要做到这点，需要mwan配置openwrt上的流量规则。同时也要在linux上通过脚本指定ip发起请求。</strong></p>\n<p><strong>我这里用的python指定发送脚本。后序程序会贴在附录。</strong></p>\n<p><strong>主要分为以下规则</strong></p>\n<ul>\n<li>从某个ip发送出的请求只走某个wan口。</li>\n<li>将正常ip下的请求全部负载均衡。</li>\n</ul>\n<p>如图</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/daa0b5992d6a9fb3beceed9958bce7d2/739fa6efefb433250b8cb44812f60ff6.png\" alt=\"image-20221124131230129\"></p>\n<h2 id=\"坑点\"><a href=\"#坑点\" class=\"headerlink\" title=\"坑点\"></a>坑点</h2><p>因为我这里需要另外一台局域网内的linux主机来通过指定wan口发起请求来实现断网重连。</p>\n<p>那么意味着需要在断网情况下也能通过wan口访问。</p>\n<p>但是mwan有个问题，就是如果断网时候，该wan口会自动下线，也就是说不能访问，这个坑我踩了好久。</p>\n<p><strong>所以要么关闭wan口下线的功能</strong></p>\n<p><strong>要么设置让两个wan口永远在线</strong></p>\n<h3 id=\"坑点之——-python的requests访问百度做判断并不准确\"><a href=\"#坑点之——-python的requests访问百度做判断并不准确\" class=\"headerlink\" title=\"坑点之——-python的requests访问百度做判断并不准确\"></a>坑点之——-python的requests访问百度做判断并不准确</h3><p>所以实用ping指定ip做判断</p>\n<pre><code>def net_check_ping(ip):\n\n    cmd = &#39;ping -I {} -c 5 baidu.com&#39;.format(ip)\n\n    ans = os.system(cmd)\n    if ans == 0:\n        return True\n    else:\n        return False</code></pre><h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><h3 id=\"python指定ip发起请求脚本\"><a href=\"#python指定ip发起请求脚本\" class=\"headerlink\" title=\"python指定ip发起请求脚本\"></a>python指定ip发起请求脚本</h3><pre class=\"line-numbers language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> json\n<span class=\"token keyword\">import</span> http<span class=\"token punctuation\">.</span>client\n<span class=\"token keyword\">import</span> urllib<span class=\"token punctuation\">.</span>parse\n\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">http_client</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    params <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"123\"</span><span class=\"token punctuation\">}</span>\n    headers <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token string\">\"Content-type\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"application/json\"</span><span class=\"token punctuation\">}</span>\n    conn <span class=\"token operator\">=</span> http<span class=\"token punctuation\">.</span>client<span class=\"token punctuation\">.</span>HTTPConnection<span class=\"token punctuation\">(</span>\n        <span class=\"token string\">\"目标ip或者域名\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5000</span><span class=\"token punctuation\">,</span> source_address<span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"指定本地的ip\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    conn<span class=\"token punctuation\">.</span>request<span class=\"token punctuation\">(</span><span class=\"token string\">\"GET\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"/\"</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">#发起特定请求</span>\n    response <span class=\"token operator\">=</span> conn<span class=\"token punctuation\">.</span>getresponse<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">.</span>status<span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">.</span>reason<span class=\"token punctuation\">)</span>\n    data <span class=\"token operator\">=</span> response<span class=\"token punctuation\">.</span>read<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>decode<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span>\n    conn<span class=\"token punctuation\">.</span>close<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    http_client<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n\n<span class=\"token keyword\">if</span> name <span class=\"token operator\">==</span> <span class=\"token string\">'main'</span><span class=\"token punctuation\">:</span>\n    main<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>或者用requests</strong></p>\n<pre><code>import random\nimport requests\nfrom requests_toolbelt import SourceAddressAdapter\n\n\nclass SourceAddressRequests(object):\n    def __init__(self):\n        self.session = requests.session()\n        self.ips = [&#39;192.168.1.209&#39;, &#39;192.168.1.210&#39;]\n\n    def adapter_requests(self, ip):\n        &quot;&quot;&quot;随机绑定一个本机ip&quot;&quot;&quot;\n        bind_address = ip\n        print(&quot;请求ip：&quot;, bind_address)\n        new_source = SourceAddressAdapter(bind_address)\n        self.session.mount(&#39;http://&#39;, new_source)\n        self.session.mount(&#39;https://&#39;, new_source)\n\n    def test_requests(self):\n        &quot;&quot;&quot;测试请求&quot;&quot;&quot;\n        url = &quot;http://httpbin.org/get&quot;\n        response = self.session.get(url=url)\n        origin = response.json()[&quot;origin&quot;]\n        print(&quot;检测到ip：&quot;, origin)\n\n    def main(self):\n\n        for i in range(len(self.ips)):\n            self.adapter_requests(self.ips[i])\n            self.test_requests()\n\n\n    # 使用指定ip发起get请求\n    def get_by_ip(self, url, headers):\n        response = self.session.get(url=url, headers=headers)\n        return response\n\n\nif __name__ == &#39;__main__&#39;:\n    test = SourceAddressRequests()\n    test.main()</code></pre><p><strong>可以用重写直接替换get，在一定程度上达到无缝衔接的效果。</strong></p>\n<pre><code># ip bind get write again\nadapter = SourceAddressRequests()\nrequests.get = adapter.get_by_ip</code></pre><h3 id=\"在宿舍内的一些openwrt上需要配置的路由表\"><a href=\"#在宿舍内的一些openwrt上需要配置的路由表\" class=\"headerlink\" title=\"在宿舍内的一些openwrt上需要配置的路由表\"></a>在宿舍内的一些openwrt上需要配置的路由表</h3><p>在宿舍内，如果openwrt某个wan断网了，那么当重新连接时，目标验证网站10.1.1.1根本ping不通。我猜是openwrt上没搞清楚这个要走那个口出去，初步判定，因为我这里涉及不通的运营商，所以导致不同的运营商网关不通，需要针对性的做出判断。</p>\n<p>配置</p>\n<ul>\n<li>注意这俩的metric一定要高，否则会走默认网关</li>\n<li>不通的ip WAN口设备一定要对应起来。<pre><code>ip route append 10.1.1.1 via 100.69.255.254 dev br-WAN1 proto static src 100.69.211.72 metric 1\n</code></pre></li>\n</ul>\n<p>ip route append 10.1.1.1 via 100.64.255.254 dev wlan0 proto static src 100.64.249.177 metric 2</p>\n<pre><code>\n\n\n\n\n\n\n一个小技巧\n\n**ping指令带上参数就可以指定源ip去ping目的ip。**\n</code></pre><p>形式如下：ping -I 192.168.195.130 192.168.195.132</p>\n<pre><code></code></pre>","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h2 id=\"openwrt新建多个wan口\"><a href=\"#openwrt新建多个wan口\" class=\"headerlink\" title=\"openwrt新建多个wan口\"></a>openwrt新建多个wan口</h2><ul>\n<li>可以采取多线多口的方式。多个物理接口对应多个wan口</li>\n<li>或者采取单线多拨的方式，但是运行商不一定支持。<ul>\n<li>在单个网卡上虚拟出多个网卡</li>\n<li>不同网卡不同的ip，mac</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"mwan配置复载均衡\"><a href=\"#mwan配置复载均衡\" class=\"headerlink\" title=\"mwan配置复载均衡\"></a>mwan配置复载均衡</h2><p>mwan是一个openwrt上的插件，可以实现多wan口的上网流量管理。</p>\n<p><strong>前置wan注意点</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/daa0b5992d6a9fb3beceed9958bce7d2/eda6e16df827df14aad0155101d03f09.png\" alt=\"image-20221123161720081\"></p>\n<ul>\n<li>网关跳跃点必须要有且不能重复</li>\n</ul>\n<p><strong>配置mwan</strong></p>\n<p>主要分为</p>\n<p><img src=\"/Users/lwl/Desktop/230293745_2_20210913102146914.jpg\" alt=\"230293745_2_20210913102146914\"></p>\n<p>中文界面如图</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/daa0b5992d6a9fb3beceed9958bce7d2/edb606a7224ab98ef8d1f4882b10fa20.png\" alt=\"image-20221123162109769\"></p>\n<p><strong>如何查看mwan的界面情况</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/daa0b5992d6a9fb3beceed9958bce7d2/5a80cbdc331c819ef110d686b3e7077d.png\" alt=\"image-20221123162154984\"></p>\n<p>在这个界面可以看到各个接口的在线情况</p>\n<h2 id=\"一套成熟的校园网多wan部署方案\"><a href=\"#一套成熟的校园网多wan部署方案\" class=\"headerlink\" title=\"一套成熟的校园网多wan部署方案\"></a>一套成熟的校园网多wan部署方案</h2><h3 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h3><ul>\n<li>实现多个wan口</li>\n<li>每个wan口都需要账号登录脚本使用指定参数做断开重连</li>\n<li>将多个wan口聚合，做负载均衡提高网速</li>\n</ul>\n<h3 id=\"1先弄出多个wan口\"><a href=\"#1先弄出多个wan口\" class=\"headerlink\" title=\"1先弄出多个wan口\"></a>1先弄出多个wan口</h3><h3 id=\"2配置mwan的基本参数\"><a href=\"#2配置mwan的基本参数\" class=\"headerlink\" title=\"2配置mwan的基本参数\"></a>2配置mwan的基本参数</h3><p>包括接口，成员，策略</p>\n<p><strong>不过这里策略多出了一些单wan口直连的，用于后序的网络断开重连维护</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/daa0b5992d6a9fb3beceed9958bce7d2/6a0de772c0c3d8ef3ba274aa238c7f57.png\" alt=\"image-20221123162711423\"></p>\n<h3 id=\"3配置流量规则\"><a href=\"#3配置流量规则\" class=\"headerlink\" title=\"3配置流量规则\"></a>3配置流量规则</h3><p><strong>为了实现不同的wan口分别发起请求做断开重连维护。</strong></p>\n<p><strong>我们需要将断开重连的的请求分别从不同的脚本发出去。</strong></p>\n<p><strong>一个思路是，一台lan口下面的linux主机上，配置不同的ip。将不同的ip通过不同的wan口发送出去。</strong></p>\n<p><strong>要做到这点，需要mwan配置openwrt上的流量规则。同时也要在linux上通过脚本指定ip发起请求。</strong></p>\n<p><strong>我这里用的python指定发送脚本。后序程序会贴在附录。</strong></p>\n<p><strong>主要分为以下规则</strong></p>\n<ul>\n<li>从某个ip发送出的请求只走某个wan口。</li>\n<li>将正常ip下的请求全部负载均衡。</li>\n</ul>\n<p>如图</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/daa0b5992d6a9fb3beceed9958bce7d2/739fa6efefb433250b8cb44812f60ff6.png\" alt=\"image-20221124131230129\"></p>\n<h2 id=\"坑点\"><a href=\"#坑点\" class=\"headerlink\" title=\"坑点\"></a>坑点</h2><p>因为我这里需要另外一台局域网内的linux主机来通过指定wan口发起请求来实现断网重连。</p>\n<p>那么意味着需要在断网情况下也能通过wan口访问。</p>\n<p>但是mwan有个问题，就是如果断网时候，该wan口会自动下线，也就是说不能访问，这个坑我踩了好久。</p>\n<p><strong>所以要么关闭wan口下线的功能</strong></p>\n<p><strong>要么设置让两个wan口永远在线</strong></p>\n<h3 id=\"坑点之——-python的requests访问百度做判断并不准确\"><a href=\"#坑点之——-python的requests访问百度做判断并不准确\" class=\"headerlink\" title=\"坑点之——-python的requests访问百度做判断并不准确\"></a>坑点之——-python的requests访问百度做判断并不准确</h3><p>所以实用ping指定ip做判断</p>\n<pre><code>def net_check_ping(ip):\n\n    cmd = &#39;ping -I {} -c 5 baidu.com&#39;.format(ip)\n\n    ans = os.system(cmd)\n    if ans == 0:\n        return True\n    else:\n        return False</code></pre><h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><h3 id=\"python指定ip发起请求脚本\"><a href=\"#python指定ip发起请求脚本\" class=\"headerlink\" title=\"python指定ip发起请求脚本\"></a>python指定ip发起请求脚本</h3><pre><code class=\"python\">import json\nimport http.client\nimport urllib.parse\n\n\ndef http_client():\n    params = {&quot;a&quot;: &quot;123&quot;}\n    headers = {&quot;Content-type&quot;: &quot;application/json&quot;}\n    conn = http.client.HTTPConnection(\n        &quot;目标ip或者域名&quot;, 5000, source_address=(&quot;指定本地的ip&quot;, 0))\n    conn.request(&quot;GET&quot;, &quot;/&quot;) #发起特定请求\n    response = conn.getresponse()\n    print(response.status, response.reason)\n    data = response.read().decode()\n    print(data)\n    conn.close()\n\n\ndef main():\n    http_client()\n\n\nif name == &#39;main&#39;:\n    main()</code></pre>\n<p><strong>或者用requests</strong></p>\n<pre><code>import random\nimport requests\nfrom requests_toolbelt import SourceAddressAdapter\n\n\nclass SourceAddressRequests(object):\n    def __init__(self):\n        self.session = requests.session()\n        self.ips = [&#39;192.168.1.209&#39;, &#39;192.168.1.210&#39;]\n\n    def adapter_requests(self, ip):\n        &quot;&quot;&quot;随机绑定一个本机ip&quot;&quot;&quot;\n        bind_address = ip\n        print(&quot;请求ip：&quot;, bind_address)\n        new_source = SourceAddressAdapter(bind_address)\n        self.session.mount(&#39;http://&#39;, new_source)\n        self.session.mount(&#39;https://&#39;, new_source)\n\n    def test_requests(self):\n        &quot;&quot;&quot;测试请求&quot;&quot;&quot;\n        url = &quot;http://httpbin.org/get&quot;\n        response = self.session.get(url=url)\n        origin = response.json()[&quot;origin&quot;]\n        print(&quot;检测到ip：&quot;, origin)\n\n    def main(self):\n\n        for i in range(len(self.ips)):\n            self.adapter_requests(self.ips[i])\n            self.test_requests()\n\n\n    # 使用指定ip发起get请求\n    def get_by_ip(self, url, headers):\n        response = self.session.get(url=url, headers=headers)\n        return response\n\n\nif __name__ == &#39;__main__&#39;:\n    test = SourceAddressRequests()\n    test.main()</code></pre><p><strong>可以用重写直接替换get，在一定程度上达到无缝衔接的效果。</strong></p>\n<pre><code># ip bind get write again\nadapter = SourceAddressRequests()\nrequests.get = adapter.get_by_ip</code></pre><h3 id=\"在宿舍内的一些openwrt上需要配置的路由表\"><a href=\"#在宿舍内的一些openwrt上需要配置的路由表\" class=\"headerlink\" title=\"在宿舍内的一些openwrt上需要配置的路由表\"></a>在宿舍内的一些openwrt上需要配置的路由表</h3><p>在宿舍内，如果openwrt某个wan断网了，那么当重新连接时，目标验证网站10.1.1.1根本ping不通。我猜是openwrt上没搞清楚这个要走那个口出去，初步判定，因为我这里涉及不通的运营商，所以导致不同的运营商网关不通，需要针对性的做出判断。</p>\n<p>配置</p>\n<ul>\n<li>注意这俩的metric一定要高，否则会走默认网关</li>\n<li>不通的ip WAN口设备一定要对应起来。<pre><code>ip route append 10.1.1.1 via 100.69.255.254 dev br-WAN1 proto static src 100.69.211.72 metric 1\n</code></pre></li>\n</ul>\n<p>ip route append 10.1.1.1 via 100.64.255.254 dev wlan0 proto static src 100.64.249.177 metric 2</p>\n<pre><code>\n\n\n\n\n\n\n一个小技巧\n\n**ping指令带上参数就可以指定源ip去ping目的ip。**\n</code></pre><p>形式如下：ping -I 192.168.195.130 192.168.195.132</p>\n<pre><code></code></pre>"},{"_content":"## 傻瓜交换机\n\n**傻瓜交换机又称为不可网管交换机**，功能上，不能进行配置和管理。应用上，对于网络安全性要求不高可以选用不可网管交换机，并且这种交换机被广泛应用于低端网络（如学生机房、网吧等）的接入层，用于提供大量的网络接口。\n\n与之对立的是智能交换机：\n\n- 二三层交换机\n- **23层是具有划分VLAN和一些其他可管控的功能**\n\n\n## 二层交换机\nOSI模型中第二层：数据链路层\n二层交换机属数据链路层设备，**可以识别数据帧中的MAC地址信息，根据MAC地址进行转发**，并将这些MAC地址与对应的端口记录在自己内部的一个地址表中。\n\n![img](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/31ef45cee04598c98173b1d8cb4cf232/9f7e5b24aee7ccbc55a16a9f3aa1aee2.png)\n\n## 三层交换机\n\nOSI模型中第三层：网络层\n\n三层就是多了一些**路由转发的和其他一些路由器上面才有的功能**，核心就是整个网络的中心设备，所有出外网和转发和到服务器的数据都在这台设备处理，过滤和转发\n\n\n\n看着三层交换机和路由器很像。但是这二者专业度不一样，而且功能效率也会差很多。\n\n\n\n## ref\n\nhttps://zhuanlan.zhihu.com/p/64455461\n\n","source":"_posts/实验室维护/交换机.md","raw":"## 傻瓜交换机\n\n**傻瓜交换机又称为不可网管交换机**，功能上，不能进行配置和管理。应用上，对于网络安全性要求不高可以选用不可网管交换机，并且这种交换机被广泛应用于低端网络（如学生机房、网吧等）的接入层，用于提供大量的网络接口。\n\n与之对立的是智能交换机：\n\n- 二三层交换机\n- **23层是具有划分VLAN和一些其他可管控的功能**\n\n\n## 二层交换机\nOSI模型中第二层：数据链路层\n二层交换机属数据链路层设备，**可以识别数据帧中的MAC地址信息，根据MAC地址进行转发**，并将这些MAC地址与对应的端口记录在自己内部的一个地址表中。\n\n![img](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/31ef45cee04598c98173b1d8cb4cf232/9f7e5b24aee7ccbc55a16a9f3aa1aee2.png)\n\n## 三层交换机\n\nOSI模型中第三层：网络层\n\n三层就是多了一些**路由转发的和其他一些路由器上面才有的功能**，核心就是整个网络的中心设备，所有出外网和转发和到服务器的数据都在这台设备处理，过滤和转发\n\n\n\n看着三层交换机和路由器很像。但是这二者专业度不一样，而且功能效率也会差很多。\n\n\n\n## ref\n\nhttps://zhuanlan.zhihu.com/p/64455461\n\n","slug":"实验室维护/交换机","published":1,"date":"2023-02-27T11:33:23.584Z","updated":"2023-02-27T11:34:33.144Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsybh000k0gcn4uu6kv2e","content":"<h2 id=\"傻瓜交换机\"><a href=\"#傻瓜交换机\" class=\"headerlink\" title=\"傻瓜交换机\"></a>傻瓜交换机</h2><p><strong>傻瓜交换机又称为不可网管交换机</strong>，功能上，不能进行配置和管理。应用上，对于网络安全性要求不高可以选用不可网管交换机，并且这种交换机被广泛应用于低端网络（如学生机房、网吧等）的接入层，用于提供大量的网络接口。</p>\n<p>与之对立的是智能交换机：</p>\n<ul>\n<li>二三层交换机</li>\n<li><strong>23层是具有划分VLAN和一些其他可管控的功能</strong></li>\n</ul>\n<h2 id=\"二层交换机\"><a href=\"#二层交换机\" class=\"headerlink\" title=\"二层交换机\"></a>二层交换机</h2><p>OSI模型中第二层：数据链路层<br>二层交换机属数据链路层设备，<strong>可以识别数据帧中的MAC地址信息，根据MAC地址进行转发</strong>，并将这些MAC地址与对应的端口记录在自己内部的一个地址表中。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/31ef45cee04598c98173b1d8cb4cf232/9f7e5b24aee7ccbc55a16a9f3aa1aee2.png\" alt=\"img\"></p>\n<h2 id=\"三层交换机\"><a href=\"#三层交换机\" class=\"headerlink\" title=\"三层交换机\"></a>三层交换机</h2><p>OSI模型中第三层：网络层</p>\n<p>三层就是多了一些<strong>路由转发的和其他一些路由器上面才有的功能</strong>，核心就是整个网络的中心设备，所有出外网和转发和到服务器的数据都在这台设备处理，过滤和转发</p>\n<p>看着三层交换机和路由器很像。但是这二者专业度不一样，而且功能效率也会差很多。</p>\n<h2 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h2><p><a href=\"https://zhuanlan.zhihu.com/p/64455461\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/64455461</a></p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h2 id=\"傻瓜交换机\"><a href=\"#傻瓜交换机\" class=\"headerlink\" title=\"傻瓜交换机\"></a>傻瓜交换机</h2><p><strong>傻瓜交换机又称为不可网管交换机</strong>，功能上，不能进行配置和管理。应用上，对于网络安全性要求不高可以选用不可网管交换机，并且这种交换机被广泛应用于低端网络（如学生机房、网吧等）的接入层，用于提供大量的网络接口。</p>\n<p>与之对立的是智能交换机：</p>\n<ul>\n<li>二三层交换机</li>\n<li><strong>23层是具有划分VLAN和一些其他可管控的功能</strong></li>\n</ul>\n<h2 id=\"二层交换机\"><a href=\"#二层交换机\" class=\"headerlink\" title=\"二层交换机\"></a>二层交换机</h2><p>OSI模型中第二层：数据链路层<br>二层交换机属数据链路层设备，<strong>可以识别数据帧中的MAC地址信息，根据MAC地址进行转发</strong>，并将这些MAC地址与对应的端口记录在自己内部的一个地址表中。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/31ef45cee04598c98173b1d8cb4cf232/9f7e5b24aee7ccbc55a16a9f3aa1aee2.png\" alt=\"img\"></p>\n<h2 id=\"三层交换机\"><a href=\"#三层交换机\" class=\"headerlink\" title=\"三层交换机\"></a>三层交换机</h2><p>OSI模型中第三层：网络层</p>\n<p>三层就是多了一些<strong>路由转发的和其他一些路由器上面才有的功能</strong>，核心就是整个网络的中心设备，所有出外网和转发和到服务器的数据都在这台设备处理，过滤和转发</p>\n<p>看着三层交换机和路由器很像。但是这二者专业度不一样，而且功能效率也会差很多。</p>\n<h2 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h2><p><a href=\"https://zhuanlan.zhihu.com/p/64455461\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/64455461</a></p>\n"},{"_content":"# 情况\n\n我正在用transformer训练自己的一个数据集。\n\n结果\n\n![image-20230113225050509](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/230e647f418926abc0ab069056ffffcc/cfb7147ebdf0563d3ab63a4259c638d3.png)\n\n\n\n显然不对了。loss值变成了nan。\n\n\n\n# 排查\n\n\n\n## 1，学习率太大，导致溢出了\n\n尝试调低学习率，更改模型初始化参数\n\n\n\n\n\n## 2，模型本身问题\n\n但是发现我这一开始loss就是nan。\n\n![image-20230113225244523](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/230e647f418926abc0ab069056ffffcc/72907cccc256126eb9cb0ab6c70319e1.png)\n\n模型内部应该加入SIGMOD之类的防止越界\n\n\n\n然后输出模型的的out查看\n\n![image-20230113230413317](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/230e647f418926abc0ab069056ffffcc/a879c2b8e861c45a003c2d2e01d649d4.png)\n\n发现第一次的数据就有nan值。不知道是中间哪一层开始的。\n\n\n\n检查开始：\n\n- 检查输入是不是异常含有nan值：pass，这里不是\n- 一层层网络检查是从哪一层开始出现nan","source":"_posts/dl/记一次训练loss变成nan值.md","raw":"# 情况\n\n我正在用transformer训练自己的一个数据集。\n\n结果\n\n![image-20230113225050509](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/230e647f418926abc0ab069056ffffcc/cfb7147ebdf0563d3ab63a4259c638d3.png)\n\n\n\n显然不对了。loss值变成了nan。\n\n\n\n# 排查\n\n\n\n## 1，学习率太大，导致溢出了\n\n尝试调低学习率，更改模型初始化参数\n\n\n\n\n\n## 2，模型本身问题\n\n但是发现我这一开始loss就是nan。\n\n![image-20230113225244523](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/230e647f418926abc0ab069056ffffcc/72907cccc256126eb9cb0ab6c70319e1.png)\n\n模型内部应该加入SIGMOD之类的防止越界\n\n\n\n然后输出模型的的out查看\n\n![image-20230113230413317](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/230e647f418926abc0ab069056ffffcc/a879c2b8e861c45a003c2d2e01d649d4.png)\n\n发现第一次的数据就有nan值。不知道是中间哪一层开始的。\n\n\n\n检查开始：\n\n- 检查输入是不是异常含有nan值：pass，这里不是\n- 一层层网络检查是从哪一层开始出现nan","slug":"dl/记一次训练loss变成nan值","published":1,"date":"2023-02-27T11:33:23.571Z","updated":"2023-02-27T11:34:33.131Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsybh000l0gcnnvyvqx4k","content":"<h1 id=\"情况\"><a href=\"#情况\" class=\"headerlink\" title=\"情况\"></a>情况</h1><p>我正在用transformer训练自己的一个数据集。</p>\n<p>结果</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/230e647f418926abc0ab069056ffffcc/cfb7147ebdf0563d3ab63a4259c638d3.png\" alt=\"image-20230113225050509\"></p>\n<p>显然不对了。loss值变成了nan。</p>\n<h1 id=\"排查\"><a href=\"#排查\" class=\"headerlink\" title=\"排查\"></a>排查</h1><h2 id=\"1，学习率太大，导致溢出了\"><a href=\"#1，学习率太大，导致溢出了\" class=\"headerlink\" title=\"1，学习率太大，导致溢出了\"></a>1，学习率太大，导致溢出了</h2><p>尝试调低学习率，更改模型初始化参数</p>\n<h2 id=\"2，模型本身问题\"><a href=\"#2，模型本身问题\" class=\"headerlink\" title=\"2，模型本身问题\"></a>2，模型本身问题</h2><p>但是发现我这一开始loss就是nan。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/230e647f418926abc0ab069056ffffcc/72907cccc256126eb9cb0ab6c70319e1.png\" alt=\"image-20230113225244523\"></p>\n<p>模型内部应该加入SIGMOD之类的防止越界</p>\n<p>然后输出模型的的out查看</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/230e647f418926abc0ab069056ffffcc/a879c2b8e861c45a003c2d2e01d649d4.png\" alt=\"image-20230113230413317\"></p>\n<p>发现第一次的数据就有nan值。不知道是中间哪一层开始的。</p>\n<p>检查开始：</p>\n<ul>\n<li>检查输入是不是异常含有nan值：pass，这里不是</li>\n<li>一层层网络检查是从哪一层开始出现nan</li>\n</ul>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"情况\"><a href=\"#情况\" class=\"headerlink\" title=\"情况\"></a>情况</h1><p>我正在用transformer训练自己的一个数据集。</p>\n<p>结果</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/230e647f418926abc0ab069056ffffcc/cfb7147ebdf0563d3ab63a4259c638d3.png\" alt=\"image-20230113225050509\"></p>\n<p>显然不对了。loss值变成了nan。</p>\n<h1 id=\"排查\"><a href=\"#排查\" class=\"headerlink\" title=\"排查\"></a>排查</h1><h2 id=\"1，学习率太大，导致溢出了\"><a href=\"#1，学习率太大，导致溢出了\" class=\"headerlink\" title=\"1，学习率太大，导致溢出了\"></a>1，学习率太大，导致溢出了</h2><p>尝试调低学习率，更改模型初始化参数</p>\n<h2 id=\"2，模型本身问题\"><a href=\"#2，模型本身问题\" class=\"headerlink\" title=\"2，模型本身问题\"></a>2，模型本身问题</h2><p>但是发现我这一开始loss就是nan。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/230e647f418926abc0ab069056ffffcc/72907cccc256126eb9cb0ab6c70319e1.png\" alt=\"image-20230113225244523\"></p>\n<p>模型内部应该加入SIGMOD之类的防止越界</p>\n<p>然后输出模型的的out查看</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/230e647f418926abc0ab069056ffffcc/a879c2b8e861c45a003c2d2e01d649d4.png\" alt=\"image-20230113230413317\"></p>\n<p>发现第一次的数据就有nan值。不知道是中间哪一层开始的。</p>\n<p>检查开始：</p>\n<ul>\n<li>检查输入是不是异常含有nan值：pass，这里不是</li>\n<li>一层层网络检查是从哪一层开始出现nan</li>\n</ul>\n"},{"_content":"# 关于光纤接口类别\n\n双lc，sfp","source":"_posts/实验室维护/各种杂乱的知识点.md","raw":"# 关于光纤接口类别\n\n双lc，sfp","slug":"实验室维护/各种杂乱的知识点","published":1,"date":"2023-02-27T11:33:23.584Z","updated":"2023-02-27T11:34:33.144Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsybi000m0gcnly4tns0u","content":"<h1 id=\"关于光纤接口类别\"><a href=\"#关于光纤接口类别\" class=\"headerlink\" title=\"关于光纤接口类别\"></a>关于光纤接口类别</h1><p>双lc，sfp</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"关于光纤接口类别\"><a href=\"#关于光纤接口类别\" class=\"headerlink\" title=\"关于光纤接口类别\"></a>关于光纤接口类别</h1><p>双lc，sfp</p>\n"},{"_content":"# 关于我在Ubuntu上配置route\n\n## 前言\n\n\n\n## 查看当前所有路由表，并进行管理\n\n`ip rule list`输出所有的路由表\n\n```\nlabot@core-labot:~$ ip rule list\n0:\tfrom all lookup local\n32766:\tfrom all lookup main\n32767:\tfrom all lookup default\n```\n\n\n\n新增路由表\n\n修改**/etc/iproute2/rt_tables**\n\n```\n#\n# reserved values\n#\n255     local\n254     main\n253     default\n0       unspec\n#\n# local\n#\n#1      inr.ruhep\n211     net_0 # 这是我们新增的路由表，前面的数据越小代表优先级越高。范围是0-255\n```\n\n\n\n但是并不代表一修改后就立刻可以通过ip rule查看到。\n\n可能需要对该表新增一些路由配置后才能显示有\n\n```\n第1步：\n  把路由表序号(10、11)和路由表名字(net_0、net_1)添加到/etc/iproute2/rt_tables中\n第2步：\n  （1）ip route add 192.168.2.0/24 dev eth0 src 192.168.2.10 table net_0\n    从192.168.2.10发送到192.168.2.0/24网段的数据从eth0发出，把该路由项添加到路由表net_0中\n  （2）ip route add default dev eth0 table net_0\n    在路由表中添加默认路由，默认路由从eth0进出\n  （3）ip rule add from 192.168.2.0/24 table net_0\n    添加路由策略，来自192.168.2.10的路由要求使用net_0\n  （4） ip route flush cache\n    把新添加的路由策略和路由表刷新到缓存中，即时生效\n```\n\n\n\n\n\n\n\n\n\n## 关于路由表解释route -n\n\n```\nlabot@core-labot:~$ route -n\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         10.10.10.10     0.0.0.0         UG    0      0        0 ens160\n0.0.0.0         10.10.10.10     0.0.0.0         UG    100    0        0 ens160\n10.10.0.0       0.0.0.0         255.255.0.0     U     0      0        0 ens160\n10.10.10.10     0.0.0.0         255.255.255.255 UH    100    0        0 ens160\n10.11.0.0       0.0.0.0         255.255.0.0     U     0      0        0 ens192\n172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0\n```\n\n**destination 目的网段**\n**[mask](https://so.csdn.net/so/search?q=mask&spm=1001.2101.3001.7020) 子网掩码**\n**interface 到达该目的地的本[路由器](https://so.csdn.net/so/search?q=路由器&spm=1001.2101.3001.7020)的出口ip**\n**gateway 下一跳路由器入口的ip**，路由器通过interface和gateway定义一调到下一个路由器的链路，通常情况下，interface和gateway是同一网段的\n**metric 跳数，该条路由记录的质量**，一般情况下，如果有多条到达相同目的地的路由记录，路由器**会采用metric值小**的那条路由\n\n### 一条条具体理解\n\n```\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n# 缺省路由，如果目标网段找不到，那么就从这走。一般有default gateway决定。本例中，如果目标网段找不到，那么就从ens160设备，到10.10.10.10网关。交给网关去处理\n0.0.0.0         10.10.10.10     0.0.0.0         UG    0      0        0 ens160\n0.0.0.0         10.10.10.10     0.0.0.0         UG    100    0        0 ens160\n\n#直联网段的路由记录，如果目的网段是10.10.0.0/16，那么从ens160出发，送到0.0.0.0。最后0.0.0.0又会发给10.10.10.10\n10.10.0.0       0.0.0.0         255.255.0.0     U     0      0        0 ens160\n10.10.10.10     0.0.0.0         255.255.255.255 UH    100    0        0 ens160\n10.11.0.0       0.0.0.0         255.255.0.0     U     0      0        0 ens192\n172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0\n```\n\n\n\n### 和ip route的区别\n\n显示格式不一样\n\n\n\n\n\n\n\n\n\n## 路由表\n\n**一个linux主机可以有多张路由表**\n\n- 查看所有路由表\n\n```\n# in\nip rule\n\n# out\n0:      from all lookup local\n32766:  from all lookup main\n32767:  from all lookup default\n# 可以看到有三张路由表，local，main，default。\n# local：路由表 local 包含本机路由及广播信息。\n# main：使用传统命令 route -n 所看到的路由表就是 main 的内容。\n# default：default 路由表在默认情况下内容为空；除非有特别的要求，否则保持其内容为空即可。\n```\n\n- 删除一个路由表\n\n```pf\nip rule del table out3 prio 32763\n```\n\n- 添加路由表\n\n```pf\n$ sudo echo \"4 out4\" >> /etc/iproute2/rt_tables\n# 此时 ip rule 不能显示新增路由表\n# 在新路由表添加应用规则后才能显示出来\n# 给 out4 路由表添加应用规则： 来自 192.168.111.111 的数据使用 out4 路由表\n$ sudo ip rule add from 192.168.111.111/32 table out4\n```\n\n\n\n\n\n## 一些route常见命令\n\n```\n    ip route show + 表名（et，main）：显示路由表； \n\n    ip route add：添加路由； \n\n    ip route append是追加   #追加一个指定网络的路由，为了平滑切换网关使用\n\n    ip route change：修改路由；\n\n    ip route replace：修改路由或添加路由；\n\n    ip route delete：删除路由；\n\n    ip route get：获得单条路由的详细信息；\n\n    ip route flush：清空路由表；\n    \n```\n\n\n\n\n\n## 关于ip route add/append 命令使用\n\n```\n\nsudo ip route append 10.10.0.0/16 via 0.0.0.0 dev ens160 src 10.10.114.32 protocol kernel  metric 100 table main\n上面的意思是，到10.10.0.0/16这个范围的目的地，经过0.0.0.0 从src 10.10.114.32 出发，使用ens160网卡\n\n\n- via 制定网关，经过哪\n- dev 制定网卡\n- src 源地址\n- protocol  是该路由的路由协议标识符。proto kernel的意思是: 在自动配置过程中由内核安装的路由。\n- metric 路由开销\n- scope 指的是路由前缀覆盖的目标地址范围。 scope link表示在设备的网段内允许通过该路由进行通信\n```\n\n\n\n\n\n## SYS test\n\n对ax3600添加默认路由，默认路由从ens192，且网关为10.11.11.11\n\n```\nsudo ip route add default dev ens192 via 10.11.11.11 table ax3600\n```\n\n\n\n\n\n给某个表添加路由策略\n\n给10.10段添加路由\n\n```\nfor((i=1; i<=3; i++));\ndo \n\tsudo ip route append 10.10.0.0/16 dev ens160 src 10.10.110.3$i protocol kernel  metric 100 table main\ndone\n```\n\n\n\n\n\n给10.11段添加路由\n\n```\nfor((i=1; i<=6; i++));\ndo \n\tsudo ip route append 10.11.0.0/16 dev ens192 src 10.11.110.3$i protocol kernel  metric 101 table main\ndone\n```\n\n\n\n## ref\n\n[route -n路由表理解](https://blog.csdn.net/yimenglin/article/details/107182098)\n\n[路由表设置详解](https://segmentfault.com/a/1190000022752866)","source":"_posts/实验室维护/关于我在Ubuntu上配置route.md","raw":"# 关于我在Ubuntu上配置route\n\n## 前言\n\n\n\n## 查看当前所有路由表，并进行管理\n\n`ip rule list`输出所有的路由表\n\n```\nlabot@core-labot:~$ ip rule list\n0:\tfrom all lookup local\n32766:\tfrom all lookup main\n32767:\tfrom all lookup default\n```\n\n\n\n新增路由表\n\n修改**/etc/iproute2/rt_tables**\n\n```\n#\n# reserved values\n#\n255     local\n254     main\n253     default\n0       unspec\n#\n# local\n#\n#1      inr.ruhep\n211     net_0 # 这是我们新增的路由表，前面的数据越小代表优先级越高。范围是0-255\n```\n\n\n\n但是并不代表一修改后就立刻可以通过ip rule查看到。\n\n可能需要对该表新增一些路由配置后才能显示有\n\n```\n第1步：\n  把路由表序号(10、11)和路由表名字(net_0、net_1)添加到/etc/iproute2/rt_tables中\n第2步：\n  （1）ip route add 192.168.2.0/24 dev eth0 src 192.168.2.10 table net_0\n    从192.168.2.10发送到192.168.2.0/24网段的数据从eth0发出，把该路由项添加到路由表net_0中\n  （2）ip route add default dev eth0 table net_0\n    在路由表中添加默认路由，默认路由从eth0进出\n  （3）ip rule add from 192.168.2.0/24 table net_0\n    添加路由策略，来自192.168.2.10的路由要求使用net_0\n  （4） ip route flush cache\n    把新添加的路由策略和路由表刷新到缓存中，即时生效\n```\n\n\n\n\n\n\n\n\n\n## 关于路由表解释route -n\n\n```\nlabot@core-labot:~$ route -n\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         10.10.10.10     0.0.0.0         UG    0      0        0 ens160\n0.0.0.0         10.10.10.10     0.0.0.0         UG    100    0        0 ens160\n10.10.0.0       0.0.0.0         255.255.0.0     U     0      0        0 ens160\n10.10.10.10     0.0.0.0         255.255.255.255 UH    100    0        0 ens160\n10.11.0.0       0.0.0.0         255.255.0.0     U     0      0        0 ens192\n172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0\n```\n\n**destination 目的网段**\n**[mask](https://so.csdn.net/so/search?q=mask&spm=1001.2101.3001.7020) 子网掩码**\n**interface 到达该目的地的本[路由器](https://so.csdn.net/so/search?q=路由器&spm=1001.2101.3001.7020)的出口ip**\n**gateway 下一跳路由器入口的ip**，路由器通过interface和gateway定义一调到下一个路由器的链路，通常情况下，interface和gateway是同一网段的\n**metric 跳数，该条路由记录的质量**，一般情况下，如果有多条到达相同目的地的路由记录，路由器**会采用metric值小**的那条路由\n\n### 一条条具体理解\n\n```\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n# 缺省路由，如果目标网段找不到，那么就从这走。一般有default gateway决定。本例中，如果目标网段找不到，那么就从ens160设备，到10.10.10.10网关。交给网关去处理\n0.0.0.0         10.10.10.10     0.0.0.0         UG    0      0        0 ens160\n0.0.0.0         10.10.10.10     0.0.0.0         UG    100    0        0 ens160\n\n#直联网段的路由记录，如果目的网段是10.10.0.0/16，那么从ens160出发，送到0.0.0.0。最后0.0.0.0又会发给10.10.10.10\n10.10.0.0       0.0.0.0         255.255.0.0     U     0      0        0 ens160\n10.10.10.10     0.0.0.0         255.255.255.255 UH    100    0        0 ens160\n10.11.0.0       0.0.0.0         255.255.0.0     U     0      0        0 ens192\n172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0\n```\n\n\n\n### 和ip route的区别\n\n显示格式不一样\n\n\n\n\n\n\n\n\n\n## 路由表\n\n**一个linux主机可以有多张路由表**\n\n- 查看所有路由表\n\n```\n# in\nip rule\n\n# out\n0:      from all lookup local\n32766:  from all lookup main\n32767:  from all lookup default\n# 可以看到有三张路由表，local，main，default。\n# local：路由表 local 包含本机路由及广播信息。\n# main：使用传统命令 route -n 所看到的路由表就是 main 的内容。\n# default：default 路由表在默认情况下内容为空；除非有特别的要求，否则保持其内容为空即可。\n```\n\n- 删除一个路由表\n\n```pf\nip rule del table out3 prio 32763\n```\n\n- 添加路由表\n\n```pf\n$ sudo echo \"4 out4\" >> /etc/iproute2/rt_tables\n# 此时 ip rule 不能显示新增路由表\n# 在新路由表添加应用规则后才能显示出来\n# 给 out4 路由表添加应用规则： 来自 192.168.111.111 的数据使用 out4 路由表\n$ sudo ip rule add from 192.168.111.111/32 table out4\n```\n\n\n\n\n\n## 一些route常见命令\n\n```\n    ip route show + 表名（et，main）：显示路由表； \n\n    ip route add：添加路由； \n\n    ip route append是追加   #追加一个指定网络的路由，为了平滑切换网关使用\n\n    ip route change：修改路由；\n\n    ip route replace：修改路由或添加路由；\n\n    ip route delete：删除路由；\n\n    ip route get：获得单条路由的详细信息；\n\n    ip route flush：清空路由表；\n    \n```\n\n\n\n\n\n## 关于ip route add/append 命令使用\n\n```\n\nsudo ip route append 10.10.0.0/16 via 0.0.0.0 dev ens160 src 10.10.114.32 protocol kernel  metric 100 table main\n上面的意思是，到10.10.0.0/16这个范围的目的地，经过0.0.0.0 从src 10.10.114.32 出发，使用ens160网卡\n\n\n- via 制定网关，经过哪\n- dev 制定网卡\n- src 源地址\n- protocol  是该路由的路由协议标识符。proto kernel的意思是: 在自动配置过程中由内核安装的路由。\n- metric 路由开销\n- scope 指的是路由前缀覆盖的目标地址范围。 scope link表示在设备的网段内允许通过该路由进行通信\n```\n\n\n\n\n\n## SYS test\n\n对ax3600添加默认路由，默认路由从ens192，且网关为10.11.11.11\n\n```\nsudo ip route add default dev ens192 via 10.11.11.11 table ax3600\n```\n\n\n\n\n\n给某个表添加路由策略\n\n给10.10段添加路由\n\n```\nfor((i=1; i<=3; i++));\ndo \n\tsudo ip route append 10.10.0.0/16 dev ens160 src 10.10.110.3$i protocol kernel  metric 100 table main\ndone\n```\n\n\n\n\n\n给10.11段添加路由\n\n```\nfor((i=1; i<=6; i++));\ndo \n\tsudo ip route append 10.11.0.0/16 dev ens192 src 10.11.110.3$i protocol kernel  metric 101 table main\ndone\n```\n\n\n\n## ref\n\n[route -n路由表理解](https://blog.csdn.net/yimenglin/article/details/107182098)\n\n[路由表设置详解](https://segmentfault.com/a/1190000022752866)","slug":"实验室维护/关于我在Ubuntu上配置route","published":1,"date":"2023-02-27T11:33:23.584Z","updated":"2023-02-27T11:34:33.143Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsybj000n0gcnjfum6z6p","content":"<h1 id=\"关于我在Ubuntu上配置route\"><a href=\"#关于我在Ubuntu上配置route\" class=\"headerlink\" title=\"关于我在Ubuntu上配置route\"></a>关于我在Ubuntu上配置route</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><h2 id=\"查看当前所有路由表，并进行管理\"><a href=\"#查看当前所有路由表，并进行管理\" class=\"headerlink\" title=\"查看当前所有路由表，并进行管理\"></a>查看当前所有路由表，并进行管理</h2><p><code>ip rule list</code>输出所有的路由表</p>\n<pre><code>labot@core-labot:~$ ip rule list\n0:    from all lookup local\n32766:    from all lookup main\n32767:    from all lookup default</code></pre><p>新增路由表</p>\n<p>修改<strong>/etc/iproute2/rt_tables</strong></p>\n<pre><code>#\n# reserved values\n#\n255     local\n254     main\n253     default\n0       unspec\n#\n# local\n#\n#1      inr.ruhep\n211     net_0 # 这是我们新增的路由表，前面的数据越小代表优先级越高。范围是0-255</code></pre><p>但是并不代表一修改后就立刻可以通过ip rule查看到。</p>\n<p>可能需要对该表新增一些路由配置后才能显示有</p>\n<pre><code>第1步：\n  把路由表序号(10、11)和路由表名字(net_0、net_1)添加到/etc/iproute2/rt_tables中\n第2步：\n  （1）ip route add 192.168.2.0/24 dev eth0 src 192.168.2.10 table net_0\n    从192.168.2.10发送到192.168.2.0/24网段的数据从eth0发出，把该路由项添加到路由表net_0中\n  （2）ip route add default dev eth0 table net_0\n    在路由表中添加默认路由，默认路由从eth0进出\n  （3）ip rule add from 192.168.2.0/24 table net_0\n    添加路由策略，来自192.168.2.10的路由要求使用net_0\n  （4） ip route flush cache\n    把新添加的路由策略和路由表刷新到缓存中，即时生效</code></pre><h2 id=\"关于路由表解释route-n\"><a href=\"#关于路由表解释route-n\" class=\"headerlink\" title=\"关于路由表解释route -n\"></a>关于路由表解释route -n</h2><pre><code>labot@core-labot:~$ route -n\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         10.10.10.10     0.0.0.0         UG    0      0        0 ens160\n0.0.0.0         10.10.10.10     0.0.0.0         UG    100    0        0 ens160\n10.10.0.0       0.0.0.0         255.255.0.0     U     0      0        0 ens160\n10.10.10.10     0.0.0.0         255.255.255.255 UH    100    0        0 ens160\n10.11.0.0       0.0.0.0         255.255.0.0     U     0      0        0 ens192\n172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</code></pre><p><strong>destination 目的网段</strong><br><strong><a href=\"https://so.csdn.net/so/search?q=mask&spm=1001.2101.3001.7020\" target=\"_blank\" rel=\"noopener\">mask</a> 子网掩码</strong><br><strong>interface 到达该目的地的本<a href=\"https://so.csdn.net/so/search?q=路由器&spm=1001.2101.3001.7020\" target=\"_blank\" rel=\"noopener\">路由器</a>的出口ip</strong><br><strong>gateway 下一跳路由器入口的ip</strong>，路由器通过interface和gateway定义一调到下一个路由器的链路，通常情况下，interface和gateway是同一网段的<br><strong>metric 跳数，该条路由记录的质量</strong>，一般情况下，如果有多条到达相同目的地的路由记录，路由器<strong>会采用metric值小</strong>的那条路由</p>\n<h3 id=\"一条条具体理解\"><a href=\"#一条条具体理解\" class=\"headerlink\" title=\"一条条具体理解\"></a>一条条具体理解</h3><pre><code>Destination     Gateway         Genmask         Flags Metric Ref    Use Iface\n# 缺省路由，如果目标网段找不到，那么就从这走。一般有default gateway决定。本例中，如果目标网段找不到，那么就从ens160设备，到10.10.10.10网关。交给网关去处理\n0.0.0.0         10.10.10.10     0.0.0.0         UG    0      0        0 ens160\n0.0.0.0         10.10.10.10     0.0.0.0         UG    100    0        0 ens160\n\n#直联网段的路由记录，如果目的网段是10.10.0.0/16，那么从ens160出发，送到0.0.0.0。最后0.0.0.0又会发给10.10.10.10\n10.10.0.0       0.0.0.0         255.255.0.0     U     0      0        0 ens160\n10.10.10.10     0.0.0.0         255.255.255.255 UH    100    0        0 ens160\n10.11.0.0       0.0.0.0         255.255.0.0     U     0      0        0 ens192\n172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</code></pre><h3 id=\"和ip-route的区别\"><a href=\"#和ip-route的区别\" class=\"headerlink\" title=\"和ip route的区别\"></a>和ip route的区别</h3><p>显示格式不一样</p>\n<h2 id=\"路由表\"><a href=\"#路由表\" class=\"headerlink\" title=\"路由表\"></a>路由表</h2><p><strong>一个linux主机可以有多张路由表</strong></p>\n<ul>\n<li>查看所有路由表</li>\n</ul>\n<pre><code># in\nip rule\n\n# out\n0:      from all lookup local\n32766:  from all lookup main\n32767:  from all lookup default\n# 可以看到有三张路由表，local，main，default。\n# local：路由表 local 包含本机路由及广播信息。\n# main：使用传统命令 route -n 所看到的路由表就是 main 的内容。\n# default：default 路由表在默认情况下内容为空；除非有特别的要求，否则保持其内容为空即可。</code></pre><ul>\n<li>删除一个路由表</li>\n</ul>\n<pre class=\"line-numbers language-pf\"><code class=\"language-pf\">ip rule del table out3 prio 32763<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<ul>\n<li>添加路由表</li>\n</ul>\n<pre class=\"line-numbers language-pf\"><code class=\"language-pf\">$ sudo echo \"4 out4\" >> /etc/iproute2/rt_tables\n# 此时 ip rule 不能显示新增路由表\n# 在新路由表添加应用规则后才能显示出来\n# 给 out4 路由表添加应用规则： 来自 192.168.111.111 的数据使用 out4 路由表\n$ sudo ip rule add from 192.168.111.111/32 table out4<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"一些route常见命令\"><a href=\"#一些route常见命令\" class=\"headerlink\" title=\"一些route常见命令\"></a>一些route常见命令</h2><pre><code>    ip route show + 表名（et，main）：显示路由表； \n\n    ip route add：添加路由； \n\n    ip route append是追加   #追加一个指定网络的路由，为了平滑切换网关使用\n\n    ip route change：修改路由；\n\n    ip route replace：修改路由或添加路由；\n\n    ip route delete：删除路由；\n\n    ip route get：获得单条路由的详细信息；\n\n    ip route flush：清空路由表；\n</code></pre><h2 id=\"关于ip-route-add-append-命令使用\"><a href=\"#关于ip-route-add-append-命令使用\" class=\"headerlink\" title=\"关于ip route add/append 命令使用\"></a>关于ip route add/append 命令使用</h2><pre><code>\nsudo ip route append 10.10.0.0/16 via 0.0.0.0 dev ens160 src 10.10.114.32 protocol kernel  metric 100 table main\n上面的意思是，到10.10.0.0/16这个范围的目的地，经过0.0.0.0 从src 10.10.114.32 出发，使用ens160网卡\n\n\n- via 制定网关，经过哪\n- dev 制定网卡\n- src 源地址\n- protocol  是该路由的路由协议标识符。proto kernel的意思是: 在自动配置过程中由内核安装的路由。\n- metric 路由开销\n- scope 指的是路由前缀覆盖的目标地址范围。 scope link表示在设备的网段内允许通过该路由进行通信</code></pre><h2 id=\"SYS-test\"><a href=\"#SYS-test\" class=\"headerlink\" title=\"SYS test\"></a>SYS test</h2><p>对ax3600添加默认路由，默认路由从ens192，且网关为10.11.11.11</p>\n<pre><code>sudo ip route add default dev ens192 via 10.11.11.11 table ax3600</code></pre><p>给某个表添加路由策略</p>\n<p>给10.10段添加路由</p>\n<pre><code>for((i=1; i&lt;=3; i++));\ndo \n    sudo ip route append 10.10.0.0/16 dev ens160 src 10.10.110.3$i protocol kernel  metric 100 table main\ndone</code></pre><p>给10.11段添加路由</p>\n<pre><code>for((i=1; i&lt;=6; i++));\ndo \n    sudo ip route append 10.11.0.0/16 dev ens192 src 10.11.110.3$i protocol kernel  metric 101 table main\ndone</code></pre><h2 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h2><p><a href=\"https://blog.csdn.net/yimenglin/article/details/107182098\" target=\"_blank\" rel=\"noopener\">route -n路由表理解</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000022752866\" target=\"_blank\" rel=\"noopener\">路由表设置详解</a></p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"关于我在Ubuntu上配置route\"><a href=\"#关于我在Ubuntu上配置route\" class=\"headerlink\" title=\"关于我在Ubuntu上配置route\"></a>关于我在Ubuntu上配置route</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><h2 id=\"查看当前所有路由表，并进行管理\"><a href=\"#查看当前所有路由表，并进行管理\" class=\"headerlink\" title=\"查看当前所有路由表，并进行管理\"></a>查看当前所有路由表，并进行管理</h2><p><code>ip rule list</code>输出所有的路由表</p>\n<pre><code>labot@core-labot:~$ ip rule list\n0:    from all lookup local\n32766:    from all lookup main\n32767:    from all lookup default</code></pre><p>新增路由表</p>\n<p>修改<strong>/etc/iproute2/rt_tables</strong></p>\n<pre><code>#\n# reserved values\n#\n255     local\n254     main\n253     default\n0       unspec\n#\n# local\n#\n#1      inr.ruhep\n211     net_0 # 这是我们新增的路由表，前面的数据越小代表优先级越高。范围是0-255</code></pre><p>但是并不代表一修改后就立刻可以通过ip rule查看到。</p>\n<p>可能需要对该表新增一些路由配置后才能显示有</p>\n<pre><code>第1步：\n  把路由表序号(10、11)和路由表名字(net_0、net_1)添加到/etc/iproute2/rt_tables中\n第2步：\n  （1）ip route add 192.168.2.0/24 dev eth0 src 192.168.2.10 table net_0\n    从192.168.2.10发送到192.168.2.0/24网段的数据从eth0发出，把该路由项添加到路由表net_0中\n  （2）ip route add default dev eth0 table net_0\n    在路由表中添加默认路由，默认路由从eth0进出\n  （3）ip rule add from 192.168.2.0/24 table net_0\n    添加路由策略，来自192.168.2.10的路由要求使用net_0\n  （4） ip route flush cache\n    把新添加的路由策略和路由表刷新到缓存中，即时生效</code></pre><h2 id=\"关于路由表解释route-n\"><a href=\"#关于路由表解释route-n\" class=\"headerlink\" title=\"关于路由表解释route -n\"></a>关于路由表解释route -n</h2><pre><code>labot@core-labot:~$ route -n\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         10.10.10.10     0.0.0.0         UG    0      0        0 ens160\n0.0.0.0         10.10.10.10     0.0.0.0         UG    100    0        0 ens160\n10.10.0.0       0.0.0.0         255.255.0.0     U     0      0        0 ens160\n10.10.10.10     0.0.0.0         255.255.255.255 UH    100    0        0 ens160\n10.11.0.0       0.0.0.0         255.255.0.0     U     0      0        0 ens192\n172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</code></pre><p><strong>destination 目的网段</strong><br><strong><a href=\"https://so.csdn.net/so/search?q=mask&spm=1001.2101.3001.7020\" target=\"_blank\" rel=\"noopener\">mask</a> 子网掩码</strong><br><strong>interface 到达该目的地的本<a href=\"https://so.csdn.net/so/search?q=路由器&spm=1001.2101.3001.7020\" target=\"_blank\" rel=\"noopener\">路由器</a>的出口ip</strong><br><strong>gateway 下一跳路由器入口的ip</strong>，路由器通过interface和gateway定义一调到下一个路由器的链路，通常情况下，interface和gateway是同一网段的<br><strong>metric 跳数，该条路由记录的质量</strong>，一般情况下，如果有多条到达相同目的地的路由记录，路由器<strong>会采用metric值小</strong>的那条路由</p>\n<h3 id=\"一条条具体理解\"><a href=\"#一条条具体理解\" class=\"headerlink\" title=\"一条条具体理解\"></a>一条条具体理解</h3><pre><code>Destination     Gateway         Genmask         Flags Metric Ref    Use Iface\n# 缺省路由，如果目标网段找不到，那么就从这走。一般有default gateway决定。本例中，如果目标网段找不到，那么就从ens160设备，到10.10.10.10网关。交给网关去处理\n0.0.0.0         10.10.10.10     0.0.0.0         UG    0      0        0 ens160\n0.0.0.0         10.10.10.10     0.0.0.0         UG    100    0        0 ens160\n\n#直联网段的路由记录，如果目的网段是10.10.0.0/16，那么从ens160出发，送到0.0.0.0。最后0.0.0.0又会发给10.10.10.10\n10.10.0.0       0.0.0.0         255.255.0.0     U     0      0        0 ens160\n10.10.10.10     0.0.0.0         255.255.255.255 UH    100    0        0 ens160\n10.11.0.0       0.0.0.0         255.255.0.0     U     0      0        0 ens192\n172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</code></pre><h3 id=\"和ip-route的区别\"><a href=\"#和ip-route的区别\" class=\"headerlink\" title=\"和ip route的区别\"></a>和ip route的区别</h3><p>显示格式不一样</p>\n<h2 id=\"路由表\"><a href=\"#路由表\" class=\"headerlink\" title=\"路由表\"></a>路由表</h2><p><strong>一个linux主机可以有多张路由表</strong></p>\n<ul>\n<li>查看所有路由表</li>\n</ul>\n<pre><code># in\nip rule\n\n# out\n0:      from all lookup local\n32766:  from all lookup main\n32767:  from all lookup default\n# 可以看到有三张路由表，local，main，default。\n# local：路由表 local 包含本机路由及广播信息。\n# main：使用传统命令 route -n 所看到的路由表就是 main 的内容。\n# default：default 路由表在默认情况下内容为空；除非有特别的要求，否则保持其内容为空即可。</code></pre><ul>\n<li>删除一个路由表</li>\n</ul>\n<pre><code class=\"pf\">ip rule del table out3 prio 32763</code></pre>\n<ul>\n<li>添加路由表</li>\n</ul>\n<pre><code class=\"pf\">$ sudo echo &quot;4 out4&quot; &gt;&gt; /etc/iproute2/rt_tables\n# 此时 ip rule 不能显示新增路由表\n# 在新路由表添加应用规则后才能显示出来\n# 给 out4 路由表添加应用规则： 来自 192.168.111.111 的数据使用 out4 路由表\n$ sudo ip rule add from 192.168.111.111/32 table out4</code></pre>\n<h2 id=\"一些route常见命令\"><a href=\"#一些route常见命令\" class=\"headerlink\" title=\"一些route常见命令\"></a>一些route常见命令</h2><pre><code>    ip route show + 表名（et，main）：显示路由表； \n\n    ip route add：添加路由； \n\n    ip route append是追加   #追加一个指定网络的路由，为了平滑切换网关使用\n\n    ip route change：修改路由；\n\n    ip route replace：修改路由或添加路由；\n\n    ip route delete：删除路由；\n\n    ip route get：获得单条路由的详细信息；\n\n    ip route flush：清空路由表；\n</code></pre><h2 id=\"关于ip-route-add-append-命令使用\"><a href=\"#关于ip-route-add-append-命令使用\" class=\"headerlink\" title=\"关于ip route add/append 命令使用\"></a>关于ip route add/append 命令使用</h2><pre><code>\nsudo ip route append 10.10.0.0/16 via 0.0.0.0 dev ens160 src 10.10.114.32 protocol kernel  metric 100 table main\n上面的意思是，到10.10.0.0/16这个范围的目的地，经过0.0.0.0 从src 10.10.114.32 出发，使用ens160网卡\n\n\n- via 制定网关，经过哪\n- dev 制定网卡\n- src 源地址\n- protocol  是该路由的路由协议标识符。proto kernel的意思是: 在自动配置过程中由内核安装的路由。\n- metric 路由开销\n- scope 指的是路由前缀覆盖的目标地址范围。 scope link表示在设备的网段内允许通过该路由进行通信</code></pre><h2 id=\"SYS-test\"><a href=\"#SYS-test\" class=\"headerlink\" title=\"SYS test\"></a>SYS test</h2><p>对ax3600添加默认路由，默认路由从ens192，且网关为10.11.11.11</p>\n<pre><code>sudo ip route add default dev ens192 via 10.11.11.11 table ax3600</code></pre><p>给某个表添加路由策略</p>\n<p>给10.10段添加路由</p>\n<pre><code>for((i=1; i&lt;=3; i++));\ndo \n    sudo ip route append 10.10.0.0/16 dev ens160 src 10.10.110.3$i protocol kernel  metric 100 table main\ndone</code></pre><p>给10.11段添加路由</p>\n<pre><code>for((i=1; i&lt;=6; i++));\ndo \n    sudo ip route append 10.11.0.0/16 dev ens192 src 10.11.110.3$i protocol kernel  metric 101 table main\ndone</code></pre><h2 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h2><p><a href=\"https://blog.csdn.net/yimenglin/article/details/107182098\" target=\"_blank\" rel=\"noopener\">route -n路由表理解</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000022752866\" target=\"_blank\" rel=\"noopener\">路由表设置详解</a></p>\n"},{"_content":"# pandas\n\n\n\n## 行列\n\n```\n# 获取某一列\ndata['key']\n\n# 获取多列\ndata[['key1', 'key2']]\n\n\n```\n\n\n## 数据条件筛选\n\n**通过[]进行基本的行筛选**\n\n```\n# 筛选出key属性等于1的所有行，也可以用>,< 以及用&等逻辑组合\ndata[data['key'] == 1]\n\n# 筛选出前100行\ndata[0:100]\n```\n\n**通过loc以及iloc进行行以及列的筛选**\n\n- loc按标签值（列名和行索引取值）访问，\n- iloc按数字索引访问\n\n**首先loc**\n\n```\n# 基本[]支持的loc也都支持\ndata.loc[data['key'] == 1]\n\n# 同时还支持列的筛选, 列用：同样可以视作全选\ndata.loc[0:100, ['key1', 'key2']]\n```\n**然后iloc**\n\n```\n# 筛选出前100行，前1,2列\ndata.iloc[0:100, [0,1]]\n```\n\n\n\n**关于字符串匹配value**\n\n```\n# 下面利用titanic的数据举例，筛选出人名中包含Mrs或者Lily的数据，|或逻辑符号在引号内。\ntrain.loc[train['Name'].str.contains('Mrs|Lily'),:].head()\n```\n\n- case=True：使用case指定区分大小写\n- **na=True：就表示把有NAN的转换为布尔值True**\n- flags=re.IGNORECASE：标志传递到re模块，例如re.IGNORECASE\n- regex=True：regex ：如果为True，则假定第一个字符串是正则表达式，否则还是字符串\n\n\n\n## 逐行进行遍历\n\n```\n# values 是负责把值取出来\nfor row in CRAN_data.iterrows():\n    print(row[1].values)\n```\n\n\n\n\n## 查看某一列的特征：平均值，count统计，max，min，std方差\n\n```\ndata_projects[\"Platform\"].unique() # 查看共有多少中可能的取值\ndata_projects[\"Platform\"].value_counts() # 同个各个离散变量的个数\ndata_projects[\"Platform\"].min()\n# 以及mean(), max(),\n```\n**dataF.describe()**可以一次性查看表的各项属性的特征\n\n\n\n\n\n# numpy\n\n## 关于reshape\n\n快速改变向量的shape。但是并不会改变原始的顺序。\n\n**也就说说，如果按照从里到外的遍历顺序，那么无论怎么reshape的顺序是不会变的。**\n\n初期数据及库准备：\n\nimport numpy as np  # 调用numpy库\n**设置一个1-18的列表**\n\n```\nanchors = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]\n#将anchors由列表转换为数组的形式\nanchors = np.array(anchors)\n\n一维reshape() 为 二维\n18个元素一维度数组，可以转换为2 x 9 及 3 X 6的二维数组\n\nprint(anchors.reshape([3,6]))  # 生成一个（3，6）的二维数组\n\nprint(anchors.reshape([2,9]))  # 生成一个（2，9）的二维数组\n```\n\n![3，6的输出结果](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/1b1d9635de88de5898e66f7ece180df7/51e8b0ed3aa99934f470914a4a5890dd.png)\n\n\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/1b1d9635de88de5898e66f7ece180df7/5b701ad441b6213cd2af64bf31d69ed1.png)\n\n\n\n\n\n## 关于计算\n\n**可以直接做逻辑运算。**\n\n```\nnum = np.array([0,1,2,1,0,1,0])\nnum == 1\n```\n\n```\narray([False,  True, False,  True, False,  True, False])\n```\n\n**可以直接做算数运算**\n\n```\nnum = np.array([0,1,2,1,0,1,0])\nnum*2\n```\n\n```\narray([0, 2, 4, 2, 0, 2, 0])\n```\n\n\n\n## 条件选择数据\n\n**先获取索引，通过where函数**\n\n```\nnum = np.array([0,1,2,1,0,1,0])\n\nnp.where(num == 1)\n```\n\n```\n(array([1, 3, 5]),)\n```\n\n\n\n**然后可以通过index，筛选数据**\n\n```\nnum = np.array([0,1,2,1,0,1,0])\n\nindex = np.where(num == 1)\nindex, num[index]\n\nout:\n((array([1, 3, 5]),), array([1, 1, 1]))\n```\n\n\n\n## 关于随机选择数据\n\n**同上，只不过把index的获取变成随机。**\n\n```\nimport random\ndef getRandomIndex(n, x):\n\t# 索引范围为[0, n), 随机选x个不重复\n    index = random.sample(range(n), x)\n    return index\n```\n\n## 将数据打乱\n\n**同样也可以用index，因为index可以打算顺序。所以可以用这张方式来讲数据打乱**\n\n\n\n# pytorch\n\n\n\n## Pytorch之permute函数， 变换维度的重要函数\n\n在lstm中，我们的数据通常是，batch， seq， dim。\n\n但是要求输入却是：seq， batch， dim\n\n所以需要做数据变换，但是传统的reshape，和view并不能改变数据的底层排列顺序。\n\n这种时候就需要用到permute函数。\n\n**Tensor.permute(a,b,c,d, ...)**：permute函数可以对任意高维矩阵进行转置，但没有 torch.permute() 这个调用方式， 只能 Tensor.permute()：\n\n（abcd）是index，**个人可以理解为改变检索方式**\n\n\n\n```\na = tensor[a][b][c]\nb = a.permute(2,1,0)\n那么相当于吧检索的顺序改变一下。\n也就是说会有：\na[A][B][C] = b[C][A][B]\n```\n\n```\nimport torch\nimport numpy as np\n\na=np.array([[[1,2,3],[4,5,6]]])\nunpermuted=torch.tensor(a)\nprint(unpermuted.size())              #  ——>  torch.Size([1, 2, 3])\n\npermuted=unpermuted.permute(2,0,1)\nprint(permuted.size())                #  ——>  torch.Size([3, 1, 2])\n\nview_test = unpermuted.view(1,3,2)\nprint(view_test.size())    \n```\n\n\n\n## 乘法\n\n**Torch.mm(): 对两个二维矩阵做矩阵的乘法**\n\n```\ntorch.mm(a, b)\n```\n\n**Torch.matmul():输入可以是高维的。**\n当输入是都是二维时，就是普通的矩阵乘法，和tensor.mm函数用法相同。\n\n**当输入有多维时，把多出的一维作为batch提出来，其他部分做矩阵乘法。**\n\n![image-20220810220646801](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/1b1d9635de88de5898e66f7ece180df7/75c072e2f13b0e0356763b3de5b63655.png)\n\n\n\n或者都是3维的\n\n![image-20220810220708808](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/1b1d9635de88de5898e66f7ece180df7/0a86bcca07904caa6e37e1c491bd0bea.png)\n\n\n\n\n\n","source":"_posts/dl/表格数据处理pandas与numpy.md","raw":"# pandas\n\n\n\n## 行列\n\n```\n# 获取某一列\ndata['key']\n\n# 获取多列\ndata[['key1', 'key2']]\n\n\n```\n\n\n## 数据条件筛选\n\n**通过[]进行基本的行筛选**\n\n```\n# 筛选出key属性等于1的所有行，也可以用>,< 以及用&等逻辑组合\ndata[data['key'] == 1]\n\n# 筛选出前100行\ndata[0:100]\n```\n\n**通过loc以及iloc进行行以及列的筛选**\n\n- loc按标签值（列名和行索引取值）访问，\n- iloc按数字索引访问\n\n**首先loc**\n\n```\n# 基本[]支持的loc也都支持\ndata.loc[data['key'] == 1]\n\n# 同时还支持列的筛选, 列用：同样可以视作全选\ndata.loc[0:100, ['key1', 'key2']]\n```\n**然后iloc**\n\n```\n# 筛选出前100行，前1,2列\ndata.iloc[0:100, [0,1]]\n```\n\n\n\n**关于字符串匹配value**\n\n```\n# 下面利用titanic的数据举例，筛选出人名中包含Mrs或者Lily的数据，|或逻辑符号在引号内。\ntrain.loc[train['Name'].str.contains('Mrs|Lily'),:].head()\n```\n\n- case=True：使用case指定区分大小写\n- **na=True：就表示把有NAN的转换为布尔值True**\n- flags=re.IGNORECASE：标志传递到re模块，例如re.IGNORECASE\n- regex=True：regex ：如果为True，则假定第一个字符串是正则表达式，否则还是字符串\n\n\n\n## 逐行进行遍历\n\n```\n# values 是负责把值取出来\nfor row in CRAN_data.iterrows():\n    print(row[1].values)\n```\n\n\n\n\n## 查看某一列的特征：平均值，count统计，max，min，std方差\n\n```\ndata_projects[\"Platform\"].unique() # 查看共有多少中可能的取值\ndata_projects[\"Platform\"].value_counts() # 同个各个离散变量的个数\ndata_projects[\"Platform\"].min()\n# 以及mean(), max(),\n```\n**dataF.describe()**可以一次性查看表的各项属性的特征\n\n\n\n\n\n# numpy\n\n## 关于reshape\n\n快速改变向量的shape。但是并不会改变原始的顺序。\n\n**也就说说，如果按照从里到外的遍历顺序，那么无论怎么reshape的顺序是不会变的。**\n\n初期数据及库准备：\n\nimport numpy as np  # 调用numpy库\n**设置一个1-18的列表**\n\n```\nanchors = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]\n#将anchors由列表转换为数组的形式\nanchors = np.array(anchors)\n\n一维reshape() 为 二维\n18个元素一维度数组，可以转换为2 x 9 及 3 X 6的二维数组\n\nprint(anchors.reshape([3,6]))  # 生成一个（3，6）的二维数组\n\nprint(anchors.reshape([2,9]))  # 生成一个（2，9）的二维数组\n```\n\n![3，6的输出结果](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/1b1d9635de88de5898e66f7ece180df7/51e8b0ed3aa99934f470914a4a5890dd.png)\n\n\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/1b1d9635de88de5898e66f7ece180df7/5b701ad441b6213cd2af64bf31d69ed1.png)\n\n\n\n\n\n## 关于计算\n\n**可以直接做逻辑运算。**\n\n```\nnum = np.array([0,1,2,1,0,1,0])\nnum == 1\n```\n\n```\narray([False,  True, False,  True, False,  True, False])\n```\n\n**可以直接做算数运算**\n\n```\nnum = np.array([0,1,2,1,0,1,0])\nnum*2\n```\n\n```\narray([0, 2, 4, 2, 0, 2, 0])\n```\n\n\n\n## 条件选择数据\n\n**先获取索引，通过where函数**\n\n```\nnum = np.array([0,1,2,1,0,1,0])\n\nnp.where(num == 1)\n```\n\n```\n(array([1, 3, 5]),)\n```\n\n\n\n**然后可以通过index，筛选数据**\n\n```\nnum = np.array([0,1,2,1,0,1,0])\n\nindex = np.where(num == 1)\nindex, num[index]\n\nout:\n((array([1, 3, 5]),), array([1, 1, 1]))\n```\n\n\n\n## 关于随机选择数据\n\n**同上，只不过把index的获取变成随机。**\n\n```\nimport random\ndef getRandomIndex(n, x):\n\t# 索引范围为[0, n), 随机选x个不重复\n    index = random.sample(range(n), x)\n    return index\n```\n\n## 将数据打乱\n\n**同样也可以用index，因为index可以打算顺序。所以可以用这张方式来讲数据打乱**\n\n\n\n# pytorch\n\n\n\n## Pytorch之permute函数， 变换维度的重要函数\n\n在lstm中，我们的数据通常是，batch， seq， dim。\n\n但是要求输入却是：seq， batch， dim\n\n所以需要做数据变换，但是传统的reshape，和view并不能改变数据的底层排列顺序。\n\n这种时候就需要用到permute函数。\n\n**Tensor.permute(a,b,c,d, ...)**：permute函数可以对任意高维矩阵进行转置，但没有 torch.permute() 这个调用方式， 只能 Tensor.permute()：\n\n（abcd）是index，**个人可以理解为改变检索方式**\n\n\n\n```\na = tensor[a][b][c]\nb = a.permute(2,1,0)\n那么相当于吧检索的顺序改变一下。\n也就是说会有：\na[A][B][C] = b[C][A][B]\n```\n\n```\nimport torch\nimport numpy as np\n\na=np.array([[[1,2,3],[4,5,6]]])\nunpermuted=torch.tensor(a)\nprint(unpermuted.size())              #  ——>  torch.Size([1, 2, 3])\n\npermuted=unpermuted.permute(2,0,1)\nprint(permuted.size())                #  ——>  torch.Size([3, 1, 2])\n\nview_test = unpermuted.view(1,3,2)\nprint(view_test.size())    \n```\n\n\n\n## 乘法\n\n**Torch.mm(): 对两个二维矩阵做矩阵的乘法**\n\n```\ntorch.mm(a, b)\n```\n\n**Torch.matmul():输入可以是高维的。**\n当输入是都是二维时，就是普通的矩阵乘法，和tensor.mm函数用法相同。\n\n**当输入有多维时，把多出的一维作为batch提出来，其他部分做矩阵乘法。**\n\n![image-20220810220646801](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/1b1d9635de88de5898e66f7ece180df7/75c072e2f13b0e0356763b3de5b63655.png)\n\n\n\n或者都是3维的\n\n![image-20220810220708808](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/1b1d9635de88de5898e66f7ece180df7/0a86bcca07904caa6e37e1c491bd0bea.png)\n\n\n\n\n\n","slug":"dl/表格数据处理pandas与numpy","published":1,"date":"2023-02-27T11:33:23.571Z","updated":"2023-02-27T11:34:33.131Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsybl000o0gcnniwojhsd","content":"<h1 id=\"pandas\"><a href=\"#pandas\" class=\"headerlink\" title=\"pandas\"></a>pandas</h1><h2 id=\"行列\"><a href=\"#行列\" class=\"headerlink\" title=\"行列\"></a>行列</h2><pre><code># 获取某一列\ndata[&#39;key&#39;]\n\n# 获取多列\ndata[[&#39;key1&#39;, &#39;key2&#39;]]\n\n</code></pre><h2 id=\"数据条件筛选\"><a href=\"#数据条件筛选\" class=\"headerlink\" title=\"数据条件筛选\"></a>数据条件筛选</h2><p><strong>通过[]进行基本的行筛选</strong></p>\n<pre><code># 筛选出key属性等于1的所有行，也可以用&gt;,&lt; 以及用&amp;等逻辑组合\ndata[data[&#39;key&#39;] == 1]\n\n# 筛选出前100行\ndata[0:100]</code></pre><p><strong>通过loc以及iloc进行行以及列的筛选</strong></p>\n<ul>\n<li>loc按标签值（列名和行索引取值）访问，</li>\n<li>iloc按数字索引访问</li>\n</ul>\n<p><strong>首先loc</strong></p>\n<pre><code># 基本[]支持的loc也都支持\ndata.loc[data[&#39;key&#39;] == 1]\n\n# 同时还支持列的筛选, 列用：同样可以视作全选\ndata.loc[0:100, [&#39;key1&#39;, &#39;key2&#39;]]</code></pre><p><strong>然后iloc</strong></p>\n<pre><code># 筛选出前100行，前1,2列\ndata.iloc[0:100, [0,1]]</code></pre><p><strong>关于字符串匹配value</strong></p>\n<pre><code># 下面利用titanic的数据举例，筛选出人名中包含Mrs或者Lily的数据，|或逻辑符号在引号内。\ntrain.loc[train[&#39;Name&#39;].str.contains(&#39;Mrs|Lily&#39;),:].head()</code></pre><ul>\n<li>case=True：使用case指定区分大小写</li>\n<li><strong>na=True：就表示把有NAN的转换为布尔值True</strong></li>\n<li>flags=re.IGNORECASE：标志传递到re模块，例如re.IGNORECASE</li>\n<li>regex=True：regex ：如果为True，则假定第一个字符串是正则表达式，否则还是字符串</li>\n</ul>\n<h2 id=\"逐行进行遍历\"><a href=\"#逐行进行遍历\" class=\"headerlink\" title=\"逐行进行遍历\"></a>逐行进行遍历</h2><pre><code># values 是负责把值取出来\nfor row in CRAN_data.iterrows():\n    print(row[1].values)</code></pre><h2 id=\"查看某一列的特征：平均值，count统计，max，min，std方差\"><a href=\"#查看某一列的特征：平均值，count统计，max，min，std方差\" class=\"headerlink\" title=\"查看某一列的特征：平均值，count统计，max，min，std方差\"></a>查看某一列的特征：平均值，count统计，max，min，std方差</h2><pre><code>data_projects[&quot;Platform&quot;].unique() # 查看共有多少中可能的取值\ndata_projects[&quot;Platform&quot;].value_counts() # 同个各个离散变量的个数\ndata_projects[&quot;Platform&quot;].min()\n# 以及mean(), max(),</code></pre><p><strong>dataF.describe()</strong>可以一次性查看表的各项属性的特征</p>\n<h1 id=\"numpy\"><a href=\"#numpy\" class=\"headerlink\" title=\"numpy\"></a>numpy</h1><h2 id=\"关于reshape\"><a href=\"#关于reshape\" class=\"headerlink\" title=\"关于reshape\"></a>关于reshape</h2><p>快速改变向量的shape。但是并不会改变原始的顺序。</p>\n<p><strong>也就说说，如果按照从里到外的遍历顺序，那么无论怎么reshape的顺序是不会变的。</strong></p>\n<p>初期数据及库准备：</p>\n<p>import numpy as np  # 调用numpy库<br><strong>设置一个1-18的列表</strong></p>\n<pre><code>anchors = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]\n#将anchors由列表转换为数组的形式\nanchors = np.array(anchors)\n\n一维reshape() 为 二维\n18个元素一维度数组，可以转换为2 x 9 及 3 X 6的二维数组\n\nprint(anchors.reshape([3,6]))  # 生成一个（3，6）的二维数组\n\nprint(anchors.reshape([2,9]))  # 生成一个（2，9）的二维数组</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/1b1d9635de88de5898e66f7ece180df7/51e8b0ed3aa99934f470914a4a5890dd.png\" alt=\"3，6的输出结果\"></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/1b1d9635de88de5898e66f7ece180df7/5b701ad441b6213cd2af64bf31d69ed1.png\" alt></p>\n<h2 id=\"关于计算\"><a href=\"#关于计算\" class=\"headerlink\" title=\"关于计算\"></a>关于计算</h2><p><strong>可以直接做逻辑运算。</strong></p>\n<pre><code>num = np.array([0,1,2,1,0,1,0])\nnum == 1</code></pre><pre><code>array([False,  True, False,  True, False,  True, False])</code></pre><p><strong>可以直接做算数运算</strong></p>\n<pre><code>num = np.array([0,1,2,1,0,1,0])\nnum*2</code></pre><pre><code>array([0, 2, 4, 2, 0, 2, 0])</code></pre><h2 id=\"条件选择数据\"><a href=\"#条件选择数据\" class=\"headerlink\" title=\"条件选择数据\"></a>条件选择数据</h2><p><strong>先获取索引，通过where函数</strong></p>\n<pre><code>num = np.array([0,1,2,1,0,1,0])\n\nnp.where(num == 1)</code></pre><pre><code>(array([1, 3, 5]),)</code></pre><p><strong>然后可以通过index，筛选数据</strong></p>\n<pre><code>num = np.array([0,1,2,1,0,1,0])\n\nindex = np.where(num == 1)\nindex, num[index]\n\nout:\n((array([1, 3, 5]),), array([1, 1, 1]))</code></pre><h2 id=\"关于随机选择数据\"><a href=\"#关于随机选择数据\" class=\"headerlink\" title=\"关于随机选择数据\"></a>关于随机选择数据</h2><p><strong>同上，只不过把index的获取变成随机。</strong></p>\n<pre><code>import random\ndef getRandomIndex(n, x):\n    # 索引范围为[0, n), 随机选x个不重复\n    index = random.sample(range(n), x)\n    return index</code></pre><h2 id=\"将数据打乱\"><a href=\"#将数据打乱\" class=\"headerlink\" title=\"将数据打乱\"></a>将数据打乱</h2><p><strong>同样也可以用index，因为index可以打算顺序。所以可以用这张方式来讲数据打乱</strong></p>\n<h1 id=\"pytorch\"><a href=\"#pytorch\" class=\"headerlink\" title=\"pytorch\"></a>pytorch</h1><h2 id=\"Pytorch之permute函数，-变换维度的重要函数\"><a href=\"#Pytorch之permute函数，-变换维度的重要函数\" class=\"headerlink\" title=\"Pytorch之permute函数， 变换维度的重要函数\"></a>Pytorch之permute函数， 变换维度的重要函数</h2><p>在lstm中，我们的数据通常是，batch， seq， dim。</p>\n<p>但是要求输入却是：seq， batch， dim</p>\n<p>所以需要做数据变换，但是传统的reshape，和view并不能改变数据的底层排列顺序。</p>\n<p>这种时候就需要用到permute函数。</p>\n<p><strong>Tensor.permute(a,b,c,d, …)</strong>：permute函数可以对任意高维矩阵进行转置，但没有 torch.permute() 这个调用方式， 只能 Tensor.permute()：</p>\n<p>（abcd）是index，<strong>个人可以理解为改变检索方式</strong></p>\n<pre><code>a = tensor[a][b][c]\nb = a.permute(2,1,0)\n那么相当于吧检索的顺序改变一下。\n也就是说会有：\na[A][B][C] = b[C][A][B]</code></pre><pre><code>import torch\nimport numpy as np\n\na=np.array([[[1,2,3],[4,5,6]]])\nunpermuted=torch.tensor(a)\nprint(unpermuted.size())              #  ——&gt;  torch.Size([1, 2, 3])\n\npermuted=unpermuted.permute(2,0,1)\nprint(permuted.size())                #  ——&gt;  torch.Size([3, 1, 2])\n\nview_test = unpermuted.view(1,3,2)\nprint(view_test.size())    </code></pre><h2 id=\"乘法\"><a href=\"#乘法\" class=\"headerlink\" title=\"乘法\"></a>乘法</h2><p><strong>Torch.mm(): 对两个二维矩阵做矩阵的乘法</strong></p>\n<pre><code>torch.mm(a, b)</code></pre><p><strong>Torch.matmul():输入可以是高维的。</strong><br>当输入是都是二维时，就是普通的矩阵乘法，和tensor.mm函数用法相同。</p>\n<p><strong>当输入有多维时，把多出的一维作为batch提出来，其他部分做矩阵乘法。</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/1b1d9635de88de5898e66f7ece180df7/75c072e2f13b0e0356763b3de5b63655.png\" alt=\"image-20220810220646801\"></p>\n<p>或者都是3维的</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/1b1d9635de88de5898e66f7ece180df7/0a86bcca07904caa6e37e1c491bd0bea.png\" alt=\"image-20220810220708808\"></p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"pandas\"><a href=\"#pandas\" class=\"headerlink\" title=\"pandas\"></a>pandas</h1><h2 id=\"行列\"><a href=\"#行列\" class=\"headerlink\" title=\"行列\"></a>行列</h2><pre><code># 获取某一列\ndata[&#39;key&#39;]\n\n# 获取多列\ndata[[&#39;key1&#39;, &#39;key2&#39;]]\n\n</code></pre><h2 id=\"数据条件筛选\"><a href=\"#数据条件筛选\" class=\"headerlink\" title=\"数据条件筛选\"></a>数据条件筛选</h2><p><strong>通过[]进行基本的行筛选</strong></p>\n<pre><code># 筛选出key属性等于1的所有行，也可以用&gt;,&lt; 以及用&amp;等逻辑组合\ndata[data[&#39;key&#39;] == 1]\n\n# 筛选出前100行\ndata[0:100]</code></pre><p><strong>通过loc以及iloc进行行以及列的筛选</strong></p>\n<ul>\n<li>loc按标签值（列名和行索引取值）访问，</li>\n<li>iloc按数字索引访问</li>\n</ul>\n<p><strong>首先loc</strong></p>\n<pre><code># 基本[]支持的loc也都支持\ndata.loc[data[&#39;key&#39;] == 1]\n\n# 同时还支持列的筛选, 列用：同样可以视作全选\ndata.loc[0:100, [&#39;key1&#39;, &#39;key2&#39;]]</code></pre><p><strong>然后iloc</strong></p>\n<pre><code># 筛选出前100行，前1,2列\ndata.iloc[0:100, [0,1]]</code></pre><p><strong>关于字符串匹配value</strong></p>\n<pre><code># 下面利用titanic的数据举例，筛选出人名中包含Mrs或者Lily的数据，|或逻辑符号在引号内。\ntrain.loc[train[&#39;Name&#39;].str.contains(&#39;Mrs|Lily&#39;),:].head()</code></pre><ul>\n<li>case=True：使用case指定区分大小写</li>\n<li><strong>na=True：就表示把有NAN的转换为布尔值True</strong></li>\n<li>flags=re.IGNORECASE：标志传递到re模块，例如re.IGNORECASE</li>\n<li>regex=True：regex ：如果为True，则假定第一个字符串是正则表达式，否则还是字符串</li>\n</ul>\n<h2 id=\"逐行进行遍历\"><a href=\"#逐行进行遍历\" class=\"headerlink\" title=\"逐行进行遍历\"></a>逐行进行遍历</h2><pre><code># values 是负责把值取出来\nfor row in CRAN_data.iterrows():\n    print(row[1].values)</code></pre><h2 id=\"查看某一列的特征：平均值，count统计，max，min，std方差\"><a href=\"#查看某一列的特征：平均值，count统计，max，min，std方差\" class=\"headerlink\" title=\"查看某一列的特征：平均值，count统计，max，min，std方差\"></a>查看某一列的特征：平均值，count统计，max，min，std方差</h2><pre><code>data_projects[&quot;Platform&quot;].unique() # 查看共有多少中可能的取值\ndata_projects[&quot;Platform&quot;].value_counts() # 同个各个离散变量的个数\ndata_projects[&quot;Platform&quot;].min()\n# 以及mean(), max(),</code></pre><p><strong>dataF.describe()</strong>可以一次性查看表的各项属性的特征</p>\n<h1 id=\"numpy\"><a href=\"#numpy\" class=\"headerlink\" title=\"numpy\"></a>numpy</h1><h2 id=\"关于reshape\"><a href=\"#关于reshape\" class=\"headerlink\" title=\"关于reshape\"></a>关于reshape</h2><p>快速改变向量的shape。但是并不会改变原始的顺序。</p>\n<p><strong>也就说说，如果按照从里到外的遍历顺序，那么无论怎么reshape的顺序是不会变的。</strong></p>\n<p>初期数据及库准备：</p>\n<p>import numpy as np  # 调用numpy库<br><strong>设置一个1-18的列表</strong></p>\n<pre><code>anchors = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]\n#将anchors由列表转换为数组的形式\nanchors = np.array(anchors)\n\n一维reshape() 为 二维\n18个元素一维度数组，可以转换为2 x 9 及 3 X 6的二维数组\n\nprint(anchors.reshape([3,6]))  # 生成一个（3，6）的二维数组\n\nprint(anchors.reshape([2,9]))  # 生成一个（2，9）的二维数组</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/1b1d9635de88de5898e66f7ece180df7/51e8b0ed3aa99934f470914a4a5890dd.png\" alt=\"3，6的输出结果\"></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/1b1d9635de88de5898e66f7ece180df7/5b701ad441b6213cd2af64bf31d69ed1.png\" alt></p>\n<h2 id=\"关于计算\"><a href=\"#关于计算\" class=\"headerlink\" title=\"关于计算\"></a>关于计算</h2><p><strong>可以直接做逻辑运算。</strong></p>\n<pre><code>num = np.array([0,1,2,1,0,1,0])\nnum == 1</code></pre><pre><code>array([False,  True, False,  True, False,  True, False])</code></pre><p><strong>可以直接做算数运算</strong></p>\n<pre><code>num = np.array([0,1,2,1,0,1,0])\nnum*2</code></pre><pre><code>array([0, 2, 4, 2, 0, 2, 0])</code></pre><h2 id=\"条件选择数据\"><a href=\"#条件选择数据\" class=\"headerlink\" title=\"条件选择数据\"></a>条件选择数据</h2><p><strong>先获取索引，通过where函数</strong></p>\n<pre><code>num = np.array([0,1,2,1,0,1,0])\n\nnp.where(num == 1)</code></pre><pre><code>(array([1, 3, 5]),)</code></pre><p><strong>然后可以通过index，筛选数据</strong></p>\n<pre><code>num = np.array([0,1,2,1,0,1,0])\n\nindex = np.where(num == 1)\nindex, num[index]\n\nout:\n((array([1, 3, 5]),), array([1, 1, 1]))</code></pre><h2 id=\"关于随机选择数据\"><a href=\"#关于随机选择数据\" class=\"headerlink\" title=\"关于随机选择数据\"></a>关于随机选择数据</h2><p><strong>同上，只不过把index的获取变成随机。</strong></p>\n<pre><code>import random\ndef getRandomIndex(n, x):\n    # 索引范围为[0, n), 随机选x个不重复\n    index = random.sample(range(n), x)\n    return index</code></pre><h2 id=\"将数据打乱\"><a href=\"#将数据打乱\" class=\"headerlink\" title=\"将数据打乱\"></a>将数据打乱</h2><p><strong>同样也可以用index，因为index可以打算顺序。所以可以用这张方式来讲数据打乱</strong></p>\n<h1 id=\"pytorch\"><a href=\"#pytorch\" class=\"headerlink\" title=\"pytorch\"></a>pytorch</h1><h2 id=\"Pytorch之permute函数，-变换维度的重要函数\"><a href=\"#Pytorch之permute函数，-变换维度的重要函数\" class=\"headerlink\" title=\"Pytorch之permute函数， 变换维度的重要函数\"></a>Pytorch之permute函数， 变换维度的重要函数</h2><p>在lstm中，我们的数据通常是，batch， seq， dim。</p>\n<p>但是要求输入却是：seq， batch， dim</p>\n<p>所以需要做数据变换，但是传统的reshape，和view并不能改变数据的底层排列顺序。</p>\n<p>这种时候就需要用到permute函数。</p>\n<p><strong>Tensor.permute(a,b,c,d, …)</strong>：permute函数可以对任意高维矩阵进行转置，但没有 torch.permute() 这个调用方式， 只能 Tensor.permute()：</p>\n<p>（abcd）是index，<strong>个人可以理解为改变检索方式</strong></p>\n<pre><code>a = tensor[a][b][c]\nb = a.permute(2,1,0)\n那么相当于吧检索的顺序改变一下。\n也就是说会有：\na[A][B][C] = b[C][A][B]</code></pre><pre><code>import torch\nimport numpy as np\n\na=np.array([[[1,2,3],[4,5,6]]])\nunpermuted=torch.tensor(a)\nprint(unpermuted.size())              #  ——&gt;  torch.Size([1, 2, 3])\n\npermuted=unpermuted.permute(2,0,1)\nprint(permuted.size())                #  ——&gt;  torch.Size([3, 1, 2])\n\nview_test = unpermuted.view(1,3,2)\nprint(view_test.size())    </code></pre><h2 id=\"乘法\"><a href=\"#乘法\" class=\"headerlink\" title=\"乘法\"></a>乘法</h2><p><strong>Torch.mm(): 对两个二维矩阵做矩阵的乘法</strong></p>\n<pre><code>torch.mm(a, b)</code></pre><p><strong>Torch.matmul():输入可以是高维的。</strong><br>当输入是都是二维时，就是普通的矩阵乘法，和tensor.mm函数用法相同。</p>\n<p><strong>当输入有多维时，把多出的一维作为batch提出来，其他部分做矩阵乘法。</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/1b1d9635de88de5898e66f7ece180df7/75c072e2f13b0e0356763b3de5b63655.png\" alt=\"image-20220810220646801\"></p>\n<p>或者都是3维的</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/1b1d9635de88de5898e66f7ece180df7/0a86bcca07904caa6e37e1c491bd0bea.png\" alt=\"image-20220810220708808\"></p>\n"},{"_content":"# openwrt docker\n\n## 提要\n\n我这里只有一台linux主机，单网口，一台路由器（但是不可以科学）。\n\n需要让所有流量都走linux里面的openwrt接口。（实现各种操作）\n\n\n\n## 正文\n\n我的路由器网关192.168.0.1。子网掩码24位\n\n\n\n\n\n**eth0是网卡名，根据具体情况更改配置**\n\n```\n# 开启混杂模式\nip link set  eth0 promisc on\n\ndocker network create -d macvlan --subnet=192.168.0.0/24 --gateway=192.168.0.1 -o parent=eth0 macnet\n```\n\n我的linux网络本机ip是：192.168.0.208\n\n\n\nopenwrt要设置为一个与本机ip不同的，且在同一个网段的\n\n```\ndocker run -d \\\n--restart always \\\n--network macnet \\\n--privileged \\\n--name openwrt_lwl \\\nsulinggg/openwrt:x86_64 /sbin/init\n```\n\n**容器版本得与本机一致。**\n\n## 容器内部配置\n\n\n\nOpenwrt容器内配置\n\n```\nvim /etc/config/network \n```\n\n具体的配置\n\n```\nconfig interface 'loopback'\n        option ifname 'lo'\n        option proto 'static'\n        option ipaddr '127.0.0.1'\n        option netmask '255.0.0.0'\n\nconfig globals 'globals'\n        option packet_steering '1'\n\nconfig interface 'lan'\n        option type 'bridge'\n        option ifname 'eth0'\n        option proto 'static'\n        option netmask '255.255.255.0'\n        option ip6assign '60'\n        option ipaddr '192.168.0.2'\n        option gateway '192.168.0.1'\n        option dns '8.8.8.8'\n\nconfig interface 'vpn0'\n        option ifname 'tun0'\n        option proto 'none'\n```\n\n\n\n\n\n重启网络\n\n```\n/etc/init.d/network restart\n```\n\n\n\n\n\n然后就可以通过192.168.0.2访问openwrt了。\n\n![image-20221113144733240](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/abc4bfe03679e22fabb51b8e9fb21bf4/76cf55cc1affeae22ac0fed3004002e5.png)\n\n\n\n\n\n## 配置科学以及一些配置\n\n做这个之前，先检查openwrt的网络是否通畅，我之前因为dns配置错了，导致一直没搞定。\n\n\n\n就是clash，ssr\n\n\n\n\n\n\n\n\n\n## 设置主路由的dhcp\n\n让连接主路由的设备默认走旁路由网关\n\n![image-20221113144137125](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/abc4bfe03679e22fabb51b8e9fb21bf4/8557371175b5879904b17864fb35bbe4.png)","source":"_posts/代理/openwrt docker旁路由.md","raw":"# openwrt docker\n\n## 提要\n\n我这里只有一台linux主机，单网口，一台路由器（但是不可以科学）。\n\n需要让所有流量都走linux里面的openwrt接口。（实现各种操作）\n\n\n\n## 正文\n\n我的路由器网关192.168.0.1。子网掩码24位\n\n\n\n\n\n**eth0是网卡名，根据具体情况更改配置**\n\n```\n# 开启混杂模式\nip link set  eth0 promisc on\n\ndocker network create -d macvlan --subnet=192.168.0.0/24 --gateway=192.168.0.1 -o parent=eth0 macnet\n```\n\n我的linux网络本机ip是：192.168.0.208\n\n\n\nopenwrt要设置为一个与本机ip不同的，且在同一个网段的\n\n```\ndocker run -d \\\n--restart always \\\n--network macnet \\\n--privileged \\\n--name openwrt_lwl \\\nsulinggg/openwrt:x86_64 /sbin/init\n```\n\n**容器版本得与本机一致。**\n\n## 容器内部配置\n\n\n\nOpenwrt容器内配置\n\n```\nvim /etc/config/network \n```\n\n具体的配置\n\n```\nconfig interface 'loopback'\n        option ifname 'lo'\n        option proto 'static'\n        option ipaddr '127.0.0.1'\n        option netmask '255.0.0.0'\n\nconfig globals 'globals'\n        option packet_steering '1'\n\nconfig interface 'lan'\n        option type 'bridge'\n        option ifname 'eth0'\n        option proto 'static'\n        option netmask '255.255.255.0'\n        option ip6assign '60'\n        option ipaddr '192.168.0.2'\n        option gateway '192.168.0.1'\n        option dns '8.8.8.8'\n\nconfig interface 'vpn0'\n        option ifname 'tun0'\n        option proto 'none'\n```\n\n\n\n\n\n重启网络\n\n```\n/etc/init.d/network restart\n```\n\n\n\n\n\n然后就可以通过192.168.0.2访问openwrt了。\n\n![image-20221113144733240](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/abc4bfe03679e22fabb51b8e9fb21bf4/76cf55cc1affeae22ac0fed3004002e5.png)\n\n\n\n\n\n## 配置科学以及一些配置\n\n做这个之前，先检查openwrt的网络是否通畅，我之前因为dns配置错了，导致一直没搞定。\n\n\n\n就是clash，ssr\n\n\n\n\n\n\n\n\n\n## 设置主路由的dhcp\n\n让连接主路由的设备默认走旁路由网关\n\n![image-20221113144137125](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/abc4bfe03679e22fabb51b8e9fb21bf4/8557371175b5879904b17864fb35bbe4.png)","slug":"代理/openwrt docker旁路由","published":1,"date":"2023-02-27T11:33:23.574Z","updated":"2023-02-27T11:34:33.133Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsybw000p0gcnmpan8qgl","content":"<h1 id=\"openwrt-docker\"><a href=\"#openwrt-docker\" class=\"headerlink\" title=\"openwrt docker\"></a>openwrt docker</h1><h2 id=\"提要\"><a href=\"#提要\" class=\"headerlink\" title=\"提要\"></a>提要</h2><p>我这里只有一台linux主机，单网口，一台路由器（但是不可以科学）。</p>\n<p>需要让所有流量都走linux里面的openwrt接口。（实现各种操作）</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>我的路由器网关192.168.0.1。子网掩码24位</p>\n<p><strong>eth0是网卡名，根据具体情况更改配置</strong></p>\n<pre><code># 开启混杂模式\nip link set  eth0 promisc on\n\ndocker network create -d macvlan --subnet=192.168.0.0/24 --gateway=192.168.0.1 -o parent=eth0 macnet</code></pre><p>我的linux网络本机ip是：192.168.0.208</p>\n<p>openwrt要设置为一个与本机ip不同的，且在同一个网段的</p>\n<pre><code>docker run -d \\\n--restart always \\\n--network macnet \\\n--privileged \\\n--name openwrt_lwl \\\nsulinggg/openwrt:x86_64 /sbin/init</code></pre><p><strong>容器版本得与本机一致。</strong></p>\n<h2 id=\"容器内部配置\"><a href=\"#容器内部配置\" class=\"headerlink\" title=\"容器内部配置\"></a>容器内部配置</h2><p>Openwrt容器内配置</p>\n<pre><code>vim /etc/config/network </code></pre><p>具体的配置</p>\n<pre><code>config interface &#39;loopback&#39;\n        option ifname &#39;lo&#39;\n        option proto &#39;static&#39;\n        option ipaddr &#39;127.0.0.1&#39;\n        option netmask &#39;255.0.0.0&#39;\n\nconfig globals &#39;globals&#39;\n        option packet_steering &#39;1&#39;\n\nconfig interface &#39;lan&#39;\n        option type &#39;bridge&#39;\n        option ifname &#39;eth0&#39;\n        option proto &#39;static&#39;\n        option netmask &#39;255.255.255.0&#39;\n        option ip6assign &#39;60&#39;\n        option ipaddr &#39;192.168.0.2&#39;\n        option gateway &#39;192.168.0.1&#39;\n        option dns &#39;8.8.8.8&#39;\n\nconfig interface &#39;vpn0&#39;\n        option ifname &#39;tun0&#39;\n        option proto &#39;none&#39;</code></pre><p>重启网络</p>\n<pre><code>/etc/init.d/network restart</code></pre><p>然后就可以通过192.168.0.2访问openwrt了。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/abc4bfe03679e22fabb51b8e9fb21bf4/76cf55cc1affeae22ac0fed3004002e5.png\" alt=\"image-20221113144733240\"></p>\n<h2 id=\"配置科学以及一些配置\"><a href=\"#配置科学以及一些配置\" class=\"headerlink\" title=\"配置科学以及一些配置\"></a>配置科学以及一些配置</h2><p>做这个之前，先检查openwrt的网络是否通畅，我之前因为dns配置错了，导致一直没搞定。</p>\n<p>就是clash，ssr</p>\n<h2 id=\"设置主路由的dhcp\"><a href=\"#设置主路由的dhcp\" class=\"headerlink\" title=\"设置主路由的dhcp\"></a>设置主路由的dhcp</h2><p>让连接主路由的设备默认走旁路由网关</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/abc4bfe03679e22fabb51b8e9fb21bf4/8557371175b5879904b17864fb35bbe4.png\" alt=\"image-20221113144137125\"></p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"openwrt-docker\"><a href=\"#openwrt-docker\" class=\"headerlink\" title=\"openwrt docker\"></a>openwrt docker</h1><h2 id=\"提要\"><a href=\"#提要\" class=\"headerlink\" title=\"提要\"></a>提要</h2><p>我这里只有一台linux主机，单网口，一台路由器（但是不可以科学）。</p>\n<p>需要让所有流量都走linux里面的openwrt接口。（实现各种操作）</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>我的路由器网关192.168.0.1。子网掩码24位</p>\n<p><strong>eth0是网卡名，根据具体情况更改配置</strong></p>\n<pre><code># 开启混杂模式\nip link set  eth0 promisc on\n\ndocker network create -d macvlan --subnet=192.168.0.0/24 --gateway=192.168.0.1 -o parent=eth0 macnet</code></pre><p>我的linux网络本机ip是：192.168.0.208</p>\n<p>openwrt要设置为一个与本机ip不同的，且在同一个网段的</p>\n<pre><code>docker run -d \\\n--restart always \\\n--network macnet \\\n--privileged \\\n--name openwrt_lwl \\\nsulinggg/openwrt:x86_64 /sbin/init</code></pre><p><strong>容器版本得与本机一致。</strong></p>\n<h2 id=\"容器内部配置\"><a href=\"#容器内部配置\" class=\"headerlink\" title=\"容器内部配置\"></a>容器内部配置</h2><p>Openwrt容器内配置</p>\n<pre><code>vim /etc/config/network </code></pre><p>具体的配置</p>\n<pre><code>config interface &#39;loopback&#39;\n        option ifname &#39;lo&#39;\n        option proto &#39;static&#39;\n        option ipaddr &#39;127.0.0.1&#39;\n        option netmask &#39;255.0.0.0&#39;\n\nconfig globals &#39;globals&#39;\n        option packet_steering &#39;1&#39;\n\nconfig interface &#39;lan&#39;\n        option type &#39;bridge&#39;\n        option ifname &#39;eth0&#39;\n        option proto &#39;static&#39;\n        option netmask &#39;255.255.255.0&#39;\n        option ip6assign &#39;60&#39;\n        option ipaddr &#39;192.168.0.2&#39;\n        option gateway &#39;192.168.0.1&#39;\n        option dns &#39;8.8.8.8&#39;\n\nconfig interface &#39;vpn0&#39;\n        option ifname &#39;tun0&#39;\n        option proto &#39;none&#39;</code></pre><p>重启网络</p>\n<pre><code>/etc/init.d/network restart</code></pre><p>然后就可以通过192.168.0.2访问openwrt了。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/abc4bfe03679e22fabb51b8e9fb21bf4/76cf55cc1affeae22ac0fed3004002e5.png\" alt=\"image-20221113144733240\"></p>\n<h2 id=\"配置科学以及一些配置\"><a href=\"#配置科学以及一些配置\" class=\"headerlink\" title=\"配置科学以及一些配置\"></a>配置科学以及一些配置</h2><p>做这个之前，先检查openwrt的网络是否通畅，我之前因为dns配置错了，导致一直没搞定。</p>\n<p>就是clash，ssr</p>\n<h2 id=\"设置主路由的dhcp\"><a href=\"#设置主路由的dhcp\" class=\"headerlink\" title=\"设置主路由的dhcp\"></a>设置主路由的dhcp</h2><p>让连接主路由的设备默认走旁路由网关</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/abc4bfe03679e22fabb51b8e9fb21bf4/8557371175b5879904b17864fb35bbe4.png\" alt=\"image-20221113144137125\"></p>\n"},{"_content":"# 代理与V2ray\n\n参考：\n\n[反向代理官方v2ray]( https://toutyrater.github.io/app/reverse.html)\n\n## 正向代理\n\n正向代理，实际上就是**翻墙的原理**\n\n一般设置一个代理服务器，通过这个代理服务器去访问你想访问的网站，代理服务器就是客户端和目标服务器之间的跳板，代理服务器接收客户端的请求并发送到目标服务器，同时接收目标服务器的应答结果并返回给客户端，起到一个中介的作用。这就是所谓的正向代理。\n\n**代理的是客户端**\n\n使用v2ray配置，\n\n**服务端：**\n\n```\n{\n\n\"log\": {\n\n\"access\": \"/var/log/v2ray/access.log\",\n\n\"error\": \"/var/log/v2ray/error.log\",\n\n\"loglevel\": \"warning\"\n\n},\n\n\"inbounds\": [\n\n{\n\n\"port\": 6688,   # 服务器端的用于接受客户端的接口\n\n\"protocol\": \"vmess\",\n\n\"settings\": {\n\n\"clients\": [\n\n{\n\n\"id\": \"8c042a38-71c1-1dcb-00df-54880236e0dc\" # 客户端也要有这个id。\n\n}\n\n]\n\n}\n\n}\n\n],\n\n\"outbounds\": [\n\n{\n\n\"protocol\": \"freedom\"\n\n}\n\n]\n\n}\n```\n\n客户端配置\n\n![image-20220508111037368](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/8cb3d7627a138d3e74c02045c2347434/c6d740bf302d115132551cefdf25eeaa.png)\n\n\n\n**注意：**\n\n客户端和服务端时间要尽量保持一致\n\n\n\n\n\n\n\n## 反向代理\n\n反向代理是代理服务器，具体上是位于 Web 服务器前面的服务器，其将客户端（例如 Web 浏览器）请求转发到这些 Web 服务器。\n\n比如如果我们客户端A要访问服务器C，不能直接访问，那么可以引入代理服务器B，让B去代理C，我们访问B就相当于访问C。\n\n反向代理用于：\n\n- 服务器负载均衡\n- 防范服务器攻击\n- 缓存\n- 加密\n- 内网穿透\n\n\n\n\n\n**和正向代理不同的是：**\n\n反向的代理代理的是服务器，所有服务器端的请求都可以走代理服务器\n\n正向代理是代理的客户端，所有客户端都可以走代理服务器\n\n![image-20220508112316782](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/8cb3d7627a138d3e74c02045c2347434/daa5afb33830ea1b0187d19056218a38.png)\n\n\n\n### 服务器内网穿透\n\n客户端\n\n```\n{  \n  \"reverse\":{ \n    // 这是 A 的反向代理设置，必须有下面的 bridges 对象\n    \"bridges\":[  \n      {  \n        \"tag\":\"bridge\", // 关于 A 的反向代理标签，在路由中会用到\n        \"domain\":\"private.cloud.com\" // A 和 B 反向代理通信的域名，可以自己取一个，可以不是自己购买的域名，但必须跟下面 B 中的 reverse 配置的域名一致\n      }\n    ]\n  },\n  \"outbounds\": [\n    {  \n      //A连接B的outbound  \n      \"tag\":\"tunnel\", // A 连接 B 的 outbound 的标签，在路由中会用到\n      \"protocol\":\"vmess\",\n      \"settings\":{  \n        \"vnext\":[  \n          {  \n            \"address\":\"110.40.204.239\", // B 地址，IP 或 实际的域名\n            \"port\":6688,\n            \"users\":[  \n              {  \n                \"id\":\"b831381d-6324-4d53-ad4f-8cda48b30811\",\n                \"alterId\":0\n              }\n            ]\n          }\n        ]\n      }\n    },\n    // 另一个 outbound，最终连接本地的内网的服务 \n    {  \n      \"protocol\":\"freedom\",\n      \"settings\":{  \n      },\n      \"tag\":\"out\"\n    }    \n  ],\n  \"routing\":{   \n    \"rules\":[  \n      {  \n        // 配置 A 主动连接 B 的路由规则\n        \"type\":\"field\",\n        \"inboundTag\":[  \n          \"bridge\"\n        ],\n        \"domain\":[  \n          \"full:private.cloud.com\"\n        ],\n        \"outboundTag\":\"tunnel\"\n      },\n      {  \n        // 反向连接访问内网的规则\n        \"type\":\"field\",\n        \"inboundTag\":[  \n          \"bridge\"\n        ],\n        \"outboundTag\":\"out\"\n      }\n    ]\n  }\n}\n```\n\n服务器\n\n```\n{  \n  \"reverse\":{  //这是 B 的反向代理设置，必须有下面的 portals 对象\n    \"portals\":[  \n      {  \n        \"tag\":\"portal\",\n        \"domain\":\"private.cloud.com\"        // 必须和上面 A 设定的域名一样，可以是虚拟的\n      }\n    ]\n  },\n  \"inbounds\": [\n    {  \n      // 接受 C 的inbound\n      \"tag\":\"external\", // 标签，路由中用到\n      \"port\":80,\n      // 开放 80 端口，用于接收外部的 HTTP 访问 \n      \"protocol\":\"dokodemo-door\",\n        \"settings\":{  \n          \"address\":\"127.0.0.1\",\n          \"port\":80, //假设 NAS 监听的端口为 80\n          \"network\":\"tcp\"\n        }\n    },\n    // 另一个 inbound，接受客户端主动发起的请求  \n    {  \n      \"tag\": \"tunnel\",// 标签，路由中用到\n      \"port\":6688, //用于连接客户端的端口\n      \"protocol\":\"vmess\",\n      \"settings\":{  \n        \"clients\":[  \n          {  \n            \"id\":\"b831381d-6324-4d53-ad4f-8cda48b30811\",\n            \"alterId\":0\n          }\n        ]\n      }\n    }\n  ],\n  \"routing\":{  \n    \"rules\":[  \n      {  //路由规则，接收 C 请求后发给 A\n        \"type\":\"field\",\n        \"inboundTag\":[  \n          \"external\"\n        ],\n        \"outboundTag\":\"portal\"\n      },\n      {  //路由规则，让 B 能够识别这是 A 主动发起的反向代理连接\n        \"type\":\"field\",\n        \"inboundTag\":[  \n          \"tunnel\"\n        ],\n        \"domain\":[  \n          \"full:private.cloud.com\"\n        ],\n        \"outboundTag\":\"portal\"\n      }\n    ]\n  }\n}\n```\n\n\n\n最后可以通过 **服务器ip：80**访问\n\n\n\n## 多级代理提高溯源难度\n\n如果就一台服务器，那么实际上通过查询那台服务器，可以找回到请求的原始ip。那么，可不可以在全球疯狂的绕几层服务器。大大提高服务器的溯源难度。\n\nv2ray就可以。v2ray可以实现链式转发。\n\n例如，如果有多个ssr账户，可以\n\n```\n{\n  \"outbounds\": [\n    {\n      \"protocol\": \"vmess\",\n      \"settings\": { // settings 的根据实际情况修改\n        \"vnext\": [\n          {\n            \"address\": \"1.1.1.1\",\n            \"port\": 8888,\n            \"users\": [\n              {\n                \"alterId\": 64,\n                \"id\": \"b12614c5-5ca4-4eba-a215-c61d642116ce\"\n              }\n            ]\n          }\n        ]\n      },\n      \"tag\": \"DOUS\",\n      \"proxySettings\": {\n          \"tag\": \"DOSG\"  \n        }\n    },\n    {\n      \"protocol\": \"shadowsocks\",\n      \"settings\": {\n        \"servers\": [\n          {\n            \"address\": \"2.2.2.2\",\n            \"method\": \"aes-256-cfb\",\n            \"ota\": false,\n            \"password\": \"password\",\n            \"port\": 1024\n          }\n        ]\n      },\n      \"tag\": \"AliHK\"\n    },\n    {\n      \"protocol\": \"shadowsocks\",\n      \"settings\": {\n        \"servers\": [\n          {\n            \"address\": \"3.3.3.3\",\n            \"method\": \"aes-256-cfb\",\n            \"ota\": false,\n            \"password\": \"password\",\n            \"port\": 3442\n          }\n        ]\n      },\n      \"tag\": \"AliSG\",\n      \"proxySettings\": {\n          \"tag\": \"AliHK\"  \n      }\n    },\n    {\n      \"protocol\": \"vmess\",\n      \"settings\": {\n        \"vnext\": [\n          {\n            \"address\": \"4.4.4.4\",\n            \"port\": 8462,\n            \"users\": [\n              {\n                \"alterId\": 64,\n                \"id\": \"b27c24ab-2b5a-433e-902c-33f1168a7902\"\n              }\n            ]\n          }\n        ]\n      },\n      \"tag\": \"DOSG\",\n      \"proxySettings\": {\n          \"tag\": \"AliSG\"  \n      }\n    },\n  ]\n}\n```\n\n那么数据包经过的节点依次为： PC -> AliHK -> AliSG -> DOSG -> DOUS -> 目标网站\n\n这样的代理转发形成了一条链条，我称之为链式代理转发。\n\n","source":"_posts/代理/v2ray与代理，多级代理.md","raw":"# 代理与V2ray\n\n参考：\n\n[反向代理官方v2ray]( https://toutyrater.github.io/app/reverse.html)\n\n## 正向代理\n\n正向代理，实际上就是**翻墙的原理**\n\n一般设置一个代理服务器，通过这个代理服务器去访问你想访问的网站，代理服务器就是客户端和目标服务器之间的跳板，代理服务器接收客户端的请求并发送到目标服务器，同时接收目标服务器的应答结果并返回给客户端，起到一个中介的作用。这就是所谓的正向代理。\n\n**代理的是客户端**\n\n使用v2ray配置，\n\n**服务端：**\n\n```\n{\n\n\"log\": {\n\n\"access\": \"/var/log/v2ray/access.log\",\n\n\"error\": \"/var/log/v2ray/error.log\",\n\n\"loglevel\": \"warning\"\n\n},\n\n\"inbounds\": [\n\n{\n\n\"port\": 6688,   # 服务器端的用于接受客户端的接口\n\n\"protocol\": \"vmess\",\n\n\"settings\": {\n\n\"clients\": [\n\n{\n\n\"id\": \"8c042a38-71c1-1dcb-00df-54880236e0dc\" # 客户端也要有这个id。\n\n}\n\n]\n\n}\n\n}\n\n],\n\n\"outbounds\": [\n\n{\n\n\"protocol\": \"freedom\"\n\n}\n\n]\n\n}\n```\n\n客户端配置\n\n![image-20220508111037368](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/8cb3d7627a138d3e74c02045c2347434/c6d740bf302d115132551cefdf25eeaa.png)\n\n\n\n**注意：**\n\n客户端和服务端时间要尽量保持一致\n\n\n\n\n\n\n\n## 反向代理\n\n反向代理是代理服务器，具体上是位于 Web 服务器前面的服务器，其将客户端（例如 Web 浏览器）请求转发到这些 Web 服务器。\n\n比如如果我们客户端A要访问服务器C，不能直接访问，那么可以引入代理服务器B，让B去代理C，我们访问B就相当于访问C。\n\n反向代理用于：\n\n- 服务器负载均衡\n- 防范服务器攻击\n- 缓存\n- 加密\n- 内网穿透\n\n\n\n\n\n**和正向代理不同的是：**\n\n反向的代理代理的是服务器，所有服务器端的请求都可以走代理服务器\n\n正向代理是代理的客户端，所有客户端都可以走代理服务器\n\n![image-20220508112316782](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/8cb3d7627a138d3e74c02045c2347434/daa5afb33830ea1b0187d19056218a38.png)\n\n\n\n### 服务器内网穿透\n\n客户端\n\n```\n{  \n  \"reverse\":{ \n    // 这是 A 的反向代理设置，必须有下面的 bridges 对象\n    \"bridges\":[  \n      {  \n        \"tag\":\"bridge\", // 关于 A 的反向代理标签，在路由中会用到\n        \"domain\":\"private.cloud.com\" // A 和 B 反向代理通信的域名，可以自己取一个，可以不是自己购买的域名，但必须跟下面 B 中的 reverse 配置的域名一致\n      }\n    ]\n  },\n  \"outbounds\": [\n    {  \n      //A连接B的outbound  \n      \"tag\":\"tunnel\", // A 连接 B 的 outbound 的标签，在路由中会用到\n      \"protocol\":\"vmess\",\n      \"settings\":{  \n        \"vnext\":[  \n          {  \n            \"address\":\"110.40.204.239\", // B 地址，IP 或 实际的域名\n            \"port\":6688,\n            \"users\":[  \n              {  \n                \"id\":\"b831381d-6324-4d53-ad4f-8cda48b30811\",\n                \"alterId\":0\n              }\n            ]\n          }\n        ]\n      }\n    },\n    // 另一个 outbound，最终连接本地的内网的服务 \n    {  \n      \"protocol\":\"freedom\",\n      \"settings\":{  \n      },\n      \"tag\":\"out\"\n    }    \n  ],\n  \"routing\":{   \n    \"rules\":[  \n      {  \n        // 配置 A 主动连接 B 的路由规则\n        \"type\":\"field\",\n        \"inboundTag\":[  \n          \"bridge\"\n        ],\n        \"domain\":[  \n          \"full:private.cloud.com\"\n        ],\n        \"outboundTag\":\"tunnel\"\n      },\n      {  \n        // 反向连接访问内网的规则\n        \"type\":\"field\",\n        \"inboundTag\":[  \n          \"bridge\"\n        ],\n        \"outboundTag\":\"out\"\n      }\n    ]\n  }\n}\n```\n\n服务器\n\n```\n{  \n  \"reverse\":{  //这是 B 的反向代理设置，必须有下面的 portals 对象\n    \"portals\":[  \n      {  \n        \"tag\":\"portal\",\n        \"domain\":\"private.cloud.com\"        // 必须和上面 A 设定的域名一样，可以是虚拟的\n      }\n    ]\n  },\n  \"inbounds\": [\n    {  \n      // 接受 C 的inbound\n      \"tag\":\"external\", // 标签，路由中用到\n      \"port\":80,\n      // 开放 80 端口，用于接收外部的 HTTP 访问 \n      \"protocol\":\"dokodemo-door\",\n        \"settings\":{  \n          \"address\":\"127.0.0.1\",\n          \"port\":80, //假设 NAS 监听的端口为 80\n          \"network\":\"tcp\"\n        }\n    },\n    // 另一个 inbound，接受客户端主动发起的请求  \n    {  \n      \"tag\": \"tunnel\",// 标签，路由中用到\n      \"port\":6688, //用于连接客户端的端口\n      \"protocol\":\"vmess\",\n      \"settings\":{  \n        \"clients\":[  \n          {  \n            \"id\":\"b831381d-6324-4d53-ad4f-8cda48b30811\",\n            \"alterId\":0\n          }\n        ]\n      }\n    }\n  ],\n  \"routing\":{  \n    \"rules\":[  \n      {  //路由规则，接收 C 请求后发给 A\n        \"type\":\"field\",\n        \"inboundTag\":[  \n          \"external\"\n        ],\n        \"outboundTag\":\"portal\"\n      },\n      {  //路由规则，让 B 能够识别这是 A 主动发起的反向代理连接\n        \"type\":\"field\",\n        \"inboundTag\":[  \n          \"tunnel\"\n        ],\n        \"domain\":[  \n          \"full:private.cloud.com\"\n        ],\n        \"outboundTag\":\"portal\"\n      }\n    ]\n  }\n}\n```\n\n\n\n最后可以通过 **服务器ip：80**访问\n\n\n\n## 多级代理提高溯源难度\n\n如果就一台服务器，那么实际上通过查询那台服务器，可以找回到请求的原始ip。那么，可不可以在全球疯狂的绕几层服务器。大大提高服务器的溯源难度。\n\nv2ray就可以。v2ray可以实现链式转发。\n\n例如，如果有多个ssr账户，可以\n\n```\n{\n  \"outbounds\": [\n    {\n      \"protocol\": \"vmess\",\n      \"settings\": { // settings 的根据实际情况修改\n        \"vnext\": [\n          {\n            \"address\": \"1.1.1.1\",\n            \"port\": 8888,\n            \"users\": [\n              {\n                \"alterId\": 64,\n                \"id\": \"b12614c5-5ca4-4eba-a215-c61d642116ce\"\n              }\n            ]\n          }\n        ]\n      },\n      \"tag\": \"DOUS\",\n      \"proxySettings\": {\n          \"tag\": \"DOSG\"  \n        }\n    },\n    {\n      \"protocol\": \"shadowsocks\",\n      \"settings\": {\n        \"servers\": [\n          {\n            \"address\": \"2.2.2.2\",\n            \"method\": \"aes-256-cfb\",\n            \"ota\": false,\n            \"password\": \"password\",\n            \"port\": 1024\n          }\n        ]\n      },\n      \"tag\": \"AliHK\"\n    },\n    {\n      \"protocol\": \"shadowsocks\",\n      \"settings\": {\n        \"servers\": [\n          {\n            \"address\": \"3.3.3.3\",\n            \"method\": \"aes-256-cfb\",\n            \"ota\": false,\n            \"password\": \"password\",\n            \"port\": 3442\n          }\n        ]\n      },\n      \"tag\": \"AliSG\",\n      \"proxySettings\": {\n          \"tag\": \"AliHK\"  \n      }\n    },\n    {\n      \"protocol\": \"vmess\",\n      \"settings\": {\n        \"vnext\": [\n          {\n            \"address\": \"4.4.4.4\",\n            \"port\": 8462,\n            \"users\": [\n              {\n                \"alterId\": 64,\n                \"id\": \"b27c24ab-2b5a-433e-902c-33f1168a7902\"\n              }\n            ]\n          }\n        ]\n      },\n      \"tag\": \"DOSG\",\n      \"proxySettings\": {\n          \"tag\": \"AliSG\"  \n      }\n    },\n  ]\n}\n```\n\n那么数据包经过的节点依次为： PC -> AliHK -> AliSG -> DOSG -> DOUS -> 目标网站\n\n这样的代理转发形成了一条链条，我称之为链式代理转发。\n\n","slug":"代理/v2ray与代理，多级代理","published":1,"date":"2023-02-27T11:33:23.573Z","updated":"2023-02-27T11:34:33.133Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsybx000q0gcn28rkdbwh","content":"<h1 id=\"代理与V2ray\"><a href=\"#代理与V2ray\" class=\"headerlink\" title=\"代理与V2ray\"></a>代理与V2ray</h1><p>参考：</p>\n<p><a href=\"https://toutyrater.github.io/app/reverse.html\" target=\"_blank\" rel=\"noopener\">反向代理官方v2ray</a></p>\n<h2 id=\"正向代理\"><a href=\"#正向代理\" class=\"headerlink\" title=\"正向代理\"></a>正向代理</h2><p>正向代理，实际上就是<strong>翻墙的原理</strong></p>\n<p>一般设置一个代理服务器，通过这个代理服务器去访问你想访问的网站，代理服务器就是客户端和目标服务器之间的跳板，代理服务器接收客户端的请求并发送到目标服务器，同时接收目标服务器的应答结果并返回给客户端，起到一个中介的作用。这就是所谓的正向代理。</p>\n<p><strong>代理的是客户端</strong></p>\n<p>使用v2ray配置，</p>\n<p><strong>服务端：</strong></p>\n<pre><code>{\n\n&quot;log&quot;: {\n\n&quot;access&quot;: &quot;/var/log/v2ray/access.log&quot;,\n\n&quot;error&quot;: &quot;/var/log/v2ray/error.log&quot;,\n\n&quot;loglevel&quot;: &quot;warning&quot;\n\n},\n\n&quot;inbounds&quot;: [\n\n{\n\n&quot;port&quot;: 6688,   # 服务器端的用于接受客户端的接口\n\n&quot;protocol&quot;: &quot;vmess&quot;,\n\n&quot;settings&quot;: {\n\n&quot;clients&quot;: [\n\n{\n\n&quot;id&quot;: &quot;8c042a38-71c1-1dcb-00df-54880236e0dc&quot; # 客户端也要有这个id。\n\n}\n\n]\n\n}\n\n}\n\n],\n\n&quot;outbounds&quot;: [\n\n{\n\n&quot;protocol&quot;: &quot;freedom&quot;\n\n}\n\n]\n\n}</code></pre><p>客户端配置</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/8cb3d7627a138d3e74c02045c2347434/c6d740bf302d115132551cefdf25eeaa.png\" alt=\"image-20220508111037368\"></p>\n<p><strong>注意：</strong></p>\n<p>客户端和服务端时间要尽量保持一致</p>\n<h2 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h2><p>反向代理是代理服务器，具体上是位于 Web 服务器前面的服务器，其将客户端（例如 Web 浏览器）请求转发到这些 Web 服务器。</p>\n<p>比如如果我们客户端A要访问服务器C，不能直接访问，那么可以引入代理服务器B，让B去代理C，我们访问B就相当于访问C。</p>\n<p>反向代理用于：</p>\n<ul>\n<li>服务器负载均衡</li>\n<li>防范服务器攻击</li>\n<li>缓存</li>\n<li>加密</li>\n<li>内网穿透</li>\n</ul>\n<p><strong>和正向代理不同的是：</strong></p>\n<p>反向的代理代理的是服务器，所有服务器端的请求都可以走代理服务器</p>\n<p>正向代理是代理的客户端，所有客户端都可以走代理服务器</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/8cb3d7627a138d3e74c02045c2347434/daa5afb33830ea1b0187d19056218a38.png\" alt=\"image-20220508112316782\"></p>\n<h3 id=\"服务器内网穿透\"><a href=\"#服务器内网穿透\" class=\"headerlink\" title=\"服务器内网穿透\"></a>服务器内网穿透</h3><p>客户端</p>\n<pre><code>{  \n  &quot;reverse&quot;:{ \n    // 这是 A 的反向代理设置，必须有下面的 bridges 对象\n    &quot;bridges&quot;:[  \n      {  \n        &quot;tag&quot;:&quot;bridge&quot;, // 关于 A 的反向代理标签，在路由中会用到\n        &quot;domain&quot;:&quot;private.cloud.com&quot; // A 和 B 反向代理通信的域名，可以自己取一个，可以不是自己购买的域名，但必须跟下面 B 中的 reverse 配置的域名一致\n      }\n    ]\n  },\n  &quot;outbounds&quot;: [\n    {  \n      //A连接B的outbound  \n      &quot;tag&quot;:&quot;tunnel&quot;, // A 连接 B 的 outbound 的标签，在路由中会用到\n      &quot;protocol&quot;:&quot;vmess&quot;,\n      &quot;settings&quot;:{  \n        &quot;vnext&quot;:[  \n          {  \n            &quot;address&quot;:&quot;110.40.204.239&quot;, // B 地址，IP 或 实际的域名\n            &quot;port&quot;:6688,\n            &quot;users&quot;:[  \n              {  \n                &quot;id&quot;:&quot;b831381d-6324-4d53-ad4f-8cda48b30811&quot;,\n                &quot;alterId&quot;:0\n              }\n            ]\n          }\n        ]\n      }\n    },\n    // 另一个 outbound，最终连接本地的内网的服务 \n    {  \n      &quot;protocol&quot;:&quot;freedom&quot;,\n      &quot;settings&quot;:{  \n      },\n      &quot;tag&quot;:&quot;out&quot;\n    }    \n  ],\n  &quot;routing&quot;:{   \n    &quot;rules&quot;:[  \n      {  \n        // 配置 A 主动连接 B 的路由规则\n        &quot;type&quot;:&quot;field&quot;,\n        &quot;inboundTag&quot;:[  \n          &quot;bridge&quot;\n        ],\n        &quot;domain&quot;:[  \n          &quot;full:private.cloud.com&quot;\n        ],\n        &quot;outboundTag&quot;:&quot;tunnel&quot;\n      },\n      {  \n        // 反向连接访问内网的规则\n        &quot;type&quot;:&quot;field&quot;,\n        &quot;inboundTag&quot;:[  \n          &quot;bridge&quot;\n        ],\n        &quot;outboundTag&quot;:&quot;out&quot;\n      }\n    ]\n  }\n}</code></pre><p>服务器</p>\n<pre><code>{  \n  &quot;reverse&quot;:{  //这是 B 的反向代理设置，必须有下面的 portals 对象\n    &quot;portals&quot;:[  \n      {  \n        &quot;tag&quot;:&quot;portal&quot;,\n        &quot;domain&quot;:&quot;private.cloud.com&quot;        // 必须和上面 A 设定的域名一样，可以是虚拟的\n      }\n    ]\n  },\n  &quot;inbounds&quot;: [\n    {  \n      // 接受 C 的inbound\n      &quot;tag&quot;:&quot;external&quot;, // 标签，路由中用到\n      &quot;port&quot;:80,\n      // 开放 80 端口，用于接收外部的 HTTP 访问 \n      &quot;protocol&quot;:&quot;dokodemo-door&quot;,\n        &quot;settings&quot;:{  \n          &quot;address&quot;:&quot;127.0.0.1&quot;,\n          &quot;port&quot;:80, //假设 NAS 监听的端口为 80\n          &quot;network&quot;:&quot;tcp&quot;\n        }\n    },\n    // 另一个 inbound，接受客户端主动发起的请求  \n    {  \n      &quot;tag&quot;: &quot;tunnel&quot;,// 标签，路由中用到\n      &quot;port&quot;:6688, //用于连接客户端的端口\n      &quot;protocol&quot;:&quot;vmess&quot;,\n      &quot;settings&quot;:{  \n        &quot;clients&quot;:[  \n          {  \n            &quot;id&quot;:&quot;b831381d-6324-4d53-ad4f-8cda48b30811&quot;,\n            &quot;alterId&quot;:0\n          }\n        ]\n      }\n    }\n  ],\n  &quot;routing&quot;:{  \n    &quot;rules&quot;:[  \n      {  //路由规则，接收 C 请求后发给 A\n        &quot;type&quot;:&quot;field&quot;,\n        &quot;inboundTag&quot;:[  \n          &quot;external&quot;\n        ],\n        &quot;outboundTag&quot;:&quot;portal&quot;\n      },\n      {  //路由规则，让 B 能够识别这是 A 主动发起的反向代理连接\n        &quot;type&quot;:&quot;field&quot;,\n        &quot;inboundTag&quot;:[  \n          &quot;tunnel&quot;\n        ],\n        &quot;domain&quot;:[  \n          &quot;full:private.cloud.com&quot;\n        ],\n        &quot;outboundTag&quot;:&quot;portal&quot;\n      }\n    ]\n  }\n}</code></pre><p>最后可以通过 <strong>服务器ip：80</strong>访问</p>\n<h2 id=\"多级代理提高溯源难度\"><a href=\"#多级代理提高溯源难度\" class=\"headerlink\" title=\"多级代理提高溯源难度\"></a>多级代理提高溯源难度</h2><p>如果就一台服务器，那么实际上通过查询那台服务器，可以找回到请求的原始ip。那么，可不可以在全球疯狂的绕几层服务器。大大提高服务器的溯源难度。</p>\n<p>v2ray就可以。v2ray可以实现链式转发。</p>\n<p>例如，如果有多个ssr账户，可以</p>\n<pre><code>{\n  &quot;outbounds&quot;: [\n    {\n      &quot;protocol&quot;: &quot;vmess&quot;,\n      &quot;settings&quot;: { // settings 的根据实际情况修改\n        &quot;vnext&quot;: [\n          {\n            &quot;address&quot;: &quot;1.1.1.1&quot;,\n            &quot;port&quot;: 8888,\n            &quot;users&quot;: [\n              {\n                &quot;alterId&quot;: 64,\n                &quot;id&quot;: &quot;b12614c5-5ca4-4eba-a215-c61d642116ce&quot;\n              }\n            ]\n          }\n        ]\n      },\n      &quot;tag&quot;: &quot;DOUS&quot;,\n      &quot;proxySettings&quot;: {\n          &quot;tag&quot;: &quot;DOSG&quot;  \n        }\n    },\n    {\n      &quot;protocol&quot;: &quot;shadowsocks&quot;,\n      &quot;settings&quot;: {\n        &quot;servers&quot;: [\n          {\n            &quot;address&quot;: &quot;2.2.2.2&quot;,\n            &quot;method&quot;: &quot;aes-256-cfb&quot;,\n            &quot;ota&quot;: false,\n            &quot;password&quot;: &quot;password&quot;,\n            &quot;port&quot;: 1024\n          }\n        ]\n      },\n      &quot;tag&quot;: &quot;AliHK&quot;\n    },\n    {\n      &quot;protocol&quot;: &quot;shadowsocks&quot;,\n      &quot;settings&quot;: {\n        &quot;servers&quot;: [\n          {\n            &quot;address&quot;: &quot;3.3.3.3&quot;,\n            &quot;method&quot;: &quot;aes-256-cfb&quot;,\n            &quot;ota&quot;: false,\n            &quot;password&quot;: &quot;password&quot;,\n            &quot;port&quot;: 3442\n          }\n        ]\n      },\n      &quot;tag&quot;: &quot;AliSG&quot;,\n      &quot;proxySettings&quot;: {\n          &quot;tag&quot;: &quot;AliHK&quot;  \n      }\n    },\n    {\n      &quot;protocol&quot;: &quot;vmess&quot;,\n      &quot;settings&quot;: {\n        &quot;vnext&quot;: [\n          {\n            &quot;address&quot;: &quot;4.4.4.4&quot;,\n            &quot;port&quot;: 8462,\n            &quot;users&quot;: [\n              {\n                &quot;alterId&quot;: 64,\n                &quot;id&quot;: &quot;b27c24ab-2b5a-433e-902c-33f1168a7902&quot;\n              }\n            ]\n          }\n        ]\n      },\n      &quot;tag&quot;: &quot;DOSG&quot;,\n      &quot;proxySettings&quot;: {\n          &quot;tag&quot;: &quot;AliSG&quot;  \n      }\n    },\n  ]\n}</code></pre><p>那么数据包经过的节点依次为： PC -&gt; AliHK -&gt; AliSG -&gt; DOSG -&gt; DOUS -&gt; 目标网站</p>\n<p>这样的代理转发形成了一条链条，我称之为链式代理转发。</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"代理与V2ray\"><a href=\"#代理与V2ray\" class=\"headerlink\" title=\"代理与V2ray\"></a>代理与V2ray</h1><p>参考：</p>\n<p><a href=\"https://toutyrater.github.io/app/reverse.html\" target=\"_blank\" rel=\"noopener\">反向代理官方v2ray</a></p>\n<h2 id=\"正向代理\"><a href=\"#正向代理\" class=\"headerlink\" title=\"正向代理\"></a>正向代理</h2><p>正向代理，实际上就是<strong>翻墙的原理</strong></p>\n<p>一般设置一个代理服务器，通过这个代理服务器去访问你想访问的网站，代理服务器就是客户端和目标服务器之间的跳板，代理服务器接收客户端的请求并发送到目标服务器，同时接收目标服务器的应答结果并返回给客户端，起到一个中介的作用。这就是所谓的正向代理。</p>\n<p><strong>代理的是客户端</strong></p>\n<p>使用v2ray配置，</p>\n<p><strong>服务端：</strong></p>\n<pre><code>{\n\n&quot;log&quot;: {\n\n&quot;access&quot;: &quot;/var/log/v2ray/access.log&quot;,\n\n&quot;error&quot;: &quot;/var/log/v2ray/error.log&quot;,\n\n&quot;loglevel&quot;: &quot;warning&quot;\n\n},\n\n&quot;inbounds&quot;: [\n\n{\n\n&quot;port&quot;: 6688,   # 服务器端的用于接受客户端的接口\n\n&quot;protocol&quot;: &quot;vmess&quot;,\n\n&quot;settings&quot;: {\n\n&quot;clients&quot;: [\n\n{\n\n&quot;id&quot;: &quot;8c042a38-71c1-1dcb-00df-54880236e0dc&quot; # 客户端也要有这个id。\n\n}\n\n]\n\n}\n\n}\n\n],\n\n&quot;outbounds&quot;: [\n\n{\n\n&quot;protocol&quot;: &quot;freedom&quot;\n\n}\n\n]\n\n}</code></pre><p>客户端配置</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/8cb3d7627a138d3e74c02045c2347434/c6d740bf302d115132551cefdf25eeaa.png\" alt=\"image-20220508111037368\"></p>\n<p><strong>注意：</strong></p>\n<p>客户端和服务端时间要尽量保持一致</p>\n<h2 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h2><p>反向代理是代理服务器，具体上是位于 Web 服务器前面的服务器，其将客户端（例如 Web 浏览器）请求转发到这些 Web 服务器。</p>\n<p>比如如果我们客户端A要访问服务器C，不能直接访问，那么可以引入代理服务器B，让B去代理C，我们访问B就相当于访问C。</p>\n<p>反向代理用于：</p>\n<ul>\n<li>服务器负载均衡</li>\n<li>防范服务器攻击</li>\n<li>缓存</li>\n<li>加密</li>\n<li>内网穿透</li>\n</ul>\n<p><strong>和正向代理不同的是：</strong></p>\n<p>反向的代理代理的是服务器，所有服务器端的请求都可以走代理服务器</p>\n<p>正向代理是代理的客户端，所有客户端都可以走代理服务器</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/8cb3d7627a138d3e74c02045c2347434/daa5afb33830ea1b0187d19056218a38.png\" alt=\"image-20220508112316782\"></p>\n<h3 id=\"服务器内网穿透\"><a href=\"#服务器内网穿透\" class=\"headerlink\" title=\"服务器内网穿透\"></a>服务器内网穿透</h3><p>客户端</p>\n<pre><code>{  \n  &quot;reverse&quot;:{ \n    // 这是 A 的反向代理设置，必须有下面的 bridges 对象\n    &quot;bridges&quot;:[  \n      {  \n        &quot;tag&quot;:&quot;bridge&quot;, // 关于 A 的反向代理标签，在路由中会用到\n        &quot;domain&quot;:&quot;private.cloud.com&quot; // A 和 B 反向代理通信的域名，可以自己取一个，可以不是自己购买的域名，但必须跟下面 B 中的 reverse 配置的域名一致\n      }\n    ]\n  },\n  &quot;outbounds&quot;: [\n    {  \n      //A连接B的outbound  \n      &quot;tag&quot;:&quot;tunnel&quot;, // A 连接 B 的 outbound 的标签，在路由中会用到\n      &quot;protocol&quot;:&quot;vmess&quot;,\n      &quot;settings&quot;:{  \n        &quot;vnext&quot;:[  \n          {  \n            &quot;address&quot;:&quot;110.40.204.239&quot;, // B 地址，IP 或 实际的域名\n            &quot;port&quot;:6688,\n            &quot;users&quot;:[  \n              {  \n                &quot;id&quot;:&quot;b831381d-6324-4d53-ad4f-8cda48b30811&quot;,\n                &quot;alterId&quot;:0\n              }\n            ]\n          }\n        ]\n      }\n    },\n    // 另一个 outbound，最终连接本地的内网的服务 \n    {  \n      &quot;protocol&quot;:&quot;freedom&quot;,\n      &quot;settings&quot;:{  \n      },\n      &quot;tag&quot;:&quot;out&quot;\n    }    \n  ],\n  &quot;routing&quot;:{   \n    &quot;rules&quot;:[  \n      {  \n        // 配置 A 主动连接 B 的路由规则\n        &quot;type&quot;:&quot;field&quot;,\n        &quot;inboundTag&quot;:[  \n          &quot;bridge&quot;\n        ],\n        &quot;domain&quot;:[  \n          &quot;full:private.cloud.com&quot;\n        ],\n        &quot;outboundTag&quot;:&quot;tunnel&quot;\n      },\n      {  \n        // 反向连接访问内网的规则\n        &quot;type&quot;:&quot;field&quot;,\n        &quot;inboundTag&quot;:[  \n          &quot;bridge&quot;\n        ],\n        &quot;outboundTag&quot;:&quot;out&quot;\n      }\n    ]\n  }\n}</code></pre><p>服务器</p>\n<pre><code>{  \n  &quot;reverse&quot;:{  //这是 B 的反向代理设置，必须有下面的 portals 对象\n    &quot;portals&quot;:[  \n      {  \n        &quot;tag&quot;:&quot;portal&quot;,\n        &quot;domain&quot;:&quot;private.cloud.com&quot;        // 必须和上面 A 设定的域名一样，可以是虚拟的\n      }\n    ]\n  },\n  &quot;inbounds&quot;: [\n    {  \n      // 接受 C 的inbound\n      &quot;tag&quot;:&quot;external&quot;, // 标签，路由中用到\n      &quot;port&quot;:80,\n      // 开放 80 端口，用于接收外部的 HTTP 访问 \n      &quot;protocol&quot;:&quot;dokodemo-door&quot;,\n        &quot;settings&quot;:{  \n          &quot;address&quot;:&quot;127.0.0.1&quot;,\n          &quot;port&quot;:80, //假设 NAS 监听的端口为 80\n          &quot;network&quot;:&quot;tcp&quot;\n        }\n    },\n    // 另一个 inbound，接受客户端主动发起的请求  \n    {  \n      &quot;tag&quot;: &quot;tunnel&quot;,// 标签，路由中用到\n      &quot;port&quot;:6688, //用于连接客户端的端口\n      &quot;protocol&quot;:&quot;vmess&quot;,\n      &quot;settings&quot;:{  \n        &quot;clients&quot;:[  \n          {  \n            &quot;id&quot;:&quot;b831381d-6324-4d53-ad4f-8cda48b30811&quot;,\n            &quot;alterId&quot;:0\n          }\n        ]\n      }\n    }\n  ],\n  &quot;routing&quot;:{  \n    &quot;rules&quot;:[  \n      {  //路由规则，接收 C 请求后发给 A\n        &quot;type&quot;:&quot;field&quot;,\n        &quot;inboundTag&quot;:[  \n          &quot;external&quot;\n        ],\n        &quot;outboundTag&quot;:&quot;portal&quot;\n      },\n      {  //路由规则，让 B 能够识别这是 A 主动发起的反向代理连接\n        &quot;type&quot;:&quot;field&quot;,\n        &quot;inboundTag&quot;:[  \n          &quot;tunnel&quot;\n        ],\n        &quot;domain&quot;:[  \n          &quot;full:private.cloud.com&quot;\n        ],\n        &quot;outboundTag&quot;:&quot;portal&quot;\n      }\n    ]\n  }\n}</code></pre><p>最后可以通过 <strong>服务器ip：80</strong>访问</p>\n<h2 id=\"多级代理提高溯源难度\"><a href=\"#多级代理提高溯源难度\" class=\"headerlink\" title=\"多级代理提高溯源难度\"></a>多级代理提高溯源难度</h2><p>如果就一台服务器，那么实际上通过查询那台服务器，可以找回到请求的原始ip。那么，可不可以在全球疯狂的绕几层服务器。大大提高服务器的溯源难度。</p>\n<p>v2ray就可以。v2ray可以实现链式转发。</p>\n<p>例如，如果有多个ssr账户，可以</p>\n<pre><code>{\n  &quot;outbounds&quot;: [\n    {\n      &quot;protocol&quot;: &quot;vmess&quot;,\n      &quot;settings&quot;: { // settings 的根据实际情况修改\n        &quot;vnext&quot;: [\n          {\n            &quot;address&quot;: &quot;1.1.1.1&quot;,\n            &quot;port&quot;: 8888,\n            &quot;users&quot;: [\n              {\n                &quot;alterId&quot;: 64,\n                &quot;id&quot;: &quot;b12614c5-5ca4-4eba-a215-c61d642116ce&quot;\n              }\n            ]\n          }\n        ]\n      },\n      &quot;tag&quot;: &quot;DOUS&quot;,\n      &quot;proxySettings&quot;: {\n          &quot;tag&quot;: &quot;DOSG&quot;  \n        }\n    },\n    {\n      &quot;protocol&quot;: &quot;shadowsocks&quot;,\n      &quot;settings&quot;: {\n        &quot;servers&quot;: [\n          {\n            &quot;address&quot;: &quot;2.2.2.2&quot;,\n            &quot;method&quot;: &quot;aes-256-cfb&quot;,\n            &quot;ota&quot;: false,\n            &quot;password&quot;: &quot;password&quot;,\n            &quot;port&quot;: 1024\n          }\n        ]\n      },\n      &quot;tag&quot;: &quot;AliHK&quot;\n    },\n    {\n      &quot;protocol&quot;: &quot;shadowsocks&quot;,\n      &quot;settings&quot;: {\n        &quot;servers&quot;: [\n          {\n            &quot;address&quot;: &quot;3.3.3.3&quot;,\n            &quot;method&quot;: &quot;aes-256-cfb&quot;,\n            &quot;ota&quot;: false,\n            &quot;password&quot;: &quot;password&quot;,\n            &quot;port&quot;: 3442\n          }\n        ]\n      },\n      &quot;tag&quot;: &quot;AliSG&quot;,\n      &quot;proxySettings&quot;: {\n          &quot;tag&quot;: &quot;AliHK&quot;  \n      }\n    },\n    {\n      &quot;protocol&quot;: &quot;vmess&quot;,\n      &quot;settings&quot;: {\n        &quot;vnext&quot;: [\n          {\n            &quot;address&quot;: &quot;4.4.4.4&quot;,\n            &quot;port&quot;: 8462,\n            &quot;users&quot;: [\n              {\n                &quot;alterId&quot;: 64,\n                &quot;id&quot;: &quot;b27c24ab-2b5a-433e-902c-33f1168a7902&quot;\n              }\n            ]\n          }\n        ]\n      },\n      &quot;tag&quot;: &quot;DOSG&quot;,\n      &quot;proxySettings&quot;: {\n          &quot;tag&quot;: &quot;AliSG&quot;  \n      }\n    },\n  ]\n}</code></pre><p>那么数据包经过的节点依次为： PC -&gt; AliHK -&gt; AliSG -&gt; DOSG -&gt; DOUS -&gt; 目标网站</p>\n<p>这样的代理转发形成了一条链条，我称之为链式代理转发。</p>\n"},{"_content":"# 介绍\n\n## 工具\n\n- v2ray，功能强大的请求转发工具（优秀的代理工具）\n\n- cloudflare：一个不错的cdn白嫖网站，同时也能够用来做一些dns管理。关键是免费加强大\n- racknerk：我的vps购买网站，一个垃圾vps，美国的\n\n\n\n## 思路\n\n想要翻越GFW，那么需要有一个境外的服务器，这个服务器能够代理我们的请求，从而访问国外的资源。此外，该服务器还要能够与国内相同，也就是说不在GFW黑名单内。\n\n\n\n\n\n# 思路\n\n先去买一个域名。\n\n我是用的**namesilo**，一个全球知名的域名购买网站。\n\n\n\n## 先将域名的dns删除\n\n如图，我的域名是`kenger.top`\n\n![image-20230212001120974](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/69f5041eb1400f670ec1ef7e99f8cc09.png)\n\n![image-20230212001750936](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/70a68199992faf152eefba100f26bbf5.png)\n\n\n\n\n\n## 更改域名的DNS的NS值\n\nNS值，也就是指**nameserver**，域名解析服务器。即DNS服务\n\n进入cloudflare，新增站点\n\n![image-20230212001827761](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/c10fe8cc1a93463a201455534e4abf19.png)\n\n\n\n可以看到上图出现了**两个NS值**。\n\n这个就是cloudflare提供给我们的免费dns服务。把这两个贴到namesilo的相应位置。\n\n## 填入NS值\n\n![image-20230212002056139](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/40c87670be6920e90c2d633c33243559.png)\n\n然后提交**submit**\n\n\n\n## 新增DNS解析记录\n\n如图。\n\n![image-20230212002239985](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/cb975bde32885b6182ef2131c75b8a67.png)\n\n## 关于cloudflare的CDN代理说明\n\nCDN实际上就是再帮我们的服务器做一次反向代理。\n\n如图，当我们访问`v.kenger.top`时，实际上是先访问cloudflare的服务器，然后cloudflare去访问我们的目标服务器。**优点是非常的安全**\n\n![image-20230212002331566](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/b1c954cf4d2cb783a29ebd62624f6263.png)\n\n\n\n\n\n## 设置SSL\n\n这里最好设置成这个，选择灵活的话，好像访问次数多了，会自动判定访问http。\n\n![image-20230212002502214](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/c707726f9a369ab9d42060db4885abde.png)\n\n\n\n\n\n\n\n\n\n# v2ray+websocker+tls设置\n\n## 工具\n\n- 我用到了宝塔面板的nginx，从而实现tls\n- v2ray里面设置了websocket。\n- 最好再加上一个网页，以假乱真，搞得像我们真的在访问一个网站。\n\n\n\n## v2ray\n\n我用的docker\n\n```\n{\n  \"log\": {\n    \"loglevel\": \"info\"\n  },\n  \"inbounds\": [\n    {\n      \"listen\": \"0.0.0.0\",\n      \"port\": 52333,\n      \"protocol\": \"vmess\",\n      \"settings\": {\n        \"clients\": [\n          {\n            \"id\": \"8FF6627C-C247-44EB-A9AA-A7EAB8385D4A\",\n            \"alterId\": 0,\n            \"security\": \"auto\"\n          }\n        ]\n      },\n      \"streamSettings\": {     // 载体配置段，设置为websocket\n      \"network\": \"ws\",\n      \"wsSettings\": {\n        \"path\": \"/vpath\"  // 与nginx中的路径保持一致\n      }\n      \n    }\n    }\n  ],\n  \"outbounds\": [\n    {\n      \"protocol\": \"freedom\",\n      \"settings\": {},\n      \"tag\": \"proxy\"\n    }\n  ]\n}\n```\n\n```\nsudo docker run -it --name v2ray -v $PWD/v2ray/config.json:/etc/v2ray/config.json -p 52333:52333 v2fly/v2fly-core:v4.31.0 \n```\n\n\n\n## 宝塔nginx\n\n![image-20230212002943126](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/6ba654e1b570afb780e97fcad4732e92.png)\n\n\n\n### 开启ssl\n\n用免费的就行\n\n![image-20230212003148350](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/fc54de028dedba39dc565bc9a3be98a9.png)\n\n\n\n### 配置nginx\n\n关键是这段\n\n```\n  location /vpath {\n      proxy_redirect off;\n      proxy_pass http://127.0.0.1:52333;\n      proxy_http_version 1.1;\n      proxy_set_header Upgrade $http_upgrade;\n      proxy_set_header Connection \"upgrade\";\n      proxy_set_header Host $host;\n      # Show real IP in v2ray access.log\n      proxy_set_header X-Real-IP $remote_addr;\n      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    }\n}\n```\n\n\n\n![image-20230212003053921](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/03d2c125ff48c1b595e1e47671c7e728.png)\n\n\n\n## 搭建伪装网站\n\n在`v.kenger.top`上搭建了代理后，还需要在该域名上做一个伪装的网站。不然空访问一个index页面也很假。\n\n就宝塔自带的nginx静态资源代理\n\n![image-20230212183926877](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/ef224ee25ad63d89dd6d32547ba58a86.png)\n\n**将网站放入该文件夹下即可。**\n\n效果\n\n![image-20230212183956514](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/6ed51f767e4f62f111ce0ffd8f771c93.png)\n\n\n\n# 一些不知道的问题\n\n- 不知道为什么，第一天搭建好后效果很差，又反复重新搭建了几次，突然又变还不错了。\n- 延迟可能会很高，但是带宽好像还能跑起来。有点时好时坏的感觉。感觉是这么一种情况，突然用这个节点的话，会很慢，但是如果使用了几分钟后，速度就还行了，至少油管2k可以了。\n- 可能我买的vps不行，虽然理论上有1gbps的带宽，但是和国内通信只能跑到很有限。反而在套上cloudflare后变快了。\n\n\n\n\n\n# ref\n\nhttps://sh.tmioe.com/772.html\n\nhttps://www.triadprogram.com/v2ray-build-by-yourself/\n\nhttps://www.winhow.top/archives/14/#Joe-8\n\n\n\n# 附录\n\n\n\n## clash配置\n\n```\n    - {name: my1, server: v.kenger.top, port: 443, type: vmess, uuid: 8FF6627C-C247-44EB-A9AA-A7EAB8385D4A, alterId: 0, cipher: auto, tls: true, network: ws, ws-opts: {path: vpath}}\n```\n\n**注意：clash延迟会很高，可能导致失败**\n\n\n\n## v2ray填写\n\n![2802654365](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/535de391b15c8ba72edcdca32d08483b.png)\n\n\n\n## 完整nginx文件\n\n```\nserver\n{\n    listen 80;\n\t\tlisten 443 ssl http2;\n    server_name v.kenger.top;\n    index index.php index.html index.htm default.php default.htm default.html;\n    root /www/wwwroot/v.kenger.top;\n\n    #SSL-START SSL相关配置，请勿删除或修改下一行带注释的404规则\n    #error_page 404/404.html;\n    #HTTP_TO_HTTPS_START\n    if ($server_port !~ 443){\n        rewrite ^(/.*)$ https://$host$1 permanent;\n    }\n    #HTTP_TO_HTTPS_END\n    ssl_certificate    /www/server/panel/vhost/cert/v.kenger.top/fullchain.pem;\n    ssl_certificate_key    /www/server/panel/vhost/cert/v.kenger.top/privkey.pem;\n    ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3;\n    ssl_ciphers EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;\n    ssl_prefer_server_ciphers on;\n    ssl_session_cache shared:SSL:10m;\n    ssl_session_timeout 10m;\n    add_header Strict-Transport-Security \"max-age=31536000\";\n    error_page 497  https://$host$request_uri;\n\t\t#SSL-END\n\n    #ERROR-PAGE-START  错误页配置，可以注释、删除或修改\n    #error_page 404 /404.html;\n    #error_page 502 /502.html;\n    #ERROR-PAGE-END\n\n    #PHP-INFO-START  PHP引用配置，可以注释或修改\n    include enable-php-00.conf;\n    #PHP-INFO-END\n\n    #REWRITE-START URL重写规则引用,修改后将导致面板设置的伪静态规则失效\n    include /www/server/panel/vhost/rewrite/v.kenger.top.conf;\n    #REWRITE-END\n\n    #禁止访问的文件或目录\n    location ~ ^/(\\.user.ini|\\.htaccess|\\.git|\\.env|\\.svn|\\.project|LICENSE|README.md)\n    {\n        return 404;\n    }\n\n    #一键申请SSL证书验证目录相关设置\n    location ~ \\.well-known{\n        allow all;\n    }\n\n    #禁止在证书验证目录放入敏感文件\n    if ( $uri ~ \"^/\\.well-known/.*\\.(php|jsp|py|js|css|lua|ts|go|zip|tar\\.gz|rar|7z|sql|bak)$\" ) {\n        return 403;\n    }\n\n    location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$\n    {\n        expires      30d;\n        error_log /dev/null;\n        access_log /dev/null;\n    }\n\n    location ~ .*\\.(js|css)?$\n    {\n        expires      12h;\n        error_log /dev/null;\n        access_log /dev/null;\n    }\n    access_log  /www/wwwlogs/v.kenger.top.log;\n    error_log  /www/wwwlogs/v.kenger.top.error.log;\n    \n    \n  location /vpath {\n      proxy_redirect off;\n      proxy_pass http://127.0.0.1:52333;\n      proxy_http_version 1.1;\n      proxy_set_header Upgrade $http_upgrade;\n      proxy_set_header Connection \"upgrade\";\n      proxy_set_header Host $host;\n      # Show real IP in v2ray access.log\n      proxy_set_header X-Real-IP $remote_addr;\n      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    }\n}\n```\n\n","source":"_posts/代理/自建机场之websocket+tls+cloudflare.md","raw":"# 介绍\n\n## 工具\n\n- v2ray，功能强大的请求转发工具（优秀的代理工具）\n\n- cloudflare：一个不错的cdn白嫖网站，同时也能够用来做一些dns管理。关键是免费加强大\n- racknerk：我的vps购买网站，一个垃圾vps，美国的\n\n\n\n## 思路\n\n想要翻越GFW，那么需要有一个境外的服务器，这个服务器能够代理我们的请求，从而访问国外的资源。此外，该服务器还要能够与国内相同，也就是说不在GFW黑名单内。\n\n\n\n\n\n# 思路\n\n先去买一个域名。\n\n我是用的**namesilo**，一个全球知名的域名购买网站。\n\n\n\n## 先将域名的dns删除\n\n如图，我的域名是`kenger.top`\n\n![image-20230212001120974](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/69f5041eb1400f670ec1ef7e99f8cc09.png)\n\n![image-20230212001750936](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/70a68199992faf152eefba100f26bbf5.png)\n\n\n\n\n\n## 更改域名的DNS的NS值\n\nNS值，也就是指**nameserver**，域名解析服务器。即DNS服务\n\n进入cloudflare，新增站点\n\n![image-20230212001827761](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/c10fe8cc1a93463a201455534e4abf19.png)\n\n\n\n可以看到上图出现了**两个NS值**。\n\n这个就是cloudflare提供给我们的免费dns服务。把这两个贴到namesilo的相应位置。\n\n## 填入NS值\n\n![image-20230212002056139](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/40c87670be6920e90c2d633c33243559.png)\n\n然后提交**submit**\n\n\n\n## 新增DNS解析记录\n\n如图。\n\n![image-20230212002239985](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/cb975bde32885b6182ef2131c75b8a67.png)\n\n## 关于cloudflare的CDN代理说明\n\nCDN实际上就是再帮我们的服务器做一次反向代理。\n\n如图，当我们访问`v.kenger.top`时，实际上是先访问cloudflare的服务器，然后cloudflare去访问我们的目标服务器。**优点是非常的安全**\n\n![image-20230212002331566](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/b1c954cf4d2cb783a29ebd62624f6263.png)\n\n\n\n\n\n## 设置SSL\n\n这里最好设置成这个，选择灵活的话，好像访问次数多了，会自动判定访问http。\n\n![image-20230212002502214](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/c707726f9a369ab9d42060db4885abde.png)\n\n\n\n\n\n\n\n\n\n# v2ray+websocker+tls设置\n\n## 工具\n\n- 我用到了宝塔面板的nginx，从而实现tls\n- v2ray里面设置了websocket。\n- 最好再加上一个网页，以假乱真，搞得像我们真的在访问一个网站。\n\n\n\n## v2ray\n\n我用的docker\n\n```\n{\n  \"log\": {\n    \"loglevel\": \"info\"\n  },\n  \"inbounds\": [\n    {\n      \"listen\": \"0.0.0.0\",\n      \"port\": 52333,\n      \"protocol\": \"vmess\",\n      \"settings\": {\n        \"clients\": [\n          {\n            \"id\": \"8FF6627C-C247-44EB-A9AA-A7EAB8385D4A\",\n            \"alterId\": 0,\n            \"security\": \"auto\"\n          }\n        ]\n      },\n      \"streamSettings\": {     // 载体配置段，设置为websocket\n      \"network\": \"ws\",\n      \"wsSettings\": {\n        \"path\": \"/vpath\"  // 与nginx中的路径保持一致\n      }\n      \n    }\n    }\n  ],\n  \"outbounds\": [\n    {\n      \"protocol\": \"freedom\",\n      \"settings\": {},\n      \"tag\": \"proxy\"\n    }\n  ]\n}\n```\n\n```\nsudo docker run -it --name v2ray -v $PWD/v2ray/config.json:/etc/v2ray/config.json -p 52333:52333 v2fly/v2fly-core:v4.31.0 \n```\n\n\n\n## 宝塔nginx\n\n![image-20230212002943126](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/6ba654e1b570afb780e97fcad4732e92.png)\n\n\n\n### 开启ssl\n\n用免费的就行\n\n![image-20230212003148350](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/fc54de028dedba39dc565bc9a3be98a9.png)\n\n\n\n### 配置nginx\n\n关键是这段\n\n```\n  location /vpath {\n      proxy_redirect off;\n      proxy_pass http://127.0.0.1:52333;\n      proxy_http_version 1.1;\n      proxy_set_header Upgrade $http_upgrade;\n      proxy_set_header Connection \"upgrade\";\n      proxy_set_header Host $host;\n      # Show real IP in v2ray access.log\n      proxy_set_header X-Real-IP $remote_addr;\n      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    }\n}\n```\n\n\n\n![image-20230212003053921](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/03d2c125ff48c1b595e1e47671c7e728.png)\n\n\n\n## 搭建伪装网站\n\n在`v.kenger.top`上搭建了代理后，还需要在该域名上做一个伪装的网站。不然空访问一个index页面也很假。\n\n就宝塔自带的nginx静态资源代理\n\n![image-20230212183926877](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/ef224ee25ad63d89dd6d32547ba58a86.png)\n\n**将网站放入该文件夹下即可。**\n\n效果\n\n![image-20230212183956514](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/6ed51f767e4f62f111ce0ffd8f771c93.png)\n\n\n\n# 一些不知道的问题\n\n- 不知道为什么，第一天搭建好后效果很差，又反复重新搭建了几次，突然又变还不错了。\n- 延迟可能会很高，但是带宽好像还能跑起来。有点时好时坏的感觉。感觉是这么一种情况，突然用这个节点的话，会很慢，但是如果使用了几分钟后，速度就还行了，至少油管2k可以了。\n- 可能我买的vps不行，虽然理论上有1gbps的带宽，但是和国内通信只能跑到很有限。反而在套上cloudflare后变快了。\n\n\n\n\n\n# ref\n\nhttps://sh.tmioe.com/772.html\n\nhttps://www.triadprogram.com/v2ray-build-by-yourself/\n\nhttps://www.winhow.top/archives/14/#Joe-8\n\n\n\n# 附录\n\n\n\n## clash配置\n\n```\n    - {name: my1, server: v.kenger.top, port: 443, type: vmess, uuid: 8FF6627C-C247-44EB-A9AA-A7EAB8385D4A, alterId: 0, cipher: auto, tls: true, network: ws, ws-opts: {path: vpath}}\n```\n\n**注意：clash延迟会很高，可能导致失败**\n\n\n\n## v2ray填写\n\n![2802654365](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/535de391b15c8ba72edcdca32d08483b.png)\n\n\n\n## 完整nginx文件\n\n```\nserver\n{\n    listen 80;\n\t\tlisten 443 ssl http2;\n    server_name v.kenger.top;\n    index index.php index.html index.htm default.php default.htm default.html;\n    root /www/wwwroot/v.kenger.top;\n\n    #SSL-START SSL相关配置，请勿删除或修改下一行带注释的404规则\n    #error_page 404/404.html;\n    #HTTP_TO_HTTPS_START\n    if ($server_port !~ 443){\n        rewrite ^(/.*)$ https://$host$1 permanent;\n    }\n    #HTTP_TO_HTTPS_END\n    ssl_certificate    /www/server/panel/vhost/cert/v.kenger.top/fullchain.pem;\n    ssl_certificate_key    /www/server/panel/vhost/cert/v.kenger.top/privkey.pem;\n    ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3;\n    ssl_ciphers EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;\n    ssl_prefer_server_ciphers on;\n    ssl_session_cache shared:SSL:10m;\n    ssl_session_timeout 10m;\n    add_header Strict-Transport-Security \"max-age=31536000\";\n    error_page 497  https://$host$request_uri;\n\t\t#SSL-END\n\n    #ERROR-PAGE-START  错误页配置，可以注释、删除或修改\n    #error_page 404 /404.html;\n    #error_page 502 /502.html;\n    #ERROR-PAGE-END\n\n    #PHP-INFO-START  PHP引用配置，可以注释或修改\n    include enable-php-00.conf;\n    #PHP-INFO-END\n\n    #REWRITE-START URL重写规则引用,修改后将导致面板设置的伪静态规则失效\n    include /www/server/panel/vhost/rewrite/v.kenger.top.conf;\n    #REWRITE-END\n\n    #禁止访问的文件或目录\n    location ~ ^/(\\.user.ini|\\.htaccess|\\.git|\\.env|\\.svn|\\.project|LICENSE|README.md)\n    {\n        return 404;\n    }\n\n    #一键申请SSL证书验证目录相关设置\n    location ~ \\.well-known{\n        allow all;\n    }\n\n    #禁止在证书验证目录放入敏感文件\n    if ( $uri ~ \"^/\\.well-known/.*\\.(php|jsp|py|js|css|lua|ts|go|zip|tar\\.gz|rar|7z|sql|bak)$\" ) {\n        return 403;\n    }\n\n    location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$\n    {\n        expires      30d;\n        error_log /dev/null;\n        access_log /dev/null;\n    }\n\n    location ~ .*\\.(js|css)?$\n    {\n        expires      12h;\n        error_log /dev/null;\n        access_log /dev/null;\n    }\n    access_log  /www/wwwlogs/v.kenger.top.log;\n    error_log  /www/wwwlogs/v.kenger.top.error.log;\n    \n    \n  location /vpath {\n      proxy_redirect off;\n      proxy_pass http://127.0.0.1:52333;\n      proxy_http_version 1.1;\n      proxy_set_header Upgrade $http_upgrade;\n      proxy_set_header Connection \"upgrade\";\n      proxy_set_header Host $host;\n      # Show real IP in v2ray access.log\n      proxy_set_header X-Real-IP $remote_addr;\n      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    }\n}\n```\n\n","slug":"代理/自建机场之websocket+tls+cloudflare","published":1,"date":"2023-02-27T11:33:23.574Z","updated":"2023-02-27T11:34:33.134Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsyby000r0gcn5k77i6ju","content":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><ul>\n<li><p>v2ray，功能强大的请求转发工具（优秀的代理工具）</p>\n</li>\n<li><p>cloudflare：一个不错的cdn白嫖网站，同时也能够用来做一些dns管理。关键是免费加强大</p>\n</li>\n<li><p>racknerk：我的vps购买网站，一个垃圾vps，美国的</p>\n</li>\n</ul>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>想要翻越GFW，那么需要有一个境外的服务器，这个服务器能够代理我们的请求，从而访问国外的资源。此外，该服务器还要能够与国内相同，也就是说不在GFW黑名单内。</p>\n<h1 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>先去买一个域名。</p>\n<p>我是用的<strong>namesilo</strong>，一个全球知名的域名购买网站。</p>\n<h2 id=\"先将域名的dns删除\"><a href=\"#先将域名的dns删除\" class=\"headerlink\" title=\"先将域名的dns删除\"></a>先将域名的dns删除</h2><p>如图，我的域名是<code>kenger.top</code></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/69f5041eb1400f670ec1ef7e99f8cc09.png\" alt=\"image-20230212001120974\"></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/70a68199992faf152eefba100f26bbf5.png\" alt=\"image-20230212001750936\"></p>\n<h2 id=\"更改域名的DNS的NS值\"><a href=\"#更改域名的DNS的NS值\" class=\"headerlink\" title=\"更改域名的DNS的NS值\"></a>更改域名的DNS的NS值</h2><p>NS值，也就是指<strong>nameserver</strong>，域名解析服务器。即DNS服务</p>\n<p>进入cloudflare，新增站点</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/c10fe8cc1a93463a201455534e4abf19.png\" alt=\"image-20230212001827761\"></p>\n<p>可以看到上图出现了<strong>两个NS值</strong>。</p>\n<p>这个就是cloudflare提供给我们的免费dns服务。把这两个贴到namesilo的相应位置。</p>\n<h2 id=\"填入NS值\"><a href=\"#填入NS值\" class=\"headerlink\" title=\"填入NS值\"></a>填入NS值</h2><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/40c87670be6920e90c2d633c33243559.png\" alt=\"image-20230212002056139\"></p>\n<p>然后提交<strong>submit</strong></p>\n<h2 id=\"新增DNS解析记录\"><a href=\"#新增DNS解析记录\" class=\"headerlink\" title=\"新增DNS解析记录\"></a>新增DNS解析记录</h2><p>如图。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/cb975bde32885b6182ef2131c75b8a67.png\" alt=\"image-20230212002239985\"></p>\n<h2 id=\"关于cloudflare的CDN代理说明\"><a href=\"#关于cloudflare的CDN代理说明\" class=\"headerlink\" title=\"关于cloudflare的CDN代理说明\"></a>关于cloudflare的CDN代理说明</h2><p>CDN实际上就是再帮我们的服务器做一次反向代理。</p>\n<p>如图，当我们访问<code>v.kenger.top</code>时，实际上是先访问cloudflare的服务器，然后cloudflare去访问我们的目标服务器。<strong>优点是非常的安全</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/b1c954cf4d2cb783a29ebd62624f6263.png\" alt=\"image-20230212002331566\"></p>\n<h2 id=\"设置SSL\"><a href=\"#设置SSL\" class=\"headerlink\" title=\"设置SSL\"></a>设置SSL</h2><p>这里最好设置成这个，选择灵活的话，好像访问次数多了，会自动判定访问http。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/c707726f9a369ab9d42060db4885abde.png\" alt=\"image-20230212002502214\"></p>\n<h1 id=\"v2ray-websocker-tls设置\"><a href=\"#v2ray-websocker-tls设置\" class=\"headerlink\" title=\"v2ray+websocker+tls设置\"></a>v2ray+websocker+tls设置</h1><h2 id=\"工具-1\"><a href=\"#工具-1\" class=\"headerlink\" title=\"工具\"></a>工具</h2><ul>\n<li>我用到了宝塔面板的nginx，从而实现tls</li>\n<li>v2ray里面设置了websocket。</li>\n<li>最好再加上一个网页，以假乱真，搞得像我们真的在访问一个网站。</li>\n</ul>\n<h2 id=\"v2ray\"><a href=\"#v2ray\" class=\"headerlink\" title=\"v2ray\"></a>v2ray</h2><p>我用的docker</p>\n<pre><code>{\n  &quot;log&quot;: {\n    &quot;loglevel&quot;: &quot;info&quot;\n  },\n  &quot;inbounds&quot;: [\n    {\n      &quot;listen&quot;: &quot;0.0.0.0&quot;,\n      &quot;port&quot;: 52333,\n      &quot;protocol&quot;: &quot;vmess&quot;,\n      &quot;settings&quot;: {\n        &quot;clients&quot;: [\n          {\n            &quot;id&quot;: &quot;8FF6627C-C247-44EB-A9AA-A7EAB8385D4A&quot;,\n            &quot;alterId&quot;: 0,\n            &quot;security&quot;: &quot;auto&quot;\n          }\n        ]\n      },\n      &quot;streamSettings&quot;: {     // 载体配置段，设置为websocket\n      &quot;network&quot;: &quot;ws&quot;,\n      &quot;wsSettings&quot;: {\n        &quot;path&quot;: &quot;/vpath&quot;  // 与nginx中的路径保持一致\n      }\n\n    }\n    }\n  ],\n  &quot;outbounds&quot;: [\n    {\n      &quot;protocol&quot;: &quot;freedom&quot;,\n      &quot;settings&quot;: {},\n      &quot;tag&quot;: &quot;proxy&quot;\n    }\n  ]\n}</code></pre><pre><code>sudo docker run -it --name v2ray -v $PWD/v2ray/config.json:/etc/v2ray/config.json -p 52333:52333 v2fly/v2fly-core:v4.31.0 </code></pre><h2 id=\"宝塔nginx\"><a href=\"#宝塔nginx\" class=\"headerlink\" title=\"宝塔nginx\"></a>宝塔nginx</h2><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/6ba654e1b570afb780e97fcad4732e92.png\" alt=\"image-20230212002943126\"></p>\n<h3 id=\"开启ssl\"><a href=\"#开启ssl\" class=\"headerlink\" title=\"开启ssl\"></a>开启ssl</h3><p>用免费的就行</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/fc54de028dedba39dc565bc9a3be98a9.png\" alt=\"image-20230212003148350\"></p>\n<h3 id=\"配置nginx\"><a href=\"#配置nginx\" class=\"headerlink\" title=\"配置nginx\"></a>配置nginx</h3><p>关键是这段</p>\n<pre><code>  location /vpath {\n      proxy_redirect off;\n      proxy_pass http://127.0.0.1:52333;\n      proxy_http_version 1.1;\n      proxy_set_header Upgrade $http_upgrade;\n      proxy_set_header Connection &quot;upgrade&quot;;\n      proxy_set_header Host $host;\n      # Show real IP in v2ray access.log\n      proxy_set_header X-Real-IP $remote_addr;\n      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    }\n}</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/03d2c125ff48c1b595e1e47671c7e728.png\" alt=\"image-20230212003053921\"></p>\n<h2 id=\"搭建伪装网站\"><a href=\"#搭建伪装网站\" class=\"headerlink\" title=\"搭建伪装网站\"></a>搭建伪装网站</h2><p>在<code>v.kenger.top</code>上搭建了代理后，还需要在该域名上做一个伪装的网站。不然空访问一个index页面也很假。</p>\n<p>就宝塔自带的nginx静态资源代理</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/ef224ee25ad63d89dd6d32547ba58a86.png\" alt=\"image-20230212183926877\"></p>\n<p><strong>将网站放入该文件夹下即可。</strong></p>\n<p>效果</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/6ed51f767e4f62f111ce0ffd8f771c93.png\" alt=\"image-20230212183956514\"></p>\n<h1 id=\"一些不知道的问题\"><a href=\"#一些不知道的问题\" class=\"headerlink\" title=\"一些不知道的问题\"></a>一些不知道的问题</h1><ul>\n<li>不知道为什么，第一天搭建好后效果很差，又反复重新搭建了几次，突然又变还不错了。</li>\n<li>延迟可能会很高，但是带宽好像还能跑起来。有点时好时坏的感觉。感觉是这么一种情况，突然用这个节点的话，会很慢，但是如果使用了几分钟后，速度就还行了，至少油管2k可以了。</li>\n<li>可能我买的vps不行，虽然理论上有1gbps的带宽，但是和国内通信只能跑到很有限。反而在套上cloudflare后变快了。</li>\n</ul>\n<h1 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h1><p><a href=\"https://sh.tmioe.com/772.html\" target=\"_blank\" rel=\"noopener\">https://sh.tmioe.com/772.html</a></p>\n<p><a href=\"https://www.triadprogram.com/v2ray-build-by-yourself/\" target=\"_blank\" rel=\"noopener\">https://www.triadprogram.com/v2ray-build-by-yourself/</a></p>\n<p><a href=\"https://www.winhow.top/archives/14/#Joe-8\" target=\"_blank\" rel=\"noopener\">https://www.winhow.top/archives/14/#Joe-8</a></p>\n<h1 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h1><h2 id=\"clash配置\"><a href=\"#clash配置\" class=\"headerlink\" title=\"clash配置\"></a>clash配置</h2><pre><code>    - {name: my1, server: v.kenger.top, port: 443, type: vmess, uuid: 8FF6627C-C247-44EB-A9AA-A7EAB8385D4A, alterId: 0, cipher: auto, tls: true, network: ws, ws-opts: {path: vpath}}</code></pre><p><strong>注意：clash延迟会很高，可能导致失败</strong></p>\n<h2 id=\"v2ray填写\"><a href=\"#v2ray填写\" class=\"headerlink\" title=\"v2ray填写\"></a>v2ray填写</h2><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/535de391b15c8ba72edcdca32d08483b.png\" alt=\"2802654365\"></p>\n<h2 id=\"完整nginx文件\"><a href=\"#完整nginx文件\" class=\"headerlink\" title=\"完整nginx文件\"></a>完整nginx文件</h2><pre><code>server\n{\n    listen 80;\n        listen 443 ssl http2;\n    server_name v.kenger.top;\n    index index.php index.html index.htm default.php default.htm default.html;\n    root /www/wwwroot/v.kenger.top;\n\n    #SSL-START SSL相关配置，请勿删除或修改下一行带注释的404规则\n    #error_page 404/404.html;\n    #HTTP_TO_HTTPS_START\n    if ($server_port !~ 443){\n        rewrite ^(/.*)$ https://$host$1 permanent;\n    }\n    #HTTP_TO_HTTPS_END\n    ssl_certificate    /www/server/panel/vhost/cert/v.kenger.top/fullchain.pem;\n    ssl_certificate_key    /www/server/panel/vhost/cert/v.kenger.top/privkey.pem;\n    ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3;\n    ssl_ciphers EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;\n    ssl_prefer_server_ciphers on;\n    ssl_session_cache shared:SSL:10m;\n    ssl_session_timeout 10m;\n    add_header Strict-Transport-Security &quot;max-age=31536000&quot;;\n    error_page 497  https://$host$request_uri;\n        #SSL-END\n\n    #ERROR-PAGE-START  错误页配置，可以注释、删除或修改\n    #error_page 404 /404.html;\n    #error_page 502 /502.html;\n    #ERROR-PAGE-END\n\n    #PHP-INFO-START  PHP引用配置，可以注释或修改\n    include enable-php-00.conf;\n    #PHP-INFO-END\n\n    #REWRITE-START URL重写规则引用,修改后将导致面板设置的伪静态规则失效\n    include /www/server/panel/vhost/rewrite/v.kenger.top.conf;\n    #REWRITE-END\n\n    #禁止访问的文件或目录\n    location ~ ^/(\\.user.ini|\\.htaccess|\\.git|\\.env|\\.svn|\\.project|LICENSE|README.md)\n    {\n        return 404;\n    }\n\n    #一键申请SSL证书验证目录相关设置\n    location ~ \\.well-known{\n        allow all;\n    }\n\n    #禁止在证书验证目录放入敏感文件\n    if ( $uri ~ &quot;^/\\.well-known/.*\\.(php|jsp|py|js|css|lua|ts|go|zip|tar\\.gz|rar|7z|sql|bak)$&quot; ) {\n        return 403;\n    }\n\n    location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$\n    {\n        expires      30d;\n        error_log /dev/null;\n        access_log /dev/null;\n    }\n\n    location ~ .*\\.(js|css)?$\n    {\n        expires      12h;\n        error_log /dev/null;\n        access_log /dev/null;\n    }\n    access_log  /www/wwwlogs/v.kenger.top.log;\n    error_log  /www/wwwlogs/v.kenger.top.error.log;\n\n\n  location /vpath {\n      proxy_redirect off;\n      proxy_pass http://127.0.0.1:52333;\n      proxy_http_version 1.1;\n      proxy_set_header Upgrade $http_upgrade;\n      proxy_set_header Connection &quot;upgrade&quot;;\n      proxy_set_header Host $host;\n      # Show real IP in v2ray access.log\n      proxy_set_header X-Real-IP $remote_addr;\n      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    }\n}</code></pre>","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><ul>\n<li><p>v2ray，功能强大的请求转发工具（优秀的代理工具）</p>\n</li>\n<li><p>cloudflare：一个不错的cdn白嫖网站，同时也能够用来做一些dns管理。关键是免费加强大</p>\n</li>\n<li><p>racknerk：我的vps购买网站，一个垃圾vps，美国的</p>\n</li>\n</ul>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>想要翻越GFW，那么需要有一个境外的服务器，这个服务器能够代理我们的请求，从而访问国外的资源。此外，该服务器还要能够与国内相同，也就是说不在GFW黑名单内。</p>\n<h1 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h1><p>先去买一个域名。</p>\n<p>我是用的<strong>namesilo</strong>，一个全球知名的域名购买网站。</p>\n<h2 id=\"先将域名的dns删除\"><a href=\"#先将域名的dns删除\" class=\"headerlink\" title=\"先将域名的dns删除\"></a>先将域名的dns删除</h2><p>如图，我的域名是<code>kenger.top</code></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/69f5041eb1400f670ec1ef7e99f8cc09.png\" alt=\"image-20230212001120974\"></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/70a68199992faf152eefba100f26bbf5.png\" alt=\"image-20230212001750936\"></p>\n<h2 id=\"更改域名的DNS的NS值\"><a href=\"#更改域名的DNS的NS值\" class=\"headerlink\" title=\"更改域名的DNS的NS值\"></a>更改域名的DNS的NS值</h2><p>NS值，也就是指<strong>nameserver</strong>，域名解析服务器。即DNS服务</p>\n<p>进入cloudflare，新增站点</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/c10fe8cc1a93463a201455534e4abf19.png\" alt=\"image-20230212001827761\"></p>\n<p>可以看到上图出现了<strong>两个NS值</strong>。</p>\n<p>这个就是cloudflare提供给我们的免费dns服务。把这两个贴到namesilo的相应位置。</p>\n<h2 id=\"填入NS值\"><a href=\"#填入NS值\" class=\"headerlink\" title=\"填入NS值\"></a>填入NS值</h2><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/40c87670be6920e90c2d633c33243559.png\" alt=\"image-20230212002056139\"></p>\n<p>然后提交<strong>submit</strong></p>\n<h2 id=\"新增DNS解析记录\"><a href=\"#新增DNS解析记录\" class=\"headerlink\" title=\"新增DNS解析记录\"></a>新增DNS解析记录</h2><p>如图。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/cb975bde32885b6182ef2131c75b8a67.png\" alt=\"image-20230212002239985\"></p>\n<h2 id=\"关于cloudflare的CDN代理说明\"><a href=\"#关于cloudflare的CDN代理说明\" class=\"headerlink\" title=\"关于cloudflare的CDN代理说明\"></a>关于cloudflare的CDN代理说明</h2><p>CDN实际上就是再帮我们的服务器做一次反向代理。</p>\n<p>如图，当我们访问<code>v.kenger.top</code>时，实际上是先访问cloudflare的服务器，然后cloudflare去访问我们的目标服务器。<strong>优点是非常的安全</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/b1c954cf4d2cb783a29ebd62624f6263.png\" alt=\"image-20230212002331566\"></p>\n<h2 id=\"设置SSL\"><a href=\"#设置SSL\" class=\"headerlink\" title=\"设置SSL\"></a>设置SSL</h2><p>这里最好设置成这个，选择灵活的话，好像访问次数多了，会自动判定访问http。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/c707726f9a369ab9d42060db4885abde.png\" alt=\"image-20230212002502214\"></p>\n<h1 id=\"v2ray-websocker-tls设置\"><a href=\"#v2ray-websocker-tls设置\" class=\"headerlink\" title=\"v2ray+websocker+tls设置\"></a>v2ray+websocker+tls设置</h1><h2 id=\"工具-1\"><a href=\"#工具-1\" class=\"headerlink\" title=\"工具\"></a>工具</h2><ul>\n<li>我用到了宝塔面板的nginx，从而实现tls</li>\n<li>v2ray里面设置了websocket。</li>\n<li>最好再加上一个网页，以假乱真，搞得像我们真的在访问一个网站。</li>\n</ul>\n<h2 id=\"v2ray\"><a href=\"#v2ray\" class=\"headerlink\" title=\"v2ray\"></a>v2ray</h2><p>我用的docker</p>\n<pre><code>{\n  &quot;log&quot;: {\n    &quot;loglevel&quot;: &quot;info&quot;\n  },\n  &quot;inbounds&quot;: [\n    {\n      &quot;listen&quot;: &quot;0.0.0.0&quot;,\n      &quot;port&quot;: 52333,\n      &quot;protocol&quot;: &quot;vmess&quot;,\n      &quot;settings&quot;: {\n        &quot;clients&quot;: [\n          {\n            &quot;id&quot;: &quot;8FF6627C-C247-44EB-A9AA-A7EAB8385D4A&quot;,\n            &quot;alterId&quot;: 0,\n            &quot;security&quot;: &quot;auto&quot;\n          }\n        ]\n      },\n      &quot;streamSettings&quot;: {     // 载体配置段，设置为websocket\n      &quot;network&quot;: &quot;ws&quot;,\n      &quot;wsSettings&quot;: {\n        &quot;path&quot;: &quot;/vpath&quot;  // 与nginx中的路径保持一致\n      }\n\n    }\n    }\n  ],\n  &quot;outbounds&quot;: [\n    {\n      &quot;protocol&quot;: &quot;freedom&quot;,\n      &quot;settings&quot;: {},\n      &quot;tag&quot;: &quot;proxy&quot;\n    }\n  ]\n}</code></pre><pre><code>sudo docker run -it --name v2ray -v $PWD/v2ray/config.json:/etc/v2ray/config.json -p 52333:52333 v2fly/v2fly-core:v4.31.0 </code></pre><h2 id=\"宝塔nginx\"><a href=\"#宝塔nginx\" class=\"headerlink\" title=\"宝塔nginx\"></a>宝塔nginx</h2><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/6ba654e1b570afb780e97fcad4732e92.png\" alt=\"image-20230212002943126\"></p>\n<h3 id=\"开启ssl\"><a href=\"#开启ssl\" class=\"headerlink\" title=\"开启ssl\"></a>开启ssl</h3><p>用免费的就行</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/fc54de028dedba39dc565bc9a3be98a9.png\" alt=\"image-20230212003148350\"></p>\n<h3 id=\"配置nginx\"><a href=\"#配置nginx\" class=\"headerlink\" title=\"配置nginx\"></a>配置nginx</h3><p>关键是这段</p>\n<pre><code>  location /vpath {\n      proxy_redirect off;\n      proxy_pass http://127.0.0.1:52333;\n      proxy_http_version 1.1;\n      proxy_set_header Upgrade $http_upgrade;\n      proxy_set_header Connection &quot;upgrade&quot;;\n      proxy_set_header Host $host;\n      # Show real IP in v2ray access.log\n      proxy_set_header X-Real-IP $remote_addr;\n      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    }\n}</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/03d2c125ff48c1b595e1e47671c7e728.png\" alt=\"image-20230212003053921\"></p>\n<h2 id=\"搭建伪装网站\"><a href=\"#搭建伪装网站\" class=\"headerlink\" title=\"搭建伪装网站\"></a>搭建伪装网站</h2><p>在<code>v.kenger.top</code>上搭建了代理后，还需要在该域名上做一个伪装的网站。不然空访问一个index页面也很假。</p>\n<p>就宝塔自带的nginx静态资源代理</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/ef224ee25ad63d89dd6d32547ba58a86.png\" alt=\"image-20230212183926877\"></p>\n<p><strong>将网站放入该文件夹下即可。</strong></p>\n<p>效果</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/6ed51f767e4f62f111ce0ffd8f771c93.png\" alt=\"image-20230212183956514\"></p>\n<h1 id=\"一些不知道的问题\"><a href=\"#一些不知道的问题\" class=\"headerlink\" title=\"一些不知道的问题\"></a>一些不知道的问题</h1><ul>\n<li>不知道为什么，第一天搭建好后效果很差，又反复重新搭建了几次，突然又变还不错了。</li>\n<li>延迟可能会很高，但是带宽好像还能跑起来。有点时好时坏的感觉。感觉是这么一种情况，突然用这个节点的话，会很慢，但是如果使用了几分钟后，速度就还行了，至少油管2k可以了。</li>\n<li>可能我买的vps不行，虽然理论上有1gbps的带宽，但是和国内通信只能跑到很有限。反而在套上cloudflare后变快了。</li>\n</ul>\n<h1 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h1><p><a href=\"https://sh.tmioe.com/772.html\" target=\"_blank\" rel=\"noopener\">https://sh.tmioe.com/772.html</a></p>\n<p><a href=\"https://www.triadprogram.com/v2ray-build-by-yourself/\" target=\"_blank\" rel=\"noopener\">https://www.triadprogram.com/v2ray-build-by-yourself/</a></p>\n<p><a href=\"https://www.winhow.top/archives/14/#Joe-8\" target=\"_blank\" rel=\"noopener\">https://www.winhow.top/archives/14/#Joe-8</a></p>\n<h1 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h1><h2 id=\"clash配置\"><a href=\"#clash配置\" class=\"headerlink\" title=\"clash配置\"></a>clash配置</h2><pre><code>    - {name: my1, server: v.kenger.top, port: 443, type: vmess, uuid: 8FF6627C-C247-44EB-A9AA-A7EAB8385D4A, alterId: 0, cipher: auto, tls: true, network: ws, ws-opts: {path: vpath}}</code></pre><p><strong>注意：clash延迟会很高，可能导致失败</strong></p>\n<h2 id=\"v2ray填写\"><a href=\"#v2ray填写\" class=\"headerlink\" title=\"v2ray填写\"></a>v2ray填写</h2><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/cf57b2981859559f5ce35c14818242a9/535de391b15c8ba72edcdca32d08483b.png\" alt=\"2802654365\"></p>\n<h2 id=\"完整nginx文件\"><a href=\"#完整nginx文件\" class=\"headerlink\" title=\"完整nginx文件\"></a>完整nginx文件</h2><pre><code>server\n{\n    listen 80;\n        listen 443 ssl http2;\n    server_name v.kenger.top;\n    index index.php index.html index.htm default.php default.htm default.html;\n    root /www/wwwroot/v.kenger.top;\n\n    #SSL-START SSL相关配置，请勿删除或修改下一行带注释的404规则\n    #error_page 404/404.html;\n    #HTTP_TO_HTTPS_START\n    if ($server_port !~ 443){\n        rewrite ^(/.*)$ https://$host$1 permanent;\n    }\n    #HTTP_TO_HTTPS_END\n    ssl_certificate    /www/server/panel/vhost/cert/v.kenger.top/fullchain.pem;\n    ssl_certificate_key    /www/server/panel/vhost/cert/v.kenger.top/privkey.pem;\n    ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3;\n    ssl_ciphers EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;\n    ssl_prefer_server_ciphers on;\n    ssl_session_cache shared:SSL:10m;\n    ssl_session_timeout 10m;\n    add_header Strict-Transport-Security &quot;max-age=31536000&quot;;\n    error_page 497  https://$host$request_uri;\n        #SSL-END\n\n    #ERROR-PAGE-START  错误页配置，可以注释、删除或修改\n    #error_page 404 /404.html;\n    #error_page 502 /502.html;\n    #ERROR-PAGE-END\n\n    #PHP-INFO-START  PHP引用配置，可以注释或修改\n    include enable-php-00.conf;\n    #PHP-INFO-END\n\n    #REWRITE-START URL重写规则引用,修改后将导致面板设置的伪静态规则失效\n    include /www/server/panel/vhost/rewrite/v.kenger.top.conf;\n    #REWRITE-END\n\n    #禁止访问的文件或目录\n    location ~ ^/(\\.user.ini|\\.htaccess|\\.git|\\.env|\\.svn|\\.project|LICENSE|README.md)\n    {\n        return 404;\n    }\n\n    #一键申请SSL证书验证目录相关设置\n    location ~ \\.well-known{\n        allow all;\n    }\n\n    #禁止在证书验证目录放入敏感文件\n    if ( $uri ~ &quot;^/\\.well-known/.*\\.(php|jsp|py|js|css|lua|ts|go|zip|tar\\.gz|rar|7z|sql|bak)$&quot; ) {\n        return 403;\n    }\n\n    location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$\n    {\n        expires      30d;\n        error_log /dev/null;\n        access_log /dev/null;\n    }\n\n    location ~ .*\\.(js|css)?$\n    {\n        expires      12h;\n        error_log /dev/null;\n        access_log /dev/null;\n    }\n    access_log  /www/wwwlogs/v.kenger.top.log;\n    error_log  /www/wwwlogs/v.kenger.top.error.log;\n\n\n  location /vpath {\n      proxy_redirect off;\n      proxy_pass http://127.0.0.1:52333;\n      proxy_http_version 1.1;\n      proxy_set_header Upgrade $http_upgrade;\n      proxy_set_header Connection &quot;upgrade&quot;;\n      proxy_set_header Host $host;\n      # Show real IP in v2ray access.log\n      proxy_set_header X-Real-IP $remote_addr;\n      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    }\n}</code></pre>"},{"_content":"# docker 使用v2ray\n\n思路：\n- 校园网内一台机器，用来做跳板实现代理功能，这台电脑上安装v2ray服务器端代理，以及frpc客户端代理v2ray的入口到服务器\n- 服务器就是frps。\n\n\n\n# 目标靶机的v2ray配置\n\n```\ndocker_name=\"v2ray-proxy\"\ndocker stop ${docker_name}\ndocker rm ${docker_name}\ndocker run -it \\\n    --name ${docker_name} \\\n    -v $PWD/config/config.json:/etc/v2ray/config.json \\\n    -p 51223:51223 \\\n    v2fly/v2fly-core:v4.31.0\n```\n\n","source":"_posts/代理/靶机与代理.md","raw":"# docker 使用v2ray\n\n思路：\n- 校园网内一台机器，用来做跳板实现代理功能，这台电脑上安装v2ray服务器端代理，以及frpc客户端代理v2ray的入口到服务器\n- 服务器就是frps。\n\n\n\n# 目标靶机的v2ray配置\n\n```\ndocker_name=\"v2ray-proxy\"\ndocker stop ${docker_name}\ndocker rm ${docker_name}\ndocker run -it \\\n    --name ${docker_name} \\\n    -v $PWD/config/config.json:/etc/v2ray/config.json \\\n    -p 51223:51223 \\\n    v2fly/v2fly-core:v4.31.0\n```\n\n","slug":"代理/靶机与代理","published":1,"date":"2023-02-27T11:33:23.574Z","updated":"2023-02-27T11:34:33.134Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsyby000s0gcne7uynmf9","content":"<h1 id=\"docker-使用v2ray\"><a href=\"#docker-使用v2ray\" class=\"headerlink\" title=\"docker 使用v2ray\"></a>docker 使用v2ray</h1><p>思路：</p>\n<ul>\n<li>校园网内一台机器，用来做跳板实现代理功能，这台电脑上安装v2ray服务器端代理，以及frpc客户端代理v2ray的入口到服务器</li>\n<li>服务器就是frps。</li>\n</ul>\n<h1 id=\"目标靶机的v2ray配置\"><a href=\"#目标靶机的v2ray配置\" class=\"headerlink\" title=\"目标靶机的v2ray配置\"></a>目标靶机的v2ray配置</h1><pre><code>docker_name=&quot;v2ray-proxy&quot;\ndocker stop ${docker_name}\ndocker rm ${docker_name}\ndocker run -it \\\n    --name ${docker_name} \\\n    -v $PWD/config/config.json:/etc/v2ray/config.json \\\n    -p 51223:51223 \\\n    v2fly/v2fly-core:v4.31.0</code></pre>","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"docker-使用v2ray\"><a href=\"#docker-使用v2ray\" class=\"headerlink\" title=\"docker 使用v2ray\"></a>docker 使用v2ray</h1><p>思路：</p>\n<ul>\n<li>校园网内一台机器，用来做跳板实现代理功能，这台电脑上安装v2ray服务器端代理，以及frpc客户端代理v2ray的入口到服务器</li>\n<li>服务器就是frps。</li>\n</ul>\n<h1 id=\"目标靶机的v2ray配置\"><a href=\"#目标靶机的v2ray配置\" class=\"headerlink\" title=\"目标靶机的v2ray配置\"></a>目标靶机的v2ray配置</h1><pre><code>docker_name=&quot;v2ray-proxy&quot;\ndocker stop ${docker_name}\ndocker rm ${docker_name}\ndocker run -it \\\n    --name ${docker_name} \\\n    -v $PWD/config/config.json:/etc/v2ray/config.json \\\n    -p 51223:51223 \\\n    v2fly/v2fly-core:v4.31.0</code></pre>"},{"_content":"# Nginx配置\n\n## Nginx的基本命令\n\n```\nnginx # 开启\nnginx -s reload     #重新加载配置文件\nnginx -s reopen     #重新打开log文件\nnginx -s stop       #快速关闭nginx服务\nnginx -s quit       #优雅的关闭nginx服务，等待工作进程处理完所有的请求\n```\n\n## 总体文件结构\n\n```\nuser  root;  # 用户\nworker_processes auto;\nerror_log  /www/wwwlogs/nginx_error.log  crit;\npid        /www/server/nginx/logs/nginx.pid;\nworker_rlimit_nofile 51200;\n\nevents\n    {\n        use epoll;\n        worker_connections 51200;\n        multi_accept on;\n    }\n\nhttp\n    {\n        include       mime.types;\n                #include luawaf.conf;\n\n                include proxy.conf;\n\n        default_type  application/octet-stream;\n\n        server_names_hash_bucket_size 512;\n        client_header_buffer_size 32k;\n        large_client_header_buffers 4 32k;\n        client_max_body_size 50m;\n\n        sendfile   on;\n        tcp_nopush on;\n\n        keepalive_timeout 60;\n\n        tcp_nodelay on;\n\n        fastcgi_connect_timeout 300;\n        fastcgi_send_timeout 300;\n        fastcgi_read_timeout 300;\n        fastcgi_buffer_size 64k;\n        fastcgi_buffers 4 64k;\n        fastcgi_busy_buffers_size 128k;\n        fastcgi_temp_file_write_size 256k;\n                fastcgi_intercept_errors on;\n\n        gzip on;\n        gzip_min_length  1k;\n        gzip_buffers     4 16k;\n        gzip_http_version 1.1;\n        gzip_comp_level 2;\n        gzip_types     text/plain application/javascript application/x-javascript text/javascript text/css application/xml;\n        gzip_vary on;\n        gzip_proxied   expired no-cache no-store private auth;\n        gzip_disable   \"MSIE [1-6]\\.\";\n\n        limit_conn_zone $binary_remote_addr zone=perip:10m;\n                limit_conn_zone $server_name zone=perserver:10m;\n\n        server_tokens off;\n\n\n# 访问日志配置在这\n\n#自定义名为main得日志格式\n\n\nlog_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                    '$status $body_bytes_sent \"$http_referer\" '\n                    '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\naccess_log /www/wwwlogs/access.log    main;  # 这里是具体路径\n\n\n\n\n\n# 这里是我们需要注意的东西，也是配置主要需要修改的东西\n  server {\n\n  #我们访问119.29.143.49：80\n        listen       81;               # 端口\n        server_name  110.40.204.239;    # 服务器名， 要代理的服务器的名字\n\n\n        #存放静态资源的文件路径\n         root   /root/front;\n\n\n        #ngix的配置文件\n        include /www/nginx/conf/*.conf;\n\n        location / {\n        }\n\n        error_page 404 /404.html;\n            location = /40x.html {\n        }\n\n        error_page 500 502 503 504 /50x.html;\n            location = /50x.html {\n        }\n    }\n    \n\n\n\ninclude /www/server/panel/vhost/nginx/*.conf;\n}\n```\n\n一个Nginx文件可以有多个server模块，实现多个功能\n## 代理静态资源\n\n\n```\n server {\n        listen       80;\n        server_name  localhost; #服务器名字ip或者域名\n\n        location / {\n            root   html;\n            index  index.html index.htm;\n        }\n\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        } \n}  \n```\n\n\n## 关于location指令\nlocation块指令会用其参数与客户端请求的URI进行匹配，匹配的URI请求会被定向到root指令定义的特殊本地文件系统目录中，重定向规则为：将URI添加到root参数后面，生成一个本地文件路径，即：root参数 + URI请求。这里示例参数”/”会匹配所有的请求，一般都会默认存在。示例定位后的目录为html/，默认是定位到安装目录的路径下的html/。这里location块指令内部的两个简单指令的含义是：\n\n\n\n如下当访问http://anonymalias.oicp.net:8008/htdocs/，就会匹配到/home/anonymalias/htdocs/index.html\n\n\n\n```\nserver {\n        listen       80;\n        server_name  localhost;\n\n        location / {\n            root   html;\n            index  index.html index.htm;\n        }\n\n        location /htdocs {\n            root   /home/anonymalias;\n            index  index.html;\n        }\n}  \n\n```\n\n## 代理服务器\n以下就是一个允许跨域访问的代理服务器配置\n```\n    server {\n        listen       80;\n        server_name  110.40.204.239;\n        location / {\n            add_header Access-Control-Allow-Origin '*' always;\n            add_header Access-Control-Allow-Headers \"Accept,Accept-Encoding,Accept-Language,Connection,Content-Length,Content-Type,Host,Origin,Referer,User-Agent\";\n            add_header Access-Control-Allow-Methods \"GET, POST, PUT, OPTIONS\";\n            add_header Access-Control-Allow-Credentials true;\n            if ($request_method = 'OPTIONS') {\n                return 200;\n            }\n            \n            proxy_pass  http://127.0.0.1:8000;\n        }\n\n    }\n\n```\n##### important\n**proxy_pass：**\n**一个nginx可以有多个location。\n那么可以实现多个后端服务通过url前缀不同共用一个端口（如80）。**\n该指令是反向代理的基本指令，用于设置代理服务器的协议和地址；对于一个client的请求，proxy_pass指令通过以下方式进行uri的转发：\n- 如果proxy_pass指令的参数没有URI，那么请求的URI会被**原样的传递**给internal server。\n- 如果proxy_pass指令的参数含有URI，client请求的URI匹配该location的部分将会被proxy_pass的path参数**替换**。\n**例如：请求为127.0.0.1/name/index.html 会被转发为：127.0.0.1/remote/index.html**\n```\nlocation /name/ {\n    proxy_pass http://127.0.0.1/remote/;\n}\n```\n\n\n## 参考\n\n[lin1](https://blog.csdn.net/anonymalias/article/details/50950910)","source":"_posts/服务器相关/Nginx配置.md","raw":"# Nginx配置\n\n## Nginx的基本命令\n\n```\nnginx # 开启\nnginx -s reload     #重新加载配置文件\nnginx -s reopen     #重新打开log文件\nnginx -s stop       #快速关闭nginx服务\nnginx -s quit       #优雅的关闭nginx服务，等待工作进程处理完所有的请求\n```\n\n## 总体文件结构\n\n```\nuser  root;  # 用户\nworker_processes auto;\nerror_log  /www/wwwlogs/nginx_error.log  crit;\npid        /www/server/nginx/logs/nginx.pid;\nworker_rlimit_nofile 51200;\n\nevents\n    {\n        use epoll;\n        worker_connections 51200;\n        multi_accept on;\n    }\n\nhttp\n    {\n        include       mime.types;\n                #include luawaf.conf;\n\n                include proxy.conf;\n\n        default_type  application/octet-stream;\n\n        server_names_hash_bucket_size 512;\n        client_header_buffer_size 32k;\n        large_client_header_buffers 4 32k;\n        client_max_body_size 50m;\n\n        sendfile   on;\n        tcp_nopush on;\n\n        keepalive_timeout 60;\n\n        tcp_nodelay on;\n\n        fastcgi_connect_timeout 300;\n        fastcgi_send_timeout 300;\n        fastcgi_read_timeout 300;\n        fastcgi_buffer_size 64k;\n        fastcgi_buffers 4 64k;\n        fastcgi_busy_buffers_size 128k;\n        fastcgi_temp_file_write_size 256k;\n                fastcgi_intercept_errors on;\n\n        gzip on;\n        gzip_min_length  1k;\n        gzip_buffers     4 16k;\n        gzip_http_version 1.1;\n        gzip_comp_level 2;\n        gzip_types     text/plain application/javascript application/x-javascript text/javascript text/css application/xml;\n        gzip_vary on;\n        gzip_proxied   expired no-cache no-store private auth;\n        gzip_disable   \"MSIE [1-6]\\.\";\n\n        limit_conn_zone $binary_remote_addr zone=perip:10m;\n                limit_conn_zone $server_name zone=perserver:10m;\n\n        server_tokens off;\n\n\n# 访问日志配置在这\n\n#自定义名为main得日志格式\n\n\nlog_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                    '$status $body_bytes_sent \"$http_referer\" '\n                    '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\naccess_log /www/wwwlogs/access.log    main;  # 这里是具体路径\n\n\n\n\n\n# 这里是我们需要注意的东西，也是配置主要需要修改的东西\n  server {\n\n  #我们访问119.29.143.49：80\n        listen       81;               # 端口\n        server_name  110.40.204.239;    # 服务器名， 要代理的服务器的名字\n\n\n        #存放静态资源的文件路径\n         root   /root/front;\n\n\n        #ngix的配置文件\n        include /www/nginx/conf/*.conf;\n\n        location / {\n        }\n\n        error_page 404 /404.html;\n            location = /40x.html {\n        }\n\n        error_page 500 502 503 504 /50x.html;\n            location = /50x.html {\n        }\n    }\n    \n\n\n\ninclude /www/server/panel/vhost/nginx/*.conf;\n}\n```\n\n一个Nginx文件可以有多个server模块，实现多个功能\n## 代理静态资源\n\n\n```\n server {\n        listen       80;\n        server_name  localhost; #服务器名字ip或者域名\n\n        location / {\n            root   html;\n            index  index.html index.htm;\n        }\n\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        } \n}  \n```\n\n\n## 关于location指令\nlocation块指令会用其参数与客户端请求的URI进行匹配，匹配的URI请求会被定向到root指令定义的特殊本地文件系统目录中，重定向规则为：将URI添加到root参数后面，生成一个本地文件路径，即：root参数 + URI请求。这里示例参数”/”会匹配所有的请求，一般都会默认存在。示例定位后的目录为html/，默认是定位到安装目录的路径下的html/。这里location块指令内部的两个简单指令的含义是：\n\n\n\n如下当访问http://anonymalias.oicp.net:8008/htdocs/，就会匹配到/home/anonymalias/htdocs/index.html\n\n\n\n```\nserver {\n        listen       80;\n        server_name  localhost;\n\n        location / {\n            root   html;\n            index  index.html index.htm;\n        }\n\n        location /htdocs {\n            root   /home/anonymalias;\n            index  index.html;\n        }\n}  \n\n```\n\n## 代理服务器\n以下就是一个允许跨域访问的代理服务器配置\n```\n    server {\n        listen       80;\n        server_name  110.40.204.239;\n        location / {\n            add_header Access-Control-Allow-Origin '*' always;\n            add_header Access-Control-Allow-Headers \"Accept,Accept-Encoding,Accept-Language,Connection,Content-Length,Content-Type,Host,Origin,Referer,User-Agent\";\n            add_header Access-Control-Allow-Methods \"GET, POST, PUT, OPTIONS\";\n            add_header Access-Control-Allow-Credentials true;\n            if ($request_method = 'OPTIONS') {\n                return 200;\n            }\n            \n            proxy_pass  http://127.0.0.1:8000;\n        }\n\n    }\n\n```\n##### important\n**proxy_pass：**\n**一个nginx可以有多个location。\n那么可以实现多个后端服务通过url前缀不同共用一个端口（如80）。**\n该指令是反向代理的基本指令，用于设置代理服务器的协议和地址；对于一个client的请求，proxy_pass指令通过以下方式进行uri的转发：\n- 如果proxy_pass指令的参数没有URI，那么请求的URI会被**原样的传递**给internal server。\n- 如果proxy_pass指令的参数含有URI，client请求的URI匹配该location的部分将会被proxy_pass的path参数**替换**。\n**例如：请求为127.0.0.1/name/index.html 会被转发为：127.0.0.1/remote/index.html**\n```\nlocation /name/ {\n    proxy_pass http://127.0.0.1/remote/;\n}\n```\n\n\n## 参考\n\n[lin1](https://blog.csdn.net/anonymalias/article/details/50950910)","slug":"服务器相关/Nginx配置","published":1,"date":"2023-02-27T11:33:23.587Z","updated":"2023-02-27T11:34:33.146Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsybz000t0gcnc8hxhbb3","content":"<h1 id=\"Nginx配置\"><a href=\"#Nginx配置\" class=\"headerlink\" title=\"Nginx配置\"></a>Nginx配置</h1><h2 id=\"Nginx的基本命令\"><a href=\"#Nginx的基本命令\" class=\"headerlink\" title=\"Nginx的基本命令\"></a>Nginx的基本命令</h2><pre><code>nginx # 开启\nnginx -s reload     #重新加载配置文件\nnginx -s reopen     #重新打开log文件\nnginx -s stop       #快速关闭nginx服务\nnginx -s quit       #优雅的关闭nginx服务，等待工作进程处理完所有的请求</code></pre><h2 id=\"总体文件结构\"><a href=\"#总体文件结构\" class=\"headerlink\" title=\"总体文件结构\"></a>总体文件结构</h2><pre><code>user  root;  # 用户\nworker_processes auto;\nerror_log  /www/wwwlogs/nginx_error.log  crit;\npid        /www/server/nginx/logs/nginx.pid;\nworker_rlimit_nofile 51200;\n\nevents\n    {\n        use epoll;\n        worker_connections 51200;\n        multi_accept on;\n    }\n\nhttp\n    {\n        include       mime.types;\n                #include luawaf.conf;\n\n                include proxy.conf;\n\n        default_type  application/octet-stream;\n\n        server_names_hash_bucket_size 512;\n        client_header_buffer_size 32k;\n        large_client_header_buffers 4 32k;\n        client_max_body_size 50m;\n\n        sendfile   on;\n        tcp_nopush on;\n\n        keepalive_timeout 60;\n\n        tcp_nodelay on;\n\n        fastcgi_connect_timeout 300;\n        fastcgi_send_timeout 300;\n        fastcgi_read_timeout 300;\n        fastcgi_buffer_size 64k;\n        fastcgi_buffers 4 64k;\n        fastcgi_busy_buffers_size 128k;\n        fastcgi_temp_file_write_size 256k;\n                fastcgi_intercept_errors on;\n\n        gzip on;\n        gzip_min_length  1k;\n        gzip_buffers     4 16k;\n        gzip_http_version 1.1;\n        gzip_comp_level 2;\n        gzip_types     text/plain application/javascript application/x-javascript text/javascript text/css application/xml;\n        gzip_vary on;\n        gzip_proxied   expired no-cache no-store private auth;\n        gzip_disable   &quot;MSIE [1-6]\\.&quot;;\n\n        limit_conn_zone $binary_remote_addr zone=perip:10m;\n                limit_conn_zone $server_name zone=perserver:10m;\n\n        server_tokens off;\n\n\n# 访问日志配置在这\n\n#自定义名为main得日志格式\n\n\nlog_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;\n                    &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;\n                    &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;\n\naccess_log /www/wwwlogs/access.log    main;  # 这里是具体路径\n\n\n\n\n\n# 这里是我们需要注意的东西，也是配置主要需要修改的东西\n  server {\n\n  #我们访问119.29.143.49：80\n        listen       81;               # 端口\n        server_name  110.40.204.239;    # 服务器名， 要代理的服务器的名字\n\n\n        #存放静态资源的文件路径\n         root   /root/front;\n\n\n        #ngix的配置文件\n        include /www/nginx/conf/*.conf;\n\n        location / {\n        }\n\n        error_page 404 /404.html;\n            location = /40x.html {\n        }\n\n        error_page 500 502 503 504 /50x.html;\n            location = /50x.html {\n        }\n    }\n\n\n\n\ninclude /www/server/panel/vhost/nginx/*.conf;\n}</code></pre><p>一个Nginx文件可以有多个server模块，实现多个功能</p>\n<h2 id=\"代理静态资源\"><a href=\"#代理静态资源\" class=\"headerlink\" title=\"代理静态资源\"></a>代理静态资源</h2><pre><code> server {\n        listen       80;\n        server_name  localhost; #服务器名字ip或者域名\n\n        location / {\n            root   html;\n            index  index.html index.htm;\n        }\n\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        } \n}  </code></pre><h2 id=\"关于location指令\"><a href=\"#关于location指令\" class=\"headerlink\" title=\"关于location指令\"></a>关于location指令</h2><p>location块指令会用其参数与客户端请求的URI进行匹配，匹配的URI请求会被定向到root指令定义的特殊本地文件系统目录中，重定向规则为：将URI添加到root参数后面，生成一个本地文件路径，即：root参数 + URI请求。这里示例参数”/”会匹配所有的请求，一般都会默认存在。示例定位后的目录为html/，默认是定位到安装目录的路径下的html/。这里location块指令内部的两个简单指令的含义是：</p>\n<p>如下当访问<a href=\"http://anonymalias.oicp.net:8008/htdocs/，就会匹配到/home/anonymalias/htdocs/index.html\" target=\"_blank\" rel=\"noopener\">http://anonymalias.oicp.net:8008/htdocs/，就会匹配到/home/anonymalias/htdocs/index.html</a></p>\n<pre><code>server {\n        listen       80;\n        server_name  localhost;\n\n        location / {\n            root   html;\n            index  index.html index.htm;\n        }\n\n        location /htdocs {\n            root   /home/anonymalias;\n            index  index.html;\n        }\n}  \n</code></pre><h2 id=\"代理服务器\"><a href=\"#代理服务器\" class=\"headerlink\" title=\"代理服务器\"></a>代理服务器</h2><p>以下就是一个允许跨域访问的代理服务器配置</p>\n<pre><code>    server {\n        listen       80;\n        server_name  110.40.204.239;\n        location / {\n            add_header Access-Control-Allow-Origin &#39;*&#39; always;\n            add_header Access-Control-Allow-Headers &quot;Accept,Accept-Encoding,Accept-Language,Connection,Content-Length,Content-Type,Host,Origin,Referer,User-Agent&quot;;\n            add_header Access-Control-Allow-Methods &quot;GET, POST, PUT, OPTIONS&quot;;\n            add_header Access-Control-Allow-Credentials true;\n            if ($request_method = &#39;OPTIONS&#39;) {\n                return 200;\n            }\n\n            proxy_pass  http://127.0.0.1:8000;\n        }\n\n    }\n</code></pre><h5 id=\"important\"><a href=\"#important\" class=\"headerlink\" title=\"important\"></a>important</h5><p><strong>proxy_pass：</strong><br><strong>一个nginx可以有多个location。<br>那么可以实现多个后端服务通过url前缀不同共用一个端口（如80）。</strong><br>该指令是反向代理的基本指令，用于设置代理服务器的协议和地址；对于一个client的请求，proxy_pass指令通过以下方式进行uri的转发：</p>\n<ul>\n<li>如果proxy_pass指令的参数没有URI，那么请求的URI会被<strong>原样的传递</strong>给internal server。</li>\n<li>如果proxy_pass指令的参数含有URI，client请求的URI匹配该location的部分将会被proxy_pass的path参数<strong>替换</strong>。</li>\n</ul>\n<p><strong>例如：请求为127.0.0.1/name/index.html 会被转发为：127.0.0.1/remote/index.html</strong></p>\n<pre><code>location /name/ {\n    proxy_pass http://127.0.0.1/remote/;\n}</code></pre><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/anonymalias/article/details/50950910\" target=\"_blank\" rel=\"noopener\">lin1</a></p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"Nginx配置\"><a href=\"#Nginx配置\" class=\"headerlink\" title=\"Nginx配置\"></a>Nginx配置</h1><h2 id=\"Nginx的基本命令\"><a href=\"#Nginx的基本命令\" class=\"headerlink\" title=\"Nginx的基本命令\"></a>Nginx的基本命令</h2><pre><code>nginx # 开启\nnginx -s reload     #重新加载配置文件\nnginx -s reopen     #重新打开log文件\nnginx -s stop       #快速关闭nginx服务\nnginx -s quit       #优雅的关闭nginx服务，等待工作进程处理完所有的请求</code></pre><h2 id=\"总体文件结构\"><a href=\"#总体文件结构\" class=\"headerlink\" title=\"总体文件结构\"></a>总体文件结构</h2><pre><code>user  root;  # 用户\nworker_processes auto;\nerror_log  /www/wwwlogs/nginx_error.log  crit;\npid        /www/server/nginx/logs/nginx.pid;\nworker_rlimit_nofile 51200;\n\nevents\n    {\n        use epoll;\n        worker_connections 51200;\n        multi_accept on;\n    }\n\nhttp\n    {\n        include       mime.types;\n                #include luawaf.conf;\n\n                include proxy.conf;\n\n        default_type  application/octet-stream;\n\n        server_names_hash_bucket_size 512;\n        client_header_buffer_size 32k;\n        large_client_header_buffers 4 32k;\n        client_max_body_size 50m;\n\n        sendfile   on;\n        tcp_nopush on;\n\n        keepalive_timeout 60;\n\n        tcp_nodelay on;\n\n        fastcgi_connect_timeout 300;\n        fastcgi_send_timeout 300;\n        fastcgi_read_timeout 300;\n        fastcgi_buffer_size 64k;\n        fastcgi_buffers 4 64k;\n        fastcgi_busy_buffers_size 128k;\n        fastcgi_temp_file_write_size 256k;\n                fastcgi_intercept_errors on;\n\n        gzip on;\n        gzip_min_length  1k;\n        gzip_buffers     4 16k;\n        gzip_http_version 1.1;\n        gzip_comp_level 2;\n        gzip_types     text/plain application/javascript application/x-javascript text/javascript text/css application/xml;\n        gzip_vary on;\n        gzip_proxied   expired no-cache no-store private auth;\n        gzip_disable   &quot;MSIE [1-6]\\.&quot;;\n\n        limit_conn_zone $binary_remote_addr zone=perip:10m;\n                limit_conn_zone $server_name zone=perserver:10m;\n\n        server_tokens off;\n\n\n# 访问日志配置在这\n\n#自定义名为main得日志格式\n\n\nlog_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;\n                    &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;\n                    &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;\n\naccess_log /www/wwwlogs/access.log    main;  # 这里是具体路径\n\n\n\n\n\n# 这里是我们需要注意的东西，也是配置主要需要修改的东西\n  server {\n\n  #我们访问119.29.143.49：80\n        listen       81;               # 端口\n        server_name  110.40.204.239;    # 服务器名， 要代理的服务器的名字\n\n\n        #存放静态资源的文件路径\n         root   /root/front;\n\n\n        #ngix的配置文件\n        include /www/nginx/conf/*.conf;\n\n        location / {\n        }\n\n        error_page 404 /404.html;\n            location = /40x.html {\n        }\n\n        error_page 500 502 503 504 /50x.html;\n            location = /50x.html {\n        }\n    }\n\n\n\n\ninclude /www/server/panel/vhost/nginx/*.conf;\n}</code></pre><p>一个Nginx文件可以有多个server模块，实现多个功能</p>\n<h2 id=\"代理静态资源\"><a href=\"#代理静态资源\" class=\"headerlink\" title=\"代理静态资源\"></a>代理静态资源</h2><pre><code> server {\n        listen       80;\n        server_name  localhost; #服务器名字ip或者域名\n\n        location / {\n            root   html;\n            index  index.html index.htm;\n        }\n\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        } \n}  </code></pre><h2 id=\"关于location指令\"><a href=\"#关于location指令\" class=\"headerlink\" title=\"关于location指令\"></a>关于location指令</h2><p>location块指令会用其参数与客户端请求的URI进行匹配，匹配的URI请求会被定向到root指令定义的特殊本地文件系统目录中，重定向规则为：将URI添加到root参数后面，生成一个本地文件路径，即：root参数 + URI请求。这里示例参数”/”会匹配所有的请求，一般都会默认存在。示例定位后的目录为html/，默认是定位到安装目录的路径下的html/。这里location块指令内部的两个简单指令的含义是：</p>\n<p>如下当访问<a href=\"http://anonymalias.oicp.net:8008/htdocs/，就会匹配到/home/anonymalias/htdocs/index.html\" target=\"_blank\" rel=\"noopener\">http://anonymalias.oicp.net:8008/htdocs/，就会匹配到/home/anonymalias/htdocs/index.html</a></p>\n<pre><code>server {\n        listen       80;\n        server_name  localhost;\n\n        location / {\n            root   html;\n            index  index.html index.htm;\n        }\n\n        location /htdocs {\n            root   /home/anonymalias;\n            index  index.html;\n        }\n}  \n</code></pre><h2 id=\"代理服务器\"><a href=\"#代理服务器\" class=\"headerlink\" title=\"代理服务器\"></a>代理服务器</h2><p>以下就是一个允许跨域访问的代理服务器配置</p>\n<pre><code>    server {\n        listen       80;\n        server_name  110.40.204.239;\n        location / {\n            add_header Access-Control-Allow-Origin &#39;*&#39; always;\n            add_header Access-Control-Allow-Headers &quot;Accept,Accept-Encoding,Accept-Language,Connection,Content-Length,Content-Type,Host,Origin,Referer,User-Agent&quot;;\n            add_header Access-Control-Allow-Methods &quot;GET, POST, PUT, OPTIONS&quot;;\n            add_header Access-Control-Allow-Credentials true;\n            if ($request_method = &#39;OPTIONS&#39;) {\n                return 200;\n            }\n\n            proxy_pass  http://127.0.0.1:8000;\n        }\n\n    }\n</code></pre><h5 id=\"important\"><a href=\"#important\" class=\"headerlink\" title=\"important\"></a>important</h5><p><strong>proxy_pass：</strong><br><strong>一个nginx可以有多个location。<br>那么可以实现多个后端服务通过url前缀不同共用一个端口（如80）。</strong><br>该指令是反向代理的基本指令，用于设置代理服务器的协议和地址；对于一个client的请求，proxy_pass指令通过以下方式进行uri的转发：</p>\n<ul>\n<li>如果proxy_pass指令的参数没有URI，那么请求的URI会被<strong>原样的传递</strong>给internal server。</li>\n<li>如果proxy_pass指令的参数含有URI，client请求的URI匹配该location的部分将会被proxy_pass的path参数<strong>替换</strong>。</li>\n</ul>\n<p><strong>例如：请求为127.0.0.1/name/index.html 会被转发为：127.0.0.1/remote/index.html</strong></p>\n<pre><code>location /name/ {\n    proxy_pass http://127.0.0.1/remote/;\n}</code></pre><h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://blog.csdn.net/anonymalias/article/details/50950910\" target=\"_blank\" rel=\"noopener\">lin1</a></p>\n"},{"_content":"### yum源配置\n\n```bash\nyum install nginx\n```\n\n没有配置yum源，好麻烦。找了教程\n\n二十二、Centos安装yum,wegt(完全配置篇）链接如下\n\nhttps://developer.aliyun.com/article/939699\n\n1、先看是不是有yum\n\n```bash\nrpm -qa | grep yum\n```\n\n2、删除之前的yum包\n\n```bash\nrpm -aq | grep yum | xargs rpm -e --nodeps\n```\n\n3、查看\n![在这里插入图片描述](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/27b7ca39ce6c419cd68af06fd49a272f/ebb746bcbd84b84aaded963e29379f52.png)4、下载rpm,repo包\n\n（1）在此网易镜像链接下载http://tel.mirrors.163.com/centos/7/os/x86_64/Packages/\n（2）五个包\n![在这里插入图片描述](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/27b7ca39ce6c419cd68af06fd49a272f/b1f89e3bf90a304bc258db1cf007a4d5.png)rz 命令上传到linux\n![在这里插入图片描述](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/27b7ca39ce6c419cd68af06fd49a272f/7b82dfea6cb68fd7f5e57be877add0d0.png)\n(4)安装\n\n```bash\nrpm -ivh python-2.7.5-89.el7.x86_64.rpm python-iniparse-0.4-9.el7.noarch.rpm --nodeps --force\n rpm -ivh yum-metadata-parser-1.1.4-10.el7.x86_64.rpm --nodeps --force\nrpm -ivh yum-3.4.3-168.el7.centos.noarch.rpm yum-plugin-fastestmirror-1.1.31-54.el7_8.noarch.rpm --nodeps --force\n```\n\n![在这里插入图片描述](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/27b7ca39ce6c419cd68af06fd49a272f/5c10bc5a8e77a816837c2b06e7e5e297.png)5、更改yum源\n\n（1）备份/etc/yum.repos.d/CentOS-Base.repo\n\n```bash\nmv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup\n```\n\n(2)下载CentOS7 repo文件\n\nhttp://mirrors.163.com/.help/centos.html根据此网站教程CenOS镜像使用帮助\n\n将下载好的repo文件放入/etc/yum.repos.d/中\n\n```bash\ncp CentOS7-Base-163.repo /etc/yum.repos.d/\n\n# 然后生成缓存\nyum clean all\nyum makecache\n```\n\n![在这里插入图片描述](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/27b7ca39ce6c419cd68af06fd49a272f/5b8d70ba3e4afe19aeb9ffb3ca271fe7.png)\n6、检查\n\n```bash\nyum -v\nyum list installed\n```","source":"_posts/服务器相关/centos的yum源的配置.md","raw":"### yum源配置\n\n```bash\nyum install nginx\n```\n\n没有配置yum源，好麻烦。找了教程\n\n二十二、Centos安装yum,wegt(完全配置篇）链接如下\n\nhttps://developer.aliyun.com/article/939699\n\n1、先看是不是有yum\n\n```bash\nrpm -qa | grep yum\n```\n\n2、删除之前的yum包\n\n```bash\nrpm -aq | grep yum | xargs rpm -e --nodeps\n```\n\n3、查看\n![在这里插入图片描述](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/27b7ca39ce6c419cd68af06fd49a272f/ebb746bcbd84b84aaded963e29379f52.png)4、下载rpm,repo包\n\n（1）在此网易镜像链接下载http://tel.mirrors.163.com/centos/7/os/x86_64/Packages/\n（2）五个包\n![在这里插入图片描述](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/27b7ca39ce6c419cd68af06fd49a272f/b1f89e3bf90a304bc258db1cf007a4d5.png)rz 命令上传到linux\n![在这里插入图片描述](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/27b7ca39ce6c419cd68af06fd49a272f/7b82dfea6cb68fd7f5e57be877add0d0.png)\n(4)安装\n\n```bash\nrpm -ivh python-2.7.5-89.el7.x86_64.rpm python-iniparse-0.4-9.el7.noarch.rpm --nodeps --force\n rpm -ivh yum-metadata-parser-1.1.4-10.el7.x86_64.rpm --nodeps --force\nrpm -ivh yum-3.4.3-168.el7.centos.noarch.rpm yum-plugin-fastestmirror-1.1.31-54.el7_8.noarch.rpm --nodeps --force\n```\n\n![在这里插入图片描述](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/27b7ca39ce6c419cd68af06fd49a272f/5c10bc5a8e77a816837c2b06e7e5e297.png)5、更改yum源\n\n（1）备份/etc/yum.repos.d/CentOS-Base.repo\n\n```bash\nmv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup\n```\n\n(2)下载CentOS7 repo文件\n\nhttp://mirrors.163.com/.help/centos.html根据此网站教程CenOS镜像使用帮助\n\n将下载好的repo文件放入/etc/yum.repos.d/中\n\n```bash\ncp CentOS7-Base-163.repo /etc/yum.repos.d/\n\n# 然后生成缓存\nyum clean all\nyum makecache\n```\n\n![在这里插入图片描述](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/27b7ca39ce6c419cd68af06fd49a272f/5b8d70ba3e4afe19aeb9ffb3ca271fe7.png)\n6、检查\n\n```bash\nyum -v\nyum list installed\n```","slug":"服务器相关/centos的yum源的配置","published":1,"date":"2023-02-27T11:33:23.586Z","updated":"2023-02-27T11:34:33.145Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsyc0000u0gcniy4ty5ql","content":"<h3 id=\"yum源配置\"><a href=\"#yum源配置\" class=\"headerlink\" title=\"yum源配置\"></a>yum源配置</h3><pre class=\"line-numbers language-bash\"><code class=\"language-bash\">yum <span class=\"token function\">install</span> nginx<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>没有配置yum源，好麻烦。找了教程</p>\n<p>二十二、Centos安装yum,wegt(完全配置篇）链接如下</p>\n<p><a href=\"https://developer.aliyun.com/article/939699\" target=\"_blank\" rel=\"noopener\">https://developer.aliyun.com/article/939699</a></p>\n<p>1、先看是不是有yum</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\">rpm -qa <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> yum<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>2、删除之前的yum包</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\">rpm -aq <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> yum <span class=\"token operator\">|</span> <span class=\"token function\">xargs</span> rpm -e --nodeps<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>3、查看<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/27b7ca39ce6c419cd68af06fd49a272f/ebb746bcbd84b84aaded963e29379f52.png\" alt=\"在这里插入图片描述\">4、下载rpm,repo包</p>\n<p>（1）在此网易镜像链接下载<a href=\"http://tel.mirrors.163.com/centos/7/os/x86_64/Packages/\" target=\"_blank\" rel=\"noopener\">http://tel.mirrors.163.com/centos/7/os/x86_64/Packages/</a><br>（2）五个包<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/27b7ca39ce6c419cd68af06fd49a272f/b1f89e3bf90a304bc258db1cf007a4d5.png\" alt=\"在这里插入图片描述\">rz 命令上传到linux<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/27b7ca39ce6c419cd68af06fd49a272f/7b82dfea6cb68fd7f5e57be877add0d0.png\" alt=\"在这里插入图片描述\"><br>(4)安装</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\">rpm -ivh python-2.7.5-89.el7.x86_64.rpm python-iniparse-0.4-9.el7.noarch.rpm --nodeps --force\n rpm -ivh yum-metadata-parser-1.1.4-10.el7.x86_64.rpm --nodeps --force\nrpm -ivh yum-3.4.3-168.el7.centos.noarch.rpm yum-plugin-fastestmirror-1.1.31-54.el7_8.noarch.rpm --nodeps --force<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/27b7ca39ce6c419cd68af06fd49a272f/5c10bc5a8e77a816837c2b06e7e5e297.png\" alt=\"在这里插入图片描述\">5、更改yum源</p>\n<p>（1）备份/etc/yum.repos.d/CentOS-Base.repo</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token function\">mv</span> /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>(2)下载CentOS7 repo文件</p>\n<p><a href=\"http://mirrors.163.com/.help/centos.html根据此网站教程CenOS镜像使用帮助\" target=\"_blank\" rel=\"noopener\">http://mirrors.163.com/.help/centos.html根据此网站教程CenOS镜像使用帮助</a></p>\n<p>将下载好的repo文件放入/etc/yum.repos.d/中</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\"><span class=\"token function\">cp</span> CentOS7-Base-163.repo /etc/yum.repos.d/\n\n<span class=\"token comment\" spellcheck=\"true\"># 然后生成缓存</span>\nyum clean all\nyum makecache<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/27b7ca39ce6c419cd68af06fd49a272f/5b8d70ba3e4afe19aeb9ffb3ca271fe7.png\" alt=\"在这里插入图片描述\"><br>6、检查</p>\n<pre class=\"line-numbers language-bash\"><code class=\"language-bash\">yum -v\nyum list installed<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h3 id=\"yum源配置\"><a href=\"#yum源配置\" class=\"headerlink\" title=\"yum源配置\"></a>yum源配置</h3><pre><code class=\"bash\">yum install nginx</code></pre>\n<p>没有配置yum源，好麻烦。找了教程</p>\n<p>二十二、Centos安装yum,wegt(完全配置篇）链接如下</p>\n<p><a href=\"https://developer.aliyun.com/article/939699\" target=\"_blank\" rel=\"noopener\">https://developer.aliyun.com/article/939699</a></p>\n<p>1、先看是不是有yum</p>\n<pre><code class=\"bash\">rpm -qa | grep yum</code></pre>\n<p>2、删除之前的yum包</p>\n<pre><code class=\"bash\">rpm -aq | grep yum | xargs rpm -e --nodeps</code></pre>\n<p>3、查看<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/27b7ca39ce6c419cd68af06fd49a272f/ebb746bcbd84b84aaded963e29379f52.png\" alt=\"在这里插入图片描述\">4、下载rpm,repo包</p>\n<p>（1）在此网易镜像链接下载<a href=\"http://tel.mirrors.163.com/centos/7/os/x86_64/Packages/\" target=\"_blank\" rel=\"noopener\">http://tel.mirrors.163.com/centos/7/os/x86_64/Packages/</a><br>（2）五个包<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/27b7ca39ce6c419cd68af06fd49a272f/b1f89e3bf90a304bc258db1cf007a4d5.png\" alt=\"在这里插入图片描述\">rz 命令上传到linux<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/27b7ca39ce6c419cd68af06fd49a272f/7b82dfea6cb68fd7f5e57be877add0d0.png\" alt=\"在这里插入图片描述\"><br>(4)安装</p>\n<pre><code class=\"bash\">rpm -ivh python-2.7.5-89.el7.x86_64.rpm python-iniparse-0.4-9.el7.noarch.rpm --nodeps --force\n rpm -ivh yum-metadata-parser-1.1.4-10.el7.x86_64.rpm --nodeps --force\nrpm -ivh yum-3.4.3-168.el7.centos.noarch.rpm yum-plugin-fastestmirror-1.1.31-54.el7_8.noarch.rpm --nodeps --force</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/27b7ca39ce6c419cd68af06fd49a272f/5c10bc5a8e77a816837c2b06e7e5e297.png\" alt=\"在这里插入图片描述\">5、更改yum源</p>\n<p>（1）备份/etc/yum.repos.d/CentOS-Base.repo</p>\n<pre><code class=\"bash\">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</code></pre>\n<p>(2)下载CentOS7 repo文件</p>\n<p><a href=\"http://mirrors.163.com/.help/centos.html根据此网站教程CenOS镜像使用帮助\" target=\"_blank\" rel=\"noopener\">http://mirrors.163.com/.help/centos.html根据此网站教程CenOS镜像使用帮助</a></p>\n<p>将下载好的repo文件放入/etc/yum.repos.d/中</p>\n<pre><code class=\"bash\">cp CentOS7-Base-163.repo /etc/yum.repos.d/\n\n# 然后生成缓存\nyum clean all\nyum makecache</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/27b7ca39ce6c419cd68af06fd49a272f/5b8d70ba3e4afe19aeb9ffb3ca271fe7.png\" alt=\"在这里插入图片描述\"><br>6、检查</p>\n<pre><code class=\"bash\">yum -v\nyum list installed</code></pre>\n"},{"_content":"# Samba用户管理\n\n**关于samba用户与系统用户关系**\n\n```\n基本没有关系，但是samba可以使用系统用户，只是并不是一套密码\n```\n\n\n\n\n\n**新建系统测试账号**\n\n```\n$sudo useradd test  //新建一个名为test的账号\n$sudo passwd test   //为test账号设置密码\n```\n\n**新增samba账号** \n\n```\n$sudo smbpasswd -a test //以系统账号test为基础建立samba用户test\n```\n\n\n\n**在vim /etc/config/samba文件末尾添加如下：**     \n\n```\nconfig sambashare 'kenger'  ## 引号中可改为想要的共享名称，建议不要有中文\n        option name 'kenger'  ## 引号中可改为想要的共享名称，建议不要有中文，与上面相同\n        option path '/mnt/test'  ## 引号中改为U盘挂载位置\n        option read_only 'no'\n        option guest_ok 'no'\n        option create_mask '777'\n        option dir_mask '777'\n```\n\n编辑配置文件**vim /etc/samba/smb.conf.template **\n\n可以直接复制\n\n```\n[global]\n\tnetbios name = |NAME|\n\tdisplay charset = |CHARSET|\n\tinterfaces = |INTERFACES|\n\tserver string = |DESCRIPTION|\n\tunix charset = |CHARSET|\n\tworkgroup = |WORKGROUP|\n\tbrowseable = yes\n\tdeadtime = 30\n\tdomain master = yes\n\tencrypt passwords = true\n\tenable core files = no\n\tguest account = nobody\n\tguest ok = yes\n\t#invalid users = root\n\tlocal master = yes\n\tload printers = no\n\tmap to guest = Bad User\n\tmax protocol = SMB2\n\tmin receivefile size = 8192\n\tnull passwords = yes\n\tobey pam restrictions = yes\n\tos level = 20\n\tpassdb backend = smbpasswd\n\tpreferred master = yes\n\tprintable = no\n\tsecurity = user\n\tsmb encrypt = disabled\n\tsmb passwd file = /etc/samba/smbpasswd\n\tsocket options = TCP_NODELAY SO_RCVBUF=960000 SO_SNDBUF=960000\n\tsyslog = 2\n\tuse sendfile = yes\n\tuse mmap = yes\n\twriteable = yes\n\tdisable spoolss = yes\n\thost msdfs = no\n\tstrict allocate = No\n\n```\n\n\n\n\n\n**进行权限设置** \n\n```\n\n\n通过设置test及其目录的访问权限，可达到对不同目录的不同的访问权限。 \n\n修改samba用户的密码 \n$sudo smbpasswd 用户名\n\n禁用samba用户 \n$sudo smbpasswd -d 用户名\n\n启用samba用户 \n$sudo smbpasswd -e 用户名\n\n删除samba用户 \n$sudo smbpasswd -x 用户名\n```\n\n\n\n\n\n","source":"_posts/服务器相关/Samba用户管理.md","raw":"# Samba用户管理\n\n**关于samba用户与系统用户关系**\n\n```\n基本没有关系，但是samba可以使用系统用户，只是并不是一套密码\n```\n\n\n\n\n\n**新建系统测试账号**\n\n```\n$sudo useradd test  //新建一个名为test的账号\n$sudo passwd test   //为test账号设置密码\n```\n\n**新增samba账号** \n\n```\n$sudo smbpasswd -a test //以系统账号test为基础建立samba用户test\n```\n\n\n\n**在vim /etc/config/samba文件末尾添加如下：**     \n\n```\nconfig sambashare 'kenger'  ## 引号中可改为想要的共享名称，建议不要有中文\n        option name 'kenger'  ## 引号中可改为想要的共享名称，建议不要有中文，与上面相同\n        option path '/mnt/test'  ## 引号中改为U盘挂载位置\n        option read_only 'no'\n        option guest_ok 'no'\n        option create_mask '777'\n        option dir_mask '777'\n```\n\n编辑配置文件**vim /etc/samba/smb.conf.template **\n\n可以直接复制\n\n```\n[global]\n\tnetbios name = |NAME|\n\tdisplay charset = |CHARSET|\n\tinterfaces = |INTERFACES|\n\tserver string = |DESCRIPTION|\n\tunix charset = |CHARSET|\n\tworkgroup = |WORKGROUP|\n\tbrowseable = yes\n\tdeadtime = 30\n\tdomain master = yes\n\tencrypt passwords = true\n\tenable core files = no\n\tguest account = nobody\n\tguest ok = yes\n\t#invalid users = root\n\tlocal master = yes\n\tload printers = no\n\tmap to guest = Bad User\n\tmax protocol = SMB2\n\tmin receivefile size = 8192\n\tnull passwords = yes\n\tobey pam restrictions = yes\n\tos level = 20\n\tpassdb backend = smbpasswd\n\tpreferred master = yes\n\tprintable = no\n\tsecurity = user\n\tsmb encrypt = disabled\n\tsmb passwd file = /etc/samba/smbpasswd\n\tsocket options = TCP_NODELAY SO_RCVBUF=960000 SO_SNDBUF=960000\n\tsyslog = 2\n\tuse sendfile = yes\n\tuse mmap = yes\n\twriteable = yes\n\tdisable spoolss = yes\n\thost msdfs = no\n\tstrict allocate = No\n\n```\n\n\n\n\n\n**进行权限设置** \n\n```\n\n\n通过设置test及其目录的访问权限，可达到对不同目录的不同的访问权限。 \n\n修改samba用户的密码 \n$sudo smbpasswd 用户名\n\n禁用samba用户 \n$sudo smbpasswd -d 用户名\n\n启用samba用户 \n$sudo smbpasswd -e 用户名\n\n删除samba用户 \n$sudo smbpasswd -x 用户名\n```\n\n\n\n\n\n","slug":"服务器相关/Samba用户管理","published":1,"date":"2023-02-27T11:33:23.589Z","updated":"2023-02-27T11:34:33.148Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsyc1000v0gcnao4v8mon","content":"<h1 id=\"Samba用户管理\"><a href=\"#Samba用户管理\" class=\"headerlink\" title=\"Samba用户管理\"></a>Samba用户管理</h1><p><strong>关于samba用户与系统用户关系</strong></p>\n<pre><code>基本没有关系，但是samba可以使用系统用户，只是并不是一套密码</code></pre><p><strong>新建系统测试账号</strong></p>\n<pre><code>$sudo useradd test  //新建一个名为test的账号\n$sudo passwd test   //为test账号设置密码</code></pre><p><strong>新增samba账号</strong> </p>\n<pre><code>$sudo smbpasswd -a test //以系统账号test为基础建立samba用户test</code></pre><p><strong>在vim /etc/config/samba文件末尾添加如下：</strong>     </p>\n<pre><code>config sambashare &#39;kenger&#39;  ## 引号中可改为想要的共享名称，建议不要有中文\n        option name &#39;kenger&#39;  ## 引号中可改为想要的共享名称，建议不要有中文，与上面相同\n        option path &#39;/mnt/test&#39;  ## 引号中改为U盘挂载位置\n        option read_only &#39;no&#39;\n        option guest_ok &#39;no&#39;\n        option create_mask &#39;777&#39;\n        option dir_mask &#39;777&#39;</code></pre><p>编辑配置文件*<em>vim /etc/samba/smb.conf.template *</em></p>\n<p>可以直接复制</p>\n<pre><code>[global]\n    netbios name = |NAME|\n    display charset = |CHARSET|\n    interfaces = |INTERFACES|\n    server string = |DESCRIPTION|\n    unix charset = |CHARSET|\n    workgroup = |WORKGROUP|\n    browseable = yes\n    deadtime = 30\n    domain master = yes\n    encrypt passwords = true\n    enable core files = no\n    guest account = nobody\n    guest ok = yes\n    #invalid users = root\n    local master = yes\n    load printers = no\n    map to guest = Bad User\n    max protocol = SMB2\n    min receivefile size = 8192\n    null passwords = yes\n    obey pam restrictions = yes\n    os level = 20\n    passdb backend = smbpasswd\n    preferred master = yes\n    printable = no\n    security = user\n    smb encrypt = disabled\n    smb passwd file = /etc/samba/smbpasswd\n    socket options = TCP_NODELAY SO_RCVBUF=960000 SO_SNDBUF=960000\n    syslog = 2\n    use sendfile = yes\n    use mmap = yes\n    writeable = yes\n    disable spoolss = yes\n    host msdfs = no\n    strict allocate = No\n</code></pre><p><strong>进行权限设置</strong> </p>\n<pre><code>\n\n通过设置test及其目录的访问权限，可达到对不同目录的不同的访问权限。 \n\n修改samba用户的密码 \n$sudo smbpasswd 用户名\n\n禁用samba用户 \n$sudo smbpasswd -d 用户名\n\n启用samba用户 \n$sudo smbpasswd -e 用户名\n\n删除samba用户 \n$sudo smbpasswd -x 用户名</code></pre>","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"Samba用户管理\"><a href=\"#Samba用户管理\" class=\"headerlink\" title=\"Samba用户管理\"></a>Samba用户管理</h1><p><strong>关于samba用户与系统用户关系</strong></p>\n<pre><code>基本没有关系，但是samba可以使用系统用户，只是并不是一套密码</code></pre><p><strong>新建系统测试账号</strong></p>\n<pre><code>$sudo useradd test  //新建一个名为test的账号\n$sudo passwd test   //为test账号设置密码</code></pre><p><strong>新增samba账号</strong> </p>\n<pre><code>$sudo smbpasswd -a test //以系统账号test为基础建立samba用户test</code></pre><p><strong>在vim /etc/config/samba文件末尾添加如下：</strong>     </p>\n<pre><code>config sambashare &#39;kenger&#39;  ## 引号中可改为想要的共享名称，建议不要有中文\n        option name &#39;kenger&#39;  ## 引号中可改为想要的共享名称，建议不要有中文，与上面相同\n        option path &#39;/mnt/test&#39;  ## 引号中改为U盘挂载位置\n        option read_only &#39;no&#39;\n        option guest_ok &#39;no&#39;\n        option create_mask &#39;777&#39;\n        option dir_mask &#39;777&#39;</code></pre><p>编辑配置文件*<em>vim /etc/samba/smb.conf.template *</em></p>\n<p>可以直接复制</p>\n<pre><code>[global]\n    netbios name = |NAME|\n    display charset = |CHARSET|\n    interfaces = |INTERFACES|\n    server string = |DESCRIPTION|\n    unix charset = |CHARSET|\n    workgroup = |WORKGROUP|\n    browseable = yes\n    deadtime = 30\n    domain master = yes\n    encrypt passwords = true\n    enable core files = no\n    guest account = nobody\n    guest ok = yes\n    #invalid users = root\n    local master = yes\n    load printers = no\n    map to guest = Bad User\n    max protocol = SMB2\n    min receivefile size = 8192\n    null passwords = yes\n    obey pam restrictions = yes\n    os level = 20\n    passdb backend = smbpasswd\n    preferred master = yes\n    printable = no\n    security = user\n    smb encrypt = disabled\n    smb passwd file = /etc/samba/smbpasswd\n    socket options = TCP_NODELAY SO_RCVBUF=960000 SO_SNDBUF=960000\n    syslog = 2\n    use sendfile = yes\n    use mmap = yes\n    writeable = yes\n    disable spoolss = yes\n    host msdfs = no\n    strict allocate = No\n</code></pre><p><strong>进行权限设置</strong> </p>\n<pre><code>\n\n通过设置test及其目录的访问权限，可达到对不同目录的不同的访问权限。 \n\n修改samba用户的密码 \n$sudo smbpasswd 用户名\n\n禁用samba用户 \n$sudo smbpasswd -d 用户名\n\n启用samba用户 \n$sudo smbpasswd -e 用户名\n\n删除samba用户 \n$sudo smbpasswd -x 用户名</code></pre>"},{"_content":"# docker 容器权限管理\n\n先创建一个linux的demo\n\n```\ndocker run -v $PWD/data:/data  -d --name ubuntu1 ubuntu sleep 10000000\n```\n\n加入最后的sleep是为了防止文件直接退出了\n\n挂载后的文件，和宿主机具有同一套文件权限管理系统。也就是说，**在宿主机上的用户权限管理，在容器里面也是认可的。**\n\n\n\n\n\n## 例子\n\n宿主机：kenger.txt文件在files（1004）用户组里面\n\n![image-20221020134533324](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/b86805c6c426c736260790d05d39a6a1/a684d4d376d178669156fe0fdd10ae96.png)\n\n如果直接在容器里面建立一个用户，进行增删改查，是没有权限的。例如我这里的test用户。\n\n![image-20221020134644235](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/b86805c6c426c736260790d05d39a6a1/f705f064ab72570a50ae80aae723786e.png)\n\n\n\n但是如果我将test用户加入到容器李同gid的files用户组里面\n\n![image-20221020134731387](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/b86805c6c426c736260790d05d39a6a1/f57afcc27ca419f27e4e71568cecec9b.png)\n\n那就是有权限的，和宿主机共享一套。\n\n完美实现了权限的管理。\n\n\n\n当然很多容器的默认用户是root。可以在一定程度实现越权。这个就看怎么操作了。","source":"_posts/服务器相关/docker 容器权限管理.md","raw":"# docker 容器权限管理\n\n先创建一个linux的demo\n\n```\ndocker run -v $PWD/data:/data  -d --name ubuntu1 ubuntu sleep 10000000\n```\n\n加入最后的sleep是为了防止文件直接退出了\n\n挂载后的文件，和宿主机具有同一套文件权限管理系统。也就是说，**在宿主机上的用户权限管理，在容器里面也是认可的。**\n\n\n\n\n\n## 例子\n\n宿主机：kenger.txt文件在files（1004）用户组里面\n\n![image-20221020134533324](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/b86805c6c426c736260790d05d39a6a1/a684d4d376d178669156fe0fdd10ae96.png)\n\n如果直接在容器里面建立一个用户，进行增删改查，是没有权限的。例如我这里的test用户。\n\n![image-20221020134644235](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/b86805c6c426c736260790d05d39a6a1/f705f064ab72570a50ae80aae723786e.png)\n\n\n\n但是如果我将test用户加入到容器李同gid的files用户组里面\n\n![image-20221020134731387](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/b86805c6c426c736260790d05d39a6a1/f57afcc27ca419f27e4e71568cecec9b.png)\n\n那就是有权限的，和宿主机共享一套。\n\n完美实现了权限的管理。\n\n\n\n当然很多容器的默认用户是root。可以在一定程度实现越权。这个就看怎么操作了。","slug":"服务器相关/docker 容器权限管理","published":1,"date":"2023-02-27T11:33:23.589Z","updated":"2023-02-27T11:34:33.148Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsyc2000w0gcnfkeh9glv","content":"<h1 id=\"docker-容器权限管理\"><a href=\"#docker-容器权限管理\" class=\"headerlink\" title=\"docker 容器权限管理\"></a>docker 容器权限管理</h1><p>先创建一个linux的demo</p>\n<pre><code>docker run -v $PWD/data:/data  -d --name ubuntu1 ubuntu sleep 10000000</code></pre><p>加入最后的sleep是为了防止文件直接退出了</p>\n<p>挂载后的文件，和宿主机具有同一套文件权限管理系统。也就是说，<strong>在宿主机上的用户权限管理，在容器里面也是认可的。</strong></p>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>宿主机：kenger.txt文件在files（1004）用户组里面</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/b86805c6c426c736260790d05d39a6a1/a684d4d376d178669156fe0fdd10ae96.png\" alt=\"image-20221020134533324\"></p>\n<p>如果直接在容器里面建立一个用户，进行增删改查，是没有权限的。例如我这里的test用户。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/b86805c6c426c736260790d05d39a6a1/f705f064ab72570a50ae80aae723786e.png\" alt=\"image-20221020134644235\"></p>\n<p>但是如果我将test用户加入到容器李同gid的files用户组里面</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/b86805c6c426c736260790d05d39a6a1/f57afcc27ca419f27e4e71568cecec9b.png\" alt=\"image-20221020134731387\"></p>\n<p>那就是有权限的，和宿主机共享一套。</p>\n<p>完美实现了权限的管理。</p>\n<p>当然很多容器的默认用户是root。可以在一定程度实现越权。这个就看怎么操作了。</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"docker-容器权限管理\"><a href=\"#docker-容器权限管理\" class=\"headerlink\" title=\"docker 容器权限管理\"></a>docker 容器权限管理</h1><p>先创建一个linux的demo</p>\n<pre><code>docker run -v $PWD/data:/data  -d --name ubuntu1 ubuntu sleep 10000000</code></pre><p>加入最后的sleep是为了防止文件直接退出了</p>\n<p>挂载后的文件，和宿主机具有同一套文件权限管理系统。也就是说，<strong>在宿主机上的用户权限管理，在容器里面也是认可的。</strong></p>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>宿主机：kenger.txt文件在files（1004）用户组里面</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/b86805c6c426c736260790d05d39a6a1/a684d4d376d178669156fe0fdd10ae96.png\" alt=\"image-20221020134533324\"></p>\n<p>如果直接在容器里面建立一个用户，进行增删改查，是没有权限的。例如我这里的test用户。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/b86805c6c426c736260790d05d39a6a1/f705f064ab72570a50ae80aae723786e.png\" alt=\"image-20221020134644235\"></p>\n<p>但是如果我将test用户加入到容器李同gid的files用户组里面</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/b86805c6c426c736260790d05d39a6a1/f57afcc27ca419f27e4e71568cecec9b.png\" alt=\"image-20221020134731387\"></p>\n<p>那就是有权限的，和宿主机共享一套。</p>\n<p>完美实现了权限的管理。</p>\n<p>当然很多容器的默认用户是root。可以在一定程度实现越权。这个就看怎么操作了。</p>\n"},{"_content":"# 思路来源之一\n\n两个仓库\n\n- https://github.com/kengerlwl/sub-web 用来做链接转化为clash\n- https://github.com/freefq/free 收集了大量免费的节点，并提供了订阅链接\n\n\n\n# 用法\n\n从free获取了大量免费节点后，然后用转换器转换为clash可以使用的链接\n\n- clash使用自动选择最快的节点\n\n  ","source":"_posts/代理/免费机场搭建.md","raw":"# 思路来源之一\n\n两个仓库\n\n- https://github.com/kengerlwl/sub-web 用来做链接转化为clash\n- https://github.com/freefq/free 收集了大量免费的节点，并提供了订阅链接\n\n\n\n# 用法\n\n从free获取了大量免费节点后，然后用转换器转换为clash可以使用的链接\n\n- clash使用自动选择最快的节点\n\n  ","slug":"代理/免费机场搭建","published":1,"date":"2023-02-27T11:33:23.574Z","updated":"2023-02-27T11:34:33.133Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsyc2000x0gcnafs6z5ba","content":"<h1 id=\"思路来源之一\"><a href=\"#思路来源之一\" class=\"headerlink\" title=\"思路来源之一\"></a>思路来源之一</h1><p>两个仓库</p>\n<ul>\n<li><a href=\"https://github.com/kengerlwl/sub-web\" target=\"_blank\" rel=\"noopener\">https://github.com/kengerlwl/sub-web</a> 用来做链接转化为clash</li>\n<li><a href=\"https://github.com/freefq/free\" target=\"_blank\" rel=\"noopener\">https://github.com/freefq/free</a> 收集了大量免费的节点，并提供了订阅链接</li>\n</ul>\n<h1 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h1><p>从free获取了大量免费节点后，然后用转换器转换为clash可以使用的链接</p>\n<ul>\n<li>clash使用自动选择最快的节点</li>\n</ul>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"思路来源之一\"><a href=\"#思路来源之一\" class=\"headerlink\" title=\"思路来源之一\"></a>思路来源之一</h1><p>两个仓库</p>\n<ul>\n<li><a href=\"https://github.com/kengerlwl/sub-web\" target=\"_blank\" rel=\"noopener\">https://github.com/kengerlwl/sub-web</a> 用来做链接转化为clash</li>\n<li><a href=\"https://github.com/freefq/free\" target=\"_blank\" rel=\"noopener\">https://github.com/freefq/free</a> 收集了大量免费的节点，并提供了订阅链接</li>\n</ul>\n<h1 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h1><p>从free获取了大量免费节点后，然后用转换器转换为clash可以使用的链接</p>\n<ul>\n<li>clash使用自动选择最快的节点</li>\n</ul>\n"},{"_content":"# docker 学习与使用\n\n## docker介绍\nDocker：容器，可以理解成一个“黑盒”。在项目变得庞大以后，往往我们会疲于管理整个项目的部署和维护。如果我们将整个项目用一个“容器”装起来，那么我们仅仅只用维护一个配置文件告诉计算机每次部署要把什么东西装进“容器”，甚至借用一些工具把这个过程自动化，部署就会变得很方便。\n\n### docker 结构\nDocker 包含三个基本概念，分别是镜像（Image）、容器（Container）和仓库（Repository）。镜像是 Docker 运行容器的前提，仓库是存放镜像的场所，可见镜像更是Docker的核心。\n\n## docker安装\n\n- windows直接去官网下载应用程序\n- linux可以直接用包管理工具下载安装包\n\n\n## docker的配置\n\n先在项目下创建一个文件`Dockerfile`。\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/ebe096f1da2738297e7b6413ebbe2ee8.png)\n\n编辑`Dockerfile`文件：\n`Dockerfile`文件的详解[link](https://blog.csdn.net/qq_39626154/article/details/82787528)\n我这里以一个flask项目为例。运行hello程序在`./app/test.py`\n```\n#基于的基础镜像\nFROM python:3.7.9\n#代码添加到flaskhello文件夹\nADD . /flaskhello\n# 设置flaskhello文件夹是工作目录\nWORKDIR /flaskhello\n\n\n# 安装支持,安装依赖文件，执行前置，可以执行很多命令。\nRUN pip install -r requirements.txt\nCMD [\"python\", \"./app/test.py\"]  #最后运行的启动命令\n```\n\n**Dockerfile详解**\n```\ndockerfile常用命令\nFROM：基础镜像，FROM命令必须是dockfile的首个命令\nLABEL：为镜像生成元数据标签信息。\nUSER：指定运行容器时的用户名或UID，后续RUN也会使用指定用户\nRUN：RUN命令是Dockfile执行命令的核心部分。它接受命令作为参数并用于创建镜像。每条RUN命令在当前镜像基础上执行，并且会提交一个新镜像层。\nWORKDIR：设置CMD指明的命令的运行目录。为后续的RUN、CMD、ENTRYPOINT、ADD指令配置工作目录。\nENV：容器启动的环境变量\nARG：构建环境的环境变量\nCOPY：复制文件到镜像中,格式： COPY 源路径 目标路径 ：COPY指令和ADD指令功能和使用方式类似。只是COPY指令不会做自动解压工作。\nADD： 拷复制文件到镜像中,格式： ADD 源路径 目标路径\nCMD：容器运行时执行的默认命令\nENTRYPOINT：指定容器的“入口”\nHEALTHCHECK：容器健康状态检查\n```\n\n**关于CMD命令**：\n一定要使得该命令运行后保持前台，否则容器就会自动关闭。这是docker容器本质上是进程的概念\n\n## 构建镜像与运行\n\n构建：\n```\n\n# 先跳转到项目根文件目录下（也就是含有Dockerfile的文件目录下）\ndocker build -t dockerdemo:v1 . # 最后一个.实际指定当前的构建目录，dockerdemo(注意只能用小写)是该docker的名字,v1是tag\n```\n结果\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/1dd8e2ef74b08c85edaff3ce485a9f8b.png)\n\n\n\n运行\n```\n# 3000是你要映射到服务器上的端口，5000是容器里面需要被映射出来的端口，demo:v1 是需要运行的容器\ndocker run -p 3000:5000 demo:v1\n\n```\n\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/938487a0270762fa06ef9dd805703815.png)\n\n访问\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/6a0342a07e2f7e40cc52440c80091133.png)\n\n\n## 容器的管理\n\n\n删除不需要的镜像，和容器\n\n查看所有的容器\n```\ndocker ps -a\n```\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/fa18eadc8f8e7155bd9f2cc67aa308de.png)\n\n\n停止和删除容器\n```\n#如何停止容器\ndocker stop + 容器id\n# 删除容器id\ndocker rm + 容器id\n\n```\n\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/11454b741864a4a26be4f6f7550d5187.png)\n\n\n要先把镜像的容器都关了，才能删除相关镜像\n\n查看当前有哪些镜像\n```\ndocker images # 查看所有镜像及其信息\n\ndocker images -q  # 输出所有镜像的id\n```\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/edb762924a89a9174f15ad4eff34b4ca.png)\n\n删除镜像\n删除images（镜像），通过image的id来指定删除谁\n```\ndocker rmi <image id>\n```\n要删除全部image（镜像）的话\n```\ndocker rmi $(docker images -q)\n```\n只删除未被使用的资源\n- Docker 提供了方便的 docker system prune 命令来删除那些已停止的容器、dangling 镜像、未被容器引用的 network 和构建过程中的 cache：\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/98587da7500a3158d54cd67bfc4fb1aa.png)\n\n\n在本地的镜像更新之后，就会出现类似图中红框内的 <none> 镜像。这表示旧的镜像已经不再被引用了，此时它们就变成了 dangling images。如果使用 -a 参数，你还会发现另外一种类型的 <none> 镜像，它们的 repository 和 tag 列都表现为 <none>：\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/fa2ce9e682aa051bef2a1ef757d8f6ff.png)\n    这些镜像被称为 intermediate 镜像(就是其它镜像依赖的层)。\n\n**我们还可在不同在子命令下执行 prune，这样删除的就是某类资源：**\n```\ndocker container prune # 删除所有退出状态的容器\ndocker volume prune # 删除未被使用的数据卷\ndocker image prune # 删除 dangling 或所有未被使用的镜像\n```\n\n\n\n\n\n## 容器的网络模式\n[参考文](https://www.cnblogs.com/feng0815/p/14192177.html)\n    \n\n### 关于docker的端口映射增改问题。\n\n一般来说，在镜像运行成容器后就不能再更改端口映射了，并且下次启动原来的映射配置也在。\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/4c63fcb2c8fe102955cc0ad9140dd734.png)\n\n想要改变两个办法。\n**法一：**\n    更改配置docker文件，具体上网查询\n**法二：**\n    把现在的容器commit成镜像，然后再把镜像运行成容器，并且在运行的时候声明端口映射。\n\n## 进入容器内部\n好文的连接[link](https://cloud.tencent.com/developer/article/1691352)\n    \n    \n### 1,新建centos的镜像和容器。\n```\ndocker pull centos\n```\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/3ce9b6dbbc468ae90b1064260374b386.png)\n\n### 2,对这个镜像创建容器（也就是说运行它）\n\n    docker container run -it -p 8888:8080 -v /opt/app:/opt/app --name=python-server 470671670cac bash\n\n命令文档查看：docker container run --help\n\n-it : 交互式终端（interactive terminal） ，也就是创建容器后进入容器。\n\n-p 8888:8080 :  端口映射（port），将容器端口映射到宿主机端口（8888：宿主机端口，8080：容器端口），宿主机端口 8888 确认能被外网访问。\n\n-v /opt/app:/opt/app：数据卷（volumn），将宿主机的数据（应用程序代码，配置文件等等）挂载到容器指定路径下，实现数据存储的持久化（如果没有数据挂载的话，容器销毁，容器中的数据会自动消失）。\n\n--name=python-server: 新的容器的名称\n\n 470671670cac：镜像ID（imageID），当然也可以是 imageName + tag（docker.io/centos:latest）\n\nbash：跟 -it 命令结合在一起操作，使容器创建后处于前端，一般是 /bin/bash，我这是bash。\n    \n结果：\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/45ca190d5f75ee947bc815474dd06af7.png)\n\n查看所有容器\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/7bd6c5162f6f969d5ee8377a9ac7e86d.png)\n\n**不中断退出容器**\n可以通过 Ctrl+p，Ctrl+q 退出容器，但容器还是处于运行状态（Up）。\n或者输入命令`exit`可以直接退出，但是容器也关闭了\n\n\n#### 查看容器的信息（例如ip等）\n`docker inspect container_id`\n\n然后有结果\n\n\n![image-20220821221517801](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/c267da1bddcfbf8c21c0375ef8dea4a6.png)    \n### 进入容器\n\n**方法一**\n`docker container exec -it 5de4e81a2e20(containerID或者容器的名字) bash（这个bash可以换成其他命令）`\n\n执行命令的方式：\n- 先启动容器\n- 然后使用exec命令去执行命令\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/18d30748b5631941cae418fdc85bd5f3.png)\n\n\n其他容器命令\n```\n容器其他相关操作命令：\n\n查看容器 ip（退出容器，在宿主机上，最好另起一个客户端）: docker container inspect  1427087a62a7（containerID）\n\n\n容器启动（交互式）：docker container start  -i containerID\n\n关闭容器：docker container stop containerID\n\n容器重启动：docker container restart containerID\n\n删除容器（-f : force 强制删除，能删除处于运行状态的容器）：docker container rm -f  containerID\n\n查看所有容器的容器ID：docker container ls -a -q\n\n删除所有容器：docker contianer rm $(docker container ls -a -q)\n\n在交互式容器中退出，退出启动容器： Ctrl + d\n\n在交互式容器中退出，但是不退出启动容器：先按 Ctrl + p 后 Ctrl + q\n\n使用 -d 启动容器并一直在后台运行 SSH作为第一进程启动：docker container run -d -p 50001:22 imageID /usr/sbin/sshd -D \n```\n\n\n​    \n### 容器内的使用\n\n我这里用的centos最新版也就是centos8.\n执行yum有个bug:`Failed to download metadata for repo 'appstream......`\n办法是进入容器执行\n```\ncd /etc/yum.repos.d/\nsed -i 's/mirrorlist/#mirrorlist/g' /etc/yum.repos.d/CentOS-*\nsed -i 's|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g' /etc/yum.repos.d/CentOS-* \n```\n\n然后就可以使用yum安装各种库和程序了\n    \n\n**改变系统的密码**\n```\n    安装 passwd（设置密码）： yum install -y passwd\n    设置密码：passwd root\n\n```\n\n**安装ssh并启动**\n\n```\n作为 python 服务的守护程序，防止容器闪退（一直夯在容器中）；\n\n安装命令： yum install -y openssh-server\n\nssh 配置文件 sshd_config 路径： /etc/ssh/sshd_config\n\nssh 启动文件路径：/usr/sbin/\n启动 SSH: /usr/sbin/sshd\n\n\n```\n启动前修改\n修改/etc/ssh/sshd_config这个ssh配置文件\n    \n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/ae0cd55ec6eb40ecc231bb3147e68e58.png)\n\n退出后访问\n\n\n### 将容器打包成镜像\n\n在运行容器时指定映射端口运行后，如果想要添加新的端口映射，可以使用以下两种方式：\n\n**方式一：将现有的容器打包成镜像，然后在使用新的镜像运行容器时重新指定要映射的端口**\n\n大概过程如下：\n\n先停止现有容器\n\n`docker stop container-name`\n将容器commit成为一个镜像\n\n`docker commit container-name  new-image-name`\n用新镜像运行容器\n    \n结果\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/a5336f35ba2098dc9cb5ba845c33baf3.png)\n\n然后运行新的镜像\n`docker run -it -d --name container-name（or id） -p p1:p1 -p p2:p2 new-image-name`\n\n两个 -p 指定多个端口映射\n\n**宿主机ssh连接入容器  **  \n\n我这里将外部的2020端口映射到容器里面的22端口。\n用特定的连接工具**MobaXterm**\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/6cf0b06d120b3f20740f150e072e9efd.png)\n\n然后输入用户名和密码：成功\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/d7bd208b5e78d93bd4304461bf75d008.png)\n\n## docker Hub的使用\n\n先在hub中建立一个名叫centos_demo的仓库，我的用户名是`${username}`\n\n在本地登录docker\n```\n#docker login\nLogin with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.\nUsername: ${username}\nPassword:\nLogin Succeeded\n```\n\n准备在本地提交，先给images打标签\n\n```\ndocker tag 镜像名 账号名/仓库名：版本号\n账号名是登陆的账号名，仓库是远端配置的仓库名，版本号自己定义一个就好。到时候pull下来也是pull这个账号名/仓库名：版本号就好\n```\n\n然后提交镜像push\n```\ndocker push 账号名/仓库名：版本号\n```","source":"_posts/服务器相关/docker 使用简单教程.md","raw":"# docker 学习与使用\n\n## docker介绍\nDocker：容器，可以理解成一个“黑盒”。在项目变得庞大以后，往往我们会疲于管理整个项目的部署和维护。如果我们将整个项目用一个“容器”装起来，那么我们仅仅只用维护一个配置文件告诉计算机每次部署要把什么东西装进“容器”，甚至借用一些工具把这个过程自动化，部署就会变得很方便。\n\n### docker 结构\nDocker 包含三个基本概念，分别是镜像（Image）、容器（Container）和仓库（Repository）。镜像是 Docker 运行容器的前提，仓库是存放镜像的场所，可见镜像更是Docker的核心。\n\n## docker安装\n\n- windows直接去官网下载应用程序\n- linux可以直接用包管理工具下载安装包\n\n\n## docker的配置\n\n先在项目下创建一个文件`Dockerfile`。\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/ebe096f1da2738297e7b6413ebbe2ee8.png)\n\n编辑`Dockerfile`文件：\n`Dockerfile`文件的详解[link](https://blog.csdn.net/qq_39626154/article/details/82787528)\n我这里以一个flask项目为例。运行hello程序在`./app/test.py`\n```\n#基于的基础镜像\nFROM python:3.7.9\n#代码添加到flaskhello文件夹\nADD . /flaskhello\n# 设置flaskhello文件夹是工作目录\nWORKDIR /flaskhello\n\n\n# 安装支持,安装依赖文件，执行前置，可以执行很多命令。\nRUN pip install -r requirements.txt\nCMD [\"python\", \"./app/test.py\"]  #最后运行的启动命令\n```\n\n**Dockerfile详解**\n```\ndockerfile常用命令\nFROM：基础镜像，FROM命令必须是dockfile的首个命令\nLABEL：为镜像生成元数据标签信息。\nUSER：指定运行容器时的用户名或UID，后续RUN也会使用指定用户\nRUN：RUN命令是Dockfile执行命令的核心部分。它接受命令作为参数并用于创建镜像。每条RUN命令在当前镜像基础上执行，并且会提交一个新镜像层。\nWORKDIR：设置CMD指明的命令的运行目录。为后续的RUN、CMD、ENTRYPOINT、ADD指令配置工作目录。\nENV：容器启动的环境变量\nARG：构建环境的环境变量\nCOPY：复制文件到镜像中,格式： COPY 源路径 目标路径 ：COPY指令和ADD指令功能和使用方式类似。只是COPY指令不会做自动解压工作。\nADD： 拷复制文件到镜像中,格式： ADD 源路径 目标路径\nCMD：容器运行时执行的默认命令\nENTRYPOINT：指定容器的“入口”\nHEALTHCHECK：容器健康状态检查\n```\n\n**关于CMD命令**：\n一定要使得该命令运行后保持前台，否则容器就会自动关闭。这是docker容器本质上是进程的概念\n\n## 构建镜像与运行\n\n构建：\n```\n\n# 先跳转到项目根文件目录下（也就是含有Dockerfile的文件目录下）\ndocker build -t dockerdemo:v1 . # 最后一个.实际指定当前的构建目录，dockerdemo(注意只能用小写)是该docker的名字,v1是tag\n```\n结果\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/1dd8e2ef74b08c85edaff3ce485a9f8b.png)\n\n\n\n运行\n```\n# 3000是你要映射到服务器上的端口，5000是容器里面需要被映射出来的端口，demo:v1 是需要运行的容器\ndocker run -p 3000:5000 demo:v1\n\n```\n\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/938487a0270762fa06ef9dd805703815.png)\n\n访问\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/6a0342a07e2f7e40cc52440c80091133.png)\n\n\n## 容器的管理\n\n\n删除不需要的镜像，和容器\n\n查看所有的容器\n```\ndocker ps -a\n```\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/fa18eadc8f8e7155bd9f2cc67aa308de.png)\n\n\n停止和删除容器\n```\n#如何停止容器\ndocker stop + 容器id\n# 删除容器id\ndocker rm + 容器id\n\n```\n\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/11454b741864a4a26be4f6f7550d5187.png)\n\n\n要先把镜像的容器都关了，才能删除相关镜像\n\n查看当前有哪些镜像\n```\ndocker images # 查看所有镜像及其信息\n\ndocker images -q  # 输出所有镜像的id\n```\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/edb762924a89a9174f15ad4eff34b4ca.png)\n\n删除镜像\n删除images（镜像），通过image的id来指定删除谁\n```\ndocker rmi <image id>\n```\n要删除全部image（镜像）的话\n```\ndocker rmi $(docker images -q)\n```\n只删除未被使用的资源\n- Docker 提供了方便的 docker system prune 命令来删除那些已停止的容器、dangling 镜像、未被容器引用的 network 和构建过程中的 cache：\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/98587da7500a3158d54cd67bfc4fb1aa.png)\n\n\n在本地的镜像更新之后，就会出现类似图中红框内的 <none> 镜像。这表示旧的镜像已经不再被引用了，此时它们就变成了 dangling images。如果使用 -a 参数，你还会发现另外一种类型的 <none> 镜像，它们的 repository 和 tag 列都表现为 <none>：\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/fa2ce9e682aa051bef2a1ef757d8f6ff.png)\n    这些镜像被称为 intermediate 镜像(就是其它镜像依赖的层)。\n\n**我们还可在不同在子命令下执行 prune，这样删除的就是某类资源：**\n```\ndocker container prune # 删除所有退出状态的容器\ndocker volume prune # 删除未被使用的数据卷\ndocker image prune # 删除 dangling 或所有未被使用的镜像\n```\n\n\n\n\n\n## 容器的网络模式\n[参考文](https://www.cnblogs.com/feng0815/p/14192177.html)\n    \n\n### 关于docker的端口映射增改问题。\n\n一般来说，在镜像运行成容器后就不能再更改端口映射了，并且下次启动原来的映射配置也在。\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/4c63fcb2c8fe102955cc0ad9140dd734.png)\n\n想要改变两个办法。\n**法一：**\n    更改配置docker文件，具体上网查询\n**法二：**\n    把现在的容器commit成镜像，然后再把镜像运行成容器，并且在运行的时候声明端口映射。\n\n## 进入容器内部\n好文的连接[link](https://cloud.tencent.com/developer/article/1691352)\n    \n    \n### 1,新建centos的镜像和容器。\n```\ndocker pull centos\n```\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/3ce9b6dbbc468ae90b1064260374b386.png)\n\n### 2,对这个镜像创建容器（也就是说运行它）\n\n    docker container run -it -p 8888:8080 -v /opt/app:/opt/app --name=python-server 470671670cac bash\n\n命令文档查看：docker container run --help\n\n-it : 交互式终端（interactive terminal） ，也就是创建容器后进入容器。\n\n-p 8888:8080 :  端口映射（port），将容器端口映射到宿主机端口（8888：宿主机端口，8080：容器端口），宿主机端口 8888 确认能被外网访问。\n\n-v /opt/app:/opt/app：数据卷（volumn），将宿主机的数据（应用程序代码，配置文件等等）挂载到容器指定路径下，实现数据存储的持久化（如果没有数据挂载的话，容器销毁，容器中的数据会自动消失）。\n\n--name=python-server: 新的容器的名称\n\n 470671670cac：镜像ID（imageID），当然也可以是 imageName + tag（docker.io/centos:latest）\n\nbash：跟 -it 命令结合在一起操作，使容器创建后处于前端，一般是 /bin/bash，我这是bash。\n    \n结果：\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/45ca190d5f75ee947bc815474dd06af7.png)\n\n查看所有容器\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/7bd6c5162f6f969d5ee8377a9ac7e86d.png)\n\n**不中断退出容器**\n可以通过 Ctrl+p，Ctrl+q 退出容器，但容器还是处于运行状态（Up）。\n或者输入命令`exit`可以直接退出，但是容器也关闭了\n\n\n#### 查看容器的信息（例如ip等）\n`docker inspect container_id`\n\n然后有结果\n\n\n![image-20220821221517801](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/c267da1bddcfbf8c21c0375ef8dea4a6.png)    \n### 进入容器\n\n**方法一**\n`docker container exec -it 5de4e81a2e20(containerID或者容器的名字) bash（这个bash可以换成其他命令）`\n\n执行命令的方式：\n- 先启动容器\n- 然后使用exec命令去执行命令\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/18d30748b5631941cae418fdc85bd5f3.png)\n\n\n其他容器命令\n```\n容器其他相关操作命令：\n\n查看容器 ip（退出容器，在宿主机上，最好另起一个客户端）: docker container inspect  1427087a62a7（containerID）\n\n\n容器启动（交互式）：docker container start  -i containerID\n\n关闭容器：docker container stop containerID\n\n容器重启动：docker container restart containerID\n\n删除容器（-f : force 强制删除，能删除处于运行状态的容器）：docker container rm -f  containerID\n\n查看所有容器的容器ID：docker container ls -a -q\n\n删除所有容器：docker contianer rm $(docker container ls -a -q)\n\n在交互式容器中退出，退出启动容器： Ctrl + d\n\n在交互式容器中退出，但是不退出启动容器：先按 Ctrl + p 后 Ctrl + q\n\n使用 -d 启动容器并一直在后台运行 SSH作为第一进程启动：docker container run -d -p 50001:22 imageID /usr/sbin/sshd -D \n```\n\n\n​    \n### 容器内的使用\n\n我这里用的centos最新版也就是centos8.\n执行yum有个bug:`Failed to download metadata for repo 'appstream......`\n办法是进入容器执行\n```\ncd /etc/yum.repos.d/\nsed -i 's/mirrorlist/#mirrorlist/g' /etc/yum.repos.d/CentOS-*\nsed -i 's|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g' /etc/yum.repos.d/CentOS-* \n```\n\n然后就可以使用yum安装各种库和程序了\n    \n\n**改变系统的密码**\n```\n    安装 passwd（设置密码）： yum install -y passwd\n    设置密码：passwd root\n\n```\n\n**安装ssh并启动**\n\n```\n作为 python 服务的守护程序，防止容器闪退（一直夯在容器中）；\n\n安装命令： yum install -y openssh-server\n\nssh 配置文件 sshd_config 路径： /etc/ssh/sshd_config\n\nssh 启动文件路径：/usr/sbin/\n启动 SSH: /usr/sbin/sshd\n\n\n```\n启动前修改\n修改/etc/ssh/sshd_config这个ssh配置文件\n    \n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/ae0cd55ec6eb40ecc231bb3147e68e58.png)\n\n退出后访问\n\n\n### 将容器打包成镜像\n\n在运行容器时指定映射端口运行后，如果想要添加新的端口映射，可以使用以下两种方式：\n\n**方式一：将现有的容器打包成镜像，然后在使用新的镜像运行容器时重新指定要映射的端口**\n\n大概过程如下：\n\n先停止现有容器\n\n`docker stop container-name`\n将容器commit成为一个镜像\n\n`docker commit container-name  new-image-name`\n用新镜像运行容器\n    \n结果\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/a5336f35ba2098dc9cb5ba845c33baf3.png)\n\n然后运行新的镜像\n`docker run -it -d --name container-name（or id） -p p1:p1 -p p2:p2 new-image-name`\n\n两个 -p 指定多个端口映射\n\n**宿主机ssh连接入容器  **  \n\n我这里将外部的2020端口映射到容器里面的22端口。\n用特定的连接工具**MobaXterm**\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/6cf0b06d120b3f20740f150e072e9efd.png)\n\n然后输入用户名和密码：成功\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/d7bd208b5e78d93bd4304461bf75d008.png)\n\n## docker Hub的使用\n\n先在hub中建立一个名叫centos_demo的仓库，我的用户名是`${username}`\n\n在本地登录docker\n```\n#docker login\nLogin with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.\nUsername: ${username}\nPassword:\nLogin Succeeded\n```\n\n准备在本地提交，先给images打标签\n\n```\ndocker tag 镜像名 账号名/仓库名：版本号\n账号名是登陆的账号名，仓库是远端配置的仓库名，版本号自己定义一个就好。到时候pull下来也是pull这个账号名/仓库名：版本号就好\n```\n\n然后提交镜像push\n```\ndocker push 账号名/仓库名：版本号\n```","slug":"服务器相关/docker 使用简单教程","published":1,"date":"2023-02-27T11:33:23.586Z","updated":"2023-02-27T11:34:33.146Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsyc3000y0gcnjisesk8t","content":"<h1 id=\"docker-学习与使用\"><a href=\"#docker-学习与使用\" class=\"headerlink\" title=\"docker 学习与使用\"></a>docker 学习与使用</h1><h2 id=\"docker介绍\"><a href=\"#docker介绍\" class=\"headerlink\" title=\"docker介绍\"></a>docker介绍</h2><p>Docker：容器，可以理解成一个“黑盒”。在项目变得庞大以后，往往我们会疲于管理整个项目的部署和维护。如果我们将整个项目用一个“容器”装起来，那么我们仅仅只用维护一个配置文件告诉计算机每次部署要把什么东西装进“容器”，甚至借用一些工具把这个过程自动化，部署就会变得很方便。</p>\n<h3 id=\"docker-结构\"><a href=\"#docker-结构\" class=\"headerlink\" title=\"docker 结构\"></a>docker 结构</h3><p>Docker 包含三个基本概念，分别是镜像（Image）、容器（Container）和仓库（Repository）。镜像是 Docker 运行容器的前提，仓库是存放镜像的场所，可见镜像更是Docker的核心。</p>\n<h2 id=\"docker安装\"><a href=\"#docker安装\" class=\"headerlink\" title=\"docker安装\"></a>docker安装</h2><ul>\n<li>windows直接去官网下载应用程序</li>\n<li>linux可以直接用包管理工具下载安装包</li>\n</ul>\n<h2 id=\"docker的配置\"><a href=\"#docker的配置\" class=\"headerlink\" title=\"docker的配置\"></a>docker的配置</h2><p>先在项目下创建一个文件<code>Dockerfile</code>。<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/ebe096f1da2738297e7b6413ebbe2ee8.png\" alt></p>\n<p>编辑<code>Dockerfile</code>文件：<br><code>Dockerfile</code>文件的详解<a href=\"https://blog.csdn.net/qq_39626154/article/details/82787528\" target=\"_blank\" rel=\"noopener\">link</a><br>我这里以一个flask项目为例。运行hello程序在<code>./app/test.py</code></p>\n<pre><code>#基于的基础镜像\nFROM python:3.7.9\n#代码添加到flaskhello文件夹\nADD . /flaskhello\n# 设置flaskhello文件夹是工作目录\nWORKDIR /flaskhello\n\n\n# 安装支持,安装依赖文件，执行前置，可以执行很多命令。\nRUN pip install -r requirements.txt\nCMD [&quot;python&quot;, &quot;./app/test.py&quot;]  #最后运行的启动命令</code></pre><p><strong>Dockerfile详解</strong></p>\n<pre><code>dockerfile常用命令\nFROM：基础镜像，FROM命令必须是dockfile的首个命令\nLABEL：为镜像生成元数据标签信息。\nUSER：指定运行容器时的用户名或UID，后续RUN也会使用指定用户\nRUN：RUN命令是Dockfile执行命令的核心部分。它接受命令作为参数并用于创建镜像。每条RUN命令在当前镜像基础上执行，并且会提交一个新镜像层。\nWORKDIR：设置CMD指明的命令的运行目录。为后续的RUN、CMD、ENTRYPOINT、ADD指令配置工作目录。\nENV：容器启动的环境变量\nARG：构建环境的环境变量\nCOPY：复制文件到镜像中,格式： COPY 源路径 目标路径 ：COPY指令和ADD指令功能和使用方式类似。只是COPY指令不会做自动解压工作。\nADD： 拷复制文件到镜像中,格式： ADD 源路径 目标路径\nCMD：容器运行时执行的默认命令\nENTRYPOINT：指定容器的“入口”\nHEALTHCHECK：容器健康状态检查</code></pre><p><strong>关于CMD命令</strong>：<br>一定要使得该命令运行后保持前台，否则容器就会自动关闭。这是docker容器本质上是进程的概念</p>\n<h2 id=\"构建镜像与运行\"><a href=\"#构建镜像与运行\" class=\"headerlink\" title=\"构建镜像与运行\"></a>构建镜像与运行</h2><p>构建：</p>\n<pre><code>\n# 先跳转到项目根文件目录下（也就是含有Dockerfile的文件目录下）\ndocker build -t dockerdemo:v1 . # 最后一个.实际指定当前的构建目录，dockerdemo(注意只能用小写)是该docker的名字,v1是tag</code></pre><p>结果<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/1dd8e2ef74b08c85edaff3ce485a9f8b.png\" alt></p>\n<p>运行</p>\n<pre><code># 3000是你要映射到服务器上的端口，5000是容器里面需要被映射出来的端口，demo:v1 是需要运行的容器\ndocker run -p 3000:5000 demo:v1\n</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/938487a0270762fa06ef9dd805703815.png\" alt></p>\n<p>访问<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/6a0342a07e2f7e40cc52440c80091133.png\" alt></p>\n<h2 id=\"容器的管理\"><a href=\"#容器的管理\" class=\"headerlink\" title=\"容器的管理\"></a>容器的管理</h2><p>删除不需要的镜像，和容器</p>\n<p>查看所有的容器</p>\n<pre><code>docker ps -a</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/fa18eadc8f8e7155bd9f2cc67aa308de.png\" alt></p>\n<p>停止和删除容器</p>\n<pre><code>#如何停止容器\ndocker stop + 容器id\n# 删除容器id\ndocker rm + 容器id\n</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/11454b741864a4a26be4f6f7550d5187.png\" alt></p>\n<p>要先把镜像的容器都关了，才能删除相关镜像</p>\n<p>查看当前有哪些镜像</p>\n<pre><code>docker images # 查看所有镜像及其信息\n\ndocker images -q  # 输出所有镜像的id</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/edb762924a89a9174f15ad4eff34b4ca.png\" alt></p>\n<p>删除镜像<br>删除images（镜像），通过image的id来指定删除谁</p>\n<pre><code>docker rmi &lt;image id&gt;</code></pre><p>要删除全部image（镜像）的话</p>\n<pre><code>docker rmi $(docker images -q)</code></pre><p>只删除未被使用的资源</p>\n<ul>\n<li>Docker 提供了方便的 docker system prune 命令来删除那些已停止的容器、dangling 镜像、未被容器引用的 network 和构建过程中的 cache：<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/98587da7500a3158d54cd67bfc4fb1aa.png\" alt></li>\n</ul>\n<p>在本地的镜像更新之后，就会出现类似图中红框内的 <none> 镜像。这表示旧的镜像已经不再被引用了，此时它们就变成了 dangling images。如果使用 -a 参数，你还会发现另外一种类型的 <none> 镜像，它们的 repository 和 tag 列都表现为 <none>：<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/fa2ce9e682aa051bef2a1ef757d8f6ff.png\" alt><br>    这些镜像被称为 intermediate 镜像(就是其它镜像依赖的层)。</none></none></none></p>\n<p><strong>我们还可在不同在子命令下执行 prune，这样删除的就是某类资源：</strong></p>\n<pre><code>docker container prune # 删除所有退出状态的容器\ndocker volume prune # 删除未被使用的数据卷\ndocker image prune # 删除 dangling 或所有未被使用的镜像</code></pre><h2 id=\"容器的网络模式\"><a href=\"#容器的网络模式\" class=\"headerlink\" title=\"容器的网络模式\"></a>容器的网络模式</h2><p><a href=\"https://www.cnblogs.com/feng0815/p/14192177.html\" target=\"_blank\" rel=\"noopener\">参考文</a></p>\n<h3 id=\"关于docker的端口映射增改问题。\"><a href=\"#关于docker的端口映射增改问题。\" class=\"headerlink\" title=\"关于docker的端口映射增改问题。\"></a>关于docker的端口映射增改问题。</h3><p>一般来说，在镜像运行成容器后就不能再更改端口映射了，并且下次启动原来的映射配置也在。<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/4c63fcb2c8fe102955cc0ad9140dd734.png\" alt></p>\n<p>想要改变两个办法。<br><strong>法一：</strong><br>    更改配置docker文件，具体上网查询<br><strong>法二：</strong><br>    把现在的容器commit成镜像，然后再把镜像运行成容器，并且在运行的时候声明端口映射。</p>\n<h2 id=\"进入容器内部\"><a href=\"#进入容器内部\" class=\"headerlink\" title=\"进入容器内部\"></a>进入容器内部</h2><p>好文的连接<a href=\"https://cloud.tencent.com/developer/article/1691352\" target=\"_blank\" rel=\"noopener\">link</a></p>\n<h3 id=\"1-新建centos的镜像和容器。\"><a href=\"#1-新建centos的镜像和容器。\" class=\"headerlink\" title=\"1,新建centos的镜像和容器。\"></a>1,新建centos的镜像和容器。</h3><pre><code>docker pull centos</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/3ce9b6dbbc468ae90b1064260374b386.png\" alt></p>\n<h3 id=\"2-对这个镜像创建容器（也就是说运行它）\"><a href=\"#2-对这个镜像创建容器（也就是说运行它）\" class=\"headerlink\" title=\"2,对这个镜像创建容器（也就是说运行它）\"></a>2,对这个镜像创建容器（也就是说运行它）</h3><pre><code>docker container run -it -p 8888:8080 -v /opt/app:/opt/app --name=python-server 470671670cac bash</code></pre><p>命令文档查看：docker container run –help</p>\n<p>-it : 交互式终端（interactive terminal） ，也就是创建容器后进入容器。</p>\n<p>-p 8888:8080 :  端口映射（port），将容器端口映射到宿主机端口（8888：宿主机端口，8080：容器端口），宿主机端口 8888 确认能被外网访问。</p>\n<p>-v /opt/app:/opt/app：数据卷（volumn），将宿主机的数据（应用程序代码，配置文件等等）挂载到容器指定路径下，实现数据存储的持久化（如果没有数据挂载的话，容器销毁，容器中的数据会自动消失）。</p>\n<p>–name=python-server: 新的容器的名称</p>\n<p> 470671670cac：镜像ID（imageID），当然也可以是 imageName + tag（docker.io/centos:latest）</p>\n<p>bash：跟 -it 命令结合在一起操作，使容器创建后处于前端，一般是 /bin/bash，我这是bash。</p>\n<p>结果：<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/45ca190d5f75ee947bc815474dd06af7.png\" alt></p>\n<p>查看所有容器<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/7bd6c5162f6f969d5ee8377a9ac7e86d.png\" alt></p>\n<p><strong>不中断退出容器</strong><br>可以通过 Ctrl+p，Ctrl+q 退出容器，但容器还是处于运行状态（Up）。<br>或者输入命令<code>exit</code>可以直接退出，但是容器也关闭了</p>\n<h4 id=\"查看容器的信息（例如ip等）\"><a href=\"#查看容器的信息（例如ip等）\" class=\"headerlink\" title=\"查看容器的信息（例如ip等）\"></a>查看容器的信息（例如ip等）</h4><p><code>docker inspect container_id</code></p>\n<p>然后有结果</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/c267da1bddcfbf8c21c0375ef8dea4a6.png\" alt=\"image-20220821221517801\">    </p>\n<h3 id=\"进入容器\"><a href=\"#进入容器\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h3><p><strong>方法一</strong><br><code>docker container exec -it 5de4e81a2e20(containerID或者容器的名字) bash（这个bash可以换成其他命令）</code></p>\n<p>执行命令的方式：</p>\n<ul>\n<li>先启动容器</li>\n<li>然后使用exec命令去执行命令<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/18d30748b5631941cae418fdc85bd5f3.png\" alt></li>\n</ul>\n<p>其他容器命令</p>\n<pre><code>容器其他相关操作命令：\n\n查看容器 ip（退出容器，在宿主机上，最好另起一个客户端）: docker container inspect  1427087a62a7（containerID）\n\n\n容器启动（交互式）：docker container start  -i containerID\n\n关闭容器：docker container stop containerID\n\n容器重启动：docker container restart containerID\n\n删除容器（-f : force 强制删除，能删除处于运行状态的容器）：docker container rm -f  containerID\n\n查看所有容器的容器ID：docker container ls -a -q\n\n删除所有容器：docker contianer rm $(docker container ls -a -q)\n\n在交互式容器中退出，退出启动容器： Ctrl + d\n\n在交互式容器中退出，但是不退出启动容器：先按 Ctrl + p 后 Ctrl + q\n\n使用 -d 启动容器并一直在后台运行 SSH作为第一进程启动：docker container run -d -p 50001:22 imageID /usr/sbin/sshd -D </code></pre><p>​    </p>\n<h3 id=\"容器内的使用\"><a href=\"#容器内的使用\" class=\"headerlink\" title=\"容器内的使用\"></a>容器内的使用</h3><p>我这里用的centos最新版也就是centos8.<br>执行yum有个bug:<code>Failed to download metadata for repo &#39;appstream......</code><br>办法是进入容器执行</p>\n<pre><code>cd /etc/yum.repos.d/\nsed -i &#39;s/mirrorlist/#mirrorlist/g&#39; /etc/yum.repos.d/CentOS-*\nsed -i &#39;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#39; /etc/yum.repos.d/CentOS-* </code></pre><p>然后就可以使用yum安装各种库和程序了</p>\n<p><strong>改变系统的密码</strong></p>\n<pre><code>    安装 passwd（设置密码）： yum install -y passwd\n    设置密码：passwd root\n</code></pre><p><strong>安装ssh并启动</strong></p>\n<pre><code>作为 python 服务的守护程序，防止容器闪退（一直夯在容器中）；\n\n安装命令： yum install -y openssh-server\n\nssh 配置文件 sshd_config 路径： /etc/ssh/sshd_config\n\nssh 启动文件路径：/usr/sbin/\n启动 SSH: /usr/sbin/sshd\n\n</code></pre><p>启动前修改<br>修改/etc/ssh/sshd_config这个ssh配置文件</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/ae0cd55ec6eb40ecc231bb3147e68e58.png\" alt></p>\n<p>退出后访问</p>\n<h3 id=\"将容器打包成镜像\"><a href=\"#将容器打包成镜像\" class=\"headerlink\" title=\"将容器打包成镜像\"></a>将容器打包成镜像</h3><p>在运行容器时指定映射端口运行后，如果想要添加新的端口映射，可以使用以下两种方式：</p>\n<p><strong>方式一：将现有的容器打包成镜像，然后在使用新的镜像运行容器时重新指定要映射的端口</strong></p>\n<p>大概过程如下：</p>\n<p>先停止现有容器</p>\n<p><code>docker stop container-name</code><br>将容器commit成为一个镜像</p>\n<p><code>docker commit container-name  new-image-name</code><br>用新镜像运行容器</p>\n<p>结果<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/a5336f35ba2098dc9cb5ba845c33baf3.png\" alt></p>\n<p>然后运行新的镜像<br><code>docker run -it -d --name container-name（or id） -p p1:p1 -p p2:p2 new-image-name</code></p>\n<p>两个 -p 指定多个端口映射</p>\n<p>*<em>宿主机ssh连接入容器  *</em>  </p>\n<p>我这里将外部的2020端口映射到容器里面的22端口。<br>用特定的连接工具<strong>MobaXterm</strong><br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/6cf0b06d120b3f20740f150e072e9efd.png\" alt></p>\n<p>然后输入用户名和密码：成功<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/d7bd208b5e78d93bd4304461bf75d008.png\" alt></p>\n<h2 id=\"docker-Hub的使用\"><a href=\"#docker-Hub的使用\" class=\"headerlink\" title=\"docker Hub的使用\"></a>docker Hub的使用</h2><p>先在hub中建立一个名叫centos_demo的仓库，我的用户名是<code>${username}</code></p>\n<p>在本地登录docker</p>\n<pre><code>#docker login\nLogin with your Docker ID to push and pull images from Docker Hub. If you don&#39;t have a Docker ID, head over to https://hub.docker.com to create one.\nUsername: ${username}\nPassword:\nLogin Succeeded</code></pre><p>准备在本地提交，先给images打标签</p>\n<pre><code>docker tag 镜像名 账号名/仓库名：版本号\n账号名是登陆的账号名，仓库是远端配置的仓库名，版本号自己定义一个就好。到时候pull下来也是pull这个账号名/仓库名：版本号就好</code></pre><p>然后提交镜像push</p>\n<pre><code>docker push 账号名/仓库名：版本号</code></pre>","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"docker-学习与使用\"><a href=\"#docker-学习与使用\" class=\"headerlink\" title=\"docker 学习与使用\"></a>docker 学习与使用</h1><h2 id=\"docker介绍\"><a href=\"#docker介绍\" class=\"headerlink\" title=\"docker介绍\"></a>docker介绍</h2><p>Docker：容器，可以理解成一个“黑盒”。在项目变得庞大以后，往往我们会疲于管理整个项目的部署和维护。如果我们将整个项目用一个“容器”装起来，那么我们仅仅只用维护一个配置文件告诉计算机每次部署要把什么东西装进“容器”，甚至借用一些工具把这个过程自动化，部署就会变得很方便。</p>\n<h3 id=\"docker-结构\"><a href=\"#docker-结构\" class=\"headerlink\" title=\"docker 结构\"></a>docker 结构</h3><p>Docker 包含三个基本概念，分别是镜像（Image）、容器（Container）和仓库（Repository）。镜像是 Docker 运行容器的前提，仓库是存放镜像的场所，可见镜像更是Docker的核心。</p>\n<h2 id=\"docker安装\"><a href=\"#docker安装\" class=\"headerlink\" title=\"docker安装\"></a>docker安装</h2><ul>\n<li>windows直接去官网下载应用程序</li>\n<li>linux可以直接用包管理工具下载安装包</li>\n</ul>\n<h2 id=\"docker的配置\"><a href=\"#docker的配置\" class=\"headerlink\" title=\"docker的配置\"></a>docker的配置</h2><p>先在项目下创建一个文件<code>Dockerfile</code>。<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/ebe096f1da2738297e7b6413ebbe2ee8.png\" alt></p>\n<p>编辑<code>Dockerfile</code>文件：<br><code>Dockerfile</code>文件的详解<a href=\"https://blog.csdn.net/qq_39626154/article/details/82787528\" target=\"_blank\" rel=\"noopener\">link</a><br>我这里以一个flask项目为例。运行hello程序在<code>./app/test.py</code></p>\n<pre><code>#基于的基础镜像\nFROM python:3.7.9\n#代码添加到flaskhello文件夹\nADD . /flaskhello\n# 设置flaskhello文件夹是工作目录\nWORKDIR /flaskhello\n\n\n# 安装支持,安装依赖文件，执行前置，可以执行很多命令。\nRUN pip install -r requirements.txt\nCMD [&quot;python&quot;, &quot;./app/test.py&quot;]  #最后运行的启动命令</code></pre><p><strong>Dockerfile详解</strong></p>\n<pre><code>dockerfile常用命令\nFROM：基础镜像，FROM命令必须是dockfile的首个命令\nLABEL：为镜像生成元数据标签信息。\nUSER：指定运行容器时的用户名或UID，后续RUN也会使用指定用户\nRUN：RUN命令是Dockfile执行命令的核心部分。它接受命令作为参数并用于创建镜像。每条RUN命令在当前镜像基础上执行，并且会提交一个新镜像层。\nWORKDIR：设置CMD指明的命令的运行目录。为后续的RUN、CMD、ENTRYPOINT、ADD指令配置工作目录。\nENV：容器启动的环境变量\nARG：构建环境的环境变量\nCOPY：复制文件到镜像中,格式： COPY 源路径 目标路径 ：COPY指令和ADD指令功能和使用方式类似。只是COPY指令不会做自动解压工作。\nADD： 拷复制文件到镜像中,格式： ADD 源路径 目标路径\nCMD：容器运行时执行的默认命令\nENTRYPOINT：指定容器的“入口”\nHEALTHCHECK：容器健康状态检查</code></pre><p><strong>关于CMD命令</strong>：<br>一定要使得该命令运行后保持前台，否则容器就会自动关闭。这是docker容器本质上是进程的概念</p>\n<h2 id=\"构建镜像与运行\"><a href=\"#构建镜像与运行\" class=\"headerlink\" title=\"构建镜像与运行\"></a>构建镜像与运行</h2><p>构建：</p>\n<pre><code>\n# 先跳转到项目根文件目录下（也就是含有Dockerfile的文件目录下）\ndocker build -t dockerdemo:v1 . # 最后一个.实际指定当前的构建目录，dockerdemo(注意只能用小写)是该docker的名字,v1是tag</code></pre><p>结果<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/1dd8e2ef74b08c85edaff3ce485a9f8b.png\" alt></p>\n<p>运行</p>\n<pre><code># 3000是你要映射到服务器上的端口，5000是容器里面需要被映射出来的端口，demo:v1 是需要运行的容器\ndocker run -p 3000:5000 demo:v1\n</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/938487a0270762fa06ef9dd805703815.png\" alt></p>\n<p>访问<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/6a0342a07e2f7e40cc52440c80091133.png\" alt></p>\n<h2 id=\"容器的管理\"><a href=\"#容器的管理\" class=\"headerlink\" title=\"容器的管理\"></a>容器的管理</h2><p>删除不需要的镜像，和容器</p>\n<p>查看所有的容器</p>\n<pre><code>docker ps -a</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/fa18eadc8f8e7155bd9f2cc67aa308de.png\" alt></p>\n<p>停止和删除容器</p>\n<pre><code>#如何停止容器\ndocker stop + 容器id\n# 删除容器id\ndocker rm + 容器id\n</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/11454b741864a4a26be4f6f7550d5187.png\" alt></p>\n<p>要先把镜像的容器都关了，才能删除相关镜像</p>\n<p>查看当前有哪些镜像</p>\n<pre><code>docker images # 查看所有镜像及其信息\n\ndocker images -q  # 输出所有镜像的id</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/edb762924a89a9174f15ad4eff34b4ca.png\" alt></p>\n<p>删除镜像<br>删除images（镜像），通过image的id来指定删除谁</p>\n<pre><code>docker rmi &lt;image id&gt;</code></pre><p>要删除全部image（镜像）的话</p>\n<pre><code>docker rmi $(docker images -q)</code></pre><p>只删除未被使用的资源</p>\n<ul>\n<li>Docker 提供了方便的 docker system prune 命令来删除那些已停止的容器、dangling 镜像、未被容器引用的 network 和构建过程中的 cache：<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/98587da7500a3158d54cd67bfc4fb1aa.png\" alt></li>\n</ul>\n<p>在本地的镜像更新之后，就会出现类似图中红框内的 <none> 镜像。这表示旧的镜像已经不再被引用了，此时它们就变成了 dangling images。如果使用 -a 参数，你还会发现另外一种类型的 <none> 镜像，它们的 repository 和 tag 列都表现为 <none>：<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/fa2ce9e682aa051bef2a1ef757d8f6ff.png\" alt><br>    这些镜像被称为 intermediate 镜像(就是其它镜像依赖的层)。</none></none></none></p>\n<p><strong>我们还可在不同在子命令下执行 prune，这样删除的就是某类资源：</strong></p>\n<pre><code>docker container prune # 删除所有退出状态的容器\ndocker volume prune # 删除未被使用的数据卷\ndocker image prune # 删除 dangling 或所有未被使用的镜像</code></pre><h2 id=\"容器的网络模式\"><a href=\"#容器的网络模式\" class=\"headerlink\" title=\"容器的网络模式\"></a>容器的网络模式</h2><p><a href=\"https://www.cnblogs.com/feng0815/p/14192177.html\" target=\"_blank\" rel=\"noopener\">参考文</a></p>\n<h3 id=\"关于docker的端口映射增改问题。\"><a href=\"#关于docker的端口映射增改问题。\" class=\"headerlink\" title=\"关于docker的端口映射增改问题。\"></a>关于docker的端口映射增改问题。</h3><p>一般来说，在镜像运行成容器后就不能再更改端口映射了，并且下次启动原来的映射配置也在。<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/4c63fcb2c8fe102955cc0ad9140dd734.png\" alt></p>\n<p>想要改变两个办法。<br><strong>法一：</strong><br>    更改配置docker文件，具体上网查询<br><strong>法二：</strong><br>    把现在的容器commit成镜像，然后再把镜像运行成容器，并且在运行的时候声明端口映射。</p>\n<h2 id=\"进入容器内部\"><a href=\"#进入容器内部\" class=\"headerlink\" title=\"进入容器内部\"></a>进入容器内部</h2><p>好文的连接<a href=\"https://cloud.tencent.com/developer/article/1691352\" target=\"_blank\" rel=\"noopener\">link</a></p>\n<h3 id=\"1-新建centos的镜像和容器。\"><a href=\"#1-新建centos的镜像和容器。\" class=\"headerlink\" title=\"1,新建centos的镜像和容器。\"></a>1,新建centos的镜像和容器。</h3><pre><code>docker pull centos</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/3ce9b6dbbc468ae90b1064260374b386.png\" alt></p>\n<h3 id=\"2-对这个镜像创建容器（也就是说运行它）\"><a href=\"#2-对这个镜像创建容器（也就是说运行它）\" class=\"headerlink\" title=\"2,对这个镜像创建容器（也就是说运行它）\"></a>2,对这个镜像创建容器（也就是说运行它）</h3><pre><code>docker container run -it -p 8888:8080 -v /opt/app:/opt/app --name=python-server 470671670cac bash</code></pre><p>命令文档查看：docker container run –help</p>\n<p>-it : 交互式终端（interactive terminal） ，也就是创建容器后进入容器。</p>\n<p>-p 8888:8080 :  端口映射（port），将容器端口映射到宿主机端口（8888：宿主机端口，8080：容器端口），宿主机端口 8888 确认能被外网访问。</p>\n<p>-v /opt/app:/opt/app：数据卷（volumn），将宿主机的数据（应用程序代码，配置文件等等）挂载到容器指定路径下，实现数据存储的持久化（如果没有数据挂载的话，容器销毁，容器中的数据会自动消失）。</p>\n<p>–name=python-server: 新的容器的名称</p>\n<p> 470671670cac：镜像ID（imageID），当然也可以是 imageName + tag（docker.io/centos:latest）</p>\n<p>bash：跟 -it 命令结合在一起操作，使容器创建后处于前端，一般是 /bin/bash，我这是bash。</p>\n<p>结果：<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/45ca190d5f75ee947bc815474dd06af7.png\" alt></p>\n<p>查看所有容器<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/7bd6c5162f6f969d5ee8377a9ac7e86d.png\" alt></p>\n<p><strong>不中断退出容器</strong><br>可以通过 Ctrl+p，Ctrl+q 退出容器，但容器还是处于运行状态（Up）。<br>或者输入命令<code>exit</code>可以直接退出，但是容器也关闭了</p>\n<h4 id=\"查看容器的信息（例如ip等）\"><a href=\"#查看容器的信息（例如ip等）\" class=\"headerlink\" title=\"查看容器的信息（例如ip等）\"></a>查看容器的信息（例如ip等）</h4><p><code>docker inspect container_id</code></p>\n<p>然后有结果</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/c267da1bddcfbf8c21c0375ef8dea4a6.png\" alt=\"image-20220821221517801\">    </p>\n<h3 id=\"进入容器\"><a href=\"#进入容器\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h3><p><strong>方法一</strong><br><code>docker container exec -it 5de4e81a2e20(containerID或者容器的名字) bash（这个bash可以换成其他命令）</code></p>\n<p>执行命令的方式：</p>\n<ul>\n<li>先启动容器</li>\n<li>然后使用exec命令去执行命令<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/18d30748b5631941cae418fdc85bd5f3.png\" alt></li>\n</ul>\n<p>其他容器命令</p>\n<pre><code>容器其他相关操作命令：\n\n查看容器 ip（退出容器，在宿主机上，最好另起一个客户端）: docker container inspect  1427087a62a7（containerID）\n\n\n容器启动（交互式）：docker container start  -i containerID\n\n关闭容器：docker container stop containerID\n\n容器重启动：docker container restart containerID\n\n删除容器（-f : force 强制删除，能删除处于运行状态的容器）：docker container rm -f  containerID\n\n查看所有容器的容器ID：docker container ls -a -q\n\n删除所有容器：docker contianer rm $(docker container ls -a -q)\n\n在交互式容器中退出，退出启动容器： Ctrl + d\n\n在交互式容器中退出，但是不退出启动容器：先按 Ctrl + p 后 Ctrl + q\n\n使用 -d 启动容器并一直在后台运行 SSH作为第一进程启动：docker container run -d -p 50001:22 imageID /usr/sbin/sshd -D </code></pre><p>​    </p>\n<h3 id=\"容器内的使用\"><a href=\"#容器内的使用\" class=\"headerlink\" title=\"容器内的使用\"></a>容器内的使用</h3><p>我这里用的centos最新版也就是centos8.<br>执行yum有个bug:<code>Failed to download metadata for repo &#39;appstream......</code><br>办法是进入容器执行</p>\n<pre><code>cd /etc/yum.repos.d/\nsed -i &#39;s/mirrorlist/#mirrorlist/g&#39; /etc/yum.repos.d/CentOS-*\nsed -i &#39;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#39; /etc/yum.repos.d/CentOS-* </code></pre><p>然后就可以使用yum安装各种库和程序了</p>\n<p><strong>改变系统的密码</strong></p>\n<pre><code>    安装 passwd（设置密码）： yum install -y passwd\n    设置密码：passwd root\n</code></pre><p><strong>安装ssh并启动</strong></p>\n<pre><code>作为 python 服务的守护程序，防止容器闪退（一直夯在容器中）；\n\n安装命令： yum install -y openssh-server\n\nssh 配置文件 sshd_config 路径： /etc/ssh/sshd_config\n\nssh 启动文件路径：/usr/sbin/\n启动 SSH: /usr/sbin/sshd\n\n</code></pre><p>启动前修改<br>修改/etc/ssh/sshd_config这个ssh配置文件</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/ae0cd55ec6eb40ecc231bb3147e68e58.png\" alt></p>\n<p>退出后访问</p>\n<h3 id=\"将容器打包成镜像\"><a href=\"#将容器打包成镜像\" class=\"headerlink\" title=\"将容器打包成镜像\"></a>将容器打包成镜像</h3><p>在运行容器时指定映射端口运行后，如果想要添加新的端口映射，可以使用以下两种方式：</p>\n<p><strong>方式一：将现有的容器打包成镜像，然后在使用新的镜像运行容器时重新指定要映射的端口</strong></p>\n<p>大概过程如下：</p>\n<p>先停止现有容器</p>\n<p><code>docker stop container-name</code><br>将容器commit成为一个镜像</p>\n<p><code>docker commit container-name  new-image-name</code><br>用新镜像运行容器</p>\n<p>结果<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/a5336f35ba2098dc9cb5ba845c33baf3.png\" alt></p>\n<p>然后运行新的镜像<br><code>docker run -it -d --name container-name（or id） -p p1:p1 -p p2:p2 new-image-name</code></p>\n<p>两个 -p 指定多个端口映射</p>\n<p>*<em>宿主机ssh连接入容器  *</em>  </p>\n<p>我这里将外部的2020端口映射到容器里面的22端口。<br>用特定的连接工具<strong>MobaXterm</strong><br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/6cf0b06d120b3f20740f150e072e9efd.png\" alt></p>\n<p>然后输入用户名和密码：成功<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/d7bd208b5e78d93bd4304461bf75d008.png\" alt></p>\n<h2 id=\"docker-Hub的使用\"><a href=\"#docker-Hub的使用\" class=\"headerlink\" title=\"docker Hub的使用\"></a>docker Hub的使用</h2><p>先在hub中建立一个名叫centos_demo的仓库，我的用户名是<code>${username}</code></p>\n<p>在本地登录docker</p>\n<pre><code>#docker login\nLogin with your Docker ID to push and pull images from Docker Hub. If you don&#39;t have a Docker ID, head over to https://hub.docker.com to create one.\nUsername: ${username}\nPassword:\nLogin Succeeded</code></pre><p>准备在本地提交，先给images打标签</p>\n<pre><code>docker tag 镜像名 账号名/仓库名：版本号\n账号名是登陆的账号名，仓库是远端配置的仓库名，版本号自己定义一个就好。到时候pull下来也是pull这个账号名/仓库名：版本号就好</code></pre><p>然后提交镜像push</p>\n<pre><code>docker push 账号名/仓库名：版本号</code></pre>"},{"_content":"## 前置测试工具\n\n**随机生成一定大小的文件**\n\n```\nout_file_name=out.txt\n#生成一个1G 的文件，内容全部为0\ndd if=/dev/zero of=out_file_name bs=1M count=1000\n\n#生产一个1G 的文件，内容随机\ndd if=/dev/urandom of=out_file_name bs=1M count=1000\n```\n\n\n\n\n\n\n\n## 磁盘配额工具(Quota)\n\n### 限制\n\n- 针对整个 partition（分区）：\n  quota 实际在运作的时候，是针对『整个 partition』进行限制的， 例如：如果你的 /dev/hda5 是挂载在 /home 底下，那么在 /home 底下的所有目录都会受到限制！\n- 只对一般身份使用者有效：\n  这就有趣了！并不是所有在 Linux 上面的账号都可以设定 quota 呢，例如 **root 就不能设定 quota** ， 因为整个系统所有的数据几乎都是他的！\n\n\n\n### 一些配置说明\n\nquota 这支程序针对整个 partition 的限制项目主要分为底下几个部分：\n\n- soft：\n  这是最**低限制容量**的意思，用户在宽限期间之内，他的容量可以超过 soft ，但必需要宽限时间之内将磁盘容量降低到 soft 的容量限制之下！\n- hard：\n  **这是『绝对不能超过』的容量**！跟 soft 相比的意思为何呢？通常 hard limit 会比 soft limit 为高，例如网络驱动器空间为 30 MB ，那么 hard limit 就设定为 30MB ，但是为了让使用者有一定的警戒心，所以当使用空间超过 25 MB 时，例如使用者使用了 27 MB 的空间时，那么系统就会警告用户， 让使用者可以在『宽限时间内』将他的档案量降低至 25 MB ( 亦即是 soft limit )之内！也就是说， soft 到 hard 之间的容量其实就是宽限的容量啦！可以达到针对使用者的『警示』作用！\n- 宽限时间：\n  那么宽限时间就可以很清楚的知道含意是什么了！也就是当您的使用者使用的空间超过了 soft limit ，却还没有到达 hard limit 时，那么在这个『宽限时间』之内， 就必需要请用户将使用的磁盘容量降低到 soft limit 之下！而当用户将磁盘容量使用情况超过 soft limit 时，『宽限时间』就会自动被启动，而在用户将容量降低到 soft limit 之下，那么宽限时间就会自动的取消啰！\n\n\n\n\n\n## quota实操\n\n### 流程\n\n Quota 从开始准备 filesystem 的支持到整个设定结束的主要的步骤大概是：\n\n1. **设定 partition 的 filesystem 支持 quota 参数：**\n   由于 quota 必须要让 partition 上面的 filesystem 支持才行，一般来说， 支持度最好的是 ext2/ext3 ，其他的 filesystem 类型鸟哥我是没有试过啦！ 启动 filesystem 支持 quota 最简单就是编辑 /etc/fstab ，使得准备要开放的 quota 磁盘可以支持 quota 啰；\n2. **建立 quota 记录文件：**\n   刚刚前面讲过，整个 quota 进行磁盘限制值记录的档案是 aquota.user/aquota.group， 要建立这两个档案就必须要先利用 quotacheck 扫瞄才行喔！所以啰，接下来的步骤就是： 使用 quotacheck 来扫瞄一下我们要使用的磁盘啰；\n3. **编辑 quota 限制值数据：**\n   再来就是使用 edquota 来编辑每个使用者或群组的可使用空间啰；\n4. **重新扫瞄与启动 quota ：**\n   设定好 quota 之后，建议可以再进行一次 quotacheck ，然后再以 quotaon 来启动吧！\n\n### 1 建立测试环境\n\n新建好用户和分组\n\n```\n[root@linux ~]# groupadd qgroup\n[root@linux ~]# useradd -m -g qgroup quser1\n[root@linux ~]# useradd -m -g qgroup quser2\n[root@linux ~]# passwd quser1\n[root@linux ~]# passwd quser2\n```\n\n\n\n### **2 建立好 filesystem 的 quota 支持：**\n\n查看系统的文件挂载情况\n\n```\n[root@linux ~]# df -h\nFilesystem           1K-blocks      Used Available Use% Mounted on\n/dev/hda1              5952252   3193292   2451720  57% /\n/dev/hdb1             28267608     77904  26730604   1% /disk2  # 这是我们计划挂载的点，/disk2\n/dev/hda5              9492644    227252   8775412   3% /disk1\n```\n\n编辑 `/etc/fstab`文件，在指定目录下面加入,usrquota,grpquota（**在  defaults,usrquota,grpquota  之间都没有空格！）**\n\n```\n[root@linux ~]# vi /etc/fstab\nLABEL=/        /          ext3    defaults                    1 1\nLABEL=/disk1   /disk1     ext3    defaults                    1 2\nLABEL=/disk2   /disk2     ext3    defaults,usrquota,grpquota  1 2 # 这里是更改的地方\n/dev/hda3      swap       swap    defaults                    0 0\n```\n\n**由于真正的 quota 在读取的时候是读取 /etc/mtab 这个档案的，偏偏这一个档案需要重新启动之后才能够以 /etc/fstab 的新数据进行改写！**\n\n**Solution:**\n\n```\n# 1重启\nreboot\n\n# 2重新挂载\n[root@linux ~]# mount -o remount /disk2\n```\n\n\n\n### **3 扫瞄磁盘的用户使用状况，并产生重要的 aquota.group 与 aquota.user：文件**\n\n用到`quotacheck`生成配置文件\n\n```\n[root@linux ~]# quotacheck -avug   # 生成配置文件\nquotacheck: Scanning /dev/hdb1 [/disk2] done\nquotacheck: Checked 3 directories and 4 files\n[root@linux ~]# ll /disk2          # 查看\n-rw-------  1 root root  6144 Sep  6 11:44 aquota.group\n-rw-------  1 root root  6144 Sep  6 11:44 aquota.user\n```\n\n\n\n### 4 **启动 quota 的限额：**\n\n```\n[root@linux ~]# quotaon -avug\n/dev/hdb1 [/disk2]: group quotas turned on\n/dev/hdb1 [/disk2]: user quotas turned on\n```\n\n\n\n### 5 **编辑使用者的可使用空间：**\n\n主要分为针对用户还是分组进行限制\n\n- 用户：设置每单个用户的限额\n- 分组：设置某个小组所有用户加起来的限制\n\n\n\n**实操**\n\n使用`edquota`设置用户`quser1` 的限额\n\n```\n[root@linux ~]# edquota -u quser1   # 输入该命令，会弹出一个vim的编辑框。修改配置即可\nDisk quotas for user quser1 (uid 502):\n  Filesystem    blocks    soft    hard   inodes   soft   hard\n  /dev/hdb1          0   45000   50000        0      0      0\n\n# 说明\nsoft的单位是KBytes。要转化为MB请除以1024\n```\n\n设置用户的限制时间（这个是针对整个分区设置的，所有用户都会一致）\n\n```\nedquota -t\n```\n\n\n\n将某个用户的限制粘贴给另一个用户（**如果quser2已经有配置了，那么会覆盖掉原有配置**）\n\n```\n[root@linux ~]# edquota -p quser1 quser2  # 把quser1的复制给 quser2\n```\n\n\n\n\n\n**查看各用户配置以及使用情况**\n\n**1**\n\n```\n[root@linux ~]# quota [-uvsl] [username]\n[root@linux ~]# quota [-gvsl] [groupname]\n参数：\n-u  ：后面可以接 username ，表示显示出该用户的 quota 限制值。若不接 username \n      ，表示显示出执行者的 quota 限制值。\n-g  ：后面可接 groupname ，表示显示出该群组的 quota 限制值。\n-v  ：显示每个 filesystem 的 quota 值；\n-s  ：可选择以 inode 或磁盘容量的限制值来显示；\n-l  ：仅显示出目前本机上面的 filesystem 的 quota 值。\n范例：\n\n范例一：秀出目前 root 自己的 quota 限制值：\n[root@linux ~]# quota -guvs\n\n范例二：秀出 quser1 这个用户的磁盘配额\n[root@linux ~]# quota -u quser1\n# 注意一下这两个范例，如果您的系统上面尚未有任何的 quota 支持的 filesystem 时，\n# 使用这两个范例时，『不会有任何信息列出来』啦！不要以为发生错误啰！\n```\n\n**或者2**\n\n```\nrepquota -a\n```\n\n\n\n\n\n### 6 **设定开机时启动 quota**\n\n```\n[root@linux ~]# vi /etc/rc.d/rc.local 在里面加入一行 (直接加在最后一行即可)：如下\n/sbin/quotaon -avug\n```\n\n\n\n\n\n## 一个针对某个小组每个人设置限额的脚本\n\n思路：\n\n- 设置一个模板用户：example（对该用户设置想要的限额）\n- 针对某用户组所有的用户，将example的配置复制过去。\n  - 考虑到有用户更新，那么就分两个接口\n  - 1，强制复制，所有人原有的配置都重新更改为example\n  - 2，只针对目前没有限制的人做复制\n\n\n\n```\n\n\n```\n\n\n\n\n\n## ref\n\n[鸟哥linux](http://cn.linux.vbird.org/linux_basic/fedora_4/0420quota-fc4.php)\n","source":"_posts/服务器相关/linux给每个用户限定存储空间大小.md","raw":"## 前置测试工具\n\n**随机生成一定大小的文件**\n\n```\nout_file_name=out.txt\n#生成一个1G 的文件，内容全部为0\ndd if=/dev/zero of=out_file_name bs=1M count=1000\n\n#生产一个1G 的文件，内容随机\ndd if=/dev/urandom of=out_file_name bs=1M count=1000\n```\n\n\n\n\n\n\n\n## 磁盘配额工具(Quota)\n\n### 限制\n\n- 针对整个 partition（分区）：\n  quota 实际在运作的时候，是针对『整个 partition』进行限制的， 例如：如果你的 /dev/hda5 是挂载在 /home 底下，那么在 /home 底下的所有目录都会受到限制！\n- 只对一般身份使用者有效：\n  这就有趣了！并不是所有在 Linux 上面的账号都可以设定 quota 呢，例如 **root 就不能设定 quota** ， 因为整个系统所有的数据几乎都是他的！\n\n\n\n### 一些配置说明\n\nquota 这支程序针对整个 partition 的限制项目主要分为底下几个部分：\n\n- soft：\n  这是最**低限制容量**的意思，用户在宽限期间之内，他的容量可以超过 soft ，但必需要宽限时间之内将磁盘容量降低到 soft 的容量限制之下！\n- hard：\n  **这是『绝对不能超过』的容量**！跟 soft 相比的意思为何呢？通常 hard limit 会比 soft limit 为高，例如网络驱动器空间为 30 MB ，那么 hard limit 就设定为 30MB ，但是为了让使用者有一定的警戒心，所以当使用空间超过 25 MB 时，例如使用者使用了 27 MB 的空间时，那么系统就会警告用户， 让使用者可以在『宽限时间内』将他的档案量降低至 25 MB ( 亦即是 soft limit )之内！也就是说， soft 到 hard 之间的容量其实就是宽限的容量啦！可以达到针对使用者的『警示』作用！\n- 宽限时间：\n  那么宽限时间就可以很清楚的知道含意是什么了！也就是当您的使用者使用的空间超过了 soft limit ，却还没有到达 hard limit 时，那么在这个『宽限时间』之内， 就必需要请用户将使用的磁盘容量降低到 soft limit 之下！而当用户将磁盘容量使用情况超过 soft limit 时，『宽限时间』就会自动被启动，而在用户将容量降低到 soft limit 之下，那么宽限时间就会自动的取消啰！\n\n\n\n\n\n## quota实操\n\n### 流程\n\n Quota 从开始准备 filesystem 的支持到整个设定结束的主要的步骤大概是：\n\n1. **设定 partition 的 filesystem 支持 quota 参数：**\n   由于 quota 必须要让 partition 上面的 filesystem 支持才行，一般来说， 支持度最好的是 ext2/ext3 ，其他的 filesystem 类型鸟哥我是没有试过啦！ 启动 filesystem 支持 quota 最简单就是编辑 /etc/fstab ，使得准备要开放的 quota 磁盘可以支持 quota 啰；\n2. **建立 quota 记录文件：**\n   刚刚前面讲过，整个 quota 进行磁盘限制值记录的档案是 aquota.user/aquota.group， 要建立这两个档案就必须要先利用 quotacheck 扫瞄才行喔！所以啰，接下来的步骤就是： 使用 quotacheck 来扫瞄一下我们要使用的磁盘啰；\n3. **编辑 quota 限制值数据：**\n   再来就是使用 edquota 来编辑每个使用者或群组的可使用空间啰；\n4. **重新扫瞄与启动 quota ：**\n   设定好 quota 之后，建议可以再进行一次 quotacheck ，然后再以 quotaon 来启动吧！\n\n### 1 建立测试环境\n\n新建好用户和分组\n\n```\n[root@linux ~]# groupadd qgroup\n[root@linux ~]# useradd -m -g qgroup quser1\n[root@linux ~]# useradd -m -g qgroup quser2\n[root@linux ~]# passwd quser1\n[root@linux ~]# passwd quser2\n```\n\n\n\n### **2 建立好 filesystem 的 quota 支持：**\n\n查看系统的文件挂载情况\n\n```\n[root@linux ~]# df -h\nFilesystem           1K-blocks      Used Available Use% Mounted on\n/dev/hda1              5952252   3193292   2451720  57% /\n/dev/hdb1             28267608     77904  26730604   1% /disk2  # 这是我们计划挂载的点，/disk2\n/dev/hda5              9492644    227252   8775412   3% /disk1\n```\n\n编辑 `/etc/fstab`文件，在指定目录下面加入,usrquota,grpquota（**在  defaults,usrquota,grpquota  之间都没有空格！）**\n\n```\n[root@linux ~]# vi /etc/fstab\nLABEL=/        /          ext3    defaults                    1 1\nLABEL=/disk1   /disk1     ext3    defaults                    1 2\nLABEL=/disk2   /disk2     ext3    defaults,usrquota,grpquota  1 2 # 这里是更改的地方\n/dev/hda3      swap       swap    defaults                    0 0\n```\n\n**由于真正的 quota 在读取的时候是读取 /etc/mtab 这个档案的，偏偏这一个档案需要重新启动之后才能够以 /etc/fstab 的新数据进行改写！**\n\n**Solution:**\n\n```\n# 1重启\nreboot\n\n# 2重新挂载\n[root@linux ~]# mount -o remount /disk2\n```\n\n\n\n### **3 扫瞄磁盘的用户使用状况，并产生重要的 aquota.group 与 aquota.user：文件**\n\n用到`quotacheck`生成配置文件\n\n```\n[root@linux ~]# quotacheck -avug   # 生成配置文件\nquotacheck: Scanning /dev/hdb1 [/disk2] done\nquotacheck: Checked 3 directories and 4 files\n[root@linux ~]# ll /disk2          # 查看\n-rw-------  1 root root  6144 Sep  6 11:44 aquota.group\n-rw-------  1 root root  6144 Sep  6 11:44 aquota.user\n```\n\n\n\n### 4 **启动 quota 的限额：**\n\n```\n[root@linux ~]# quotaon -avug\n/dev/hdb1 [/disk2]: group quotas turned on\n/dev/hdb1 [/disk2]: user quotas turned on\n```\n\n\n\n### 5 **编辑使用者的可使用空间：**\n\n主要分为针对用户还是分组进行限制\n\n- 用户：设置每单个用户的限额\n- 分组：设置某个小组所有用户加起来的限制\n\n\n\n**实操**\n\n使用`edquota`设置用户`quser1` 的限额\n\n```\n[root@linux ~]# edquota -u quser1   # 输入该命令，会弹出一个vim的编辑框。修改配置即可\nDisk quotas for user quser1 (uid 502):\n  Filesystem    blocks    soft    hard   inodes   soft   hard\n  /dev/hdb1          0   45000   50000        0      0      0\n\n# 说明\nsoft的单位是KBytes。要转化为MB请除以1024\n```\n\n设置用户的限制时间（这个是针对整个分区设置的，所有用户都会一致）\n\n```\nedquota -t\n```\n\n\n\n将某个用户的限制粘贴给另一个用户（**如果quser2已经有配置了，那么会覆盖掉原有配置**）\n\n```\n[root@linux ~]# edquota -p quser1 quser2  # 把quser1的复制给 quser2\n```\n\n\n\n\n\n**查看各用户配置以及使用情况**\n\n**1**\n\n```\n[root@linux ~]# quota [-uvsl] [username]\n[root@linux ~]# quota [-gvsl] [groupname]\n参数：\n-u  ：后面可以接 username ，表示显示出该用户的 quota 限制值。若不接 username \n      ，表示显示出执行者的 quota 限制值。\n-g  ：后面可接 groupname ，表示显示出该群组的 quota 限制值。\n-v  ：显示每个 filesystem 的 quota 值；\n-s  ：可选择以 inode 或磁盘容量的限制值来显示；\n-l  ：仅显示出目前本机上面的 filesystem 的 quota 值。\n范例：\n\n范例一：秀出目前 root 自己的 quota 限制值：\n[root@linux ~]# quota -guvs\n\n范例二：秀出 quser1 这个用户的磁盘配额\n[root@linux ~]# quota -u quser1\n# 注意一下这两个范例，如果您的系统上面尚未有任何的 quota 支持的 filesystem 时，\n# 使用这两个范例时，『不会有任何信息列出来』啦！不要以为发生错误啰！\n```\n\n**或者2**\n\n```\nrepquota -a\n```\n\n\n\n\n\n### 6 **设定开机时启动 quota**\n\n```\n[root@linux ~]# vi /etc/rc.d/rc.local 在里面加入一行 (直接加在最后一行即可)：如下\n/sbin/quotaon -avug\n```\n\n\n\n\n\n## 一个针对某个小组每个人设置限额的脚本\n\n思路：\n\n- 设置一个模板用户：example（对该用户设置想要的限额）\n- 针对某用户组所有的用户，将example的配置复制过去。\n  - 考虑到有用户更新，那么就分两个接口\n  - 1，强制复制，所有人原有的配置都重新更改为example\n  - 2，只针对目前没有限制的人做复制\n\n\n\n```\n\n\n```\n\n\n\n\n\n## ref\n\n[鸟哥linux](http://cn.linux.vbird.org/linux_basic/fedora_4/0420quota-fc4.php)\n","slug":"服务器相关/linux给每个用户限定存储空间大小","published":1,"date":"2023-02-27T11:33:23.585Z","updated":"2023-02-27T11:34:33.144Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsyc5000z0gcnfh5894fn","content":"<h2 id=\"前置测试工具\"><a href=\"#前置测试工具\" class=\"headerlink\" title=\"前置测试工具\"></a>前置测试工具</h2><p><strong>随机生成一定大小的文件</strong></p>\n<pre><code>out_file_name=out.txt\n#生成一个1G 的文件，内容全部为0\ndd if=/dev/zero of=out_file_name bs=1M count=1000\n\n#生产一个1G 的文件，内容随机\ndd if=/dev/urandom of=out_file_name bs=1M count=1000</code></pre><h2 id=\"磁盘配额工具-Quota\"><a href=\"#磁盘配额工具-Quota\" class=\"headerlink\" title=\"磁盘配额工具(Quota)\"></a>磁盘配额工具(Quota)</h2><h3 id=\"限制\"><a href=\"#限制\" class=\"headerlink\" title=\"限制\"></a>限制</h3><ul>\n<li>针对整个 partition（分区）：<br>quota 实际在运作的时候，是针对『整个 partition』进行限制的， 例如：如果你的 /dev/hda5 是挂载在 /home 底下，那么在 /home 底下的所有目录都会受到限制！</li>\n<li>只对一般身份使用者有效：<br>这就有趣了！并不是所有在 Linux 上面的账号都可以设定 quota 呢，例如 <strong>root 就不能设定 quota</strong> ， 因为整个系统所有的数据几乎都是他的！</li>\n</ul>\n<h3 id=\"一些配置说明\"><a href=\"#一些配置说明\" class=\"headerlink\" title=\"一些配置说明\"></a>一些配置说明</h3><p>quota 这支程序针对整个 partition 的限制项目主要分为底下几个部分：</p>\n<ul>\n<li>soft：<br>这是最<strong>低限制容量</strong>的意思，用户在宽限期间之内，他的容量可以超过 soft ，但必需要宽限时间之内将磁盘容量降低到 soft 的容量限制之下！</li>\n<li>hard：<br><strong>这是『绝对不能超过』的容量</strong>！跟 soft 相比的意思为何呢？通常 hard limit 会比 soft limit 为高，例如网络驱动器空间为 30 MB ，那么 hard limit 就设定为 30MB ，但是为了让使用者有一定的警戒心，所以当使用空间超过 25 MB 时，例如使用者使用了 27 MB 的空间时，那么系统就会警告用户， 让使用者可以在『宽限时间内』将他的档案量降低至 25 MB ( 亦即是 soft limit )之内！也就是说， soft 到 hard 之间的容量其实就是宽限的容量啦！可以达到针对使用者的『警示』作用！</li>\n<li>宽限时间：<br>那么宽限时间就可以很清楚的知道含意是什么了！也就是当您的使用者使用的空间超过了 soft limit ，却还没有到达 hard limit 时，那么在这个『宽限时间』之内， 就必需要请用户将使用的磁盘容量降低到 soft limit 之下！而当用户将磁盘容量使用情况超过 soft limit 时，『宽限时间』就会自动被启动，而在用户将容量降低到 soft limit 之下，那么宽限时间就会自动的取消啰！</li>\n</ul>\n<h2 id=\"quota实操\"><a href=\"#quota实操\" class=\"headerlink\" title=\"quota实操\"></a>quota实操</h2><h3 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h3><p> Quota 从开始准备 filesystem 的支持到整个设定结束的主要的步骤大概是：</p>\n<ol>\n<li><strong>设定 partition 的 filesystem 支持 quota 参数：</strong><br>由于 quota 必须要让 partition 上面的 filesystem 支持才行，一般来说， 支持度最好的是 ext2/ext3 ，其他的 filesystem 类型鸟哥我是没有试过啦！ 启动 filesystem 支持 quota 最简单就是编辑 /etc/fstab ，使得准备要开放的 quota 磁盘可以支持 quota 啰；</li>\n<li><strong>建立 quota 记录文件：</strong><br>刚刚前面讲过，整个 quota 进行磁盘限制值记录的档案是 aquota.user/aquota.group， 要建立这两个档案就必须要先利用 quotacheck 扫瞄才行喔！所以啰，接下来的步骤就是： 使用 quotacheck 来扫瞄一下我们要使用的磁盘啰；</li>\n<li><strong>编辑 quota 限制值数据：</strong><br>再来就是使用 edquota 来编辑每个使用者或群组的可使用空间啰；</li>\n<li><strong>重新扫瞄与启动 quota ：</strong><br>设定好 quota 之后，建议可以再进行一次 quotacheck ，然后再以 quotaon 来启动吧！</li>\n</ol>\n<h3 id=\"1-建立测试环境\"><a href=\"#1-建立测试环境\" class=\"headerlink\" title=\"1 建立测试环境\"></a>1 建立测试环境</h3><p>新建好用户和分组</p>\n<pre><code>[root@linux ~]# groupadd qgroup\n[root@linux ~]# useradd -m -g qgroup quser1\n[root@linux ~]# useradd -m -g qgroup quser2\n[root@linux ~]# passwd quser1\n[root@linux ~]# passwd quser2</code></pre><h3 id=\"2-建立好-filesystem-的-quota-支持：\"><a href=\"#2-建立好-filesystem-的-quota-支持：\" class=\"headerlink\" title=\"2 建立好 filesystem 的 quota 支持：\"></a><strong>2 建立好 filesystem 的 quota 支持：</strong></h3><p>查看系统的文件挂载情况</p>\n<pre><code>[root@linux ~]# df -h\nFilesystem           1K-blocks      Used Available Use% Mounted on\n/dev/hda1              5952252   3193292   2451720  57% /\n/dev/hdb1             28267608     77904  26730604   1% /disk2  # 这是我们计划挂载的点，/disk2\n/dev/hda5              9492644    227252   8775412   3% /disk1</code></pre><p>编辑 <code>/etc/fstab</code>文件，在指定目录下面加入,usrquota,grpquota（<strong>在  defaults,usrquota,grpquota  之间都没有空格！）</strong></p>\n<pre><code>[root@linux ~]# vi /etc/fstab\nLABEL=/        /          ext3    defaults                    1 1\nLABEL=/disk1   /disk1     ext3    defaults                    1 2\nLABEL=/disk2   /disk2     ext3    defaults,usrquota,grpquota  1 2 # 这里是更改的地方\n/dev/hda3      swap       swap    defaults                    0 0</code></pre><p><strong>由于真正的 quota 在读取的时候是读取 /etc/mtab 这个档案的，偏偏这一个档案需要重新启动之后才能够以 /etc/fstab 的新数据进行改写！</strong></p>\n<p><strong>Solution:</strong></p>\n<pre><code># 1重启\nreboot\n\n# 2重新挂载\n[root@linux ~]# mount -o remount /disk2</code></pre><h3 id=\"3-扫瞄磁盘的用户使用状况，并产生重要的-aquota-group-与-aquota-user：文件\"><a href=\"#3-扫瞄磁盘的用户使用状况，并产生重要的-aquota-group-与-aquota-user：文件\" class=\"headerlink\" title=\"3 扫瞄磁盘的用户使用状况，并产生重要的 aquota.group 与 aquota.user：文件\"></a><strong>3 扫瞄磁盘的用户使用状况，并产生重要的 aquota.group 与 aquota.user：文件</strong></h3><p>用到<code>quotacheck</code>生成配置文件</p>\n<pre><code>[root@linux ~]# quotacheck -avug   # 生成配置文件\nquotacheck: Scanning /dev/hdb1 [/disk2] done\nquotacheck: Checked 3 directories and 4 files\n[root@linux ~]# ll /disk2          # 查看\n-rw-------  1 root root  6144 Sep  6 11:44 aquota.group\n-rw-------  1 root root  6144 Sep  6 11:44 aquota.user</code></pre><h3 id=\"4-启动-quota-的限额：\"><a href=\"#4-启动-quota-的限额：\" class=\"headerlink\" title=\"4 启动 quota 的限额：\"></a>4 <strong>启动 quota 的限额：</strong></h3><pre><code>[root@linux ~]# quotaon -avug\n/dev/hdb1 [/disk2]: group quotas turned on\n/dev/hdb1 [/disk2]: user quotas turned on</code></pre><h3 id=\"5-编辑使用者的可使用空间：\"><a href=\"#5-编辑使用者的可使用空间：\" class=\"headerlink\" title=\"5 编辑使用者的可使用空间：\"></a>5 <strong>编辑使用者的可使用空间：</strong></h3><p>主要分为针对用户还是分组进行限制</p>\n<ul>\n<li>用户：设置每单个用户的限额</li>\n<li>分组：设置某个小组所有用户加起来的限制</li>\n</ul>\n<p><strong>实操</strong></p>\n<p>使用<code>edquota</code>设置用户<code>quser1</code> 的限额</p>\n<pre><code>[root@linux ~]# edquota -u quser1   # 输入该命令，会弹出一个vim的编辑框。修改配置即可\nDisk quotas for user quser1 (uid 502):\n  Filesystem    blocks    soft    hard   inodes   soft   hard\n  /dev/hdb1          0   45000   50000        0      0      0\n\n# 说明\nsoft的单位是KBytes。要转化为MB请除以1024</code></pre><p>设置用户的限制时间（这个是针对整个分区设置的，所有用户都会一致）</p>\n<pre><code>edquota -t</code></pre><p>将某个用户的限制粘贴给另一个用户（<strong>如果quser2已经有配置了，那么会覆盖掉原有配置</strong>）</p>\n<pre><code>[root@linux ~]# edquota -p quser1 quser2  # 把quser1的复制给 quser2</code></pre><p><strong>查看各用户配置以及使用情况</strong></p>\n<p><strong>1</strong></p>\n<pre><code>[root@linux ~]# quota [-uvsl] [username]\n[root@linux ~]# quota [-gvsl] [groupname]\n参数：\n-u  ：后面可以接 username ，表示显示出该用户的 quota 限制值。若不接 username \n      ，表示显示出执行者的 quota 限制值。\n-g  ：后面可接 groupname ，表示显示出该群组的 quota 限制值。\n-v  ：显示每个 filesystem 的 quota 值；\n-s  ：可选择以 inode 或磁盘容量的限制值来显示；\n-l  ：仅显示出目前本机上面的 filesystem 的 quota 值。\n范例：\n\n范例一：秀出目前 root 自己的 quota 限制值：\n[root@linux ~]# quota -guvs\n\n范例二：秀出 quser1 这个用户的磁盘配额\n[root@linux ~]# quota -u quser1\n# 注意一下这两个范例，如果您的系统上面尚未有任何的 quota 支持的 filesystem 时，\n# 使用这两个范例时，『不会有任何信息列出来』啦！不要以为发生错误啰！</code></pre><p><strong>或者2</strong></p>\n<pre><code>repquota -a</code></pre><h3 id=\"6-设定开机时启动-quota\"><a href=\"#6-设定开机时启动-quota\" class=\"headerlink\" title=\"6 设定开机时启动 quota\"></a>6 <strong>设定开机时启动 quota</strong></h3><pre><code>[root@linux ~]# vi /etc/rc.d/rc.local 在里面加入一行 (直接加在最后一行即可)：如下\n/sbin/quotaon -avug</code></pre><h2 id=\"一个针对某个小组每个人设置限额的脚本\"><a href=\"#一个针对某个小组每个人设置限额的脚本\" class=\"headerlink\" title=\"一个针对某个小组每个人设置限额的脚本\"></a>一个针对某个小组每个人设置限额的脚本</h2><p>思路：</p>\n<ul>\n<li>设置一个模板用户：example（对该用户设置想要的限额）</li>\n<li>针对某用户组所有的用户，将example的配置复制过去。<ul>\n<li>考虑到有用户更新，那么就分两个接口</li>\n<li>1，强制复制，所有人原有的配置都重新更改为example</li>\n<li>2，只针对目前没有限制的人做复制</li>\n</ul>\n</li>\n</ul>\n<pre><code>\n</code></pre><h2 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h2><p><a href=\"http://cn.linux.vbird.org/linux_basic/fedora_4/0420quota-fc4.php\" target=\"_blank\" rel=\"noopener\">鸟哥linux</a></p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h2 id=\"前置测试工具\"><a href=\"#前置测试工具\" class=\"headerlink\" title=\"前置测试工具\"></a>前置测试工具</h2><p><strong>随机生成一定大小的文件</strong></p>\n<pre><code>out_file_name=out.txt\n#生成一个1G 的文件，内容全部为0\ndd if=/dev/zero of=out_file_name bs=1M count=1000\n\n#生产一个1G 的文件，内容随机\ndd if=/dev/urandom of=out_file_name bs=1M count=1000</code></pre><h2 id=\"磁盘配额工具-Quota\"><a href=\"#磁盘配额工具-Quota\" class=\"headerlink\" title=\"磁盘配额工具(Quota)\"></a>磁盘配额工具(Quota)</h2><h3 id=\"限制\"><a href=\"#限制\" class=\"headerlink\" title=\"限制\"></a>限制</h3><ul>\n<li>针对整个 partition（分区）：<br>quota 实际在运作的时候，是针对『整个 partition』进行限制的， 例如：如果你的 /dev/hda5 是挂载在 /home 底下，那么在 /home 底下的所有目录都会受到限制！</li>\n<li>只对一般身份使用者有效：<br>这就有趣了！并不是所有在 Linux 上面的账号都可以设定 quota 呢，例如 <strong>root 就不能设定 quota</strong> ， 因为整个系统所有的数据几乎都是他的！</li>\n</ul>\n<h3 id=\"一些配置说明\"><a href=\"#一些配置说明\" class=\"headerlink\" title=\"一些配置说明\"></a>一些配置说明</h3><p>quota 这支程序针对整个 partition 的限制项目主要分为底下几个部分：</p>\n<ul>\n<li>soft：<br>这是最<strong>低限制容量</strong>的意思，用户在宽限期间之内，他的容量可以超过 soft ，但必需要宽限时间之内将磁盘容量降低到 soft 的容量限制之下！</li>\n<li>hard：<br><strong>这是『绝对不能超过』的容量</strong>！跟 soft 相比的意思为何呢？通常 hard limit 会比 soft limit 为高，例如网络驱动器空间为 30 MB ，那么 hard limit 就设定为 30MB ，但是为了让使用者有一定的警戒心，所以当使用空间超过 25 MB 时，例如使用者使用了 27 MB 的空间时，那么系统就会警告用户， 让使用者可以在『宽限时间内』将他的档案量降低至 25 MB ( 亦即是 soft limit )之内！也就是说， soft 到 hard 之间的容量其实就是宽限的容量啦！可以达到针对使用者的『警示』作用！</li>\n<li>宽限时间：<br>那么宽限时间就可以很清楚的知道含意是什么了！也就是当您的使用者使用的空间超过了 soft limit ，却还没有到达 hard limit 时，那么在这个『宽限时间』之内， 就必需要请用户将使用的磁盘容量降低到 soft limit 之下！而当用户将磁盘容量使用情况超过 soft limit 时，『宽限时间』就会自动被启动，而在用户将容量降低到 soft limit 之下，那么宽限时间就会自动的取消啰！</li>\n</ul>\n<h2 id=\"quota实操\"><a href=\"#quota实操\" class=\"headerlink\" title=\"quota实操\"></a>quota实操</h2><h3 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h3><p> Quota 从开始准备 filesystem 的支持到整个设定结束的主要的步骤大概是：</p>\n<ol>\n<li><strong>设定 partition 的 filesystem 支持 quota 参数：</strong><br>由于 quota 必须要让 partition 上面的 filesystem 支持才行，一般来说， 支持度最好的是 ext2/ext3 ，其他的 filesystem 类型鸟哥我是没有试过啦！ 启动 filesystem 支持 quota 最简单就是编辑 /etc/fstab ，使得准备要开放的 quota 磁盘可以支持 quota 啰；</li>\n<li><strong>建立 quota 记录文件：</strong><br>刚刚前面讲过，整个 quota 进行磁盘限制值记录的档案是 aquota.user/aquota.group， 要建立这两个档案就必须要先利用 quotacheck 扫瞄才行喔！所以啰，接下来的步骤就是： 使用 quotacheck 来扫瞄一下我们要使用的磁盘啰；</li>\n<li><strong>编辑 quota 限制值数据：</strong><br>再来就是使用 edquota 来编辑每个使用者或群组的可使用空间啰；</li>\n<li><strong>重新扫瞄与启动 quota ：</strong><br>设定好 quota 之后，建议可以再进行一次 quotacheck ，然后再以 quotaon 来启动吧！</li>\n</ol>\n<h3 id=\"1-建立测试环境\"><a href=\"#1-建立测试环境\" class=\"headerlink\" title=\"1 建立测试环境\"></a>1 建立测试环境</h3><p>新建好用户和分组</p>\n<pre><code>[root@linux ~]# groupadd qgroup\n[root@linux ~]# useradd -m -g qgroup quser1\n[root@linux ~]# useradd -m -g qgroup quser2\n[root@linux ~]# passwd quser1\n[root@linux ~]# passwd quser2</code></pre><h3 id=\"2-建立好-filesystem-的-quota-支持：\"><a href=\"#2-建立好-filesystem-的-quota-支持：\" class=\"headerlink\" title=\"2 建立好 filesystem 的 quota 支持：\"></a><strong>2 建立好 filesystem 的 quota 支持：</strong></h3><p>查看系统的文件挂载情况</p>\n<pre><code>[root@linux ~]# df -h\nFilesystem           1K-blocks      Used Available Use% Mounted on\n/dev/hda1              5952252   3193292   2451720  57% /\n/dev/hdb1             28267608     77904  26730604   1% /disk2  # 这是我们计划挂载的点，/disk2\n/dev/hda5              9492644    227252   8775412   3% /disk1</code></pre><p>编辑 <code>/etc/fstab</code>文件，在指定目录下面加入,usrquota,grpquota（<strong>在  defaults,usrquota,grpquota  之间都没有空格！）</strong></p>\n<pre><code>[root@linux ~]# vi /etc/fstab\nLABEL=/        /          ext3    defaults                    1 1\nLABEL=/disk1   /disk1     ext3    defaults                    1 2\nLABEL=/disk2   /disk2     ext3    defaults,usrquota,grpquota  1 2 # 这里是更改的地方\n/dev/hda3      swap       swap    defaults                    0 0</code></pre><p><strong>由于真正的 quota 在读取的时候是读取 /etc/mtab 这个档案的，偏偏这一个档案需要重新启动之后才能够以 /etc/fstab 的新数据进行改写！</strong></p>\n<p><strong>Solution:</strong></p>\n<pre><code># 1重启\nreboot\n\n# 2重新挂载\n[root@linux ~]# mount -o remount /disk2</code></pre><h3 id=\"3-扫瞄磁盘的用户使用状况，并产生重要的-aquota-group-与-aquota-user：文件\"><a href=\"#3-扫瞄磁盘的用户使用状况，并产生重要的-aquota-group-与-aquota-user：文件\" class=\"headerlink\" title=\"3 扫瞄磁盘的用户使用状况，并产生重要的 aquota.group 与 aquota.user：文件\"></a><strong>3 扫瞄磁盘的用户使用状况，并产生重要的 aquota.group 与 aquota.user：文件</strong></h3><p>用到<code>quotacheck</code>生成配置文件</p>\n<pre><code>[root@linux ~]# quotacheck -avug   # 生成配置文件\nquotacheck: Scanning /dev/hdb1 [/disk2] done\nquotacheck: Checked 3 directories and 4 files\n[root@linux ~]# ll /disk2          # 查看\n-rw-------  1 root root  6144 Sep  6 11:44 aquota.group\n-rw-------  1 root root  6144 Sep  6 11:44 aquota.user</code></pre><h3 id=\"4-启动-quota-的限额：\"><a href=\"#4-启动-quota-的限额：\" class=\"headerlink\" title=\"4 启动 quota 的限额：\"></a>4 <strong>启动 quota 的限额：</strong></h3><pre><code>[root@linux ~]# quotaon -avug\n/dev/hdb1 [/disk2]: group quotas turned on\n/dev/hdb1 [/disk2]: user quotas turned on</code></pre><h3 id=\"5-编辑使用者的可使用空间：\"><a href=\"#5-编辑使用者的可使用空间：\" class=\"headerlink\" title=\"5 编辑使用者的可使用空间：\"></a>5 <strong>编辑使用者的可使用空间：</strong></h3><p>主要分为针对用户还是分组进行限制</p>\n<ul>\n<li>用户：设置每单个用户的限额</li>\n<li>分组：设置某个小组所有用户加起来的限制</li>\n</ul>\n<p><strong>实操</strong></p>\n<p>使用<code>edquota</code>设置用户<code>quser1</code> 的限额</p>\n<pre><code>[root@linux ~]# edquota -u quser1   # 输入该命令，会弹出一个vim的编辑框。修改配置即可\nDisk quotas for user quser1 (uid 502):\n  Filesystem    blocks    soft    hard   inodes   soft   hard\n  /dev/hdb1          0   45000   50000        0      0      0\n\n# 说明\nsoft的单位是KBytes。要转化为MB请除以1024</code></pre><p>设置用户的限制时间（这个是针对整个分区设置的，所有用户都会一致）</p>\n<pre><code>edquota -t</code></pre><p>将某个用户的限制粘贴给另一个用户（<strong>如果quser2已经有配置了，那么会覆盖掉原有配置</strong>）</p>\n<pre><code>[root@linux ~]# edquota -p quser1 quser2  # 把quser1的复制给 quser2</code></pre><p><strong>查看各用户配置以及使用情况</strong></p>\n<p><strong>1</strong></p>\n<pre><code>[root@linux ~]# quota [-uvsl] [username]\n[root@linux ~]# quota [-gvsl] [groupname]\n参数：\n-u  ：后面可以接 username ，表示显示出该用户的 quota 限制值。若不接 username \n      ，表示显示出执行者的 quota 限制值。\n-g  ：后面可接 groupname ，表示显示出该群组的 quota 限制值。\n-v  ：显示每个 filesystem 的 quota 值；\n-s  ：可选择以 inode 或磁盘容量的限制值来显示；\n-l  ：仅显示出目前本机上面的 filesystem 的 quota 值。\n范例：\n\n范例一：秀出目前 root 自己的 quota 限制值：\n[root@linux ~]# quota -guvs\n\n范例二：秀出 quser1 这个用户的磁盘配额\n[root@linux ~]# quota -u quser1\n# 注意一下这两个范例，如果您的系统上面尚未有任何的 quota 支持的 filesystem 时，\n# 使用这两个范例时，『不会有任何信息列出来』啦！不要以为发生错误啰！</code></pre><p><strong>或者2</strong></p>\n<pre><code>repquota -a</code></pre><h3 id=\"6-设定开机时启动-quota\"><a href=\"#6-设定开机时启动-quota\" class=\"headerlink\" title=\"6 设定开机时启动 quota\"></a>6 <strong>设定开机时启动 quota</strong></h3><pre><code>[root@linux ~]# vi /etc/rc.d/rc.local 在里面加入一行 (直接加在最后一行即可)：如下\n/sbin/quotaon -avug</code></pre><h2 id=\"一个针对某个小组每个人设置限额的脚本\"><a href=\"#一个针对某个小组每个人设置限额的脚本\" class=\"headerlink\" title=\"一个针对某个小组每个人设置限额的脚本\"></a>一个针对某个小组每个人设置限额的脚本</h2><p>思路：</p>\n<ul>\n<li>设置一个模板用户：example（对该用户设置想要的限额）</li>\n<li>针对某用户组所有的用户，将example的配置复制过去。<ul>\n<li>考虑到有用户更新，那么就分两个接口</li>\n<li>1，强制复制，所有人原有的配置都重新更改为example</li>\n<li>2，只针对目前没有限制的人做复制</li>\n</ul>\n</li>\n</ul>\n<pre><code>\n</code></pre><h2 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h2><p><a href=\"http://cn.linux.vbird.org/linux_basic/fedora_4/0420quota-fc4.php\" target=\"_blank\" rel=\"noopener\">鸟哥linux</a></p>\n"},{"_content":"## 变量\n\n- 简单定义一个变量\n\n```\nurl=\"http://c.biancheng.net\"\nwebsite1='C语言中文网：${url}'\nwebsite2=\"C语言中文网：${url}\"\necho $website1   \necho $website2\n```\n\n**单引号代表默认全是字符串**\n\n**双引号代表会解析内部的变量**\n\n- 将代码块的输出定义为变量\n\n```\nvariable=$(command)\necho $variable\n```\n\n## 循环\n\n```\n# 方式一\nfor i in list:\ndo\nshell_command\ndone\n\n#方式二\nfor((i=1;i<=10;i++));  \ndo   \necho $(expr $i \\* 3 + 1);  \ndone\n\n# 方式三\nwhile [ true ] \ndo\necho test\ndone\n```\n\n\n\n## 判断if\n\n```\n# demo 如下\nif  condition\nthen\n   statement1\nelse\n   statement2\nfi\n\n# 例子\nif [ ! \"$a\" = \"\" ]\n\n```\n\n\n\n## 函数\n\n```\n# 手动输入读取参数类型\nfunWithReturn(){\n    echo \"这个函数会对输入的两个数字进行相加运算...\"\n    echo \"输入第一个数字: \"\n    read aNum\n    echo \"输入第二个数字: \"\n    read anotherNum\n    echo \"两个数字分别为 $aNum 和 $anotherNum !\"\n    return $(($aNum+$anotherNum))\n}\n# 可以用这种方式捕获echo的内容。（也就说说可以echo结果然后捕获。）另一种方式是用全局变量\nvar1=$(funWithReturn)\necho \" $var1\"\n\n# 输入参数型\nfunWithParam(){\n    echo \"第一个参数为 $1 !\"\n    echo \"第二个参数为 $2 !\"\n    echo \"第十个参数为 $10 !\"\n    echo \"第十个参数为 ${10} !\"\n    echo \"第十一个参数为 ${11} !\"\n    echo \"参数总数有 $# 个!\"\n    echo \"作为一个字符串输出所有参数 $* !\"\n}\nfunWithParam 1 2 3 4 5 6 7 8 9 34 73\n```\n\n\n\n## 各种括号以及方括号\n\nhttps://blog.csdn.net/taiyang1987912/article/details/39551385\n\n\n\n## my_shell_scropt\n\nOpenwrt network 检测\n\n想来也是傻逼，网络都没了，怎么发送消息报错啊\n\n```\n#!/bin/bash\n\nsend_msg(){\n\nwget --quiet \\\n  --method GET \\\n  --header 'cache-control: no-cache' \\\n  --header 'postman-token: d5c91d47-1f97-6f9a-735d-366f09451895' \\\n  --output-document \\\n  - 'http://110.40.204.239:5700/send_private_msg?user_id=2892211452&message=openwrt%20network%20wrong'\n}\n\n\nwhile((true))\ndo\n\nsleep 120\n\n\n# set try 2 times, and timeout is 1 second\n\nnet_out=$(ping -c 2 -i 1  baidu.com | grep ttl=)\n# iw wlan1 info\n\nif [ ! \"$net_out\" = \"\" ]\nthen\n\tnet_ok\n  #echo \"network exist, $net_out\"\nelse\ndate\n  # restrat the network service\nwifi down && wifi up   # 重启wifi\n/etc/init.d/network restart  #重启网络进程\n  send_msg\n  echo \"network fail\"\nfi\n\ndone\n```\n\n## grep 命令\n\n我们知道grep命令是用来匹配输出的，但是普通的用法是看这行是否含有关键字或者符合正则表达式。\n\n但是实际操作中经常碰到如果匹配到不仅仅输出该行，还有输出相邻的剩下的行。\n\n**打印后面相邻**n行\n\n利用`-A n`达到目的\n\n**打印前面相邻**n行\n\n利用`-B n`达到目的\n\n**打印前后相邻**n行\n\n利用`-C n`达到目的\n\n\n\n\n\n\n\n## awk命令\n\n空格输出多个变量\n\n```\necho $(seq 1 9) | awk '{ print $5,$6,$7}' | while read a b c\n```\n\n指定分割符\n\n```\nawk -F ',' '{print $2, $3}' employee.txt\n```\n\nprintf格式化输出\n\n```\n pip list | awk -F ' ' '{printf(\"%s==%s\\n\", $1, $2)}' \n```\n\n\n\n\n\n\n\n## sed 命令\n\n```\n#匹配行前加\nsed -i '/allow 361way.com   /iallow www.361way.com' the.conf.file\n#匹配行前后\nsed -i '/allow 361way.com   /aallow www.361way.com' the.conf.file\n```\n\n**行前后添加**\n\n```\n\n在首行前插入一行\n# sed -i '1i\\AAA' aa.txt\n在首行后插入一行\n# sed -i '1a\\AAA' aa.txt \n\n在尾行前插入一行\n# sed -i '$i\\AAA' aa.txt \n在尾行后插入一样\n# sed -i '$a\\AAA' aa.txt \n\n\n# 第n行前添加一行\n# sed -i 'ni\\AAA' aa.txt\n\n```\n\n\n\n\n\n\n\n## Mac /linux常用的命令\n\n**大部分linux都能够直接用**\n\n### caffeine 防止息屏命令\n\n```\n# 600000秒不息屏\ncaffeinate -u -t 600000\n```\n\n\n\n### 实时查看网络速度nload\n\n```\n# en0 代表的是设备，可以通过ip address查看哪些设备\nnload device en0\n```\n\n\n\n\n\n### 定时执行\n\n```\n\n实例1：每1分钟执行一次myCommand\n* * * * * myCommand\n(分钟，小时，日，月，星期)\n\n# 星期六的23点执行\n0 23 * * 6 cmd\n\n\n# 每小时的3,15分钟执行\n3,15 * * * * myCommand\n\n# 每小时的3到15分钟执行\n3-15 * * * * myCommand\n\n# 每小时的3到15分钟内，每隔3分钟执行一次\n3-15/3 * * * * myCommand\n\n```\n\n- ***** 取值范围内的所有数字\n- **/** 每过多少个数字\n- **-** 从X到Z\n- **，**散列数字\n\n\n\n### 关于linux用户管理\n查看所有用户\n```\ncat /etc/passwd\n```\n\n添加用户\n```\nuseradd -d /home/test test  # 添加用户test，指定其home目录为/home/test\nuseradd -s /bin/bash -g group test # 添加用户test，指定用户组\n```\n\n删除用户\n```\nuserdel -r test # 加入r是为了删干净，删除了用户和用户的配置文件\n```\n\n添加用户组\n```\ngroupadd -g 101  g1  # 添加用户组g1,指定gid为101\n```\n\n删除用户组\n```\ngroupdel g1\n```\n\n\n\n\n\n### 关于用户文件权限管理\n\n#### **查看文件权限**\n\n`ls -ahl`\n\n假设我这里有一个用户kenger（1002），用户组files（1004）\n\n显示的内容如下：\n\n![image-20221020134132328](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/c53b935433a115d5732aa06e1e6ac8ac/bdd03cabe38c22bbb73f783161e8504d.png)\n\n其中的kenger.txt表示属于kenger用户，files用户组。同组的具有rwx权限。\n\n**- 10个字符确定不同用户能对文件干什么**\n\n**- 第一个字符代表文件（-）、目录（d），链接（l）**\n\n**- 其余字符每3个一组（rwx），读（r）、写（w）、执行（x）**\n\n**- 第一组rwx：文件所有者的权限是读、写和执行**\n\n**- 第二组rw-：与文件所有者同一组的用户的权限是读、写但不能执行**\n\n**- 第三组r--：不与文件所有者同组的其他用户的权限是读不能写和执行**\n\n\n\n#### 更改用户权限\n\n建议用chmod =\n\nchmod 改变文件或目录的权限\n\nchmod 755 abc：赋予abc权限rwxr-xr-x\n\n**chmod u=rwx，g=rx，o=rx abc**：同上u=用户权限，g=组权限，o=不同组其他用户权限\n\nchmod u-x，g+w abc：给abc去除用户执行的权限，增加组写的权限\n\nchmod a+r abc：给所有用户添加读的权限\n\n\n\n\n\n\n\n### 自动输入y 确认\n\n\n\n\n\n# docker 容器相关的命令\n\n**一些容器没有su命令。**\n\n安装的方式\n\n```\n-bash/zsh: su: command not found\n \n#Debian\napt-get install util-linux\n \n#Ubuntu\napt-get install util-linux\n \n#Alpine\napk add util-linux\n \n#Arch Linux\npacman -S util-linux\n \n#Kali Linux\napt-get install util-linux\n \n#CentOS\nyum install util-linux\n \n#Fedora\ndnf install util-linux\n \n#OS X\nbrew install util-linux\n \n#Raspbian\napt-get install login\n \n#Docker\ndocker run cmd.cat/su su\n```\n\n","source":"_posts/服务器相关/shell小note.md","raw":"## 变量\n\n- 简单定义一个变量\n\n```\nurl=\"http://c.biancheng.net\"\nwebsite1='C语言中文网：${url}'\nwebsite2=\"C语言中文网：${url}\"\necho $website1   \necho $website2\n```\n\n**单引号代表默认全是字符串**\n\n**双引号代表会解析内部的变量**\n\n- 将代码块的输出定义为变量\n\n```\nvariable=$(command)\necho $variable\n```\n\n## 循环\n\n```\n# 方式一\nfor i in list:\ndo\nshell_command\ndone\n\n#方式二\nfor((i=1;i<=10;i++));  \ndo   \necho $(expr $i \\* 3 + 1);  \ndone\n\n# 方式三\nwhile [ true ] \ndo\necho test\ndone\n```\n\n\n\n## 判断if\n\n```\n# demo 如下\nif  condition\nthen\n   statement1\nelse\n   statement2\nfi\n\n# 例子\nif [ ! \"$a\" = \"\" ]\n\n```\n\n\n\n## 函数\n\n```\n# 手动输入读取参数类型\nfunWithReturn(){\n    echo \"这个函数会对输入的两个数字进行相加运算...\"\n    echo \"输入第一个数字: \"\n    read aNum\n    echo \"输入第二个数字: \"\n    read anotherNum\n    echo \"两个数字分别为 $aNum 和 $anotherNum !\"\n    return $(($aNum+$anotherNum))\n}\n# 可以用这种方式捕获echo的内容。（也就说说可以echo结果然后捕获。）另一种方式是用全局变量\nvar1=$(funWithReturn)\necho \" $var1\"\n\n# 输入参数型\nfunWithParam(){\n    echo \"第一个参数为 $1 !\"\n    echo \"第二个参数为 $2 !\"\n    echo \"第十个参数为 $10 !\"\n    echo \"第十个参数为 ${10} !\"\n    echo \"第十一个参数为 ${11} !\"\n    echo \"参数总数有 $# 个!\"\n    echo \"作为一个字符串输出所有参数 $* !\"\n}\nfunWithParam 1 2 3 4 5 6 7 8 9 34 73\n```\n\n\n\n## 各种括号以及方括号\n\nhttps://blog.csdn.net/taiyang1987912/article/details/39551385\n\n\n\n## my_shell_scropt\n\nOpenwrt network 检测\n\n想来也是傻逼，网络都没了，怎么发送消息报错啊\n\n```\n#!/bin/bash\n\nsend_msg(){\n\nwget --quiet \\\n  --method GET \\\n  --header 'cache-control: no-cache' \\\n  --header 'postman-token: d5c91d47-1f97-6f9a-735d-366f09451895' \\\n  --output-document \\\n  - 'http://110.40.204.239:5700/send_private_msg?user_id=2892211452&message=openwrt%20network%20wrong'\n}\n\n\nwhile((true))\ndo\n\nsleep 120\n\n\n# set try 2 times, and timeout is 1 second\n\nnet_out=$(ping -c 2 -i 1  baidu.com | grep ttl=)\n# iw wlan1 info\n\nif [ ! \"$net_out\" = \"\" ]\nthen\n\tnet_ok\n  #echo \"network exist, $net_out\"\nelse\ndate\n  # restrat the network service\nwifi down && wifi up   # 重启wifi\n/etc/init.d/network restart  #重启网络进程\n  send_msg\n  echo \"network fail\"\nfi\n\ndone\n```\n\n## grep 命令\n\n我们知道grep命令是用来匹配输出的，但是普通的用法是看这行是否含有关键字或者符合正则表达式。\n\n但是实际操作中经常碰到如果匹配到不仅仅输出该行，还有输出相邻的剩下的行。\n\n**打印后面相邻**n行\n\n利用`-A n`达到目的\n\n**打印前面相邻**n行\n\n利用`-B n`达到目的\n\n**打印前后相邻**n行\n\n利用`-C n`达到目的\n\n\n\n\n\n\n\n## awk命令\n\n空格输出多个变量\n\n```\necho $(seq 1 9) | awk '{ print $5,$6,$7}' | while read a b c\n```\n\n指定分割符\n\n```\nawk -F ',' '{print $2, $3}' employee.txt\n```\n\nprintf格式化输出\n\n```\n pip list | awk -F ' ' '{printf(\"%s==%s\\n\", $1, $2)}' \n```\n\n\n\n\n\n\n\n## sed 命令\n\n```\n#匹配行前加\nsed -i '/allow 361way.com   /iallow www.361way.com' the.conf.file\n#匹配行前后\nsed -i '/allow 361way.com   /aallow www.361way.com' the.conf.file\n```\n\n**行前后添加**\n\n```\n\n在首行前插入一行\n# sed -i '1i\\AAA' aa.txt\n在首行后插入一行\n# sed -i '1a\\AAA' aa.txt \n\n在尾行前插入一行\n# sed -i '$i\\AAA' aa.txt \n在尾行后插入一样\n# sed -i '$a\\AAA' aa.txt \n\n\n# 第n行前添加一行\n# sed -i 'ni\\AAA' aa.txt\n\n```\n\n\n\n\n\n\n\n## Mac /linux常用的命令\n\n**大部分linux都能够直接用**\n\n### caffeine 防止息屏命令\n\n```\n# 600000秒不息屏\ncaffeinate -u -t 600000\n```\n\n\n\n### 实时查看网络速度nload\n\n```\n# en0 代表的是设备，可以通过ip address查看哪些设备\nnload device en0\n```\n\n\n\n\n\n### 定时执行\n\n```\n\n实例1：每1分钟执行一次myCommand\n* * * * * myCommand\n(分钟，小时，日，月，星期)\n\n# 星期六的23点执行\n0 23 * * 6 cmd\n\n\n# 每小时的3,15分钟执行\n3,15 * * * * myCommand\n\n# 每小时的3到15分钟执行\n3-15 * * * * myCommand\n\n# 每小时的3到15分钟内，每隔3分钟执行一次\n3-15/3 * * * * myCommand\n\n```\n\n- ***** 取值范围内的所有数字\n- **/** 每过多少个数字\n- **-** 从X到Z\n- **，**散列数字\n\n\n\n### 关于linux用户管理\n查看所有用户\n```\ncat /etc/passwd\n```\n\n添加用户\n```\nuseradd -d /home/test test  # 添加用户test，指定其home目录为/home/test\nuseradd -s /bin/bash -g group test # 添加用户test，指定用户组\n```\n\n删除用户\n```\nuserdel -r test # 加入r是为了删干净，删除了用户和用户的配置文件\n```\n\n添加用户组\n```\ngroupadd -g 101  g1  # 添加用户组g1,指定gid为101\n```\n\n删除用户组\n```\ngroupdel g1\n```\n\n\n\n\n\n### 关于用户文件权限管理\n\n#### **查看文件权限**\n\n`ls -ahl`\n\n假设我这里有一个用户kenger（1002），用户组files（1004）\n\n显示的内容如下：\n\n![image-20221020134132328](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/c53b935433a115d5732aa06e1e6ac8ac/bdd03cabe38c22bbb73f783161e8504d.png)\n\n其中的kenger.txt表示属于kenger用户，files用户组。同组的具有rwx权限。\n\n**- 10个字符确定不同用户能对文件干什么**\n\n**- 第一个字符代表文件（-）、目录（d），链接（l）**\n\n**- 其余字符每3个一组（rwx），读（r）、写（w）、执行（x）**\n\n**- 第一组rwx：文件所有者的权限是读、写和执行**\n\n**- 第二组rw-：与文件所有者同一组的用户的权限是读、写但不能执行**\n\n**- 第三组r--：不与文件所有者同组的其他用户的权限是读不能写和执行**\n\n\n\n#### 更改用户权限\n\n建议用chmod =\n\nchmod 改变文件或目录的权限\n\nchmod 755 abc：赋予abc权限rwxr-xr-x\n\n**chmod u=rwx，g=rx，o=rx abc**：同上u=用户权限，g=组权限，o=不同组其他用户权限\n\nchmod u-x，g+w abc：给abc去除用户执行的权限，增加组写的权限\n\nchmod a+r abc：给所有用户添加读的权限\n\n\n\n\n\n\n\n### 自动输入y 确认\n\n\n\n\n\n# docker 容器相关的命令\n\n**一些容器没有su命令。**\n\n安装的方式\n\n```\n-bash/zsh: su: command not found\n \n#Debian\napt-get install util-linux\n \n#Ubuntu\napt-get install util-linux\n \n#Alpine\napk add util-linux\n \n#Arch Linux\npacman -S util-linux\n \n#Kali Linux\napt-get install util-linux\n \n#CentOS\nyum install util-linux\n \n#Fedora\ndnf install util-linux\n \n#OS X\nbrew install util-linux\n \n#Raspbian\napt-get install login\n \n#Docker\ndocker run cmd.cat/su su\n```\n\n","slug":"服务器相关/shell小note","published":1,"date":"2023-02-27T11:33:23.586Z","updated":"2023-02-27T11:34:33.145Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsyc700100gcn11x6z7vp","content":"<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><ul>\n<li>简单定义一个变量</li>\n</ul>\n<pre><code>url=&quot;http://c.biancheng.net&quot;\nwebsite1=&#39;C语言中文网：${url}&#39;\nwebsite2=&quot;C语言中文网：${url}&quot;\necho $website1   \necho $website2</code></pre><p><strong>单引号代表默认全是字符串</strong></p>\n<p><strong>双引号代表会解析内部的变量</strong></p>\n<ul>\n<li>将代码块的输出定义为变量</li>\n</ul>\n<pre><code>variable=$(command)\necho $variable</code></pre><h2 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h2><pre><code># 方式一\nfor i in list:\ndo\nshell_command\ndone\n\n#方式二\nfor((i=1;i&lt;=10;i++));  \ndo   \necho $(expr $i \\* 3 + 1);  \ndone\n\n# 方式三\nwhile [ true ] \ndo\necho test\ndone</code></pre><h2 id=\"判断if\"><a href=\"#判断if\" class=\"headerlink\" title=\"判断if\"></a>判断if</h2><pre><code># demo 如下\nif  condition\nthen\n   statement1\nelse\n   statement2\nfi\n\n# 例子\nif [ ! &quot;$a&quot; = &quot;&quot; ]\n</code></pre><h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><pre><code># 手动输入读取参数类型\nfunWithReturn(){\n    echo &quot;这个函数会对输入的两个数字进行相加运算...&quot;\n    echo &quot;输入第一个数字: &quot;\n    read aNum\n    echo &quot;输入第二个数字: &quot;\n    read anotherNum\n    echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot;\n    return $(($aNum+$anotherNum))\n}\n# 可以用这种方式捕获echo的内容。（也就说说可以echo结果然后捕获。）另一种方式是用全局变量\nvar1=$(funWithReturn)\necho &quot; $var1&quot;\n\n# 输入参数型\nfunWithParam(){\n    echo &quot;第一个参数为 $1 !&quot;\n    echo &quot;第二个参数为 $2 !&quot;\n    echo &quot;第十个参数为 $10 !&quot;\n    echo &quot;第十个参数为 ${10} !&quot;\n    echo &quot;第十一个参数为 ${11} !&quot;\n    echo &quot;参数总数有 $# 个!&quot;\n    echo &quot;作为一个字符串输出所有参数 $* !&quot;\n}\nfunWithParam 1 2 3 4 5 6 7 8 9 34 73</code></pre><h2 id=\"各种括号以及方括号\"><a href=\"#各种括号以及方括号\" class=\"headerlink\" title=\"各种括号以及方括号\"></a>各种括号以及方括号</h2><p><a href=\"https://blog.csdn.net/taiyang1987912/article/details/39551385\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/taiyang1987912/article/details/39551385</a></p>\n<h2 id=\"my-shell-scropt\"><a href=\"#my-shell-scropt\" class=\"headerlink\" title=\"my_shell_scropt\"></a>my_shell_scropt</h2><p>Openwrt network 检测</p>\n<p>想来也是傻逼，网络都没了，怎么发送消息报错啊</p>\n<pre><code>#!/bin/bash\n\nsend_msg(){\n\nwget --quiet \\\n  --method GET \\\n  --header &#39;cache-control: no-cache&#39; \\\n  --header &#39;postman-token: d5c91d47-1f97-6f9a-735d-366f09451895&#39; \\\n  --output-document \\\n  - &#39;http://110.40.204.239:5700/send_private_msg?user_id=2892211452&amp;message=openwrt%20network%20wrong&#39;\n}\n\n\nwhile((true))\ndo\n\nsleep 120\n\n\n# set try 2 times, and timeout is 1 second\n\nnet_out=$(ping -c 2 -i 1  baidu.com | grep ttl=)\n# iw wlan1 info\n\nif [ ! &quot;$net_out&quot; = &quot;&quot; ]\nthen\n    net_ok\n  #echo &quot;network exist, $net_out&quot;\nelse\ndate\n  # restrat the network service\nwifi down &amp;&amp; wifi up   # 重启wifi\n/etc/init.d/network restart  #重启网络进程\n  send_msg\n  echo &quot;network fail&quot;\nfi\n\ndone</code></pre><h2 id=\"grep-命令\"><a href=\"#grep-命令\" class=\"headerlink\" title=\"grep 命令\"></a>grep 命令</h2><p>我们知道grep命令是用来匹配输出的，但是普通的用法是看这行是否含有关键字或者符合正则表达式。</p>\n<p>但是实际操作中经常碰到如果匹配到不仅仅输出该行，还有输出相邻的剩下的行。</p>\n<p><strong>打印后面相邻</strong>n行</p>\n<p>利用<code>-A n</code>达到目的</p>\n<p><strong>打印前面相邻</strong>n行</p>\n<p>利用<code>-B n</code>达到目的</p>\n<p><strong>打印前后相邻</strong>n行</p>\n<p>利用<code>-C n</code>达到目的</p>\n<h2 id=\"awk命令\"><a href=\"#awk命令\" class=\"headerlink\" title=\"awk命令\"></a>awk命令</h2><p>空格输出多个变量</p>\n<pre><code>echo $(seq 1 9) | awk &#39;{ print $5,$6,$7}&#39; | while read a b c</code></pre><p>指定分割符</p>\n<pre><code>awk -F &#39;,&#39; &#39;{print $2, $3}&#39; employee.txt</code></pre><p>printf格式化输出</p>\n<pre><code> pip list | awk -F &#39; &#39; &#39;{printf(&quot;%s==%s\\n&quot;, $1, $2)}&#39; </code></pre><h2 id=\"sed-命令\"><a href=\"#sed-命令\" class=\"headerlink\" title=\"sed 命令\"></a>sed 命令</h2><pre><code>#匹配行前加\nsed -i &#39;/allow 361way.com   /iallow www.361way.com&#39; the.conf.file\n#匹配行前后\nsed -i &#39;/allow 361way.com   /aallow www.361way.com&#39; the.conf.file</code></pre><p><strong>行前后添加</strong></p>\n<pre><code>\n在首行前插入一行\n# sed -i &#39;1i\\AAA&#39; aa.txt\n在首行后插入一行\n# sed -i &#39;1a\\AAA&#39; aa.txt \n\n在尾行前插入一行\n# sed -i &#39;$i\\AAA&#39; aa.txt \n在尾行后插入一样\n# sed -i &#39;$a\\AAA&#39; aa.txt \n\n\n# 第n行前添加一行\n# sed -i &#39;ni\\AAA&#39; aa.txt\n</code></pre><h2 id=\"Mac-linux常用的命令\"><a href=\"#Mac-linux常用的命令\" class=\"headerlink\" title=\"Mac /linux常用的命令\"></a>Mac /linux常用的命令</h2><p><strong>大部分linux都能够直接用</strong></p>\n<h3 id=\"caffeine-防止息屏命令\"><a href=\"#caffeine-防止息屏命令\" class=\"headerlink\" title=\"caffeine 防止息屏命令\"></a>caffeine 防止息屏命令</h3><pre><code># 600000秒不息屏\ncaffeinate -u -t 600000</code></pre><h3 id=\"实时查看网络速度nload\"><a href=\"#实时查看网络速度nload\" class=\"headerlink\" title=\"实时查看网络速度nload\"></a>实时查看网络速度nload</h3><pre><code># en0 代表的是设备，可以通过ip address查看哪些设备\nnload device en0</code></pre><h3 id=\"定时执行\"><a href=\"#定时执行\" class=\"headerlink\" title=\"定时执行\"></a>定时执行</h3><pre><code>\n实例1：每1分钟执行一次myCommand\n* * * * * myCommand\n(分钟，小时，日，月，星期)\n\n# 星期六的23点执行\n0 23 * * 6 cmd\n\n\n# 每小时的3,15分钟执行\n3,15 * * * * myCommand\n\n# 每小时的3到15分钟执行\n3-15 * * * * myCommand\n\n# 每小时的3到15分钟内，每隔3分钟执行一次\n3-15/3 * * * * myCommand\n</code></pre><ul>\n<li>***** 取值范围内的所有数字</li>\n<li><strong>/</strong> 每过多少个数字</li>\n<li><strong>-</strong> 从X到Z</li>\n<li><strong>，</strong>散列数字</li>\n</ul>\n<h3 id=\"关于linux用户管理\"><a href=\"#关于linux用户管理\" class=\"headerlink\" title=\"关于linux用户管理\"></a>关于linux用户管理</h3><p>查看所有用户</p>\n<pre><code>cat /etc/passwd</code></pre><p>添加用户</p>\n<pre><code>useradd -d /home/test test  # 添加用户test，指定其home目录为/home/test\nuseradd -s /bin/bash -g group test # 添加用户test，指定用户组</code></pre><p>删除用户</p>\n<pre><code>userdel -r test # 加入r是为了删干净，删除了用户和用户的配置文件</code></pre><p>添加用户组</p>\n<pre><code>groupadd -g 101  g1  # 添加用户组g1,指定gid为101</code></pre><p>删除用户组</p>\n<pre><code>groupdel g1</code></pre><h3 id=\"关于用户文件权限管理\"><a href=\"#关于用户文件权限管理\" class=\"headerlink\" title=\"关于用户文件权限管理\"></a>关于用户文件权限管理</h3><h4 id=\"查看文件权限\"><a href=\"#查看文件权限\" class=\"headerlink\" title=\"查看文件权限\"></a><strong>查看文件权限</strong></h4><p><code>ls -ahl</code></p>\n<p>假设我这里有一个用户kenger（1002），用户组files（1004）</p>\n<p>显示的内容如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/c53b935433a115d5732aa06e1e6ac8ac/bdd03cabe38c22bbb73f783161e8504d.png\" alt=\"image-20221020134132328\"></p>\n<p>其中的kenger.txt表示属于kenger用户，files用户组。同组的具有rwx权限。</p>\n<p><strong>- 10个字符确定不同用户能对文件干什么</strong></p>\n<p><strong>- 第一个字符代表文件（-）、目录（d），链接（l）</strong></p>\n<p><strong>- 其余字符每3个一组（rwx），读（r）、写（w）、执行（x）</strong></p>\n<p><strong>- 第一组rwx：文件所有者的权限是读、写和执行</strong></p>\n<p><strong>- 第二组rw-：与文件所有者同一组的用户的权限是读、写但不能执行</strong></p>\n<p><strong>- 第三组r–：不与文件所有者同组的其他用户的权限是读不能写和执行</strong></p>\n<h4 id=\"更改用户权限\"><a href=\"#更改用户权限\" class=\"headerlink\" title=\"更改用户权限\"></a>更改用户权限</h4><p>建议用chmod =</p>\n<p>chmod 改变文件或目录的权限</p>\n<p>chmod 755 abc：赋予abc权限rwxr-xr-x</p>\n<p><strong>chmod u=rwx，g=rx，o=rx abc</strong>：同上u=用户权限，g=组权限，o=不同组其他用户权限</p>\n<p>chmod u-x，g+w abc：给abc去除用户执行的权限，增加组写的权限</p>\n<p>chmod a+r abc：给所有用户添加读的权限</p>\n<h3 id=\"自动输入y-确认\"><a href=\"#自动输入y-确认\" class=\"headerlink\" title=\"自动输入y 确认\"></a>自动输入y 确认</h3><h1 id=\"docker-容器相关的命令\"><a href=\"#docker-容器相关的命令\" class=\"headerlink\" title=\"docker 容器相关的命令\"></a>docker 容器相关的命令</h1><p><strong>一些容器没有su命令。</strong></p>\n<p>安装的方式</p>\n<pre><code>-bash/zsh: su: command not found\n\n#Debian\napt-get install util-linux\n\n#Ubuntu\napt-get install util-linux\n\n#Alpine\napk add util-linux\n\n#Arch Linux\npacman -S util-linux\n\n#Kali Linux\napt-get install util-linux\n\n#CentOS\nyum install util-linux\n\n#Fedora\ndnf install util-linux\n\n#OS X\nbrew install util-linux\n\n#Raspbian\napt-get install login\n\n#Docker\ndocker run cmd.cat/su su</code></pre>","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><ul>\n<li>简单定义一个变量</li>\n</ul>\n<pre><code>url=&quot;http://c.biancheng.net&quot;\nwebsite1=&#39;C语言中文网：${url}&#39;\nwebsite2=&quot;C语言中文网：${url}&quot;\necho $website1   \necho $website2</code></pre><p><strong>单引号代表默认全是字符串</strong></p>\n<p><strong>双引号代表会解析内部的变量</strong></p>\n<ul>\n<li>将代码块的输出定义为变量</li>\n</ul>\n<pre><code>variable=$(command)\necho $variable</code></pre><h2 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h2><pre><code># 方式一\nfor i in list:\ndo\nshell_command\ndone\n\n#方式二\nfor((i=1;i&lt;=10;i++));  \ndo   \necho $(expr $i \\* 3 + 1);  \ndone\n\n# 方式三\nwhile [ true ] \ndo\necho test\ndone</code></pre><h2 id=\"判断if\"><a href=\"#判断if\" class=\"headerlink\" title=\"判断if\"></a>判断if</h2><pre><code># demo 如下\nif  condition\nthen\n   statement1\nelse\n   statement2\nfi\n\n# 例子\nif [ ! &quot;$a&quot; = &quot;&quot; ]\n</code></pre><h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><pre><code># 手动输入读取参数类型\nfunWithReturn(){\n    echo &quot;这个函数会对输入的两个数字进行相加运算...&quot;\n    echo &quot;输入第一个数字: &quot;\n    read aNum\n    echo &quot;输入第二个数字: &quot;\n    read anotherNum\n    echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot;\n    return $(($aNum+$anotherNum))\n}\n# 可以用这种方式捕获echo的内容。（也就说说可以echo结果然后捕获。）另一种方式是用全局变量\nvar1=$(funWithReturn)\necho &quot; $var1&quot;\n\n# 输入参数型\nfunWithParam(){\n    echo &quot;第一个参数为 $1 !&quot;\n    echo &quot;第二个参数为 $2 !&quot;\n    echo &quot;第十个参数为 $10 !&quot;\n    echo &quot;第十个参数为 ${10} !&quot;\n    echo &quot;第十一个参数为 ${11} !&quot;\n    echo &quot;参数总数有 $# 个!&quot;\n    echo &quot;作为一个字符串输出所有参数 $* !&quot;\n}\nfunWithParam 1 2 3 4 5 6 7 8 9 34 73</code></pre><h2 id=\"各种括号以及方括号\"><a href=\"#各种括号以及方括号\" class=\"headerlink\" title=\"各种括号以及方括号\"></a>各种括号以及方括号</h2><p><a href=\"https://blog.csdn.net/taiyang1987912/article/details/39551385\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/taiyang1987912/article/details/39551385</a></p>\n<h2 id=\"my-shell-scropt\"><a href=\"#my-shell-scropt\" class=\"headerlink\" title=\"my_shell_scropt\"></a>my_shell_scropt</h2><p>Openwrt network 检测</p>\n<p>想来也是傻逼，网络都没了，怎么发送消息报错啊</p>\n<pre><code>#!/bin/bash\n\nsend_msg(){\n\nwget --quiet \\\n  --method GET \\\n  --header &#39;cache-control: no-cache&#39; \\\n  --header &#39;postman-token: d5c91d47-1f97-6f9a-735d-366f09451895&#39; \\\n  --output-document \\\n  - &#39;http://110.40.204.239:5700/send_private_msg?user_id=2892211452&amp;message=openwrt%20network%20wrong&#39;\n}\n\n\nwhile((true))\ndo\n\nsleep 120\n\n\n# set try 2 times, and timeout is 1 second\n\nnet_out=$(ping -c 2 -i 1  baidu.com | grep ttl=)\n# iw wlan1 info\n\nif [ ! &quot;$net_out&quot; = &quot;&quot; ]\nthen\n    net_ok\n  #echo &quot;network exist, $net_out&quot;\nelse\ndate\n  # restrat the network service\nwifi down &amp;&amp; wifi up   # 重启wifi\n/etc/init.d/network restart  #重启网络进程\n  send_msg\n  echo &quot;network fail&quot;\nfi\n\ndone</code></pre><h2 id=\"grep-命令\"><a href=\"#grep-命令\" class=\"headerlink\" title=\"grep 命令\"></a>grep 命令</h2><p>我们知道grep命令是用来匹配输出的，但是普通的用法是看这行是否含有关键字或者符合正则表达式。</p>\n<p>但是实际操作中经常碰到如果匹配到不仅仅输出该行，还有输出相邻的剩下的行。</p>\n<p><strong>打印后面相邻</strong>n行</p>\n<p>利用<code>-A n</code>达到目的</p>\n<p><strong>打印前面相邻</strong>n行</p>\n<p>利用<code>-B n</code>达到目的</p>\n<p><strong>打印前后相邻</strong>n行</p>\n<p>利用<code>-C n</code>达到目的</p>\n<h2 id=\"awk命令\"><a href=\"#awk命令\" class=\"headerlink\" title=\"awk命令\"></a>awk命令</h2><p>空格输出多个变量</p>\n<pre><code>echo $(seq 1 9) | awk &#39;{ print $5,$6,$7}&#39; | while read a b c</code></pre><p>指定分割符</p>\n<pre><code>awk -F &#39;,&#39; &#39;{print $2, $3}&#39; employee.txt</code></pre><p>printf格式化输出</p>\n<pre><code> pip list | awk -F &#39; &#39; &#39;{printf(&quot;%s==%s\\n&quot;, $1, $2)}&#39; </code></pre><h2 id=\"sed-命令\"><a href=\"#sed-命令\" class=\"headerlink\" title=\"sed 命令\"></a>sed 命令</h2><pre><code>#匹配行前加\nsed -i &#39;/allow 361way.com   /iallow www.361way.com&#39; the.conf.file\n#匹配行前后\nsed -i &#39;/allow 361way.com   /aallow www.361way.com&#39; the.conf.file</code></pre><p><strong>行前后添加</strong></p>\n<pre><code>\n在首行前插入一行\n# sed -i &#39;1i\\AAA&#39; aa.txt\n在首行后插入一行\n# sed -i &#39;1a\\AAA&#39; aa.txt \n\n在尾行前插入一行\n# sed -i &#39;$i\\AAA&#39; aa.txt \n在尾行后插入一样\n# sed -i &#39;$a\\AAA&#39; aa.txt \n\n\n# 第n行前添加一行\n# sed -i &#39;ni\\AAA&#39; aa.txt\n</code></pre><h2 id=\"Mac-linux常用的命令\"><a href=\"#Mac-linux常用的命令\" class=\"headerlink\" title=\"Mac /linux常用的命令\"></a>Mac /linux常用的命令</h2><p><strong>大部分linux都能够直接用</strong></p>\n<h3 id=\"caffeine-防止息屏命令\"><a href=\"#caffeine-防止息屏命令\" class=\"headerlink\" title=\"caffeine 防止息屏命令\"></a>caffeine 防止息屏命令</h3><pre><code># 600000秒不息屏\ncaffeinate -u -t 600000</code></pre><h3 id=\"实时查看网络速度nload\"><a href=\"#实时查看网络速度nload\" class=\"headerlink\" title=\"实时查看网络速度nload\"></a>实时查看网络速度nload</h3><pre><code># en0 代表的是设备，可以通过ip address查看哪些设备\nnload device en0</code></pre><h3 id=\"定时执行\"><a href=\"#定时执行\" class=\"headerlink\" title=\"定时执行\"></a>定时执行</h3><pre><code>\n实例1：每1分钟执行一次myCommand\n* * * * * myCommand\n(分钟，小时，日，月，星期)\n\n# 星期六的23点执行\n0 23 * * 6 cmd\n\n\n# 每小时的3,15分钟执行\n3,15 * * * * myCommand\n\n# 每小时的3到15分钟执行\n3-15 * * * * myCommand\n\n# 每小时的3到15分钟内，每隔3分钟执行一次\n3-15/3 * * * * myCommand\n</code></pre><ul>\n<li>***** 取值范围内的所有数字</li>\n<li><strong>/</strong> 每过多少个数字</li>\n<li><strong>-</strong> 从X到Z</li>\n<li><strong>，</strong>散列数字</li>\n</ul>\n<h3 id=\"关于linux用户管理\"><a href=\"#关于linux用户管理\" class=\"headerlink\" title=\"关于linux用户管理\"></a>关于linux用户管理</h3><p>查看所有用户</p>\n<pre><code>cat /etc/passwd</code></pre><p>添加用户</p>\n<pre><code>useradd -d /home/test test  # 添加用户test，指定其home目录为/home/test\nuseradd -s /bin/bash -g group test # 添加用户test，指定用户组</code></pre><p>删除用户</p>\n<pre><code>userdel -r test # 加入r是为了删干净，删除了用户和用户的配置文件</code></pre><p>添加用户组</p>\n<pre><code>groupadd -g 101  g1  # 添加用户组g1,指定gid为101</code></pre><p>删除用户组</p>\n<pre><code>groupdel g1</code></pre><h3 id=\"关于用户文件权限管理\"><a href=\"#关于用户文件权限管理\" class=\"headerlink\" title=\"关于用户文件权限管理\"></a>关于用户文件权限管理</h3><h4 id=\"查看文件权限\"><a href=\"#查看文件权限\" class=\"headerlink\" title=\"查看文件权限\"></a><strong>查看文件权限</strong></h4><p><code>ls -ahl</code></p>\n<p>假设我这里有一个用户kenger（1002），用户组files（1004）</p>\n<p>显示的内容如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/c53b935433a115d5732aa06e1e6ac8ac/bdd03cabe38c22bbb73f783161e8504d.png\" alt=\"image-20221020134132328\"></p>\n<p>其中的kenger.txt表示属于kenger用户，files用户组。同组的具有rwx权限。</p>\n<p><strong>- 10个字符确定不同用户能对文件干什么</strong></p>\n<p><strong>- 第一个字符代表文件（-）、目录（d），链接（l）</strong></p>\n<p><strong>- 其余字符每3个一组（rwx），读（r）、写（w）、执行（x）</strong></p>\n<p><strong>- 第一组rwx：文件所有者的权限是读、写和执行</strong></p>\n<p><strong>- 第二组rw-：与文件所有者同一组的用户的权限是读、写但不能执行</strong></p>\n<p><strong>- 第三组r–：不与文件所有者同组的其他用户的权限是读不能写和执行</strong></p>\n<h4 id=\"更改用户权限\"><a href=\"#更改用户权限\" class=\"headerlink\" title=\"更改用户权限\"></a>更改用户权限</h4><p>建议用chmod =</p>\n<p>chmod 改变文件或目录的权限</p>\n<p>chmod 755 abc：赋予abc权限rwxr-xr-x</p>\n<p><strong>chmod u=rwx，g=rx，o=rx abc</strong>：同上u=用户权限，g=组权限，o=不同组其他用户权限</p>\n<p>chmod u-x，g+w abc：给abc去除用户执行的权限，增加组写的权限</p>\n<p>chmod a+r abc：给所有用户添加读的权限</p>\n<h3 id=\"自动输入y-确认\"><a href=\"#自动输入y-确认\" class=\"headerlink\" title=\"自动输入y 确认\"></a>自动输入y 确认</h3><h1 id=\"docker-容器相关的命令\"><a href=\"#docker-容器相关的命令\" class=\"headerlink\" title=\"docker 容器相关的命令\"></a>docker 容器相关的命令</h1><p><strong>一些容器没有su命令。</strong></p>\n<p>安装的方式</p>\n<pre><code>-bash/zsh: su: command not found\n\n#Debian\napt-get install util-linux\n\n#Ubuntu\napt-get install util-linux\n\n#Alpine\napk add util-linux\n\n#Arch Linux\npacman -S util-linux\n\n#Kali Linux\napt-get install util-linux\n\n#CentOS\nyum install util-linux\n\n#Fedora\ndnf install util-linux\n\n#OS X\nbrew install util-linux\n\n#Raspbian\napt-get install login\n\n#Docker\ndocker run cmd.cat/su su</code></pre>"},{"_content":"# 语法\n\n\n\nshell中将命令结果赋值给变量\n\n两种方法，推荐使用后者，支持嵌套，下面两个参考链接写得很清楚了\n\n```\nvar=`command`\n\nvar=$(command)\n\n```\n\n\n\n# demo\n\n一个经典的判断执行结果的例子\n\n```\ngit_ans='dat8987e'\ngrep_ans=$(echo $git_ans | grep date)\nif [[  $grep_ans != \"\" ]]\nthen\n  echo $git_ans\nelse\n  echo \"仓库文件更新，开始同步\"\nfi\n```\n\n\n\n# ref\n\n参考：\n\nhttp://stackoverflow.com/questions/9449778/what-is-the-benefit-of-using-instead-of-backticks-in-shell-scripts\n\n\n\n\n\n\n\n","source":"_posts/服务器相关/shell将命令执行结果赋值给变量.md","raw":"# 语法\n\n\n\nshell中将命令结果赋值给变量\n\n两种方法，推荐使用后者，支持嵌套，下面两个参考链接写得很清楚了\n\n```\nvar=`command`\n\nvar=$(command)\n\n```\n\n\n\n# demo\n\n一个经典的判断执行结果的例子\n\n```\ngit_ans='dat8987e'\ngrep_ans=$(echo $git_ans | grep date)\nif [[  $grep_ans != \"\" ]]\nthen\n  echo $git_ans\nelse\n  echo \"仓库文件更新，开始同步\"\nfi\n```\n\n\n\n# ref\n\n参考：\n\nhttp://stackoverflow.com/questions/9449778/what-is-the-benefit-of-using-instead-of-backticks-in-shell-scripts\n\n\n\n\n\n\n\n","slug":"服务器相关/shell将命令执行结果赋值给变量","published":1,"date":"2023-02-27T11:33:23.589Z","updated":"2023-02-27T11:34:33.148Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsyc700110gcnkvd33kv6","content":"<h1 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h1><p>shell中将命令结果赋值给变量</p>\n<p>两种方法，推荐使用后者，支持嵌套，下面两个参考链接写得很清楚了</p>\n<pre><code>var=`command`\n\nvar=$(command)\n</code></pre><h1 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h1><p>一个经典的判断执行结果的例子</p>\n<pre><code>git_ans=&#39;dat8987e&#39;\ngrep_ans=$(echo $git_ans | grep date)\nif [[  $grep_ans != &quot;&quot; ]]\nthen\n  echo $git_ans\nelse\n  echo &quot;仓库文件更新，开始同步&quot;\nfi</code></pre><h1 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h1><p>参考：</p>\n<p><a href=\"http://stackoverflow.com/questions/9449778/what-is-the-benefit-of-using-instead-of-backticks-in-shell-scripts\" target=\"_blank\" rel=\"noopener\">http://stackoverflow.com/questions/9449778/what-is-the-benefit-of-using-instead-of-backticks-in-shell-scripts</a></p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h1><p>shell中将命令结果赋值给变量</p>\n<p>两种方法，推荐使用后者，支持嵌套，下面两个参考链接写得很清楚了</p>\n<pre><code>var=`command`\n\nvar=$(command)\n</code></pre><h1 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h1><p>一个经典的判断执行结果的例子</p>\n<pre><code>git_ans=&#39;dat8987e&#39;\ngrep_ans=$(echo $git_ans | grep date)\nif [[  $grep_ans != &quot;&quot; ]]\nthen\n  echo $git_ans\nelse\n  echo &quot;仓库文件更新，开始同步&quot;\nfi</code></pre><h1 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h1><p>参考：</p>\n<p><a href=\"http://stackoverflow.com/questions/9449778/what-is-the-benefit-of-using-instead-of-backticks-in-shell-scripts\" target=\"_blank\" rel=\"noopener\">http://stackoverflow.com/questions/9449778/what-is-the-benefit-of-using-instead-of-backticks-in-shell-scripts</a></p>\n"},{"_content":"# ldap 在linux上同步身份认证\n\n# 安装ldap及其管理器环境\n\n[参考compose文件](https://github.com/2892211452/docker_demo/tree/main/ldap_compose)\n\n安装完成后，可以看到管理界面\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/4ecf958df4cd734532cd81636478dda9/5fef2c31edb928d7b2c1b99c6e422b78.png)\n\n\n具体如何进行账号添加，小组管理可以翻阅相关文档。这里不作展开。\n\n\n# 在linux上配置nslcd连接ldap\n首先要安装相关库\n```\nyum install nss-pam-ldapd\n```\n\n**如果不确定本地是否能够连通服务器ldap，可以用ldap的客户端进行连通性测试**\n`yum install nss-pam-ldapd openldap-clients openldap -y`\n\n**测试ldap服务连通性**\n```\nldapsearch -x -H ldap://110.40.*.*:389 -b dc=lwl,dc=com -D \"cn=admin,dc=lwl,dc=com\" -w your_password\n```\n\n\n\n**注，如果是Ubuntu，那么直接安装**\n\n```\napt-get install libnss-ldapd libpam-ldapd \n```\n\n\n\n\n\n## linux本地配置相关文件\n\n`vi /etc/nsswitch.conf`\n\n关键是在这三组后面添加ldap\n\n```\npasswd:     files sss ldap\nshadow:     files sss ldap\ngroup:      files sss ldap\n```\n\n修改`/etc/nslcd.conf` 文件\n\n```\n# The user and group nslcd should run as.\nuid nslcd\ngid ldap\n\n\nuri ldap://110.40.*.*\n\n\n\nbase dc=lwl,dc=com\nbinddn cn=admin,dc=lwl,dc=com\nbindpw your_password\nssl no\ntls_cacertdir /etc/openldap/cacertsorg\n```\n\n\n\n修改`/etc/openldap/ldap.conf`文件\n\n```\nTLS_CACERTDIR /etc/openldap/cacerts\n\n# Turning this off breaks GSSAPI used with krb5 when rdns = false\n\nSASL_NOCANON    on\nURI ldap://110.40.*.*/\nBASE dc=lwl,dc=com\n```\n\n为了解决新建用户后没有home目录的问题。\n```\n# 在su的时候新建home目录。配置vi /etc/pam.d/system-auth 新增一行配置\nsession required pam_mkhomedir.so skel=/etc/skel umask=0022\n\n# 在ssh的时候新建home目录， 在/etc/pam.d/sshd后面新增一行\nsession    required     pam_mkhomedir.so \n```\n\n**配置完后，启动相关程序**\n```\nsystemctl restart nslcd\nsystemctl restart sshd\n```\n\n## 配置自动同步authconfig，不然密码认证可能不过\n\n安装`yum install authconfig`\n\n运行：\n```\nauthconfig --enableldap --enableldapauth --ldapserver=\"110.40.*.*\" --ldapbasedn=\"dc=lwl,dc=com\" --update\n```\n\n\n\n# 最后getent查看数据库\n\n我们要查看目前有多少用户或者用户组需要用getent命令这个命令可以查看当前的所有信息。包括在线的ldap的数据库里面的用户。\n`getent passwd`\n\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/4ecf958df4cd734532cd81636478dda9/d440b86a9717540789e1a35b5c1c366f.png)\n\n\n\n# 解决一些后序问题\n\n- 解决一些后序问题\n\n    - ssh连接用户home目录没有的问题\n    - 管理用户权限管理的问题。 例如要执行docker命令，但是普通用户没有权限。\n\n    **solution：**\n\n    写一个脚本去监听所有用户，如果当前用户没有home目录，就新建。然后针对每个用户，在.bashrc文件里面对sudo进行alias别名封装一部分docker命令。\n\n    **bashrc_demo文件**\n\n    ```\n    \n    # 封装docker命令\n    alias docker=\"sudo /usr/bin/docker\"\n    ```\n\n    **bash_profle_demo文件**\n\n    因为如果仅仅新建.bashrc 文件，那么ssh进去以后并不会一定执行，加入该文件能够ssh后自动执行bashrc文件。\n\n    ```\n    # if running bash  \n    if [ -n \"$BASH_VERSION\" ]; then  \n        # include .bashrc if it exists  \n        if [ -f \"$HOME/.bashrc\" ]; then  \n            . \"$HOME/.bashrc\"  \n        fi  \n    fi \n    ```\n\n    **shell 脚本**\n\n    - 检查所有用户目录是否创建，没有就建立\n    - 检查所有用户的.bashrc等配置文件是否创建\n      - 没有就创建demo\n      - 有的话就比对我们需要缝合进去的命令，如果缺少就加入（这样可以当个人修改了一些自己需要的bashrc配置后，可以继续在上一个人的基础上添加公共配置）\n\n    ```\n    #!/usr/bin/bash\n    while(true)\n    do\n        # 睡一秒\n        sleep 1\n        \n        # 如果后序匹配特征变了，可以适当改变grep的匹配规则\n        home_drs=$(getent passwd  | grep /home | awk -F: '{print$6}')\n        #echo $home_drs\n        for home_dr in $home_drs;\n        do\n    \n            #echo $home_dr\n    \n            #判断用户文件夹是否存在\n            if [ ! -d \"$home_dr\" ]; then\n              mkdir $home_dr\n              echo \"创建文件夹\" $home_dr\n            fi\n    \n    \n            #判断bash_profile配置文件是否存在\n            file_pre=\"$home_dr/.bash_profile\"\n            if [ ! -f \"$file_pre\" ];\n             then\n              cp bash_profile_demo \"$file_pre\"\n              echo \"创建文件\" \"$file_pre\"\n            fi\n    \n            #判断bashrc配置文件是否存在\n            file=\"$home_dr/.bashrc\"\n            #file=/home/liuwenlong/.bashrc\n            if [ ! -f \"$file\" ];\n             then\n              cp bashrc_demo \"$file\"\n              echo \"创建文件\" $file\n             else\n              echo 'file存在'\n              # 选择去除空行和注释后的命令，判断是否需要加入\n              cat bashrc_demo | grep -v '#' | grep -v '^$' | while read line\n              do\n                        #echo $line\n    \n                        # 判断匹配函数，匹配函数不为0，则包含给定字符\n                        if [ ! `grep -c \"$line\" $file` -ne '0' ];\n                        then\n                            echo \"没有命令行 $line ,补上 \"\n                            echo \"$line\" >> $file\n    \n                        fi\n              done\n    \n            fi\n             \n        done\n    \n    \n    done\n    ```\n\n    **sudoers文件**\n\n    ```\n    # ldap组执行权限开放 docker 命令\n    %group1  ALL=(ALL)      NOPASSWD:/usr/bin/docker\n    ```\n\n    # ref\n\n    [OpenLDAP同步linux用户](https://blog.csdn.net/weixin_42728895/article/details/114540168) [linux nslcd服务,](https://blog.csdn.net/weixin_42101056/article/details/116740544?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5-116740544-blog-116740538.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5-116740544-blog-116740538.pc_relevant_default&utm_relevant_index=10)\n\n    [CentOS 6通过ldap集成AD域账号(nslcd方式)](https://blog.csdn.net/weixin_42101056/article/details/116740544?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5-116740544-blog-116740538.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5-116740544-blog-116740538.pc_relevant_default&utm_relevant_index=10)\n\n    [配置Linux使用LDAP用户认证的方法](https://cloud.tencent.com/developer/article/1721854?from=15425)\n- ](https://cloud.tencent.com/developer/article/1721854?from=15425)\n","source":"_posts/服务器相关/linux同步身份认证.md","raw":"# ldap 在linux上同步身份认证\n\n# 安装ldap及其管理器环境\n\n[参考compose文件](https://github.com/2892211452/docker_demo/tree/main/ldap_compose)\n\n安装完成后，可以看到管理界面\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/4ecf958df4cd734532cd81636478dda9/5fef2c31edb928d7b2c1b99c6e422b78.png)\n\n\n具体如何进行账号添加，小组管理可以翻阅相关文档。这里不作展开。\n\n\n# 在linux上配置nslcd连接ldap\n首先要安装相关库\n```\nyum install nss-pam-ldapd\n```\n\n**如果不确定本地是否能够连通服务器ldap，可以用ldap的客户端进行连通性测试**\n`yum install nss-pam-ldapd openldap-clients openldap -y`\n\n**测试ldap服务连通性**\n```\nldapsearch -x -H ldap://110.40.*.*:389 -b dc=lwl,dc=com -D \"cn=admin,dc=lwl,dc=com\" -w your_password\n```\n\n\n\n**注，如果是Ubuntu，那么直接安装**\n\n```\napt-get install libnss-ldapd libpam-ldapd \n```\n\n\n\n\n\n## linux本地配置相关文件\n\n`vi /etc/nsswitch.conf`\n\n关键是在这三组后面添加ldap\n\n```\npasswd:     files sss ldap\nshadow:     files sss ldap\ngroup:      files sss ldap\n```\n\n修改`/etc/nslcd.conf` 文件\n\n```\n# The user and group nslcd should run as.\nuid nslcd\ngid ldap\n\n\nuri ldap://110.40.*.*\n\n\n\nbase dc=lwl,dc=com\nbinddn cn=admin,dc=lwl,dc=com\nbindpw your_password\nssl no\ntls_cacertdir /etc/openldap/cacertsorg\n```\n\n\n\n修改`/etc/openldap/ldap.conf`文件\n\n```\nTLS_CACERTDIR /etc/openldap/cacerts\n\n# Turning this off breaks GSSAPI used with krb5 when rdns = false\n\nSASL_NOCANON    on\nURI ldap://110.40.*.*/\nBASE dc=lwl,dc=com\n```\n\n为了解决新建用户后没有home目录的问题。\n```\n# 在su的时候新建home目录。配置vi /etc/pam.d/system-auth 新增一行配置\nsession required pam_mkhomedir.so skel=/etc/skel umask=0022\n\n# 在ssh的时候新建home目录， 在/etc/pam.d/sshd后面新增一行\nsession    required     pam_mkhomedir.so \n```\n\n**配置完后，启动相关程序**\n```\nsystemctl restart nslcd\nsystemctl restart sshd\n```\n\n## 配置自动同步authconfig，不然密码认证可能不过\n\n安装`yum install authconfig`\n\n运行：\n```\nauthconfig --enableldap --enableldapauth --ldapserver=\"110.40.*.*\" --ldapbasedn=\"dc=lwl,dc=com\" --update\n```\n\n\n\n# 最后getent查看数据库\n\n我们要查看目前有多少用户或者用户组需要用getent命令这个命令可以查看当前的所有信息。包括在线的ldap的数据库里面的用户。\n`getent passwd`\n\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/4ecf958df4cd734532cd81636478dda9/d440b86a9717540789e1a35b5c1c366f.png)\n\n\n\n# 解决一些后序问题\n\n- 解决一些后序问题\n\n    - ssh连接用户home目录没有的问题\n    - 管理用户权限管理的问题。 例如要执行docker命令，但是普通用户没有权限。\n\n    **solution：**\n\n    写一个脚本去监听所有用户，如果当前用户没有home目录，就新建。然后针对每个用户，在.bashrc文件里面对sudo进行alias别名封装一部分docker命令。\n\n    **bashrc_demo文件**\n\n    ```\n    \n    # 封装docker命令\n    alias docker=\"sudo /usr/bin/docker\"\n    ```\n\n    **bash_profle_demo文件**\n\n    因为如果仅仅新建.bashrc 文件，那么ssh进去以后并不会一定执行，加入该文件能够ssh后自动执行bashrc文件。\n\n    ```\n    # if running bash  \n    if [ -n \"$BASH_VERSION\" ]; then  \n        # include .bashrc if it exists  \n        if [ -f \"$HOME/.bashrc\" ]; then  \n            . \"$HOME/.bashrc\"  \n        fi  \n    fi \n    ```\n\n    **shell 脚本**\n\n    - 检查所有用户目录是否创建，没有就建立\n    - 检查所有用户的.bashrc等配置文件是否创建\n      - 没有就创建demo\n      - 有的话就比对我们需要缝合进去的命令，如果缺少就加入（这样可以当个人修改了一些自己需要的bashrc配置后，可以继续在上一个人的基础上添加公共配置）\n\n    ```\n    #!/usr/bin/bash\n    while(true)\n    do\n        # 睡一秒\n        sleep 1\n        \n        # 如果后序匹配特征变了，可以适当改变grep的匹配规则\n        home_drs=$(getent passwd  | grep /home | awk -F: '{print$6}')\n        #echo $home_drs\n        for home_dr in $home_drs;\n        do\n    \n            #echo $home_dr\n    \n            #判断用户文件夹是否存在\n            if [ ! -d \"$home_dr\" ]; then\n              mkdir $home_dr\n              echo \"创建文件夹\" $home_dr\n            fi\n    \n    \n            #判断bash_profile配置文件是否存在\n            file_pre=\"$home_dr/.bash_profile\"\n            if [ ! -f \"$file_pre\" ];\n             then\n              cp bash_profile_demo \"$file_pre\"\n              echo \"创建文件\" \"$file_pre\"\n            fi\n    \n            #判断bashrc配置文件是否存在\n            file=\"$home_dr/.bashrc\"\n            #file=/home/liuwenlong/.bashrc\n            if [ ! -f \"$file\" ];\n             then\n              cp bashrc_demo \"$file\"\n              echo \"创建文件\" $file\n             else\n              echo 'file存在'\n              # 选择去除空行和注释后的命令，判断是否需要加入\n              cat bashrc_demo | grep -v '#' | grep -v '^$' | while read line\n              do\n                        #echo $line\n    \n                        # 判断匹配函数，匹配函数不为0，则包含给定字符\n                        if [ ! `grep -c \"$line\" $file` -ne '0' ];\n                        then\n                            echo \"没有命令行 $line ,补上 \"\n                            echo \"$line\" >> $file\n    \n                        fi\n              done\n    \n            fi\n             \n        done\n    \n    \n    done\n    ```\n\n    **sudoers文件**\n\n    ```\n    # ldap组执行权限开放 docker 命令\n    %group1  ALL=(ALL)      NOPASSWD:/usr/bin/docker\n    ```\n\n    # ref\n\n    [OpenLDAP同步linux用户](https://blog.csdn.net/weixin_42728895/article/details/114540168) [linux nslcd服务,](https://blog.csdn.net/weixin_42101056/article/details/116740544?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5-116740544-blog-116740538.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5-116740544-blog-116740538.pc_relevant_default&utm_relevant_index=10)\n\n    [CentOS 6通过ldap集成AD域账号(nslcd方式)](https://blog.csdn.net/weixin_42101056/article/details/116740544?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5-116740544-blog-116740538.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5-116740544-blog-116740538.pc_relevant_default&utm_relevant_index=10)\n\n    [配置Linux使用LDAP用户认证的方法](https://cloud.tencent.com/developer/article/1721854?from=15425)\n- ](https://cloud.tencent.com/developer/article/1721854?from=15425)\n","slug":"服务器相关/linux同步身份认证","published":1,"date":"2023-02-27T11:33:23.589Z","updated":"2023-02-27T11:34:33.148Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsyc800120gcn66ho24gd","content":"<h1 id=\"ldap-在linux上同步身份认证\"><a href=\"#ldap-在linux上同步身份认证\" class=\"headerlink\" title=\"ldap 在linux上同步身份认证\"></a>ldap 在linux上同步身份认证</h1><h1 id=\"安装ldap及其管理器环境\"><a href=\"#安装ldap及其管理器环境\" class=\"headerlink\" title=\"安装ldap及其管理器环境\"></a>安装ldap及其管理器环境</h1><p><a href=\"https://github.com/2892211452/docker_demo/tree/main/ldap_compose\" target=\"_blank\" rel=\"noopener\">参考compose文件</a></p>\n<p>安装完成后，可以看到管理界面<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/4ecf958df4cd734532cd81636478dda9/5fef2c31edb928d7b2c1b99c6e422b78.png\" alt></p>\n<p>具体如何进行账号添加，小组管理可以翻阅相关文档。这里不作展开。</p>\n<h1 id=\"在linux上配置nslcd连接ldap\"><a href=\"#在linux上配置nslcd连接ldap\" class=\"headerlink\" title=\"在linux上配置nslcd连接ldap\"></a>在linux上配置nslcd连接ldap</h1><p>首先要安装相关库</p>\n<pre><code>yum install nss-pam-ldapd</code></pre><p><strong>如果不确定本地是否能够连通服务器ldap，可以用ldap的客户端进行连通性测试</strong><br><code>yum install nss-pam-ldapd openldap-clients openldap -y</code></p>\n<p><strong>测试ldap服务连通性</strong></p>\n<pre><code>ldapsearch -x -H ldap://110.40.*.*:389 -b dc=lwl,dc=com -D &quot;cn=admin,dc=lwl,dc=com&quot; -w your_password</code></pre><p><strong>注，如果是Ubuntu，那么直接安装</strong></p>\n<pre><code>apt-get install libnss-ldapd libpam-ldapd </code></pre><h2 id=\"linux本地配置相关文件\"><a href=\"#linux本地配置相关文件\" class=\"headerlink\" title=\"linux本地配置相关文件\"></a>linux本地配置相关文件</h2><p><code>vi /etc/nsswitch.conf</code></p>\n<p>关键是在这三组后面添加ldap</p>\n<pre><code>passwd:     files sss ldap\nshadow:     files sss ldap\ngroup:      files sss ldap</code></pre><p>修改<code>/etc/nslcd.conf</code> 文件</p>\n<pre><code># The user and group nslcd should run as.\nuid nslcd\ngid ldap\n\n\nuri ldap://110.40.*.*\n\n\n\nbase dc=lwl,dc=com\nbinddn cn=admin,dc=lwl,dc=com\nbindpw your_password\nssl no\ntls_cacertdir /etc/openldap/cacertsorg</code></pre><p>修改<code>/etc/openldap/ldap.conf</code>文件</p>\n<pre><code>TLS_CACERTDIR /etc/openldap/cacerts\n\n# Turning this off breaks GSSAPI used with krb5 when rdns = false\n\nSASL_NOCANON    on\nURI ldap://110.40.*.*/\nBASE dc=lwl,dc=com</code></pre><p>为了解决新建用户后没有home目录的问题。</p>\n<pre><code># 在su的时候新建home目录。配置vi /etc/pam.d/system-auth 新增一行配置\nsession required pam_mkhomedir.so skel=/etc/skel umask=0022\n\n# 在ssh的时候新建home目录， 在/etc/pam.d/sshd后面新增一行\nsession    required     pam_mkhomedir.so </code></pre><p><strong>配置完后，启动相关程序</strong></p>\n<pre><code>systemctl restart nslcd\nsystemctl restart sshd</code></pre><h2 id=\"配置自动同步authconfig，不然密码认证可能不过\"><a href=\"#配置自动同步authconfig，不然密码认证可能不过\" class=\"headerlink\" title=\"配置自动同步authconfig，不然密码认证可能不过\"></a>配置自动同步authconfig，不然密码认证可能不过</h2><p>安装<code>yum install authconfig</code></p>\n<p>运行：</p>\n<pre><code>authconfig --enableldap --enableldapauth --ldapserver=&quot;110.40.*.*&quot; --ldapbasedn=&quot;dc=lwl,dc=com&quot; --update</code></pre><h1 id=\"最后getent查看数据库\"><a href=\"#最后getent查看数据库\" class=\"headerlink\" title=\"最后getent查看数据库\"></a>最后getent查看数据库</h1><p>我们要查看目前有多少用户或者用户组需要用getent命令这个命令可以查看当前的所有信息。包括在线的ldap的数据库里面的用户。<br><code>getent passwd</code></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/4ecf958df4cd734532cd81636478dda9/d440b86a9717540789e1a35b5c1c366f.png\" alt></p>\n<h1 id=\"解决一些后序问题\"><a href=\"#解决一些后序问题\" class=\"headerlink\" title=\"解决一些后序问题\"></a>解决一些后序问题</h1><ul>\n<li><p>解决一些后序问题</p>\n<ul>\n<li>ssh连接用户home目录没有的问题</li>\n<li>管理用户权限管理的问题。 例如要执行docker命令，但是普通用户没有权限。</li>\n</ul>\n<p>  <strong>solution：</strong></p>\n<p>  写一个脚本去监听所有用户，如果当前用户没有home目录，就新建。然后针对每个用户，在.bashrc文件里面对sudo进行alias别名封装一部分docker命令。</p>\n<p>  <strong>bashrc_demo文件</strong></p>\n<pre><code>\n  # 封装docker命令\n  alias docker=&quot;sudo /usr/bin/docker&quot;</code></pre><p>  <strong>bash_profle_demo文件</strong></p>\n<p>  因为如果仅仅新建.bashrc 文件，那么ssh进去以后并不会一定执行，加入该文件能够ssh后自动执行bashrc文件。</p>\n<pre><code>  # if running bash  \n  if [ -n &quot;$BASH_VERSION&quot; ]; then  \n      # include .bashrc if it exists  \n      if [ -f &quot;$HOME/.bashrc&quot; ]; then  \n          . &quot;$HOME/.bashrc&quot;  \n      fi  \n  fi </code></pre><p>  <strong>shell 脚本</strong></p>\n<ul>\n<li><p>检查所有用户目录是否创建，没有就建立</p>\n</li>\n<li><p>检查所有用户的.bashrc等配置文件是否创建</p>\n<ul>\n<li>没有就创建demo</li>\n<li>有的话就比对我们需要缝合进去的命令，如果缺少就加入（这样可以当个人修改了一些自己需要的bashrc配置后，可以继续在上一个人的基础上添加公共配置）</li>\n</ul>\n<pre><code>#!/usr/bin/bash\nwhile(true)\ndo\n  # 睡一秒\n  sleep 1\n\n  # 如果后序匹配特征变了，可以适当改变grep的匹配规则\n  home_drs=$(getent passwd  | grep /home | awk -F: &#39;{print$6}&#39;)\n  #echo $home_drs\n  for home_dr in $home_drs;\n  do\n\n      #echo $home_dr\n\n      #判断用户文件夹是否存在\n      if [ ! -d &quot;$home_dr&quot; ]; then\n        mkdir $home_dr\n        echo &quot;创建文件夹&quot; $home_dr\n      fi\n\n</code></pre></li>\n</ul>\n</li>\n</ul>\n<pre><code>        #判断bash_profile配置文件是否存在\n        file_pre=&quot;$home_dr/.bash_profile&quot;\n        if [ ! -f &quot;$file_pre&quot; ];\n         then\n          cp bash_profile_demo &quot;$file_pre&quot;\n          echo &quot;创建文件&quot; &quot;$file_pre&quot;\n        fi\n\n        #判断bashrc配置文件是否存在\n        file=&quot;$home_dr/.bashrc&quot;\n        #file=/home/liuwenlong/.bashrc\n        if [ ! -f &quot;$file&quot; ];\n         then\n          cp bashrc_demo &quot;$file&quot;\n          echo &quot;创建文件&quot; $file\n         else\n          echo &#39;file存在&#39;\n          # 选择去除空行和注释后的命令，判断是否需要加入\n          cat bashrc_demo | grep -v &#39;#&#39; | grep -v &#39;^$&#39; | while read line\n          do\n                    #echo $line\n\n                    # 判断匹配函数，匹配函数不为0，则包含给定字符\n                    if [ ! `grep -c &quot;$line&quot; $file` -ne &#39;0&#39; ];\n                    then\n                        echo &quot;没有命令行 $line ,补上 &quot;\n                        echo &quot;$line&quot; &gt;&gt; $file\n\n                    fi\n          done\n\n        fi\n\n    done\n\n\ndone\n```\n\n**sudoers文件**\n\n```\n# ldap组执行权限开放 docker 命令\n%group1  ALL=(ALL)      NOPASSWD:/usr/bin/docker\n```\n\n# ref\n\n[OpenLDAP同步linux用户](https://blog.csdn.net/weixin_42728895/article/details/114540168) [linux nslcd服务,](https://blog.csdn.net/weixin_42101056/article/details/116740544?spm=1001.2101.3001.6650.5&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5-116740544-blog-116740538.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5-116740544-blog-116740538.pc_relevant_default&amp;utm_relevant_index=10)\n\n[CentOS 6通过ldap集成AD域账号(nslcd方式)](https://blog.csdn.net/weixin_42101056/article/details/116740544?spm=1001.2101.3001.6650.5&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5-116740544-blog-116740538.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5-116740544-blog-116740538.pc_relevant_default&amp;utm_relevant_index=10)\n\n[配置Linux使用LDAP用户认证的方法](https://cloud.tencent.com/developer/article/1721854?from=15425)</code></pre><ul>\n<li>](<a href=\"https://cloud.tencent.com/developer/article/1721854?from=15425\" target=\"_blank\" rel=\"noopener\">https://cloud.tencent.com/developer/article/1721854?from=15425</a>)</li>\n</ul>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"ldap-在linux上同步身份认证\"><a href=\"#ldap-在linux上同步身份认证\" class=\"headerlink\" title=\"ldap 在linux上同步身份认证\"></a>ldap 在linux上同步身份认证</h1><h1 id=\"安装ldap及其管理器环境\"><a href=\"#安装ldap及其管理器环境\" class=\"headerlink\" title=\"安装ldap及其管理器环境\"></a>安装ldap及其管理器环境</h1><p><a href=\"https://github.com/2892211452/docker_demo/tree/main/ldap_compose\" target=\"_blank\" rel=\"noopener\">参考compose文件</a></p>\n<p>安装完成后，可以看到管理界面<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/4ecf958df4cd734532cd81636478dda9/5fef2c31edb928d7b2c1b99c6e422b78.png\" alt></p>\n<p>具体如何进行账号添加，小组管理可以翻阅相关文档。这里不作展开。</p>\n<h1 id=\"在linux上配置nslcd连接ldap\"><a href=\"#在linux上配置nslcd连接ldap\" class=\"headerlink\" title=\"在linux上配置nslcd连接ldap\"></a>在linux上配置nslcd连接ldap</h1><p>首先要安装相关库</p>\n<pre><code>yum install nss-pam-ldapd</code></pre><p><strong>如果不确定本地是否能够连通服务器ldap，可以用ldap的客户端进行连通性测试</strong><br><code>yum install nss-pam-ldapd openldap-clients openldap -y</code></p>\n<p><strong>测试ldap服务连通性</strong></p>\n<pre><code>ldapsearch -x -H ldap://110.40.*.*:389 -b dc=lwl,dc=com -D &quot;cn=admin,dc=lwl,dc=com&quot; -w your_password</code></pre><p><strong>注，如果是Ubuntu，那么直接安装</strong></p>\n<pre><code>apt-get install libnss-ldapd libpam-ldapd </code></pre><h2 id=\"linux本地配置相关文件\"><a href=\"#linux本地配置相关文件\" class=\"headerlink\" title=\"linux本地配置相关文件\"></a>linux本地配置相关文件</h2><p><code>vi /etc/nsswitch.conf</code></p>\n<p>关键是在这三组后面添加ldap</p>\n<pre><code>passwd:     files sss ldap\nshadow:     files sss ldap\ngroup:      files sss ldap</code></pre><p>修改<code>/etc/nslcd.conf</code> 文件</p>\n<pre><code># The user and group nslcd should run as.\nuid nslcd\ngid ldap\n\n\nuri ldap://110.40.*.*\n\n\n\nbase dc=lwl,dc=com\nbinddn cn=admin,dc=lwl,dc=com\nbindpw your_password\nssl no\ntls_cacertdir /etc/openldap/cacertsorg</code></pre><p>修改<code>/etc/openldap/ldap.conf</code>文件</p>\n<pre><code>TLS_CACERTDIR /etc/openldap/cacerts\n\n# Turning this off breaks GSSAPI used with krb5 when rdns = false\n\nSASL_NOCANON    on\nURI ldap://110.40.*.*/\nBASE dc=lwl,dc=com</code></pre><p>为了解决新建用户后没有home目录的问题。</p>\n<pre><code># 在su的时候新建home目录。配置vi /etc/pam.d/system-auth 新增一行配置\nsession required pam_mkhomedir.so skel=/etc/skel umask=0022\n\n# 在ssh的时候新建home目录， 在/etc/pam.d/sshd后面新增一行\nsession    required     pam_mkhomedir.so </code></pre><p><strong>配置完后，启动相关程序</strong></p>\n<pre><code>systemctl restart nslcd\nsystemctl restart sshd</code></pre><h2 id=\"配置自动同步authconfig，不然密码认证可能不过\"><a href=\"#配置自动同步authconfig，不然密码认证可能不过\" class=\"headerlink\" title=\"配置自动同步authconfig，不然密码认证可能不过\"></a>配置自动同步authconfig，不然密码认证可能不过</h2><p>安装<code>yum install authconfig</code></p>\n<p>运行：</p>\n<pre><code>authconfig --enableldap --enableldapauth --ldapserver=&quot;110.40.*.*&quot; --ldapbasedn=&quot;dc=lwl,dc=com&quot; --update</code></pre><h1 id=\"最后getent查看数据库\"><a href=\"#最后getent查看数据库\" class=\"headerlink\" title=\"最后getent查看数据库\"></a>最后getent查看数据库</h1><p>我们要查看目前有多少用户或者用户组需要用getent命令这个命令可以查看当前的所有信息。包括在线的ldap的数据库里面的用户。<br><code>getent passwd</code></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/4ecf958df4cd734532cd81636478dda9/d440b86a9717540789e1a35b5c1c366f.png\" alt></p>\n<h1 id=\"解决一些后序问题\"><a href=\"#解决一些后序问题\" class=\"headerlink\" title=\"解决一些后序问题\"></a>解决一些后序问题</h1><ul>\n<li><p>解决一些后序问题</p>\n<ul>\n<li>ssh连接用户home目录没有的问题</li>\n<li>管理用户权限管理的问题。 例如要执行docker命令，但是普通用户没有权限。</li>\n</ul>\n<p>  <strong>solution：</strong></p>\n<p>  写一个脚本去监听所有用户，如果当前用户没有home目录，就新建。然后针对每个用户，在.bashrc文件里面对sudo进行alias别名封装一部分docker命令。</p>\n<p>  <strong>bashrc_demo文件</strong></p>\n<pre><code>\n  # 封装docker命令\n  alias docker=&quot;sudo /usr/bin/docker&quot;</code></pre><p>  <strong>bash_profle_demo文件</strong></p>\n<p>  因为如果仅仅新建.bashrc 文件，那么ssh进去以后并不会一定执行，加入该文件能够ssh后自动执行bashrc文件。</p>\n<pre><code>  # if running bash  \n  if [ -n &quot;$BASH_VERSION&quot; ]; then  \n      # include .bashrc if it exists  \n      if [ -f &quot;$HOME/.bashrc&quot; ]; then  \n          . &quot;$HOME/.bashrc&quot;  \n      fi  \n  fi </code></pre><p>  <strong>shell 脚本</strong></p>\n<ul>\n<li><p>检查所有用户目录是否创建，没有就建立</p>\n</li>\n<li><p>检查所有用户的.bashrc等配置文件是否创建</p>\n<ul>\n<li>没有就创建demo</li>\n<li>有的话就比对我们需要缝合进去的命令，如果缺少就加入（这样可以当个人修改了一些自己需要的bashrc配置后，可以继续在上一个人的基础上添加公共配置）</li>\n</ul>\n<pre><code>#!/usr/bin/bash\nwhile(true)\ndo\n  # 睡一秒\n  sleep 1\n\n  # 如果后序匹配特征变了，可以适当改变grep的匹配规则\n  home_drs=$(getent passwd  | grep /home | awk -F: &#39;{print$6}&#39;)\n  #echo $home_drs\n  for home_dr in $home_drs;\n  do\n\n      #echo $home_dr\n\n      #判断用户文件夹是否存在\n      if [ ! -d &quot;$home_dr&quot; ]; then\n        mkdir $home_dr\n        echo &quot;创建文件夹&quot; $home_dr\n      fi\n\n</code></pre></li>\n</ul>\n</li>\n</ul>\n<pre><code>        #判断bash_profile配置文件是否存在\n        file_pre=&quot;$home_dr/.bash_profile&quot;\n        if [ ! -f &quot;$file_pre&quot; ];\n         then\n          cp bash_profile_demo &quot;$file_pre&quot;\n          echo &quot;创建文件&quot; &quot;$file_pre&quot;\n        fi\n\n        #判断bashrc配置文件是否存在\n        file=&quot;$home_dr/.bashrc&quot;\n        #file=/home/liuwenlong/.bashrc\n        if [ ! -f &quot;$file&quot; ];\n         then\n          cp bashrc_demo &quot;$file&quot;\n          echo &quot;创建文件&quot; $file\n         else\n          echo &#39;file存在&#39;\n          # 选择去除空行和注释后的命令，判断是否需要加入\n          cat bashrc_demo | grep -v &#39;#&#39; | grep -v &#39;^$&#39; | while read line\n          do\n                    #echo $line\n\n                    # 判断匹配函数，匹配函数不为0，则包含给定字符\n                    if [ ! `grep -c &quot;$line&quot; $file` -ne &#39;0&#39; ];\n                    then\n                        echo &quot;没有命令行 $line ,补上 &quot;\n                        echo &quot;$line&quot; &gt;&gt; $file\n\n                    fi\n          done\n\n        fi\n\n    done\n\n\ndone\n```\n\n**sudoers文件**\n\n```\n# ldap组执行权限开放 docker 命令\n%group1  ALL=(ALL)      NOPASSWD:/usr/bin/docker\n```\n\n# ref\n\n[OpenLDAP同步linux用户](https://blog.csdn.net/weixin_42728895/article/details/114540168) [linux nslcd服务,](https://blog.csdn.net/weixin_42101056/article/details/116740544?spm=1001.2101.3001.6650.5&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5-116740544-blog-116740538.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5-116740544-blog-116740538.pc_relevant_default&amp;utm_relevant_index=10)\n\n[CentOS 6通过ldap集成AD域账号(nslcd方式)](https://blog.csdn.net/weixin_42101056/article/details/116740544?spm=1001.2101.3001.6650.5&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5-116740544-blog-116740538.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-5-116740544-blog-116740538.pc_relevant_default&amp;utm_relevant_index=10)\n\n[配置Linux使用LDAP用户认证的方法](https://cloud.tencent.com/developer/article/1721854?from=15425)</code></pre><ul>\n<li>](<a href=\"https://cloud.tencent.com/developer/article/1721854?from=15425\" target=\"_blank\" rel=\"noopener\">https://cloud.tencent.com/developer/article/1721854?from=15425</a>)</li>\n</ul>\n"},{"_content":"# 架构\n\n在开发过程中，不可避免的需要下载各种程序的可执行文件。如何针对自己系统的发行版下载好久显得很重要。\n\n如何查看系统架构\n\n```\nuname -a\n```\n\n- cpu的架构将决定其指令集，是否是RISC或者CISC。\n\n- 公司\n\n- - **Intel和AMD都是芯片公司**\n  - Intel公司：用的架构大多是x86架构，x86_64架构，和IA64安腾架构。指令集是CISC（复杂指令集）\n  - AMD也是个芯片公司，主业除了设计CPU（AMD不流片，所以没有制造）还有设计显卡（收购的ATI），**AMD设计的CPU和intel x86/x86_64系列兼容**。例如**AMD64**\n\n## 例子\n\n\n\n分类\n\n- 很多时候注意看一下发行版就可以了。例如ubuntu，centos\n\n- x86是指intel的开发的一种32位指令集\n- x86_64，表示是x86指令集的64扩展（兼容32位的64位）。也兼容AMD64。（**x86_64,x64,AMD64基本上是同一个东西）**（AMD做64比intel要早）\n- arm架构，用是精简指令集。M系列苹果就是arm64\n- AArch64是ARMv8的一种执行状态。\n- powerpc64le等，目标架构为64位[PowerPC](https://zh.m.wikipedia.org/wiki/PowerPC)和[Power Architecture](https://zh.m.wikipedia.org/wiki/Power_Architecture)处理器（很少用）\n\n\n\n![image-20230116215725688](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/658b2b5c183fcf1e9130b23aa3785369/2af73444b80ec3a9311613ade8970541.png)\n\n\n\n\n\n\n\n","source":"_posts/服务器相关/linux查看系统架构.md","raw":"# 架构\n\n在开发过程中，不可避免的需要下载各种程序的可执行文件。如何针对自己系统的发行版下载好久显得很重要。\n\n如何查看系统架构\n\n```\nuname -a\n```\n\n- cpu的架构将决定其指令集，是否是RISC或者CISC。\n\n- 公司\n\n- - **Intel和AMD都是芯片公司**\n  - Intel公司：用的架构大多是x86架构，x86_64架构，和IA64安腾架构。指令集是CISC（复杂指令集）\n  - AMD也是个芯片公司，主业除了设计CPU（AMD不流片，所以没有制造）还有设计显卡（收购的ATI），**AMD设计的CPU和intel x86/x86_64系列兼容**。例如**AMD64**\n\n## 例子\n\n\n\n分类\n\n- 很多时候注意看一下发行版就可以了。例如ubuntu，centos\n\n- x86是指intel的开发的一种32位指令集\n- x86_64，表示是x86指令集的64扩展（兼容32位的64位）。也兼容AMD64。（**x86_64,x64,AMD64基本上是同一个东西）**（AMD做64比intel要早）\n- arm架构，用是精简指令集。M系列苹果就是arm64\n- AArch64是ARMv8的一种执行状态。\n- powerpc64le等，目标架构为64位[PowerPC](https://zh.m.wikipedia.org/wiki/PowerPC)和[Power Architecture](https://zh.m.wikipedia.org/wiki/Power_Architecture)处理器（很少用）\n\n\n\n![image-20230116215725688](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/658b2b5c183fcf1e9130b23aa3785369/2af73444b80ec3a9311613ade8970541.png)\n\n\n\n\n\n\n\n","slug":"服务器相关/linux查看系统架构","published":1,"date":"2023-02-27T11:33:23.588Z","updated":"2023-02-27T11:34:33.147Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsyc800130gcnhqii6ite","content":"<h1 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h1><p>在开发过程中，不可避免的需要下载各种程序的可执行文件。如何针对自己系统的发行版下载好久显得很重要。</p>\n<p>如何查看系统架构</p>\n<pre><code>uname -a</code></pre><ul>\n<li><p>cpu的架构将决定其指令集，是否是RISC或者CISC。</p>\n</li>\n<li><p>公司</p>\n</li>\n<li><ul>\n<li><strong>Intel和AMD都是芯片公司</strong></li>\n<li>Intel公司：用的架构大多是x86架构，x86_64架构，和IA64安腾架构。指令集是CISC（复杂指令集）</li>\n<li>AMD也是个芯片公司，主业除了设计CPU（AMD不流片，所以没有制造）还有设计显卡（收购的ATI），<strong>AMD设计的CPU和intel x86/x86_64系列兼容</strong>。例如<strong>AMD64</strong></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>分类</p>\n<ul>\n<li><p>很多时候注意看一下发行版就可以了。例如ubuntu，centos</p>\n</li>\n<li><p>x86是指intel的开发的一种32位指令集</p>\n</li>\n<li><p>x86_64，表示是x86指令集的64扩展（兼容32位的64位）。也兼容AMD64。（<strong>x86_64,x64,AMD64基本上是同一个东西）</strong>（AMD做64比intel要早）</p>\n</li>\n<li><p>arm架构，用是精简指令集。M系列苹果就是arm64</p>\n</li>\n<li><p>AArch64是ARMv8的一种执行状态。</p>\n</li>\n<li><p>powerpc64le等，目标架构为64位<a href=\"https://zh.m.wikipedia.org/wiki/PowerPC\" target=\"_blank\" rel=\"noopener\">PowerPC</a>和<a href=\"https://zh.m.wikipedia.org/wiki/Power_Architecture\" target=\"_blank\" rel=\"noopener\">Power Architecture</a>处理器（很少用）</p>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/658b2b5c183fcf1e9130b23aa3785369/2af73444b80ec3a9311613ade8970541.png\" alt=\"image-20230116215725688\"></p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h1><p>在开发过程中，不可避免的需要下载各种程序的可执行文件。如何针对自己系统的发行版下载好久显得很重要。</p>\n<p>如何查看系统架构</p>\n<pre><code>uname -a</code></pre><ul>\n<li><p>cpu的架构将决定其指令集，是否是RISC或者CISC。</p>\n</li>\n<li><p>公司</p>\n</li>\n<li><ul>\n<li><strong>Intel和AMD都是芯片公司</strong></li>\n<li>Intel公司：用的架构大多是x86架构，x86_64架构，和IA64安腾架构。指令集是CISC（复杂指令集）</li>\n<li>AMD也是个芯片公司，主业除了设计CPU（AMD不流片，所以没有制造）还有设计显卡（收购的ATI），<strong>AMD设计的CPU和intel x86/x86_64系列兼容</strong>。例如<strong>AMD64</strong></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>分类</p>\n<ul>\n<li><p>很多时候注意看一下发行版就可以了。例如ubuntu，centos</p>\n</li>\n<li><p>x86是指intel的开发的一种32位指令集</p>\n</li>\n<li><p>x86_64，表示是x86指令集的64扩展（兼容32位的64位）。也兼容AMD64。（<strong>x86_64,x64,AMD64基本上是同一个东西）</strong>（AMD做64比intel要早）</p>\n</li>\n<li><p>arm架构，用是精简指令集。M系列苹果就是arm64</p>\n</li>\n<li><p>AArch64是ARMv8的一种执行状态。</p>\n</li>\n<li><p>powerpc64le等，目标架构为64位<a href=\"https://zh.m.wikipedia.org/wiki/PowerPC\" target=\"_blank\" rel=\"noopener\">PowerPC</a>和<a href=\"https://zh.m.wikipedia.org/wiki/Power_Architecture\" target=\"_blank\" rel=\"noopener\">Power Architecture</a>处理器（很少用）</p>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/658b2b5c183fcf1e9130b23aa3785369/2af73444b80ec3a9311613ade8970541.png\" alt=\"image-20230116215725688\"></p>\n"},{"_content":"# sudoers文件进行权限管理\n\n作用：能够进行用户以及用户组的权限管理。\n\n使用说明：\n\n**注意，后面的空格只能空一个**\n\n```\n# 用户进行权限管理\nroot    ALL=(ALL) ALL\nroot表示被授权的用户，这里是根用户；\n第一个ALL表示所有计算机；\n第二个ALL表示所有用户；\n第三个ALL表示所有命令；\n\n# 加入%变成root组。\n%root    ALL=(ALL) ALL\n\n# smith组所有用户可以免密码sudo执行useradd，userdel命令\n%smith  ALL=(ALL)  NOPASSWD:useradd,userdel\n```\n\n\n\n## 使用visudo命令进行sudoers文件的修改\n\n如果直接用vim进行sudoers文件的修改，那么是没有纠错功能的，如果sudoers文件配置错误，就会导致用不了sudo权限了，用不了sudo就改不回来了，逻辑闭环。\n\n所以实用visudo命令进行sudoers文件修改，有自动纠错的功能。\n\n进入etc文件夹，输入\n\n```\nvisudo\n```\n\n\n\n# 一个遭遇的小问题\n\n**如果在非root用户情况下，sudoers错误情况下用root权限执行命令**\n\n找到一个神奇的方法：远程的话开两个ssh终端，**两个终端要同一个用户**\n\n![img](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/256a8173241b71a641a53b2611818473/d3937500028f3c23bb88cf2d30177105.png)\n\n 对tty1终端：`输入 echo $$` //获取pid\n\n![img](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/256a8173241b71a641a53b2611818473/8023102ce6f8366254f1184377084c9e.png)\n\n切换到tty2：输入 `pkttyagent --process 获取的pid值 ；此时该tty2终端会卡住`\n\n![img](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/256a8173241b71a641a53b2611818473/35c4611902ca88caa0a631c4e84d6769.png)\n\n切到tty1：输入 `pkexec visudo ；此时tty1也会卡住`\n\n![img](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/256a8173241b71a641a53b2611818473/e7d7d494ae4cc05619a8d73e2043aee1.png)\n\n切到tty2：会看到要求输入密码，对应输入\n\n![img](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/256a8173241b71a641a53b2611818473/c7103736a1a11c107746bd6f74137ad4.png)\n\n切回到tty1：发现已经进入了visudo编辑界面，实际上把**pkexec**后面的命令换成其他也是一样的用sudo执行\n\n# ref\n\n[文献1](https://www.cnblogs.com/wayneliu007/p/10321542.html)\n\n","source":"_posts/服务器相关/sudo权限管理要记与提权.md","raw":"# sudoers文件进行权限管理\n\n作用：能够进行用户以及用户组的权限管理。\n\n使用说明：\n\n**注意，后面的空格只能空一个**\n\n```\n# 用户进行权限管理\nroot    ALL=(ALL) ALL\nroot表示被授权的用户，这里是根用户；\n第一个ALL表示所有计算机；\n第二个ALL表示所有用户；\n第三个ALL表示所有命令；\n\n# 加入%变成root组。\n%root    ALL=(ALL) ALL\n\n# smith组所有用户可以免密码sudo执行useradd，userdel命令\n%smith  ALL=(ALL)  NOPASSWD:useradd,userdel\n```\n\n\n\n## 使用visudo命令进行sudoers文件的修改\n\n如果直接用vim进行sudoers文件的修改，那么是没有纠错功能的，如果sudoers文件配置错误，就会导致用不了sudo权限了，用不了sudo就改不回来了，逻辑闭环。\n\n所以实用visudo命令进行sudoers文件修改，有自动纠错的功能。\n\n进入etc文件夹，输入\n\n```\nvisudo\n```\n\n\n\n# 一个遭遇的小问题\n\n**如果在非root用户情况下，sudoers错误情况下用root权限执行命令**\n\n找到一个神奇的方法：远程的话开两个ssh终端，**两个终端要同一个用户**\n\n![img](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/256a8173241b71a641a53b2611818473/d3937500028f3c23bb88cf2d30177105.png)\n\n 对tty1终端：`输入 echo $$` //获取pid\n\n![img](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/256a8173241b71a641a53b2611818473/8023102ce6f8366254f1184377084c9e.png)\n\n切换到tty2：输入 `pkttyagent --process 获取的pid值 ；此时该tty2终端会卡住`\n\n![img](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/256a8173241b71a641a53b2611818473/35c4611902ca88caa0a631c4e84d6769.png)\n\n切到tty1：输入 `pkexec visudo ；此时tty1也会卡住`\n\n![img](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/256a8173241b71a641a53b2611818473/e7d7d494ae4cc05619a8d73e2043aee1.png)\n\n切到tty2：会看到要求输入密码，对应输入\n\n![img](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/256a8173241b71a641a53b2611818473/c7103736a1a11c107746bd6f74137ad4.png)\n\n切回到tty1：发现已经进入了visudo编辑界面，实际上把**pkexec**后面的命令换成其他也是一样的用sudo执行\n\n# ref\n\n[文献1](https://www.cnblogs.com/wayneliu007/p/10321542.html)\n\n","slug":"服务器相关/sudo权限管理要记与提权","published":1,"date":"2023-02-27T11:33:23.588Z","updated":"2023-02-27T11:34:33.147Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsyc800140gcnzeh1yvq1","content":"<h1 id=\"sudoers文件进行权限管理\"><a href=\"#sudoers文件进行权限管理\" class=\"headerlink\" title=\"sudoers文件进行权限管理\"></a>sudoers文件进行权限管理</h1><p>作用：能够进行用户以及用户组的权限管理。</p>\n<p>使用说明：</p>\n<p><strong>注意，后面的空格只能空一个</strong></p>\n<pre><code># 用户进行权限管理\nroot    ALL=(ALL) ALL\nroot表示被授权的用户，这里是根用户；\n第一个ALL表示所有计算机；\n第二个ALL表示所有用户；\n第三个ALL表示所有命令；\n\n# 加入%变成root组。\n%root    ALL=(ALL) ALL\n\n# smith组所有用户可以免密码sudo执行useradd，userdel命令\n%smith  ALL=(ALL)  NOPASSWD:useradd,userdel</code></pre><h2 id=\"使用visudo命令进行sudoers文件的修改\"><a href=\"#使用visudo命令进行sudoers文件的修改\" class=\"headerlink\" title=\"使用visudo命令进行sudoers文件的修改\"></a>使用visudo命令进行sudoers文件的修改</h2><p>如果直接用vim进行sudoers文件的修改，那么是没有纠错功能的，如果sudoers文件配置错误，就会导致用不了sudo权限了，用不了sudo就改不回来了，逻辑闭环。</p>\n<p>所以实用visudo命令进行sudoers文件修改，有自动纠错的功能。</p>\n<p>进入etc文件夹，输入</p>\n<pre><code>visudo</code></pre><h1 id=\"一个遭遇的小问题\"><a href=\"#一个遭遇的小问题\" class=\"headerlink\" title=\"一个遭遇的小问题\"></a>一个遭遇的小问题</h1><p><strong>如果在非root用户情况下，sudoers错误情况下用root权限执行命令</strong></p>\n<p>找到一个神奇的方法：远程的话开两个ssh终端，<strong>两个终端要同一个用户</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/256a8173241b71a641a53b2611818473/d3937500028f3c23bb88cf2d30177105.png\" alt=\"img\"></p>\n<p> 对tty1终端：<code>输入 echo $$</code> //获取pid</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/256a8173241b71a641a53b2611818473/8023102ce6f8366254f1184377084c9e.png\" alt=\"img\"></p>\n<p>切换到tty2：输入 <code>pkttyagent --process 获取的pid值 ；此时该tty2终端会卡住</code></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/256a8173241b71a641a53b2611818473/35c4611902ca88caa0a631c4e84d6769.png\" alt=\"img\"></p>\n<p>切到tty1：输入 <code>pkexec visudo ；此时tty1也会卡住</code></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/256a8173241b71a641a53b2611818473/e7d7d494ae4cc05619a8d73e2043aee1.png\" alt=\"img\"></p>\n<p>切到tty2：会看到要求输入密码，对应输入</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/256a8173241b71a641a53b2611818473/c7103736a1a11c107746bd6f74137ad4.png\" alt=\"img\"></p>\n<p>切回到tty1：发现已经进入了visudo编辑界面，实际上把<strong>pkexec</strong>后面的命令换成其他也是一样的用sudo执行</p>\n<h1 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h1><p><a href=\"https://www.cnblogs.com/wayneliu007/p/10321542.html\" target=\"_blank\" rel=\"noopener\">文献1</a></p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"sudoers文件进行权限管理\"><a href=\"#sudoers文件进行权限管理\" class=\"headerlink\" title=\"sudoers文件进行权限管理\"></a>sudoers文件进行权限管理</h1><p>作用：能够进行用户以及用户组的权限管理。</p>\n<p>使用说明：</p>\n<p><strong>注意，后面的空格只能空一个</strong></p>\n<pre><code># 用户进行权限管理\nroot    ALL=(ALL) ALL\nroot表示被授权的用户，这里是根用户；\n第一个ALL表示所有计算机；\n第二个ALL表示所有用户；\n第三个ALL表示所有命令；\n\n# 加入%变成root组。\n%root    ALL=(ALL) ALL\n\n# smith组所有用户可以免密码sudo执行useradd，userdel命令\n%smith  ALL=(ALL)  NOPASSWD:useradd,userdel</code></pre><h2 id=\"使用visudo命令进行sudoers文件的修改\"><a href=\"#使用visudo命令进行sudoers文件的修改\" class=\"headerlink\" title=\"使用visudo命令进行sudoers文件的修改\"></a>使用visudo命令进行sudoers文件的修改</h2><p>如果直接用vim进行sudoers文件的修改，那么是没有纠错功能的，如果sudoers文件配置错误，就会导致用不了sudo权限了，用不了sudo就改不回来了，逻辑闭环。</p>\n<p>所以实用visudo命令进行sudoers文件修改，有自动纠错的功能。</p>\n<p>进入etc文件夹，输入</p>\n<pre><code>visudo</code></pre><h1 id=\"一个遭遇的小问题\"><a href=\"#一个遭遇的小问题\" class=\"headerlink\" title=\"一个遭遇的小问题\"></a>一个遭遇的小问题</h1><p><strong>如果在非root用户情况下，sudoers错误情况下用root权限执行命令</strong></p>\n<p>找到一个神奇的方法：远程的话开两个ssh终端，<strong>两个终端要同一个用户</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/256a8173241b71a641a53b2611818473/d3937500028f3c23bb88cf2d30177105.png\" alt=\"img\"></p>\n<p> 对tty1终端：<code>输入 echo $$</code> //获取pid</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/256a8173241b71a641a53b2611818473/8023102ce6f8366254f1184377084c9e.png\" alt=\"img\"></p>\n<p>切换到tty2：输入 <code>pkttyagent --process 获取的pid值 ；此时该tty2终端会卡住</code></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/256a8173241b71a641a53b2611818473/35c4611902ca88caa0a631c4e84d6769.png\" alt=\"img\"></p>\n<p>切到tty1：输入 <code>pkexec visudo ；此时tty1也会卡住</code></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/256a8173241b71a641a53b2611818473/e7d7d494ae4cc05619a8d73e2043aee1.png\" alt=\"img\"></p>\n<p>切到tty2：会看到要求输入密码，对应输入</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/256a8173241b71a641a53b2611818473/c7103736a1a11c107746bd6f74137ad4.png\" alt=\"img\"></p>\n<p>切回到tty1：发现已经进入了visudo编辑界面，实际上把<strong>pkexec</strong>后面的命令换成其他也是一样的用sudo执行</p>\n<h1 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h1><p><a href=\"https://www.cnblogs.com/wayneliu007/p/10321542.html\" target=\"_blank\" rel=\"noopener\">文献1</a></p>\n"},{"_content":"## /dev 目录\n\n/dev这个目录对所有的用户都十分重要。因为在这个目录中包含了所有Linux系统中使用的外部设备。但是这里并不是放的外部设备的驱动程序，这一点和windows,dos操作系统不一样。它实际上是一个访问这些外部设备的端口。我们可以非常方便地去访问这些外部设备，和访问一个文件，一个目录没有任何区别。\n**Linux沿袭[Unix](http://www.ltesting.net/html/76/category-catid-376.html)的风格，将所有设备认成是一个文件。**\n\n一些常见的设备：\n\n```\n　　/dev/hd[a-t]：IDE设备\n\n　　/dev/sd[a-z]：SCSI设备\n\n　　/dev/fd[0-7]：标准软驱\n\n　　/dev/md[0-31]：软raid设备\n\n　　/dev/loop[0-7]：本地回环设备\n\n　　/dev/ram[0-15]：内存\n\n　　/dev/null：无限数据接收设备,相当于黑洞\n\n```\n\n","source":"_posts/服务器相关/一些不那么常用的linux知识.md","raw":"## /dev 目录\n\n/dev这个目录对所有的用户都十分重要。因为在这个目录中包含了所有Linux系统中使用的外部设备。但是这里并不是放的外部设备的驱动程序，这一点和windows,dos操作系统不一样。它实际上是一个访问这些外部设备的端口。我们可以非常方便地去访问这些外部设备，和访问一个文件，一个目录没有任何区别。\n**Linux沿袭[Unix](http://www.ltesting.net/html/76/category-catid-376.html)的风格，将所有设备认成是一个文件。**\n\n一些常见的设备：\n\n```\n　　/dev/hd[a-t]：IDE设备\n\n　　/dev/sd[a-z]：SCSI设备\n\n　　/dev/fd[0-7]：标准软驱\n\n　　/dev/md[0-31]：软raid设备\n\n　　/dev/loop[0-7]：本地回环设备\n\n　　/dev/ram[0-15]：内存\n\n　　/dev/null：无限数据接收设备,相当于黑洞\n\n```\n\n","slug":"服务器相关/一些不那么常用的linux知识","published":1,"date":"2023-02-27T11:33:23.585Z","updated":"2023-02-27T11:34:33.145Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsyc900150gcnoxqwbxwg","content":"<h2 id=\"dev-目录\"><a href=\"#dev-目录\" class=\"headerlink\" title=\"/dev 目录\"></a>/dev 目录</h2><p>/dev这个目录对所有的用户都十分重要。因为在这个目录中包含了所有Linux系统中使用的外部设备。但是这里并不是放的外部设备的驱动程序，这一点和windows,dos操作系统不一样。它实际上是一个访问这些外部设备的端口。我们可以非常方便地去访问这些外部设备，和访问一个文件，一个目录没有任何区别。<br><strong>Linux沿袭<a href=\"http://www.ltesting.net/html/76/category-catid-376.html\" target=\"_blank\" rel=\"noopener\">Unix</a>的风格，将所有设备认成是一个文件。</strong></p>\n<p>一些常见的设备：</p>\n<pre><code>　　/dev/hd[a-t]：IDE设备\n\n　　/dev/sd[a-z]：SCSI设备\n\n　　/dev/fd[0-7]：标准软驱\n\n　　/dev/md[0-31]：软raid设备\n\n　　/dev/loop[0-7]：本地回环设备\n\n　　/dev/ram[0-15]：内存\n\n　　/dev/null：无限数据接收设备,相当于黑洞\n</code></pre>","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h2 id=\"dev-目录\"><a href=\"#dev-目录\" class=\"headerlink\" title=\"/dev 目录\"></a>/dev 目录</h2><p>/dev这个目录对所有的用户都十分重要。因为在这个目录中包含了所有Linux系统中使用的外部设备。但是这里并不是放的外部设备的驱动程序，这一点和windows,dos操作系统不一样。它实际上是一个访问这些外部设备的端口。我们可以非常方便地去访问这些外部设备，和访问一个文件，一个目录没有任何区别。<br><strong>Linux沿袭<a href=\"http://www.ltesting.net/html/76/category-catid-376.html\" target=\"_blank\" rel=\"noopener\">Unix</a>的风格，将所有设备认成是一个文件。</strong></p>\n<p>一些常见的设备：</p>\n<pre><code>　　/dev/hd[a-t]：IDE设备\n\n　　/dev/sd[a-z]：SCSI设备\n\n　　/dev/fd[0-7]：标准软驱\n\n　　/dev/md[0-31]：软raid设备\n\n　　/dev/loop[0-7]：本地回环设备\n\n　　/dev/ram[0-15]：内存\n\n　　/dev/null：无限数据接收设备,相当于黑洞\n</code></pre>"},{"_content":"### 打开指定网页地址\n\n```\n$ w3m www.baidu.com\n```\n\n 可以通过**滚动鼠标**、**按箭头键移动光标**或**点击所需的位置**将光标移动到那里。\n\n### 输入文本框\n\n使用将光标移动到文本框位置，然后**按 Enter键**，就可以输入文本。\n\n### 网页跳转\n\n- 使用将光标移动到超链接位置，然后**按 Enter键**。\n- 按Tab键可将光标移动到页面上的下一个超链接位置。\n\n### 返回上一页\n\n Shift + B\n\n### 选项卡操作\n\n\\# 按 Shift + T打开一个新的选项卡。\n\\# 通过点击它们在标签之间进行切换，也使用 Shift+[ 和 Shift+] 快捷键在选项卡之间切换\n\n\n\n# ref\n\nhttps://www.cnblogs.com/bymo/p/9699353.html","source":"_posts/服务器相关/命令行浏览器w3m.md","raw":"### 打开指定网页地址\n\n```\n$ w3m www.baidu.com\n```\n\n 可以通过**滚动鼠标**、**按箭头键移动光标**或**点击所需的位置**将光标移动到那里。\n\n### 输入文本框\n\n使用将光标移动到文本框位置，然后**按 Enter键**，就可以输入文本。\n\n### 网页跳转\n\n- 使用将光标移动到超链接位置，然后**按 Enter键**。\n- 按Tab键可将光标移动到页面上的下一个超链接位置。\n\n### 返回上一页\n\n Shift + B\n\n### 选项卡操作\n\n\\# 按 Shift + T打开一个新的选项卡。\n\\# 通过点击它们在标签之间进行切换，也使用 Shift+[ 和 Shift+] 快捷键在选项卡之间切换\n\n\n\n# ref\n\nhttps://www.cnblogs.com/bymo/p/9699353.html","slug":"服务器相关/命令行浏览器w3m","published":1,"date":"2023-02-27T11:33:23.588Z","updated":"2023-02-27T11:34:33.147Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsyc900160gcn408xt8sn","content":"<h3 id=\"打开指定网页地址\"><a href=\"#打开指定网页地址\" class=\"headerlink\" title=\"打开指定网页地址\"></a>打开指定网页地址</h3><pre><code>$ w3m www.baidu.com</code></pre><p> 可以通过<strong>滚动鼠标</strong>、<strong>按箭头键移动光标</strong>或<strong>点击所需的位置</strong>将光标移动到那里。</p>\n<h3 id=\"输入文本框\"><a href=\"#输入文本框\" class=\"headerlink\" title=\"输入文本框\"></a>输入文本框</h3><p>使用将光标移动到文本框位置，然后<strong>按 Enter键</strong>，就可以输入文本。</p>\n<h3 id=\"网页跳转\"><a href=\"#网页跳转\" class=\"headerlink\" title=\"网页跳转\"></a>网页跳转</h3><ul>\n<li>使用将光标移动到超链接位置，然后<strong>按 Enter键</strong>。</li>\n<li>按Tab键可将光标移动到页面上的下一个超链接位置。</li>\n</ul>\n<h3 id=\"返回上一页\"><a href=\"#返回上一页\" class=\"headerlink\" title=\"返回上一页\"></a>返回上一页</h3><p> Shift + B</p>\n<h3 id=\"选项卡操作\"><a href=\"#选项卡操作\" class=\"headerlink\" title=\"选项卡操作\"></a>选项卡操作</h3><p># 按 Shift + T打开一个新的选项卡。<br># 通过点击它们在标签之间进行切换，也使用 Shift+[ 和 Shift+] 快捷键在选项卡之间切换</p>\n<h1 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h1><p><a href=\"https://www.cnblogs.com/bymo/p/9699353.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/bymo/p/9699353.html</a></p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h3 id=\"打开指定网页地址\"><a href=\"#打开指定网页地址\" class=\"headerlink\" title=\"打开指定网页地址\"></a>打开指定网页地址</h3><pre><code>$ w3m www.baidu.com</code></pre><p> 可以通过<strong>滚动鼠标</strong>、<strong>按箭头键移动光标</strong>或<strong>点击所需的位置</strong>将光标移动到那里。</p>\n<h3 id=\"输入文本框\"><a href=\"#输入文本框\" class=\"headerlink\" title=\"输入文本框\"></a>输入文本框</h3><p>使用将光标移动到文本框位置，然后<strong>按 Enter键</strong>，就可以输入文本。</p>\n<h3 id=\"网页跳转\"><a href=\"#网页跳转\" class=\"headerlink\" title=\"网页跳转\"></a>网页跳转</h3><ul>\n<li>使用将光标移动到超链接位置，然后<strong>按 Enter键</strong>。</li>\n<li>按Tab键可将光标移动到页面上的下一个超链接位置。</li>\n</ul>\n<h3 id=\"返回上一页\"><a href=\"#返回上一页\" class=\"headerlink\" title=\"返回上一页\"></a>返回上一页</h3><p> Shift + B</p>\n<h3 id=\"选项卡操作\"><a href=\"#选项卡操作\" class=\"headerlink\" title=\"选项卡操作\"></a>选项卡操作</h3><p># 按 Shift + T打开一个新的选项卡。<br># 通过点击它们在标签之间进行切换，也使用 Shift+[ 和 Shift+] 快捷键在选项卡之间切换</p>\n<h1 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h1><p><a href=\"https://www.cnblogs.com/bymo/p/9699353.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/bymo/p/9699353.html</a></p>\n"},{"_content":"# 应用的场景\n\n有若干服务需要访问，他们或者ip不一样，或者端口不一样。\n\n如果一个个的去绑定隐形url域名挺麻烦的。也没必要。\n\n一个优秀的办法是，通过不同的域名访问过去。然后根据域名不同做反向代理。\n\n\n\n# demo\n\n我服务器上有一个wordpress，其端口是8081。我想要通过`blog.kenger.com`去访问该服务。\n\n\n\n## 设置二级域名\n\n先直接将域名指向服务器ip。或者服务器www域名也可以。总之就是直接到80端口。\n\n![image-20221217203603861](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7d3fdd730213faafd876f5c39adc98ca/f6fdfb6c69c5f7b513aa171974e0ea87.png)\n\n## 设置宝塔面板nginx\n\n然后去宝塔\n\n![image-20221217203731037](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7d3fdd730213faafd876f5c39adc98ca/efcab459a012bf898b8bc6260ddaf6a8.png)\n\n\n\n添加一个站点\n\n![image-20221217203751574](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7d3fdd730213faafd876f5c39adc98ca/ea3a5a87ac083d069d4d82b89c69c386.png)\n\n\n\n设置反向代理到本地\n\n![image-20221217204302535](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7d3fdd730213faafd876f5c39adc98ca/693152a0e565faee0ca878b3661da118.png)\n\n### 错误注意\n\n尽量不要用localhost。用127.0.0.1更好。\n\n![image-20221217203808588](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7d3fdd730213faafd876f5c39adc98ca/b403b7242a1e21d95530d7cce95128dc.png)\n\n\n\n然后就可以访问了\n\n\n\n![image-20221217204312605](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7d3fdd730213faafd876f5c39adc98ca/860676fa93d310175d980bf6a266df6d.png)\n\n\n\n\n\n","source":"_posts/服务器相关/基于宝塔nginx的多站点管理.md","raw":"# 应用的场景\n\n有若干服务需要访问，他们或者ip不一样，或者端口不一样。\n\n如果一个个的去绑定隐形url域名挺麻烦的。也没必要。\n\n一个优秀的办法是，通过不同的域名访问过去。然后根据域名不同做反向代理。\n\n\n\n# demo\n\n我服务器上有一个wordpress，其端口是8081。我想要通过`blog.kenger.com`去访问该服务。\n\n\n\n## 设置二级域名\n\n先直接将域名指向服务器ip。或者服务器www域名也可以。总之就是直接到80端口。\n\n![image-20221217203603861](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7d3fdd730213faafd876f5c39adc98ca/f6fdfb6c69c5f7b513aa171974e0ea87.png)\n\n## 设置宝塔面板nginx\n\n然后去宝塔\n\n![image-20221217203731037](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7d3fdd730213faafd876f5c39adc98ca/efcab459a012bf898b8bc6260ddaf6a8.png)\n\n\n\n添加一个站点\n\n![image-20221217203751574](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7d3fdd730213faafd876f5c39adc98ca/ea3a5a87ac083d069d4d82b89c69c386.png)\n\n\n\n设置反向代理到本地\n\n![image-20221217204302535](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7d3fdd730213faafd876f5c39adc98ca/693152a0e565faee0ca878b3661da118.png)\n\n### 错误注意\n\n尽量不要用localhost。用127.0.0.1更好。\n\n![image-20221217203808588](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7d3fdd730213faafd876f5c39adc98ca/b403b7242a1e21d95530d7cce95128dc.png)\n\n\n\n然后就可以访问了\n\n\n\n![image-20221217204312605](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7d3fdd730213faafd876f5c39adc98ca/860676fa93d310175d980bf6a266df6d.png)\n\n\n\n\n\n","slug":"服务器相关/基于宝塔nginx的多站点管理","published":1,"date":"2023-02-27T11:33:23.588Z","updated":"2023-02-27T11:34:33.147Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsyca00170gcnqs172sh9","content":"<h1 id=\"应用的场景\"><a href=\"#应用的场景\" class=\"headerlink\" title=\"应用的场景\"></a>应用的场景</h1><p>有若干服务需要访问，他们或者ip不一样，或者端口不一样。</p>\n<p>如果一个个的去绑定隐形url域名挺麻烦的。也没必要。</p>\n<p>一个优秀的办法是，通过不同的域名访问过去。然后根据域名不同做反向代理。</p>\n<h1 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h1><p>我服务器上有一个wordpress，其端口是8081。我想要通过<code>blog.kenger.com</code>去访问该服务。</p>\n<h2 id=\"设置二级域名\"><a href=\"#设置二级域名\" class=\"headerlink\" title=\"设置二级域名\"></a>设置二级域名</h2><p>先直接将域名指向服务器ip。或者服务器www域名也可以。总之就是直接到80端口。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7d3fdd730213faafd876f5c39adc98ca/f6fdfb6c69c5f7b513aa171974e0ea87.png\" alt=\"image-20221217203603861\"></p>\n<h2 id=\"设置宝塔面板nginx\"><a href=\"#设置宝塔面板nginx\" class=\"headerlink\" title=\"设置宝塔面板nginx\"></a>设置宝塔面板nginx</h2><p>然后去宝塔</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7d3fdd730213faafd876f5c39adc98ca/efcab459a012bf898b8bc6260ddaf6a8.png\" alt=\"image-20221217203731037\"></p>\n<p>添加一个站点</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7d3fdd730213faafd876f5c39adc98ca/ea3a5a87ac083d069d4d82b89c69c386.png\" alt=\"image-20221217203751574\"></p>\n<p>设置反向代理到本地</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7d3fdd730213faafd876f5c39adc98ca/693152a0e565faee0ca878b3661da118.png\" alt=\"image-20221217204302535\"></p>\n<h3 id=\"错误注意\"><a href=\"#错误注意\" class=\"headerlink\" title=\"错误注意\"></a>错误注意</h3><p>尽量不要用localhost。用127.0.0.1更好。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7d3fdd730213faafd876f5c39adc98ca/b403b7242a1e21d95530d7cce95128dc.png\" alt=\"image-20221217203808588\"></p>\n<p>然后就可以访问了</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7d3fdd730213faafd876f5c39adc98ca/860676fa93d310175d980bf6a266df6d.png\" alt=\"image-20221217204312605\"></p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"应用的场景\"><a href=\"#应用的场景\" class=\"headerlink\" title=\"应用的场景\"></a>应用的场景</h1><p>有若干服务需要访问，他们或者ip不一样，或者端口不一样。</p>\n<p>如果一个个的去绑定隐形url域名挺麻烦的。也没必要。</p>\n<p>一个优秀的办法是，通过不同的域名访问过去。然后根据域名不同做反向代理。</p>\n<h1 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h1><p>我服务器上有一个wordpress，其端口是8081。我想要通过<code>blog.kenger.com</code>去访问该服务。</p>\n<h2 id=\"设置二级域名\"><a href=\"#设置二级域名\" class=\"headerlink\" title=\"设置二级域名\"></a>设置二级域名</h2><p>先直接将域名指向服务器ip。或者服务器www域名也可以。总之就是直接到80端口。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7d3fdd730213faafd876f5c39adc98ca/f6fdfb6c69c5f7b513aa171974e0ea87.png\" alt=\"image-20221217203603861\"></p>\n<h2 id=\"设置宝塔面板nginx\"><a href=\"#设置宝塔面板nginx\" class=\"headerlink\" title=\"设置宝塔面板nginx\"></a>设置宝塔面板nginx</h2><p>然后去宝塔</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7d3fdd730213faafd876f5c39adc98ca/efcab459a012bf898b8bc6260ddaf6a8.png\" alt=\"image-20221217203731037\"></p>\n<p>添加一个站点</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7d3fdd730213faafd876f5c39adc98ca/ea3a5a87ac083d069d4d82b89c69c386.png\" alt=\"image-20221217203751574\"></p>\n<p>设置反向代理到本地</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7d3fdd730213faafd876f5c39adc98ca/693152a0e565faee0ca878b3661da118.png\" alt=\"image-20221217204302535\"></p>\n<h3 id=\"错误注意\"><a href=\"#错误注意\" class=\"headerlink\" title=\"错误注意\"></a>错误注意</h3><p>尽量不要用localhost。用127.0.0.1更好。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7d3fdd730213faafd876f5c39adc98ca/b403b7242a1e21d95530d7cce95128dc.png\" alt=\"image-20221217203808588\"></p>\n<p>然后就可以访问了</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7d3fdd730213faafd876f5c39adc98ca/860676fa93d310175d980bf6a266df6d.png\" alt=\"image-20221217204312605\"></p>\n"},{"_content":"# 服务器可以挂载很多云网盘\n\n**用到的工具Rclone**\n\n可以支持很多的云盘，不仅仅是google，还有onedrive等。\n\n\n\n# 安装相关库\n\n```\ncurl https://rclone.org/install.sh | sudo bash\n\n\nyum install fuse\n```\n\n\n\n# 用rclone登录云盘配置\n\n```\nrclone config\n```\n\nout\n\n```\n2020/03/04 17:17:28 NOTICE: Config file \"/root/.config/rclone/rclone.conf\" not found - using defaults\nNo remotes found - make a new one\nn) New remote\ns) Set configuration password\nq) Quit config\n```\n\n选择n，建立新的远程连接\n\n然后输入名字。这个可以随便自己填。\n\n然后有：\n\n![image-20220831231450455](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/ddc552e2fb60427a31c6b3d28ba21944/190c5cd6fd72ae07d40dc37b782a5c5b.png)\n\n**对于这个id以及secret，输入enter跳过就行。**\n\n\n\n然后要选择Rclone对Google Drive网盘文件的操作权限：选择1\n\n```\nOption scope.\nScope that rclone should use when requesting access from drive.\nEnter a string value. Press Enter for the default (\"\").\nChoose a number from below, or type in your own value.\n 1 / Full access all files, excluding Application Data Folder.\n   \\ \"drive\"\n 2 / Read-only access to file metadata and file contents.\n   \\ \"drive.readonly\"\n   / Access to files created by rclone only.\n 3 | These are visible in the drive website.\n   | File authorization is revoked when the user deauthorizes the app.\n   \\ \"drive.file\"\n   / Allows read and write access to the Application Data folder.\n 4 | This is not visible in the drive website.\n   \\ \"drive.appfolder\"\n   / Allows read-only access to file metadata but\n 5 | does not allow any access to read or download file content.\n   \\ \"drive.metadata.readonly\"\nscope> 1\n\n```\n\n然后是一些设置\n\n```\n# 一\nEdit advanced config?\ny) Yes\nn) No (default)\ny/n> n\n\n# 二\nUse auto config?\n * Say Y if not sure\n * Say N if you are working on a remote or headless machine\n\ny) Yes (default)\nn) No\ny/n> n\n\n\n```\n\n\n\n**关键；然后会出现一个需要到网页登录验证的连接。用nginx做跨越访问代理到公网。**\n\n```\n2022/08/31 23:17:42 NOTICE: If your browser doesn't open automatically go to the following link: http://127.0.0.1:53682/auth?state=-y3AQQerN0TGxaYaTe7TIQ\n2022/08/31 23:17:42 NOTICE: Log in and authorize rclone for access\n2022/08/31 23:17:42 NOTICE: Waiting for code...\n```\n\n对于http://127.0.0.1:53682/auth?state=-y3AQQerN0TGxaYaTe7TIQ 代理到公网访问登录。\n\n\n\n后面会出现一些设置选项，基本选择yes。然后可以退出了。\n\n\n\n# 挂载\n\n```\nrclone mount GoogleDrive: /google --allow-other --allow-non-empty --vfs-cache-mode writes\n```\n\n解释：\n\n**rclone mount 我之前输入的云盘名字: 本地被挂载的路径--allow-other --allow-non-empty --vfs-cache-mode writes**\n\n\n\n挂载onedrive\n\n```\nrclone mount one_drive_test1: /onedrive --allow-other --allow-non-empty --vfs-cache-mode writes\n```\n\n\n\n\n\n# 查看\n\n```\ndf -h\n```\n\n![image-20220831232119105](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/ddc552e2fb60427a31c6b3d28ba21944/c80ebaf306121bc49740af4fe17cb717.png)\n\n\n\n可以正常访问。\n\n\n\n\n\n# 关于挂载onedrive云盘。\n\n我这里用的是从pdd上买的5T永久免费盘。\n基本流程和上面是一致的，但是要注意：\n- 这个要选择第一个\n\n- ![image-20220917175707801](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/ddc552e2fb60427a31c6b3d28ba21944/8e7ea2a21d97e78f3d5ff4631ce393f1.png)\n\n  \n\n\n\n# ref\n\nhttps://www.unvone.com/69270.html\n\nhttps://333rd.net/posts/tech/linux%E4%BD%BF%E7%94%A8rclone%E6%8C%82%E8%BD%BDgoogle-drive%E7%BD%91%E7%9B%98/","source":"_posts/服务器相关/服务器挂载其他云盘，例如googledrive，onedrive.md","raw":"# 服务器可以挂载很多云网盘\n\n**用到的工具Rclone**\n\n可以支持很多的云盘，不仅仅是google，还有onedrive等。\n\n\n\n# 安装相关库\n\n```\ncurl https://rclone.org/install.sh | sudo bash\n\n\nyum install fuse\n```\n\n\n\n# 用rclone登录云盘配置\n\n```\nrclone config\n```\n\nout\n\n```\n2020/03/04 17:17:28 NOTICE: Config file \"/root/.config/rclone/rclone.conf\" not found - using defaults\nNo remotes found - make a new one\nn) New remote\ns) Set configuration password\nq) Quit config\n```\n\n选择n，建立新的远程连接\n\n然后输入名字。这个可以随便自己填。\n\n然后有：\n\n![image-20220831231450455](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/ddc552e2fb60427a31c6b3d28ba21944/190c5cd6fd72ae07d40dc37b782a5c5b.png)\n\n**对于这个id以及secret，输入enter跳过就行。**\n\n\n\n然后要选择Rclone对Google Drive网盘文件的操作权限：选择1\n\n```\nOption scope.\nScope that rclone should use when requesting access from drive.\nEnter a string value. Press Enter for the default (\"\").\nChoose a number from below, or type in your own value.\n 1 / Full access all files, excluding Application Data Folder.\n   \\ \"drive\"\n 2 / Read-only access to file metadata and file contents.\n   \\ \"drive.readonly\"\n   / Access to files created by rclone only.\n 3 | These are visible in the drive website.\n   | File authorization is revoked when the user deauthorizes the app.\n   \\ \"drive.file\"\n   / Allows read and write access to the Application Data folder.\n 4 | This is not visible in the drive website.\n   \\ \"drive.appfolder\"\n   / Allows read-only access to file metadata but\n 5 | does not allow any access to read or download file content.\n   \\ \"drive.metadata.readonly\"\nscope> 1\n\n```\n\n然后是一些设置\n\n```\n# 一\nEdit advanced config?\ny) Yes\nn) No (default)\ny/n> n\n\n# 二\nUse auto config?\n * Say Y if not sure\n * Say N if you are working on a remote or headless machine\n\ny) Yes (default)\nn) No\ny/n> n\n\n\n```\n\n\n\n**关键；然后会出现一个需要到网页登录验证的连接。用nginx做跨越访问代理到公网。**\n\n```\n2022/08/31 23:17:42 NOTICE: If your browser doesn't open automatically go to the following link: http://127.0.0.1:53682/auth?state=-y3AQQerN0TGxaYaTe7TIQ\n2022/08/31 23:17:42 NOTICE: Log in and authorize rclone for access\n2022/08/31 23:17:42 NOTICE: Waiting for code...\n```\n\n对于http://127.0.0.1:53682/auth?state=-y3AQQerN0TGxaYaTe7TIQ 代理到公网访问登录。\n\n\n\n后面会出现一些设置选项，基本选择yes。然后可以退出了。\n\n\n\n# 挂载\n\n```\nrclone mount GoogleDrive: /google --allow-other --allow-non-empty --vfs-cache-mode writes\n```\n\n解释：\n\n**rclone mount 我之前输入的云盘名字: 本地被挂载的路径--allow-other --allow-non-empty --vfs-cache-mode writes**\n\n\n\n挂载onedrive\n\n```\nrclone mount one_drive_test1: /onedrive --allow-other --allow-non-empty --vfs-cache-mode writes\n```\n\n\n\n\n\n# 查看\n\n```\ndf -h\n```\n\n![image-20220831232119105](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/ddc552e2fb60427a31c6b3d28ba21944/c80ebaf306121bc49740af4fe17cb717.png)\n\n\n\n可以正常访问。\n\n\n\n\n\n# 关于挂载onedrive云盘。\n\n我这里用的是从pdd上买的5T永久免费盘。\n基本流程和上面是一致的，但是要注意：\n- 这个要选择第一个\n\n- ![image-20220917175707801](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/ddc552e2fb60427a31c6b3d28ba21944/8e7ea2a21d97e78f3d5ff4631ce393f1.png)\n\n  \n\n\n\n# ref\n\nhttps://www.unvone.com/69270.html\n\nhttps://333rd.net/posts/tech/linux%E4%BD%BF%E7%94%A8rclone%E6%8C%82%E8%BD%BDgoogle-drive%E7%BD%91%E7%9B%98/","slug":"服务器相关/服务器挂载其他云盘，例如googledrive，onedrive","published":1,"date":"2023-02-27T11:33:23.588Z","updated":"2023-02-27T11:34:33.147Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsyca00180gcndip1u45y","content":"<h1 id=\"服务器可以挂载很多云网盘\"><a href=\"#服务器可以挂载很多云网盘\" class=\"headerlink\" title=\"服务器可以挂载很多云网盘\"></a>服务器可以挂载很多云网盘</h1><p><strong>用到的工具Rclone</strong></p>\n<p>可以支持很多的云盘，不仅仅是google，还有onedrive等。</p>\n<h1 id=\"安装相关库\"><a href=\"#安装相关库\" class=\"headerlink\" title=\"安装相关库\"></a>安装相关库</h1><pre><code>curl https://rclone.org/install.sh | sudo bash\n\n\nyum install fuse</code></pre><h1 id=\"用rclone登录云盘配置\"><a href=\"#用rclone登录云盘配置\" class=\"headerlink\" title=\"用rclone登录云盘配置\"></a>用rclone登录云盘配置</h1><pre><code>rclone config</code></pre><p>out</p>\n<pre><code>2020/03/04 17:17:28 NOTICE: Config file &quot;/root/.config/rclone/rclone.conf&quot; not found - using defaults\nNo remotes found - make a new one\nn) New remote\ns) Set configuration password\nq) Quit config</code></pre><p>选择n，建立新的远程连接</p>\n<p>然后输入名字。这个可以随便自己填。</p>\n<p>然后有：</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/ddc552e2fb60427a31c6b3d28ba21944/190c5cd6fd72ae07d40dc37b782a5c5b.png\" alt=\"image-20220831231450455\"></p>\n<p><strong>对于这个id以及secret，输入enter跳过就行。</strong></p>\n<p>然后要选择Rclone对Google Drive网盘文件的操作权限：选择1</p>\n<pre><code>Option scope.\nScope that rclone should use when requesting access from drive.\nEnter a string value. Press Enter for the default (&quot;&quot;).\nChoose a number from below, or type in your own value.\n 1 / Full access all files, excluding Application Data Folder.\n   \\ &quot;drive&quot;\n 2 / Read-only access to file metadata and file contents.\n   \\ &quot;drive.readonly&quot;\n   / Access to files created by rclone only.\n 3 | These are visible in the drive website.\n   | File authorization is revoked when the user deauthorizes the app.\n   \\ &quot;drive.file&quot;\n   / Allows read and write access to the Application Data folder.\n 4 | This is not visible in the drive website.\n   \\ &quot;drive.appfolder&quot;\n   / Allows read-only access to file metadata but\n 5 | does not allow any access to read or download file content.\n   \\ &quot;drive.metadata.readonly&quot;\nscope&gt; 1\n</code></pre><p>然后是一些设置</p>\n<pre><code># 一\nEdit advanced config?\ny) Yes\nn) No (default)\ny/n&gt; n\n\n# 二\nUse auto config?\n * Say Y if not sure\n * Say N if you are working on a remote or headless machine\n\ny) Yes (default)\nn) No\ny/n&gt; n\n\n</code></pre><p><strong>关键；然后会出现一个需要到网页登录验证的连接。用nginx做跨越访问代理到公网。</strong></p>\n<pre><code>2022/08/31 23:17:42 NOTICE: If your browser doesn&#39;t open automatically go to the following link: http://127.0.0.1:53682/auth?state=-y3AQQerN0TGxaYaTe7TIQ\n2022/08/31 23:17:42 NOTICE: Log in and authorize rclone for access\n2022/08/31 23:17:42 NOTICE: Waiting for code...</code></pre><p>对于<a href=\"http://127.0.0.1:53682/auth?state=-y3AQQerN0TGxaYaTe7TIQ\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:53682/auth?state=-y3AQQerN0TGxaYaTe7TIQ</a> 代理到公网访问登录。</p>\n<p>后面会出现一些设置选项，基本选择yes。然后可以退出了。</p>\n<h1 id=\"挂载\"><a href=\"#挂载\" class=\"headerlink\" title=\"挂载\"></a>挂载</h1><pre><code>rclone mount GoogleDrive: /google --allow-other --allow-non-empty --vfs-cache-mode writes</code></pre><p>解释：</p>\n<p><strong>rclone mount 我之前输入的云盘名字: 本地被挂载的路径–allow-other –allow-non-empty –vfs-cache-mode writes</strong></p>\n<p>挂载onedrive</p>\n<pre><code>rclone mount one_drive_test1: /onedrive --allow-other --allow-non-empty --vfs-cache-mode writes</code></pre><h1 id=\"查看\"><a href=\"#查看\" class=\"headerlink\" title=\"查看\"></a>查看</h1><pre><code>df -h</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/ddc552e2fb60427a31c6b3d28ba21944/c80ebaf306121bc49740af4fe17cb717.png\" alt=\"image-20220831232119105\"></p>\n<p>可以正常访问。</p>\n<h1 id=\"关于挂载onedrive云盘。\"><a href=\"#关于挂载onedrive云盘。\" class=\"headerlink\" title=\"关于挂载onedrive云盘。\"></a>关于挂载onedrive云盘。</h1><p>我这里用的是从pdd上买的5T永久免费盘。<br>基本流程和上面是一致的，但是要注意：</p>\n<ul>\n<li><p>这个要选择第一个</p>\n</li>\n<li><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/ddc552e2fb60427a31c6b3d28ba21944/8e7ea2a21d97e78f3d5ff4631ce393f1.png\" alt=\"image-20220917175707801\"></p>\n</li>\n</ul>\n<h1 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h1><p><a href=\"https://www.unvone.com/69270.html\" target=\"_blank\" rel=\"noopener\">https://www.unvone.com/69270.html</a></p>\n<p><a href=\"https://333rd.net/posts/tech/linux%E4%BD%BF%E7%94%A8rclone%E6%8C%82%E8%BD%BDgoogle-drive%E7%BD%91%E7%9B%98/\" target=\"_blank\" rel=\"noopener\">https://333rd.net/posts/tech/linux%E4%BD%BF%E7%94%A8rclone%E6%8C%82%E8%BD%BDgoogle-drive%E7%BD%91%E7%9B%98/</a></p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"服务器可以挂载很多云网盘\"><a href=\"#服务器可以挂载很多云网盘\" class=\"headerlink\" title=\"服务器可以挂载很多云网盘\"></a>服务器可以挂载很多云网盘</h1><p><strong>用到的工具Rclone</strong></p>\n<p>可以支持很多的云盘，不仅仅是google，还有onedrive等。</p>\n<h1 id=\"安装相关库\"><a href=\"#安装相关库\" class=\"headerlink\" title=\"安装相关库\"></a>安装相关库</h1><pre><code>curl https://rclone.org/install.sh | sudo bash\n\n\nyum install fuse</code></pre><h1 id=\"用rclone登录云盘配置\"><a href=\"#用rclone登录云盘配置\" class=\"headerlink\" title=\"用rclone登录云盘配置\"></a>用rclone登录云盘配置</h1><pre><code>rclone config</code></pre><p>out</p>\n<pre><code>2020/03/04 17:17:28 NOTICE: Config file &quot;/root/.config/rclone/rclone.conf&quot; not found - using defaults\nNo remotes found - make a new one\nn) New remote\ns) Set configuration password\nq) Quit config</code></pre><p>选择n，建立新的远程连接</p>\n<p>然后输入名字。这个可以随便自己填。</p>\n<p>然后有：</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/ddc552e2fb60427a31c6b3d28ba21944/190c5cd6fd72ae07d40dc37b782a5c5b.png\" alt=\"image-20220831231450455\"></p>\n<p><strong>对于这个id以及secret，输入enter跳过就行。</strong></p>\n<p>然后要选择Rclone对Google Drive网盘文件的操作权限：选择1</p>\n<pre><code>Option scope.\nScope that rclone should use when requesting access from drive.\nEnter a string value. Press Enter for the default (&quot;&quot;).\nChoose a number from below, or type in your own value.\n 1 / Full access all files, excluding Application Data Folder.\n   \\ &quot;drive&quot;\n 2 / Read-only access to file metadata and file contents.\n   \\ &quot;drive.readonly&quot;\n   / Access to files created by rclone only.\n 3 | These are visible in the drive website.\n   | File authorization is revoked when the user deauthorizes the app.\n   \\ &quot;drive.file&quot;\n   / Allows read and write access to the Application Data folder.\n 4 | This is not visible in the drive website.\n   \\ &quot;drive.appfolder&quot;\n   / Allows read-only access to file metadata but\n 5 | does not allow any access to read or download file content.\n   \\ &quot;drive.metadata.readonly&quot;\nscope&gt; 1\n</code></pre><p>然后是一些设置</p>\n<pre><code># 一\nEdit advanced config?\ny) Yes\nn) No (default)\ny/n&gt; n\n\n# 二\nUse auto config?\n * Say Y if not sure\n * Say N if you are working on a remote or headless machine\n\ny) Yes (default)\nn) No\ny/n&gt; n\n\n</code></pre><p><strong>关键；然后会出现一个需要到网页登录验证的连接。用nginx做跨越访问代理到公网。</strong></p>\n<pre><code>2022/08/31 23:17:42 NOTICE: If your browser doesn&#39;t open automatically go to the following link: http://127.0.0.1:53682/auth?state=-y3AQQerN0TGxaYaTe7TIQ\n2022/08/31 23:17:42 NOTICE: Log in and authorize rclone for access\n2022/08/31 23:17:42 NOTICE: Waiting for code...</code></pre><p>对于<a href=\"http://127.0.0.1:53682/auth?state=-y3AQQerN0TGxaYaTe7TIQ\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:53682/auth?state=-y3AQQerN0TGxaYaTe7TIQ</a> 代理到公网访问登录。</p>\n<p>后面会出现一些设置选项，基本选择yes。然后可以退出了。</p>\n<h1 id=\"挂载\"><a href=\"#挂载\" class=\"headerlink\" title=\"挂载\"></a>挂载</h1><pre><code>rclone mount GoogleDrive: /google --allow-other --allow-non-empty --vfs-cache-mode writes</code></pre><p>解释：</p>\n<p><strong>rclone mount 我之前输入的云盘名字: 本地被挂载的路径–allow-other –allow-non-empty –vfs-cache-mode writes</strong></p>\n<p>挂载onedrive</p>\n<pre><code>rclone mount one_drive_test1: /onedrive --allow-other --allow-non-empty --vfs-cache-mode writes</code></pre><h1 id=\"查看\"><a href=\"#查看\" class=\"headerlink\" title=\"查看\"></a>查看</h1><pre><code>df -h</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/ddc552e2fb60427a31c6b3d28ba21944/c80ebaf306121bc49740af4fe17cb717.png\" alt=\"image-20220831232119105\"></p>\n<p>可以正常访问。</p>\n<h1 id=\"关于挂载onedrive云盘。\"><a href=\"#关于挂载onedrive云盘。\" class=\"headerlink\" title=\"关于挂载onedrive云盘。\"></a>关于挂载onedrive云盘。</h1><p>我这里用的是从pdd上买的5T永久免费盘。<br>基本流程和上面是一致的，但是要注意：</p>\n<ul>\n<li><p>这个要选择第一个</p>\n</li>\n<li><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/ddc552e2fb60427a31c6b3d28ba21944/8e7ea2a21d97e78f3d5ff4631ce393f1.png\" alt=\"image-20220917175707801\"></p>\n</li>\n</ul>\n<h1 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h1><p><a href=\"https://www.unvone.com/69270.html\" target=\"_blank\" rel=\"noopener\">https://www.unvone.com/69270.html</a></p>\n<p><a href=\"https://333rd.net/posts/tech/linux%E4%BD%BF%E7%94%A8rclone%E6%8C%82%E8%BD%BDgoogle-drive%E7%BD%91%E7%9B%98/\" target=\"_blank\" rel=\"noopener\">https://333rd.net/posts/tech/linux%E4%BD%BF%E7%94%A8rclone%E6%8C%82%E8%BD%BDgoogle-drive%E7%BD%91%E7%9B%98/</a></p>\n"},{"_content":"\n\n# 监控哪些人在服务器卷小脚步\n\n```\n#coding=gbk\nimport os, re\nimport requests\nimport time\n\n# 要留下就返回true\ndef is_none(s):\n    if s:\n        return True\n    else:\n        return False\n\n\n# execute command, and return the output\ndef execCmd(cmd):\n    r = os.popen(cmd)\n    text = r.read()\n    r.close()\n    return text\n\n\ndef send_msg(msg):\n    # url = 'http://110.40.204.239:5700/send_group_msg?group_id={}&message={}'.format(\n    #     '590020444',\n    #     msg\n    # )\n\n    url = 'http://110.40.204.239:5700/send_private_msg?user_id={}&message={}'.format(\n        '2892211452',\n        msg\n    )\n    print(msg)\n    requests.get(url)\n    pass\n\n\n\nif __name__ == '__main__':\n    listen_username = 'lwl'\n    cmd = \"w | grep {}\".format(listen_username)\n    online_users = {}\n    while True:\n\n        result = execCmd(cmd)\n        print(result)\n        result = result.split('\\n')\n        online_tty = {}\n        all_msgs = \"\"\n        for i in result:\n\n            try:\n                # 字符串划分\n                i = list(filter(is_none, i.split(' ')))\n                print(i)\n                username = i[0]\n                id = i[1]\n                online_tty[id] = 1\n                date = i[3]\n\n                # 不在，通知并且添加到在线用户\n                if id not in online_users:\n                    online_users[id] = {\n                        \"username\":username,\n                        \"date\":date\n                    }\n                    all_msgs = all_msgs + \"{} 于 {} 登录了服务器\\n\".format(username, date)\n                else: # 如果id一样，但是用户不一样了，代表也是有新用户登录了\n                    if username != online_users[id]['username']:\n                        online_users[id] = {\n                            \"username\": username,\n                            \"date\": date\n                        }\n                        all_msgs = all_msgs + \"{} 于 {} 登录了服务器\\n\".format(username, date)\n            except Exception as e:\n                print(e)\n\n        if all_msgs:\n            send_msg(all_msgs)\n\n\n        # 清理掉不在线的终端\n        del_key = []\n        for key in online_users:\n            if key not in online_tty:\n                print(\"{} 终端已经下线\".format(online_users[key]))\n                del_key.append(key)\n        for key in del_key:\n            online_users.__delitem__(key)\n        print(online_users)\n        time.sleep(5)\n```\n\n\n\n## 防卷v2\n\n```\n#coding=utf-8\n#coding=gbk\nimport os, re\nimport requests\nimport time\n\n# 要留下就返回true\ndef is_none(s):\n    if s:\n        return True\n    else:\n        return False\n\n\n# execute command, and return the output\ndef execCmd(cmd):\n    r = os.popen(cmd)\n    text = r.read()\n    r.close()\n    return text\n\n\ndef send_msg(msg):\n    # url = 'http://110.40.204.239:5700/send_group_msg?group_id={}&message={}'.format(\n    #     '590020444',\n    #     msg\n    # )\n\n    url = 'http://110.40.204.239:5700/send_private_msg?user_id={}&message={}'.format(\n        '2892211452',\n        msg\n    )\n    rsp = requests.get(url)\n    print(\"发送消息结果\" + rsp.text)\n\n\n\nif __name__ == '__main__':\n    all_listen_username = {\"lwl\"}\n    online_users = {}\n    while True:\n\n        # 针对每一个用户都进行检测\n        for listen_username in all_listen_username:\n            cmd = \"w | grep {}\".format(listen_username)\n            result = execCmd(cmd)\n            # print(result)\n            result = result.split('\\n')\n            online_tty = {} # 当前在线终端\n            all_msgs = \"\"\n            for i in result:\n\n                try:\n                    # 字符串划分\n                    i = list(filter(is_none, i.split(' ')))\n                    # print(i)\n                    username = i[0]\n                    id = i[1]\n                    \n                    date = i[3]\n\n                    # 用人和时间做key值\n                    key = date + \" \" + username\n\n                    online_tty[key] = 1\n                    \n                    # 剔除掉非目标用户\n                    if username != listen_username:\n                        continue\n\n                    # 不在，通知并且添加到在线用户\n                    if key not in online_users:\n                        online_users[key] = {\n                            \"username\":username,\n                            \"date\":date\n                        }\n                        all_msgs = all_msgs + \"{} 于 {} 登录了服务器\\n\".format(username, date)\n    \n                except Exception as e:\n                    print(e)\n\n            if all_msgs:\n                send_msg(all_msgs)\n\n\n            # 清理掉不在线的终端\n            del_key = []\n            for user_key in online_users:\n                if user_key not in online_tty:\n                    print(\"{} 终端已经下线\".format(online_users[user_key]))\n                    del_key.append(user_key)\n            for user_key in del_key:\n                online_users.__delitem__(user_key)\n                del_msg = \"{} 用户已经下线\".format(user_key)\n                send_msg(del_msg)\n        # print(online_users)\n        time.sleep(5)\n```\n\n\n\n\n\n# 自动下线小脚本\n\n自动下线指定用户的终端，**一经发现，直接下线**\n\n```\nusername=M1ld\nwhile(true)\ndo\n\tsleep(500);\n\twho | grep $username | awk -F ' ' '{print $2}' | xargs  pkill -kill -t \ndone;\n```\n\n","source":"_posts/服务器相关/趣味shell小脚本.md","raw":"\n\n# 监控哪些人在服务器卷小脚步\n\n```\n#coding=gbk\nimport os, re\nimport requests\nimport time\n\n# 要留下就返回true\ndef is_none(s):\n    if s:\n        return True\n    else:\n        return False\n\n\n# execute command, and return the output\ndef execCmd(cmd):\n    r = os.popen(cmd)\n    text = r.read()\n    r.close()\n    return text\n\n\ndef send_msg(msg):\n    # url = 'http://110.40.204.239:5700/send_group_msg?group_id={}&message={}'.format(\n    #     '590020444',\n    #     msg\n    # )\n\n    url = 'http://110.40.204.239:5700/send_private_msg?user_id={}&message={}'.format(\n        '2892211452',\n        msg\n    )\n    print(msg)\n    requests.get(url)\n    pass\n\n\n\nif __name__ == '__main__':\n    listen_username = 'lwl'\n    cmd = \"w | grep {}\".format(listen_username)\n    online_users = {}\n    while True:\n\n        result = execCmd(cmd)\n        print(result)\n        result = result.split('\\n')\n        online_tty = {}\n        all_msgs = \"\"\n        for i in result:\n\n            try:\n                # 字符串划分\n                i = list(filter(is_none, i.split(' ')))\n                print(i)\n                username = i[0]\n                id = i[1]\n                online_tty[id] = 1\n                date = i[3]\n\n                # 不在，通知并且添加到在线用户\n                if id not in online_users:\n                    online_users[id] = {\n                        \"username\":username,\n                        \"date\":date\n                    }\n                    all_msgs = all_msgs + \"{} 于 {} 登录了服务器\\n\".format(username, date)\n                else: # 如果id一样，但是用户不一样了，代表也是有新用户登录了\n                    if username != online_users[id]['username']:\n                        online_users[id] = {\n                            \"username\": username,\n                            \"date\": date\n                        }\n                        all_msgs = all_msgs + \"{} 于 {} 登录了服务器\\n\".format(username, date)\n            except Exception as e:\n                print(e)\n\n        if all_msgs:\n            send_msg(all_msgs)\n\n\n        # 清理掉不在线的终端\n        del_key = []\n        for key in online_users:\n            if key not in online_tty:\n                print(\"{} 终端已经下线\".format(online_users[key]))\n                del_key.append(key)\n        for key in del_key:\n            online_users.__delitem__(key)\n        print(online_users)\n        time.sleep(5)\n```\n\n\n\n## 防卷v2\n\n```\n#coding=utf-8\n#coding=gbk\nimport os, re\nimport requests\nimport time\n\n# 要留下就返回true\ndef is_none(s):\n    if s:\n        return True\n    else:\n        return False\n\n\n# execute command, and return the output\ndef execCmd(cmd):\n    r = os.popen(cmd)\n    text = r.read()\n    r.close()\n    return text\n\n\ndef send_msg(msg):\n    # url = 'http://110.40.204.239:5700/send_group_msg?group_id={}&message={}'.format(\n    #     '590020444',\n    #     msg\n    # )\n\n    url = 'http://110.40.204.239:5700/send_private_msg?user_id={}&message={}'.format(\n        '2892211452',\n        msg\n    )\n    rsp = requests.get(url)\n    print(\"发送消息结果\" + rsp.text)\n\n\n\nif __name__ == '__main__':\n    all_listen_username = {\"lwl\"}\n    online_users = {}\n    while True:\n\n        # 针对每一个用户都进行检测\n        for listen_username in all_listen_username:\n            cmd = \"w | grep {}\".format(listen_username)\n            result = execCmd(cmd)\n            # print(result)\n            result = result.split('\\n')\n            online_tty = {} # 当前在线终端\n            all_msgs = \"\"\n            for i in result:\n\n                try:\n                    # 字符串划分\n                    i = list(filter(is_none, i.split(' ')))\n                    # print(i)\n                    username = i[0]\n                    id = i[1]\n                    \n                    date = i[3]\n\n                    # 用人和时间做key值\n                    key = date + \" \" + username\n\n                    online_tty[key] = 1\n                    \n                    # 剔除掉非目标用户\n                    if username != listen_username:\n                        continue\n\n                    # 不在，通知并且添加到在线用户\n                    if key not in online_users:\n                        online_users[key] = {\n                            \"username\":username,\n                            \"date\":date\n                        }\n                        all_msgs = all_msgs + \"{} 于 {} 登录了服务器\\n\".format(username, date)\n    \n                except Exception as e:\n                    print(e)\n\n            if all_msgs:\n                send_msg(all_msgs)\n\n\n            # 清理掉不在线的终端\n            del_key = []\n            for user_key in online_users:\n                if user_key not in online_tty:\n                    print(\"{} 终端已经下线\".format(online_users[user_key]))\n                    del_key.append(user_key)\n            for user_key in del_key:\n                online_users.__delitem__(user_key)\n                del_msg = \"{} 用户已经下线\".format(user_key)\n                send_msg(del_msg)\n        # print(online_users)\n        time.sleep(5)\n```\n\n\n\n\n\n# 自动下线小脚本\n\n自动下线指定用户的终端，**一经发现，直接下线**\n\n```\nusername=M1ld\nwhile(true)\ndo\n\tsleep(500);\n\twho | grep $username | awk -F ' ' '{print $2}' | xargs  pkill -kill -t \ndone;\n```\n\n","slug":"服务器相关/趣味shell小脚本","published":1,"date":"2023-02-27T11:33:23.587Z","updated":"2023-02-27T11:34:33.146Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsycc00190gcnb7588bwp","content":"<h1 id=\"监控哪些人在服务器卷小脚步\"><a href=\"#监控哪些人在服务器卷小脚步\" class=\"headerlink\" title=\"监控哪些人在服务器卷小脚步\"></a>监控哪些人在服务器卷小脚步</h1><pre><code>#coding=gbk\nimport os, re\nimport requests\nimport time\n\n# 要留下就返回true\ndef is_none(s):\n    if s:\n        return True\n    else:\n        return False\n\n\n# execute command, and return the output\ndef execCmd(cmd):\n    r = os.popen(cmd)\n    text = r.read()\n    r.close()\n    return text\n\n\ndef send_msg(msg):\n    # url = &#39;http://110.40.204.239:5700/send_group_msg?group_id={}&amp;message={}&#39;.format(\n    #     &#39;590020444&#39;,\n    #     msg\n    # )\n\n    url = &#39;http://110.40.204.239:5700/send_private_msg?user_id={}&amp;message={}&#39;.format(\n        &#39;2892211452&#39;,\n        msg\n    )\n    print(msg)\n    requests.get(url)\n    pass\n\n\n\nif __name__ == &#39;__main__&#39;:\n    listen_username = &#39;lwl&#39;\n    cmd = &quot;w | grep {}&quot;.format(listen_username)\n    online_users = {}\n    while True:\n\n        result = execCmd(cmd)\n        print(result)\n        result = result.split(&#39;\\n&#39;)\n        online_tty = {}\n        all_msgs = &quot;&quot;\n        for i in result:\n\n            try:\n                # 字符串划分\n                i = list(filter(is_none, i.split(&#39; &#39;)))\n                print(i)\n                username = i[0]\n                id = i[1]\n                online_tty[id] = 1\n                date = i[3]\n\n                # 不在，通知并且添加到在线用户\n                if id not in online_users:\n                    online_users[id] = {\n                        &quot;username&quot;:username,\n                        &quot;date&quot;:date\n                    }\n                    all_msgs = all_msgs + &quot;{} 于 {} 登录了服务器\\n&quot;.format(username, date)\n                else: # 如果id一样，但是用户不一样了，代表也是有新用户登录了\n                    if username != online_users[id][&#39;username&#39;]:\n                        online_users[id] = {\n                            &quot;username&quot;: username,\n                            &quot;date&quot;: date\n                        }\n                        all_msgs = all_msgs + &quot;{} 于 {} 登录了服务器\\n&quot;.format(username, date)\n            except Exception as e:\n                print(e)\n\n        if all_msgs:\n            send_msg(all_msgs)\n\n\n        # 清理掉不在线的终端\n        del_key = []\n        for key in online_users:\n            if key not in online_tty:\n                print(&quot;{} 终端已经下线&quot;.format(online_users[key]))\n                del_key.append(key)\n        for key in del_key:\n            online_users.__delitem__(key)\n        print(online_users)\n        time.sleep(5)</code></pre><h2 id=\"防卷v2\"><a href=\"#防卷v2\" class=\"headerlink\" title=\"防卷v2\"></a>防卷v2</h2><pre><code>#coding=utf-8\n#coding=gbk\nimport os, re\nimport requests\nimport time\n\n# 要留下就返回true\ndef is_none(s):\n    if s:\n        return True\n    else:\n        return False\n\n\n# execute command, and return the output\ndef execCmd(cmd):\n    r = os.popen(cmd)\n    text = r.read()\n    r.close()\n    return text\n\n\ndef send_msg(msg):\n    # url = &#39;http://110.40.204.239:5700/send_group_msg?group_id={}&amp;message={}&#39;.format(\n    #     &#39;590020444&#39;,\n    #     msg\n    # )\n\n    url = &#39;http://110.40.204.239:5700/send_private_msg?user_id={}&amp;message={}&#39;.format(\n        &#39;2892211452&#39;,\n        msg\n    )\n    rsp = requests.get(url)\n    print(&quot;发送消息结果&quot; + rsp.text)\n\n\n\nif __name__ == &#39;__main__&#39;:\n    all_listen_username = {&quot;lwl&quot;}\n    online_users = {}\n    while True:\n\n        # 针对每一个用户都进行检测\n        for listen_username in all_listen_username:\n            cmd = &quot;w | grep {}&quot;.format(listen_username)\n            result = execCmd(cmd)\n            # print(result)\n            result = result.split(&#39;\\n&#39;)\n            online_tty = {} # 当前在线终端\n            all_msgs = &quot;&quot;\n            for i in result:\n\n                try:\n                    # 字符串划分\n                    i = list(filter(is_none, i.split(&#39; &#39;)))\n                    # print(i)\n                    username = i[0]\n                    id = i[1]\n\n                    date = i[3]\n\n                    # 用人和时间做key值\n                    key = date + &quot; &quot; + username\n\n                    online_tty[key] = 1\n\n                    # 剔除掉非目标用户\n                    if username != listen_username:\n                        continue\n\n                    # 不在，通知并且添加到在线用户\n                    if key not in online_users:\n                        online_users[key] = {\n                            &quot;username&quot;:username,\n                            &quot;date&quot;:date\n                        }\n                        all_msgs = all_msgs + &quot;{} 于 {} 登录了服务器\\n&quot;.format(username, date)\n\n                except Exception as e:\n                    print(e)\n\n            if all_msgs:\n                send_msg(all_msgs)\n\n\n            # 清理掉不在线的终端\n            del_key = []\n            for user_key in online_users:\n                if user_key not in online_tty:\n                    print(&quot;{} 终端已经下线&quot;.format(online_users[user_key]))\n                    del_key.append(user_key)\n            for user_key in del_key:\n                online_users.__delitem__(user_key)\n                del_msg = &quot;{} 用户已经下线&quot;.format(user_key)\n                send_msg(del_msg)\n        # print(online_users)\n        time.sleep(5)</code></pre><h1 id=\"自动下线小脚本\"><a href=\"#自动下线小脚本\" class=\"headerlink\" title=\"自动下线小脚本\"></a>自动下线小脚本</h1><p>自动下线指定用户的终端，<strong>一经发现，直接下线</strong></p>\n<pre><code>username=M1ld\nwhile(true)\ndo\n    sleep(500);\n    who | grep $username | awk -F &#39; &#39; &#39;{print $2}&#39; | xargs  pkill -kill -t \ndone;</code></pre>","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"监控哪些人在服务器卷小脚步\"><a href=\"#监控哪些人在服务器卷小脚步\" class=\"headerlink\" title=\"监控哪些人在服务器卷小脚步\"></a>监控哪些人在服务器卷小脚步</h1><pre><code>#coding=gbk\nimport os, re\nimport requests\nimport time\n\n# 要留下就返回true\ndef is_none(s):\n    if s:\n        return True\n    else:\n        return False\n\n\n# execute command, and return the output\ndef execCmd(cmd):\n    r = os.popen(cmd)\n    text = r.read()\n    r.close()\n    return text\n\n\ndef send_msg(msg):\n    # url = &#39;http://110.40.204.239:5700/send_group_msg?group_id={}&amp;message={}&#39;.format(\n    #     &#39;590020444&#39;,\n    #     msg\n    # )\n\n    url = &#39;http://110.40.204.239:5700/send_private_msg?user_id={}&amp;message={}&#39;.format(\n        &#39;2892211452&#39;,\n        msg\n    )\n    print(msg)\n    requests.get(url)\n    pass\n\n\n\nif __name__ == &#39;__main__&#39;:\n    listen_username = &#39;lwl&#39;\n    cmd = &quot;w | grep {}&quot;.format(listen_username)\n    online_users = {}\n    while True:\n\n        result = execCmd(cmd)\n        print(result)\n        result = result.split(&#39;\\n&#39;)\n        online_tty = {}\n        all_msgs = &quot;&quot;\n        for i in result:\n\n            try:\n                # 字符串划分\n                i = list(filter(is_none, i.split(&#39; &#39;)))\n                print(i)\n                username = i[0]\n                id = i[1]\n                online_tty[id] = 1\n                date = i[3]\n\n                # 不在，通知并且添加到在线用户\n                if id not in online_users:\n                    online_users[id] = {\n                        &quot;username&quot;:username,\n                        &quot;date&quot;:date\n                    }\n                    all_msgs = all_msgs + &quot;{} 于 {} 登录了服务器\\n&quot;.format(username, date)\n                else: # 如果id一样，但是用户不一样了，代表也是有新用户登录了\n                    if username != online_users[id][&#39;username&#39;]:\n                        online_users[id] = {\n                            &quot;username&quot;: username,\n                            &quot;date&quot;: date\n                        }\n                        all_msgs = all_msgs + &quot;{} 于 {} 登录了服务器\\n&quot;.format(username, date)\n            except Exception as e:\n                print(e)\n\n        if all_msgs:\n            send_msg(all_msgs)\n\n\n        # 清理掉不在线的终端\n        del_key = []\n        for key in online_users:\n            if key not in online_tty:\n                print(&quot;{} 终端已经下线&quot;.format(online_users[key]))\n                del_key.append(key)\n        for key in del_key:\n            online_users.__delitem__(key)\n        print(online_users)\n        time.sleep(5)</code></pre><h2 id=\"防卷v2\"><a href=\"#防卷v2\" class=\"headerlink\" title=\"防卷v2\"></a>防卷v2</h2><pre><code>#coding=utf-8\n#coding=gbk\nimport os, re\nimport requests\nimport time\n\n# 要留下就返回true\ndef is_none(s):\n    if s:\n        return True\n    else:\n        return False\n\n\n# execute command, and return the output\ndef execCmd(cmd):\n    r = os.popen(cmd)\n    text = r.read()\n    r.close()\n    return text\n\n\ndef send_msg(msg):\n    # url = &#39;http://110.40.204.239:5700/send_group_msg?group_id={}&amp;message={}&#39;.format(\n    #     &#39;590020444&#39;,\n    #     msg\n    # )\n\n    url = &#39;http://110.40.204.239:5700/send_private_msg?user_id={}&amp;message={}&#39;.format(\n        &#39;2892211452&#39;,\n        msg\n    )\n    rsp = requests.get(url)\n    print(&quot;发送消息结果&quot; + rsp.text)\n\n\n\nif __name__ == &#39;__main__&#39;:\n    all_listen_username = {&quot;lwl&quot;}\n    online_users = {}\n    while True:\n\n        # 针对每一个用户都进行检测\n        for listen_username in all_listen_username:\n            cmd = &quot;w | grep {}&quot;.format(listen_username)\n            result = execCmd(cmd)\n            # print(result)\n            result = result.split(&#39;\\n&#39;)\n            online_tty = {} # 当前在线终端\n            all_msgs = &quot;&quot;\n            for i in result:\n\n                try:\n                    # 字符串划分\n                    i = list(filter(is_none, i.split(&#39; &#39;)))\n                    # print(i)\n                    username = i[0]\n                    id = i[1]\n\n                    date = i[3]\n\n                    # 用人和时间做key值\n                    key = date + &quot; &quot; + username\n\n                    online_tty[key] = 1\n\n                    # 剔除掉非目标用户\n                    if username != listen_username:\n                        continue\n\n                    # 不在，通知并且添加到在线用户\n                    if key not in online_users:\n                        online_users[key] = {\n                            &quot;username&quot;:username,\n                            &quot;date&quot;:date\n                        }\n                        all_msgs = all_msgs + &quot;{} 于 {} 登录了服务器\\n&quot;.format(username, date)\n\n                except Exception as e:\n                    print(e)\n\n            if all_msgs:\n                send_msg(all_msgs)\n\n\n            # 清理掉不在线的终端\n            del_key = []\n            for user_key in online_users:\n                if user_key not in online_tty:\n                    print(&quot;{} 终端已经下线&quot;.format(online_users[user_key]))\n                    del_key.append(user_key)\n            for user_key in del_key:\n                online_users.__delitem__(user_key)\n                del_msg = &quot;{} 用户已经下线&quot;.format(user_key)\n                send_msg(del_msg)\n        # print(online_users)\n        time.sleep(5)</code></pre><h1 id=\"自动下线小脚本\"><a href=\"#自动下线小脚本\" class=\"headerlink\" title=\"自动下线小脚本\"></a>自动下线小脚本</h1><p>自动下线指定用户的终端，<strong>一经发现，直接下线</strong></p>\n<pre><code>username=M1ld\nwhile(true)\ndo\n    sleep(500);\n    who | grep $username | awk -F &#39; &#39; &#39;{print $2}&#39; | xargs  pkill -kill -t \ndone;</code></pre>"},{"_content":"# 防火墙\n\n\n\n## linux防火墙组成\n\niptables：用户空间工具\n\nnetfilter：内核里的工具\n\n\n\n\n\n## iptables\n\n\n\n关键是几个概念\n\n入站，出站，转发\n\n\n\n\n\n## ref\n\nhttps://www.right.com.cn/forum/forum.php?mod=viewthread&tid=4982313&highlight=%B7%C0%BB%F0%C7%BD\n\n\n万字讲解OpenWrt防火墙iptables，并使用UCI配置防火墙 原创\nhttps://blog.51cto.com/u_15346415/3694634","source":"_posts/服务器相关/openwrt防火墙使用.md","raw":"# 防火墙\n\n\n\n## linux防火墙组成\n\niptables：用户空间工具\n\nnetfilter：内核里的工具\n\n\n\n\n\n## iptables\n\n\n\n关键是几个概念\n\n入站，出站，转发\n\n\n\n\n\n## ref\n\nhttps://www.right.com.cn/forum/forum.php?mod=viewthread&tid=4982313&highlight=%B7%C0%BB%F0%C7%BD\n\n\n万字讲解OpenWrt防火墙iptables，并使用UCI配置防火墙 原创\nhttps://blog.51cto.com/u_15346415/3694634","slug":"服务器相关/openwrt防火墙使用","published":1,"date":"2023-02-27T11:33:23.588Z","updated":"2023-02-27T11:34:33.147Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsycc001a0gcneaijkzjy","content":"<h1 id=\"防火墙\"><a href=\"#防火墙\" class=\"headerlink\" title=\"防火墙\"></a>防火墙</h1><h2 id=\"linux防火墙组成\"><a href=\"#linux防火墙组成\" class=\"headerlink\" title=\"linux防火墙组成\"></a>linux防火墙组成</h2><p>iptables：用户空间工具</p>\n<p>netfilter：内核里的工具</p>\n<h2 id=\"iptables\"><a href=\"#iptables\" class=\"headerlink\" title=\"iptables\"></a>iptables</h2><p>关键是几个概念</p>\n<p>入站，出站，转发</p>\n<h2 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h2><p><a href=\"https://www.right.com.cn/forum/forum.php?mod=viewthread&amp;tid=4982313&amp;highlight=%B7%C0%BB%F0%C7%BD\" target=\"_blank\" rel=\"noopener\">https://www.right.com.cn/forum/forum.php?mod=viewthread&amp;tid=4982313&amp;highlight=%B7%C0%BB%F0%C7%BD</a></p>\n<p>万字讲解OpenWrt防火墙iptables，并使用UCI配置防火墙 原创<br><a href=\"https://blog.51cto.com/u_15346415/3694634\" target=\"_blank\" rel=\"noopener\">https://blog.51cto.com/u_15346415/3694634</a></p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"防火墙\"><a href=\"#防火墙\" class=\"headerlink\" title=\"防火墙\"></a>防火墙</h1><h2 id=\"linux防火墙组成\"><a href=\"#linux防火墙组成\" class=\"headerlink\" title=\"linux防火墙组成\"></a>linux防火墙组成</h2><p>iptables：用户空间工具</p>\n<p>netfilter：内核里的工具</p>\n<h2 id=\"iptables\"><a href=\"#iptables\" class=\"headerlink\" title=\"iptables\"></a>iptables</h2><p>关键是几个概念</p>\n<p>入站，出站，转发</p>\n<h2 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h2><p><a href=\"https://www.right.com.cn/forum/forum.php?mod=viewthread&amp;tid=4982313&amp;highlight=%B7%C0%BB%F0%C7%BD\" target=\"_blank\" rel=\"noopener\">https://www.right.com.cn/forum/forum.php?mod=viewthread&amp;tid=4982313&amp;highlight=%B7%C0%BB%F0%C7%BD</a></p>\n<p>万字讲解OpenWrt防火墙iptables，并使用UCI配置防火墙 原创<br><a href=\"https://blog.51cto.com/u_15346415/3694634\" target=\"_blank\" rel=\"noopener\">https://blog.51cto.com/u_15346415/3694634</a></p>\n"},{"_content":"# 场景\n\n最近写了一个python脚本。本来打算去宝塔里面整一个计划任务执行。\n\n但是我测试的时候使用的环境是conda里面的python。\n\n所以要让宝塔计划任务里面也使用该环境。\n\n\n\n# 思路\n\n### 法1\n\n对于简单的，直接指定解释器的路径\n\n```\n/root/.conda/envs/main/bin/python3.7 test.py\n```\n\n\n\n### 法二\n\n第一个办法对于涵盖有`sh`脚本的文件不是很友好。\n\n使用，source激活指定环境。\n\n```\nsource activate\nconda activate main\nbash sync_wordpress.sh \n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n## source命令的说明\n\n`source filename`\n\nsource是bash shell的内置命令，用于**读取filename脚本文件中的命令**，**并在当前shell执行**。由于filename的执行环境是在当前shell，因此常用source命令在配置文件改变后，重新执行配置文件，避免重新登录。\n\n\n\n### source和 sh，bash的区别\n\nsh 会新建一个子shell，并在子shell中读取执行filename中的命令。**子shell会继承父shell的环境变量，但子shell中新生成的变量或者环境变化并不会传播到父shell中**，如需将新变量导入到父shell中，需使用export命令。\n\n\n\n\n\n\n\n**活用好source命令，能够解决很多环境上的问题。**\n","source":"_posts/服务器相关/source命令---如何使用conda环境运行脚本（在一些乱七八糟的环境下）.md","raw":"# 场景\n\n最近写了一个python脚本。本来打算去宝塔里面整一个计划任务执行。\n\n但是我测试的时候使用的环境是conda里面的python。\n\n所以要让宝塔计划任务里面也使用该环境。\n\n\n\n# 思路\n\n### 法1\n\n对于简单的，直接指定解释器的路径\n\n```\n/root/.conda/envs/main/bin/python3.7 test.py\n```\n\n\n\n### 法二\n\n第一个办法对于涵盖有`sh`脚本的文件不是很友好。\n\n使用，source激活指定环境。\n\n```\nsource activate\nconda activate main\nbash sync_wordpress.sh \n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n## source命令的说明\n\n`source filename`\n\nsource是bash shell的内置命令，用于**读取filename脚本文件中的命令**，**并在当前shell执行**。由于filename的执行环境是在当前shell，因此常用source命令在配置文件改变后，重新执行配置文件，避免重新登录。\n\n\n\n### source和 sh，bash的区别\n\nsh 会新建一个子shell，并在子shell中读取执行filename中的命令。**子shell会继承父shell的环境变量，但子shell中新生成的变量或者环境变化并不会传播到父shell中**，如需将新变量导入到父shell中，需使用export命令。\n\n\n\n\n\n\n\n**活用好source命令，能够解决很多环境上的问题。**\n","slug":"服务器相关/source命令---如何使用conda环境运行脚本（在一些乱七八糟的环境下）","published":1,"date":"2023-02-27T11:33:23.589Z","updated":"2023-02-27T11:34:33.148Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsycd001b0gcn9lvr8150","content":"<h1 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h1><p>最近写了一个python脚本。本来打算去宝塔里面整一个计划任务执行。</p>\n<p>但是我测试的时候使用的环境是conda里面的python。</p>\n<p>所以要让宝塔计划任务里面也使用该环境。</p>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><h3 id=\"法1\"><a href=\"#法1\" class=\"headerlink\" title=\"法1\"></a>法1</h3><p>对于简单的，直接指定解释器的路径</p>\n<pre><code>/root/.conda/envs/main/bin/python3.7 test.py</code></pre><h3 id=\"法二\"><a href=\"#法二\" class=\"headerlink\" title=\"法二\"></a>法二</h3><p>第一个办法对于涵盖有<code>sh</code>脚本的文件不是很友好。</p>\n<p>使用，source激活指定环境。</p>\n<pre><code>source activate\nconda activate main\nbash sync_wordpress.sh </code></pre><h2 id=\"source命令的说明\"><a href=\"#source命令的说明\" class=\"headerlink\" title=\"source命令的说明\"></a>source命令的说明</h2><p><code>source filename</code></p>\n<p>source是bash shell的内置命令，用于<strong>读取filename脚本文件中的命令</strong>，<strong>并在当前shell执行</strong>。由于filename的执行环境是在当前shell，因此常用source命令在配置文件改变后，重新执行配置文件，避免重新登录。</p>\n<h3 id=\"source和-sh，bash的区别\"><a href=\"#source和-sh，bash的区别\" class=\"headerlink\" title=\"source和 sh，bash的区别\"></a>source和 sh，bash的区别</h3><p>sh 会新建一个子shell，并在子shell中读取执行filename中的命令。<strong>子shell会继承父shell的环境变量，但子shell中新生成的变量或者环境变化并不会传播到父shell中</strong>，如需将新变量导入到父shell中，需使用export命令。</p>\n<p><strong>活用好source命令，能够解决很多环境上的问题。</strong></p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h1><p>最近写了一个python脚本。本来打算去宝塔里面整一个计划任务执行。</p>\n<p>但是我测试的时候使用的环境是conda里面的python。</p>\n<p>所以要让宝塔计划任务里面也使用该环境。</p>\n<h1 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h1><h3 id=\"法1\"><a href=\"#法1\" class=\"headerlink\" title=\"法1\"></a>法1</h3><p>对于简单的，直接指定解释器的路径</p>\n<pre><code>/root/.conda/envs/main/bin/python3.7 test.py</code></pre><h3 id=\"法二\"><a href=\"#法二\" class=\"headerlink\" title=\"法二\"></a>法二</h3><p>第一个办法对于涵盖有<code>sh</code>脚本的文件不是很友好。</p>\n<p>使用，source激活指定环境。</p>\n<pre><code>source activate\nconda activate main\nbash sync_wordpress.sh </code></pre><h2 id=\"source命令的说明\"><a href=\"#source命令的说明\" class=\"headerlink\" title=\"source命令的说明\"></a>source命令的说明</h2><p><code>source filename</code></p>\n<p>source是bash shell的内置命令，用于<strong>读取filename脚本文件中的命令</strong>，<strong>并在当前shell执行</strong>。由于filename的执行环境是在当前shell，因此常用source命令在配置文件改变后，重新执行配置文件，避免重新登录。</p>\n<h3 id=\"source和-sh，bash的区别\"><a href=\"#source和-sh，bash的区别\" class=\"headerlink\" title=\"source和 sh，bash的区别\"></a>source和 sh，bash的区别</h3><p>sh 会新建一个子shell，并在子shell中读取执行filename中的命令。<strong>子shell会继承父shell的环境变量，但子shell中新生成的变量或者环境变化并不会传播到父shell中</strong>，如需将新变量导入到父shell中，需使用export命令。</p>\n<p><strong>活用好source命令，能够解决很多环境上的问题。</strong></p>\n"},{"_content":"# 如何使用docker搭建一套开发环境\n\n\n\n在群晖，树莓派openwrt等设备上。由于系统以及设备版本等原因。其上面要么不能安装python，java等环境，要么就是安装了也会很多库用不了。总之就是很麻烦。\n\n如果直接安装在docker，在docker里面当服务器重头开始搞一套开发以及部署环境。那又会非常的耗费资源。\n\n因此，为什么不用docker的Ubuntu等当开发环境呢。\n\n**计划：**\n\n- 安装一个Ubuntu的docker容器。\n- 在容器内安装python环境。\n- 做好目录挂载以及端口开放。（注意容器内的环境只能用容器内的文件项目）\n- 通过docker的exec命令执行容器内的脚本以及环境。\n- 通过alias别名来设置环境变量。\n- 最终就是要运行代码的路径最好和容器内部一致，并且挂载上，这样就能在容器内和容器外都一致了。\n\n\n\n\n\n## 关于/etc/profile更改环境变量以及别名alias\n\n```\nalias ubash='docker exec -it ubuntu2 bash'  # 直接用内部的bash来执行, 不过这招不好使\nalias pip='docker exec -it ubuntu2 pip'\nalias python='docker exec -it ubuntu2 python3'\n```\n\n\n\n### 前置配置文件\n\n**/etc/profile：** 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行。是系统全局针对终端环境的设置，它是login时最先被系统加载的，是它**调用了/etc/bashrc，以及/etc/profile.d目录下的*.sh文件**，如果有一个软件包，系统上只安装一份，供所有开发者使用，**建议在/etc/profile.d下创建一个新的xxx.sh，配置环境变量。**\n**~/.bashrc:**是用户相关的终端（shell）的环境设置，通常打开一个新终端时，默认会load里面的设置，在这里的设置不影响其它人。如果一个服务器多个开发者使用，大家都需要有自己的sdk安装和设置，那么最好就是设置它。\n\n\n\n\n\n**为了实现内部运行脚本的功能：**\n\n- 要么直接搞个sh文件，然后执行这个sh脚本\n\n- 要么用，（python，一行多命令可以用；）\n\n  ```\n   python -c \"import os; os.system('cd /volume1/208/csu_tool/Healthy-Punch-Card && python3 auto.py ')\"\n  ```\n\n  ```\n   python -c \"import os; os.system('cd /volume1/208/csu_tool/csu_net_keep && python3 main.py')\"\n  ```\n\n  \n\n\n\n\n\n\n\n## docker部署\n\n**如何给已经运行中的容器挂载新的目录  ,提交现有容器为新镜像，然后重新运行它**\n\n```\n$ docker ps  -a\nCONTAINER ID        IMAGE                 COMMAND                  CREATED              STATUS                          PORTS               NAMES\n   5a3422adeead        ubuntu:14.04          \"/bin/bash\"              About a minute ago   Exited (0) About a minute ago                       agitated_newton\n$ docker commit 5a3422adeead newimagename\n$ docker run -ti -v \"$PWD/dir1\":/dir1 -v \"$PWD/dir2\":/dir2 newimagename /bin/bash\ndocker run -d -p 51022:22 -p 8888:8888 --name ubuntu3 -v $PWD/data:/data -v /volume1:/volume1 ubuntu:v3\n\n```\n\n\n\n\n\n## ubutun容器安装软件\n\nsshd开放。\n\n宝塔面板安装（可以实现很多有用的任务）\n\n\n\n## 注意\n\n有些系统里面哪怕是同样安装Ubuntu。但是其会自动吧镜像最小化，导致系统有些功能用不了或者被阉割。\n\n可以用`unminimize`命令来恢复。\n\n\n\n","source":"_posts/服务器相关/如何使用docker搭建一套开发环境.md","raw":"# 如何使用docker搭建一套开发环境\n\n\n\n在群晖，树莓派openwrt等设备上。由于系统以及设备版本等原因。其上面要么不能安装python，java等环境，要么就是安装了也会很多库用不了。总之就是很麻烦。\n\n如果直接安装在docker，在docker里面当服务器重头开始搞一套开发以及部署环境。那又会非常的耗费资源。\n\n因此，为什么不用docker的Ubuntu等当开发环境呢。\n\n**计划：**\n\n- 安装一个Ubuntu的docker容器。\n- 在容器内安装python环境。\n- 做好目录挂载以及端口开放。（注意容器内的环境只能用容器内的文件项目）\n- 通过docker的exec命令执行容器内的脚本以及环境。\n- 通过alias别名来设置环境变量。\n- 最终就是要运行代码的路径最好和容器内部一致，并且挂载上，这样就能在容器内和容器外都一致了。\n\n\n\n\n\n## 关于/etc/profile更改环境变量以及别名alias\n\n```\nalias ubash='docker exec -it ubuntu2 bash'  # 直接用内部的bash来执行, 不过这招不好使\nalias pip='docker exec -it ubuntu2 pip'\nalias python='docker exec -it ubuntu2 python3'\n```\n\n\n\n### 前置配置文件\n\n**/etc/profile：** 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行。是系统全局针对终端环境的设置，它是login时最先被系统加载的，是它**调用了/etc/bashrc，以及/etc/profile.d目录下的*.sh文件**，如果有一个软件包，系统上只安装一份，供所有开发者使用，**建议在/etc/profile.d下创建一个新的xxx.sh，配置环境变量。**\n**~/.bashrc:**是用户相关的终端（shell）的环境设置，通常打开一个新终端时，默认会load里面的设置，在这里的设置不影响其它人。如果一个服务器多个开发者使用，大家都需要有自己的sdk安装和设置，那么最好就是设置它。\n\n\n\n\n\n**为了实现内部运行脚本的功能：**\n\n- 要么直接搞个sh文件，然后执行这个sh脚本\n\n- 要么用，（python，一行多命令可以用；）\n\n  ```\n   python -c \"import os; os.system('cd /volume1/208/csu_tool/Healthy-Punch-Card && python3 auto.py ')\"\n  ```\n\n  ```\n   python -c \"import os; os.system('cd /volume1/208/csu_tool/csu_net_keep && python3 main.py')\"\n  ```\n\n  \n\n\n\n\n\n\n\n## docker部署\n\n**如何给已经运行中的容器挂载新的目录  ,提交现有容器为新镜像，然后重新运行它**\n\n```\n$ docker ps  -a\nCONTAINER ID        IMAGE                 COMMAND                  CREATED              STATUS                          PORTS               NAMES\n   5a3422adeead        ubuntu:14.04          \"/bin/bash\"              About a minute ago   Exited (0) About a minute ago                       agitated_newton\n$ docker commit 5a3422adeead newimagename\n$ docker run -ti -v \"$PWD/dir1\":/dir1 -v \"$PWD/dir2\":/dir2 newimagename /bin/bash\ndocker run -d -p 51022:22 -p 8888:8888 --name ubuntu3 -v $PWD/data:/data -v /volume1:/volume1 ubuntu:v3\n\n```\n\n\n\n\n\n## ubutun容器安装软件\n\nsshd开放。\n\n宝塔面板安装（可以实现很多有用的任务）\n\n\n\n## 注意\n\n有些系统里面哪怕是同样安装Ubuntu。但是其会自动吧镜像最小化，导致系统有些功能用不了或者被阉割。\n\n可以用`unminimize`命令来恢复。\n\n\n\n","slug":"服务器相关/如何使用docker搭建一套开发环境","published":1,"date":"2023-02-27T11:33:23.587Z","updated":"2023-02-27T11:34:33.146Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsycd001c0gcnetdjy65o","content":"<h1 id=\"如何使用docker搭建一套开发环境\"><a href=\"#如何使用docker搭建一套开发环境\" class=\"headerlink\" title=\"如何使用docker搭建一套开发环境\"></a>如何使用docker搭建一套开发环境</h1><p>在群晖，树莓派openwrt等设备上。由于系统以及设备版本等原因。其上面要么不能安装python，java等环境，要么就是安装了也会很多库用不了。总之就是很麻烦。</p>\n<p>如果直接安装在docker，在docker里面当服务器重头开始搞一套开发以及部署环境。那又会非常的耗费资源。</p>\n<p>因此，为什么不用docker的Ubuntu等当开发环境呢。</p>\n<p><strong>计划：</strong></p>\n<ul>\n<li>安装一个Ubuntu的docker容器。</li>\n<li>在容器内安装python环境。</li>\n<li>做好目录挂载以及端口开放。（注意容器内的环境只能用容器内的文件项目）</li>\n<li>通过docker的exec命令执行容器内的脚本以及环境。</li>\n<li>通过alias别名来设置环境变量。</li>\n<li>最终就是要运行代码的路径最好和容器内部一致，并且挂载上，这样就能在容器内和容器外都一致了。</li>\n</ul>\n<h2 id=\"关于-etc-profile更改环境变量以及别名alias\"><a href=\"#关于-etc-profile更改环境变量以及别名alias\" class=\"headerlink\" title=\"关于/etc/profile更改环境变量以及别名alias\"></a>关于/etc/profile更改环境变量以及别名alias</h2><pre><code>alias ubash=&#39;docker exec -it ubuntu2 bash&#39;  # 直接用内部的bash来执行, 不过这招不好使\nalias pip=&#39;docker exec -it ubuntu2 pip&#39;\nalias python=&#39;docker exec -it ubuntu2 python3&#39;</code></pre><h3 id=\"前置配置文件\"><a href=\"#前置配置文件\" class=\"headerlink\" title=\"前置配置文件\"></a>前置配置文件</h3><p><strong>/etc/profile：</strong> 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行。是系统全局针对终端环境的设置，它是login时最先被系统加载的，是它<strong>调用了/etc/bashrc，以及/etc/profile.d目录下的*.sh文件</strong>，如果有一个软件包，系统上只安装一份，供所有开发者使用，<strong>建议在/etc/profile.d下创建一个新的xxx.sh，配置环境变量。</strong><br><strong>~/.bashrc:</strong>是用户相关的终端（shell）的环境设置，通常打开一个新终端时，默认会load里面的设置，在这里的设置不影响其它人。如果一个服务器多个开发者使用，大家都需要有自己的sdk安装和设置，那么最好就是设置它。</p>\n<p><strong>为了实现内部运行脚本的功能：</strong></p>\n<ul>\n<li><p>要么直接搞个sh文件，然后执行这个sh脚本</p>\n</li>\n<li><p>要么用，（python，一行多命令可以用；）</p>\n<pre><code> python -c &quot;import os; os.system(&#39;cd /volume1/208/csu_tool/Healthy-Punch-Card &amp;&amp; python3 auto.py &#39;)&quot;</code></pre><pre><code> python -c &quot;import os; os.system(&#39;cd /volume1/208/csu_tool/csu_net_keep &amp;&amp; python3 main.py&#39;)&quot;</code></pre></li>\n</ul>\n<h2 id=\"docker部署\"><a href=\"#docker部署\" class=\"headerlink\" title=\"docker部署\"></a>docker部署</h2><p><strong>如何给已经运行中的容器挂载新的目录  ,提交现有容器为新镜像，然后重新运行它</strong></p>\n<pre><code>$ docker ps  -a\nCONTAINER ID        IMAGE                 COMMAND                  CREATED              STATUS                          PORTS               NAMES\n   5a3422adeead        ubuntu:14.04          &quot;/bin/bash&quot;              About a minute ago   Exited (0) About a minute ago                       agitated_newton\n$ docker commit 5a3422adeead newimagename\n$ docker run -ti -v &quot;$PWD/dir1&quot;:/dir1 -v &quot;$PWD/dir2&quot;:/dir2 newimagename /bin/bash\ndocker run -d -p 51022:22 -p 8888:8888 --name ubuntu3 -v $PWD/data:/data -v /volume1:/volume1 ubuntu:v3\n</code></pre><h2 id=\"ubutun容器安装软件\"><a href=\"#ubutun容器安装软件\" class=\"headerlink\" title=\"ubutun容器安装软件\"></a>ubutun容器安装软件</h2><p>sshd开放。</p>\n<p>宝塔面板安装（可以实现很多有用的任务）</p>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><p>有些系统里面哪怕是同样安装Ubuntu。但是其会自动吧镜像最小化，导致系统有些功能用不了或者被阉割。</p>\n<p>可以用<code>unminimize</code>命令来恢复。</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"如何使用docker搭建一套开发环境\"><a href=\"#如何使用docker搭建一套开发环境\" class=\"headerlink\" title=\"如何使用docker搭建一套开发环境\"></a>如何使用docker搭建一套开发环境</h1><p>在群晖，树莓派openwrt等设备上。由于系统以及设备版本等原因。其上面要么不能安装python，java等环境，要么就是安装了也会很多库用不了。总之就是很麻烦。</p>\n<p>如果直接安装在docker，在docker里面当服务器重头开始搞一套开发以及部署环境。那又会非常的耗费资源。</p>\n<p>因此，为什么不用docker的Ubuntu等当开发环境呢。</p>\n<p><strong>计划：</strong></p>\n<ul>\n<li>安装一个Ubuntu的docker容器。</li>\n<li>在容器内安装python环境。</li>\n<li>做好目录挂载以及端口开放。（注意容器内的环境只能用容器内的文件项目）</li>\n<li>通过docker的exec命令执行容器内的脚本以及环境。</li>\n<li>通过alias别名来设置环境变量。</li>\n<li>最终就是要运行代码的路径最好和容器内部一致，并且挂载上，这样就能在容器内和容器外都一致了。</li>\n</ul>\n<h2 id=\"关于-etc-profile更改环境变量以及别名alias\"><a href=\"#关于-etc-profile更改环境变量以及别名alias\" class=\"headerlink\" title=\"关于/etc/profile更改环境变量以及别名alias\"></a>关于/etc/profile更改环境变量以及别名alias</h2><pre><code>alias ubash=&#39;docker exec -it ubuntu2 bash&#39;  # 直接用内部的bash来执行, 不过这招不好使\nalias pip=&#39;docker exec -it ubuntu2 pip&#39;\nalias python=&#39;docker exec -it ubuntu2 python3&#39;</code></pre><h3 id=\"前置配置文件\"><a href=\"#前置配置文件\" class=\"headerlink\" title=\"前置配置文件\"></a>前置配置文件</h3><p><strong>/etc/profile：</strong> 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行。是系统全局针对终端环境的设置，它是login时最先被系统加载的，是它<strong>调用了/etc/bashrc，以及/etc/profile.d目录下的*.sh文件</strong>，如果有一个软件包，系统上只安装一份，供所有开发者使用，<strong>建议在/etc/profile.d下创建一个新的xxx.sh，配置环境变量。</strong><br><strong>~/.bashrc:</strong>是用户相关的终端（shell）的环境设置，通常打开一个新终端时，默认会load里面的设置，在这里的设置不影响其它人。如果一个服务器多个开发者使用，大家都需要有自己的sdk安装和设置，那么最好就是设置它。</p>\n<p><strong>为了实现内部运行脚本的功能：</strong></p>\n<ul>\n<li><p>要么直接搞个sh文件，然后执行这个sh脚本</p>\n</li>\n<li><p>要么用，（python，一行多命令可以用；）</p>\n<pre><code> python -c &quot;import os; os.system(&#39;cd /volume1/208/csu_tool/Healthy-Punch-Card &amp;&amp; python3 auto.py &#39;)&quot;</code></pre><pre><code> python -c &quot;import os; os.system(&#39;cd /volume1/208/csu_tool/csu_net_keep &amp;&amp; python3 main.py&#39;)&quot;</code></pre></li>\n</ul>\n<h2 id=\"docker部署\"><a href=\"#docker部署\" class=\"headerlink\" title=\"docker部署\"></a>docker部署</h2><p><strong>如何给已经运行中的容器挂载新的目录  ,提交现有容器为新镜像，然后重新运行它</strong></p>\n<pre><code>$ docker ps  -a\nCONTAINER ID        IMAGE                 COMMAND                  CREATED              STATUS                          PORTS               NAMES\n   5a3422adeead        ubuntu:14.04          &quot;/bin/bash&quot;              About a minute ago   Exited (0) About a minute ago                       agitated_newton\n$ docker commit 5a3422adeead newimagename\n$ docker run -ti -v &quot;$PWD/dir1&quot;:/dir1 -v &quot;$PWD/dir2&quot;:/dir2 newimagename /bin/bash\ndocker run -d -p 51022:22 -p 8888:8888 --name ubuntu3 -v $PWD/data:/data -v /volume1:/volume1 ubuntu:v3\n</code></pre><h2 id=\"ubutun容器安装软件\"><a href=\"#ubutun容器安装软件\" class=\"headerlink\" title=\"ubutun容器安装软件\"></a>ubutun容器安装软件</h2><p>sshd开放。</p>\n<p>宝塔面板安装（可以实现很多有用的任务）</p>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><p>有些系统里面哪怕是同样安装Ubuntu。但是其会自动吧镜像最小化，导致系统有些功能用不了或者被阉割。</p>\n<p>可以用<code>unminimize</code>命令来恢复。</p>\n"},{"_content":"# C++复习\n\n\n\n### 常用头文件\n\n```\n#include<iostream> \n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <ctime>\n#include <algorithm>\n#include <cmath>\n#include<bits/stdc++.h>\n\n\n\nusing namespace std;\n\n//常见常量与等价定义 \ntypedef long long int64;\ntypedef pair<int, int> ii;\nconst double eps = 1e-6;\nconst int INF = 1 << 29;\nconst int MOD = 1e9 + 7;\nconst int MAXN = 100;\n```\n\n\n\n\n\n### 标准IO\n\n| 头文件     | 函数和描述                                                   |\n| :--------- | :----------------------------------------------------------- |\n| <iostream> | 该文件定义了 **cin、cout、cerr** 和 **clog** 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。 |\n| <iomanip>  | 该文件通过所谓的参数化的流操纵器（比如 **setw** 和 **setprecision**），来声明对执行标准化 I/O 有用的服务。 |\n| <fstream>  | 该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。 |\n\n#### 关于scanf\n\n- 输入string\n\n  ```\n  \tchar s[100100];\n  \t\n  \twhile(scanf(\"%s\", s) != EOF){\n  \tint len = strlen(s); //#include<bits/stdc++.h>\n  \n  ```\n\n  \n\n- \n\n\n\n\n\n### STL模板\n\nC++ 标准模板库的核心包括以下三个组件：\n\n| 组件                | 描述                                                         |\n| :------------------ | :----------------------------------------------------------- |\n| 容器（Containers）  | 容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。 |\n| 算法（Algorithms）  | 算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。 |\n| 迭代器（iterators） | 迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。 |\n\n\n\n#### 字典\n\n**内部实现机理**\n\n- map： **map内部实现了一个红黑树**，该结构具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素，因此，**对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了map的效率。**\n- unordered_map: unordered_map内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的\n\n#### map红黑树使用\n\n**存入**\n\n```\nmap<int,int> count;\ncount[i]=1;\n```\n\n**查找**\n\n```\n如果key存在，则find返回key对应的迭代器，如果key不存在，则find返回尾后迭代器 .end()。可以参考下面的示例来判断key值是否存在\n\nif (mymap.find(key) == mymap.end())\n    cout << \"没有这个key\" << endl;\n```\n\n**统计次数**\n\n```\ncount函数\ncount函数用于统计key值在map中出现的次数，map的key不允许重复，因此如果key存在返回1，不存在返回0\n\nif (mymap.count(key) == 0)\n```\n\n**取值**\n\nMap中元素取值主要有at和[ ]两种操作，at会作下标检查，而[]不会。\n\n\n\n**删除**\n\n```\n// 删除迭代器指向位置的键值对，并返回一个指向下一元素的迭代器\niterator erase( iterator pos )\n\n// 删除一定范围内的元素，并返回一个指向下一元素的迭代器\niterator erase( const_iterator first, const_iterator last );\n\n// 根据Key来进行删除， 返回删除的元素数量，在map里结果非0即1\nsize_t erase( const key_type& key );\n\n// 清空map，清空后的size为0\nvoid clear();\n```\n\n\n\n**遍历**\n\n```\n map<int, int>::iterator iter;\n    iter = _map.begin();\n    while(iter != _map.end()) {\n        cout << iter->first << \" : \" << iter->second << endl;\n        iter++;\n    }\n```\n\n\n\n\n\n#### vector 使用\n\n**初始化大小**\n\n```\nvector<int> ans(10,0); 10个0\nvector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中// 相当于切片\n```\n\n**插入**\n\n\n- void push_back(const T& x):向量尾部增加一个元素X\n- iterator insert(iterator it,const T& x):向量中迭代器指向元素前增加一个元素x\n\n\n\n**遍历**\n\n```\n    cout<<\"直接利用数组：\"; \n    for(int i=0;i<10;i++)//方法一 \n    {\n        cout<<obj[i]<<\" \";\n    }\n \n    cout<<endl; \n    cout<<\"利用迭代器：\" ;\n    //方法二，使用迭代器将容器中数据输出 \n    vector<int>::iterator it;//声明一个迭代器，来访问vector容器，作用：遍历或者指向vector容器的元素 \n    for(it=obj.begin();it!=obj.end();it++)\n    {\n        cout<<*it<<\" \";\n    }\n```\n\n\n\n\n\n**删除函数**\n\n- iterator erase(iterator it):删除向量中迭代器指向元素\n- iterator erase(iterator first,iterator last):删除向量中[first,last)中元素\n- void pop_back():删除向量中最后一个元素\n\n- iterator insert(iterator it,const_iterator first,const_iterator last):向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据\n\n\n\n\n\n#### set 库\n\n**存入**\n\n```\na.insert(i);\n```\n\n**统计**\n\n**count()** 用来查找set中某个某个键值出现的次数。这个函数在set并不是很实用，因为一个键值在set只可能出现0或1次，这样就变成了判断某一键值是否在set出现过了。\n\n**查找**\n\n```\nfind()  ，返回给定值值得定位器，如果没找到则返回end()。\n```\n\n\n\n\n\n**查找邻近元素**\n\n```\nlower_bound(key_value) ，返回第一个大于等于key_value的定位器\n\nupper_bound(key_value)，返回最后一个大于等于key_value的定位器\n```\n\n\n\n\n\n**删除**\n\n```\nerase(iterator)  ,删除定位器iterator指向的值\n\nerase(first,second),删除定位器first和second之间的值\n\nerase(key_value),删除键值key_value的值\n```\n\n\n\n\n\n#### 栈\n\n和其他序列容器相比，stack 是一类存储机制简单、所提供操作较少的容器。下面是 stack 容器可以提供的一套完整操作：\n\n- top()：返回一个栈顶元素的引用，类型为 T&。如果栈为空，返回值未定义。\n- push(const T& obj)：可以将对象副本压入栈顶。这是通过调用底层容器的 push_back() 函数完成的。\n- push(T&& obj)：以移动对象的方式将对象压入栈顶。这是通过调用底层容器的有右值引用参数的 push_back() 函数完成的。\n- pop()：弹出栈顶元素。\n- size()：返回栈中元素的个数。\n- empty()：在栈中没有元素的情况下返回 true。\n- emplace()：用传入的参数调用构造函数，在栈顶生成对象。\n- swap(stack<T> & other_stack)：将当前栈中的元素和参数中的元素交换。参数所包含元素的类型必须和当前栈的相同。对于 stack 对象有一个特例化的全局函数 swap() 可以使用。\n\n\n\n#### 优先级队列（默认是最大堆）\n\n```\n#include <queue>\n```\n\n具体方法\n\n和队列基本操作相同:\n\n- top 访问队头元素\n- empty 队列是否为空\n- size 返回队列内元素个数\n- push 插入元素到队尾 (并排序)\n- emplace 原地构造一个元素并插入队列\n- pop 弹出队头元素\n- swap 交换内容\n\n定义：`priority_queue<Type, Container, Functional>`\n\n**默认是最大堆**\n\n**最后一个参数是比较函数**\n\n```\n#include <iostream>\n#include <queue>\nusing namespace std;\n\n//方法1\nstruct tmp1 //运算符重载<\n{\n    int x;\n    tmp1(int a) {x = a;}\n    bool operator<(const tmp1& a) const\n    {\n        return x < a.x; //大顶堆\n    }\n};\n\n//方法2\nstruct tmp2 //重写仿函数\n{\n    bool operator() (tmp1 a, tmp1 b) \n    {\n        return a.x < b.x; //大顶堆\n    }\n};\n\nint main() \n{\n    tmp1 a(1);\n    tmp1 b(2);\n    tmp1 c(3);\n    priority_queue<tmp1> d;\n    d.push(b);\n    d.push(c);\n    d.push(a);\n    while (!d.empty()) \n    {\n        cout << d.top().x << '\\n';\n        d.pop();\n    }\n    cout << endl;\n\n    priority_queue<tmp1, vector<tmp1>, tmp2> f;\n    f.push(c);\n    f.push(b);\n    f.push(a);\n    while (!f.empty()) \n    {\n        cout << f.top().x << '\\n';\n        f.pop();\n    }\n}\n\n```\n\n\n\n\n\n\n\n### algorithm库得方法\n\n**排序**\n\n```\nvector\nbool compare(int a,int b) \n{ \n    return a< b; //升序排列，如果改为return a>b，则为降序 \n} \nint a[20]={2,4,1,23,5,76,0,43,24,65},i; \nfor(i=0;i<20;i++) \n    cout<< a[i]<< endl; \nsort(a,a+20,compare);\nsort(a.begin(), a.end(), cmp) //或者\n```\n\n\n\n**反转**vector\n\n```\nreverse(ans.begin(), ans.end());\n```\n\n这里是引用过去得，相当于直接改变了\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 基本数据类型\n\nC++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了**七种基本的 C++ 数据类型**：\n\n| 类型     | 关键字  |\n| :------- | :------ |\n| 布尔型   | bool    |\n| 字符型   | char    |\n| 整型     | int     |\n| 浮点型   | float   |\n| 双浮点型 | double  |\n| 无类型   | void    |\n| 宽字符型 | wchar_t |\n\n### 修饰符\n\n类型还可以用关键字修饰\n\n- signed\n- unsigned\n- short\n- long\n\n举例：\n\n| 类型               | 位            | 范围                                                         |\n| :----------------- | :------------ | :----------------------------------------------------------- |\n| char               | 1 个字节      | -128 到 127 或者 0 到 255                                    |\n| unsigned char      | 1 个字节      | 0 到 255                                                     |\n| signed char        | 1 个字节      | -128 到 127                                                  |\n| int                | 4 个字节      | -2147483648 到 2147483647                                    |\n| unsigned int       | 4 个字节      | 0 到 4294967295                                              |\n| signed int         | 4 个字节      | -2147483648 到 2147483647                                    |\n| short int          | 2 个字节      | -32768 到 32767                                              |\n| unsigned short int | 2 个字节      | 0 到 65,535                                                  |\n| signed short int   | 2 个字节      | -32768 到 32767                                              |\n| long int           | 8 个字节      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807      |\n| signed long int    | 8 个字节      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807      |\n| unsigned long int  | 8 个字节      | 0 到 18,446,744,073,709,551,615                              |\n| float              | 4 个字节      | 精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字) |\n| double             | 8 个字节      | 双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字) |\n| long double        | 16 个字节     | 长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。 |\n| wchar_t            | 2 或 4 个字节 | 1 个宽字符                                                   |\n\n\n\n### 关于&&和||运算得优先级\n\n要注意这里面是有着短路得运算得思路得。\n\n而且对于一个队列得判断，应该先判断这个队列是否为空，在对队列就进行引用。\n\n`while (!working.empty() && working.top().startTime <= ts )`\n\n\n\n### typedef 声明\n\n您可以使用 **typedef** 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法：\n\n```\ntypedef type newname; \n```\n\n### 枚举类型\n\n枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。\n\n如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓\"枚举\"是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。\n\n创建枚举，需要使用关键字 **enum**。枚举类型的一般形式为：\n\n```\nenum 枚举名{ \n     标识符[=整型常数], \n     标识符[=整型常数], \n... \n    标识符[=整型常数]\n} 枚举变量;\n    \n```\n\n如果枚举没有初始化, 即省掉\"=整型常数\"时, 则从第一个标识符开始。\n\n\n\n\n\n### C++ 中的变量声明\n\n变量声明向编译器保证变量以给定的类型和名称存在，**这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译**。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。\n\n\n\n```\n// 函数声明\nint func(); // 如果没有这句就会报错\n \nint main()\n{\n    // 函数调用\n    int i = func();\n}\n \n// 函数定义\nint func()\n{\n    return 0;\n}\n```\n\n### 变量作用域\n\n**全局变量**\n\n**在所有函数外部定义的变量（通常是在程序的头部），称为全局变量**。全局变量的值在程序的整个生命周期内都是有效的。\n\n全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。下面的实例使用了全局变量和局部变量：\n\n\n\n### 常量#define 和 const\n\n**宏定义 #define 和常量 const 的区别**\n\n**类型和安全检查不同**\n\n宏定义是字符替换，没有数据类型的区别，同时这种替换没有类型安全检查，可能产生边际效应等错误；\n\nconst常量是常量的声明，有类型区别，需要在编译阶段进行类型检查\n\n**编译器处理不同**\n\n宏定义是一个\"编译时\"概念，在预处理阶段展开，不能对宏定义进行调试，生命周期结束与编译时期；\n\nconst常量是一个\"运行时\"概念，在程序运行使用，类似于一个只读行数据\n\n**存储方式不同**\n\n宏定义是直接替换，不会分配内存，存储与程序的代码段中；\n\nconst常量需要进行内存分配，存储与程序的数据段中\n\n**定义域不同**\n\n```\nvoid f1 ()\n{\n    #define N 12\n    const int n 12;\n}\nvoid f2 ()\n{\n    cout<<N <<endl; //正确，N已经定义过，不受定义域限制\n    cout<<n <<endl; //错误，n定义域只在f1函数中\n}\n```\n\n**定义后能否取消**\n\n宏定义可以通过#undef来使之前的宏定义失效\n\nconst常量定义后将在定义域内永久有效\n\n\n\n### goto语句\n\nC++ 中 **goto** 语句的语法：\n\n```\ngoto label;\n..\n.\nlabel: statement;\n```\n\n\n\n\n\n### 函数参数\n\n如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的**形式参数**。\n\n形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。\n\n当调用函数时，有三种向函数传递参数的方式：\n\n| 调用类型                                                     | 描述                                                         |\n| :----------------------------------------------------------- | :----------------------------------------------------------- |\n| [传值调用](https://www.runoob.com/cplusplus/cpp-function-call-by-value.html) | 该方法把参数的实际值赋值给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。 |\n| [指针调用](https://www.runoob.com/cplusplus/cpp-function-call-by-pointer.html) | 该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 |\n| [引用调用](https://www.runoob.com/cplusplus/cpp-function-call-by-reference.html) | 该方法把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 |\n\n\n\n### C++ 随机数\n\n在许多情况下，需要生成随机数。关于随机数生成器，有两个相关的函数。一个是 **rand()**，该函数只返回一个伪随机数。生成随机数之前必须先调用 **srand()** 函数。\n\n下面是一个关于生成随机数的简单实例。实例中使用了 **time()** 函数来获取系统时间的秒数，通过调用 rand() 函数来生成随机数：\n\n实例\n\n```\n#include <iostream>\n#include <ctime>\n#include <cstdlib>\n \nusing namespace std;\n \nint main ()\n{\n   int i,j;\n \n   // 设置种子\n   srand( (unsigned)time( NULL ) );\n \n   /* 生成 10 个随机数 */\n   for( i = 0; i < 10; i++ )\n   {\n      // 生成实际的随机数\n      j= rand();\n      cout <<\"随机数： \" << j << endl;\n   }\n \n   return 0;\n}\n```\n\n### 数组\n\n\n在 C++ 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示：\n\n```\ntype arrayName [ arraySize ];\n```\n\n**初始化数组**\n\n```\ndouble balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0};\n```\n\n**多维数组**\n\n```\ntype name[size1][size2]...[sizeN];\n```\n\n\n\n### 字符串\n\n这里只讲**string**\n\n| 序号 | 函数 & 目的                                                  |\n| :--- | :----------------------------------------------------------- |\n| 1    | **strcpy(s1, s2);** 复制字符串 s2 到字符串 s1。              |\n| 2    | **strcat(s1, s2);** 连接字符串 s2 到字符串 s1 的末尾。连接字符串也可以用 **+** 号，例如: `string str1 = \"runoob\"; string str2 = \"google\"; string str = str1 + str2;` |\n| 3    | **strlen(s1);** 返回字符串 s1 的长度。                       |\n| 4    | **strcmp(s1, s2);** 如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回值小于 0；如果 s1>s2 则返回值大于 0。 |\n| 5    | **strchr(s1, ch);** 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 |\n| 6    | **strstr(s1, s2);** 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 |\n\n注意，**字符和字符串不一样**\n\n```\nchar c = 'c';\nstring s= \"string\";\nchar a = s[0];\n```\n\n一个单引号，一个双。\n\n\n\n### 字符串转换成数字\n\n- stoi() string类型字符串转换为int\n- stod() string类型字符串转换为double\n- to_string() 重载方法，将一些整形，浮点型等转换为string类型字符串\n\n\n\n### cctype 数据类型判断\n\n- isalnum() 判断一个字符是不是alphanumeric，即大小写英文字母或是数字\n- isalpha() 判断一个字符是不是alphabetic，即英文字母\n- isdigit() 判断一个字符是不是数字\n- tolower() 将大写转换为小写\n- toupper() 将小写转换为大写\n\n### 指针\n\n#### 定义\n\n**指针**是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：\n\n```\ntype *var-name;\n```\n\n```\nint    *ip;    /* 一个整型的指针 */\ndouble *dp;    /* 一个 double 型的指针 */\nfloat  *fp;    /* 一个浮点型的指针 */\nchar   *ch;    /* 一个字符型的指针 */\n```\n\n\n\n#### 关于&和*\n\n符号&代表取值，符号*代表解引用：\n\n| 符号 | 意义   |\n| ---- | ------ |\n| &    | 取地址 |\n| *    | 解引用 |\n\n\n\n#### **指针与数组**\n\n我们知道，一维数组名本身就是一个指针\n\n```cpp\nint arr[] = {1, 2, 3, 4, 5};\nint* p1 = arr;\nint* p2 = &arr[0];\nint* p3 = &arr;    //报错\n```\n\n在定义了指向数组首元素的指针变量后，我们可以通过这个指针变量来访问数组元素：\n\n```cpp\n int arr[] = { 1,2,3,4,5 };\n  int* p1 = arr;\n  int length = sizeof(arr) / sizeof(int);\n  for (int i = 0; i < length; i++)\n  {\n    cout << p1[i] << endl;\n    cout << *(p1 + i) << endl;\n  }\n```\n\n\n\n**数组名作为函数传递的时候，会退化成一个指针**\n\n\n\n### 引用\n\n引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。\n\n```\n实例\n#include <iostream>\n \nusing namespace std;\n \nint main ()\n{\n   // 声明简单的变量\n   int    i;\n   double d;\n \n   // 声明引用变量\n   int&    r = i;\n   double& s = d;\n   \n   i = 5;\n   cout << \"Value of i : \" << i << endl;\n   cout << \"Value of i reference : \" << r  << endl;\n \n   d = 11.7;\n   cout << \"Value of d : \" << d << endl;\n   cout << \"Value of d reference : \" << s  << endl;\n   \n   return 0;\n}\n```\n\n引用传递得意思。\n\n\n\n","source":"_posts/综合/C++复习.md","raw":"# C++复习\n\n\n\n### 常用头文件\n\n```\n#include<iostream> \n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <ctime>\n#include <algorithm>\n#include <cmath>\n#include<bits/stdc++.h>\n\n\n\nusing namespace std;\n\n//常见常量与等价定义 \ntypedef long long int64;\ntypedef pair<int, int> ii;\nconst double eps = 1e-6;\nconst int INF = 1 << 29;\nconst int MOD = 1e9 + 7;\nconst int MAXN = 100;\n```\n\n\n\n\n\n### 标准IO\n\n| 头文件     | 函数和描述                                                   |\n| :--------- | :----------------------------------------------------------- |\n| <iostream> | 该文件定义了 **cin、cout、cerr** 和 **clog** 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。 |\n| <iomanip>  | 该文件通过所谓的参数化的流操纵器（比如 **setw** 和 **setprecision**），来声明对执行标准化 I/O 有用的服务。 |\n| <fstream>  | 该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。 |\n\n#### 关于scanf\n\n- 输入string\n\n  ```\n  \tchar s[100100];\n  \t\n  \twhile(scanf(\"%s\", s) != EOF){\n  \tint len = strlen(s); //#include<bits/stdc++.h>\n  \n  ```\n\n  \n\n- \n\n\n\n\n\n### STL模板\n\nC++ 标准模板库的核心包括以下三个组件：\n\n| 组件                | 描述                                                         |\n| :------------------ | :----------------------------------------------------------- |\n| 容器（Containers）  | 容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。 |\n| 算法（Algorithms）  | 算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。 |\n| 迭代器（iterators） | 迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。 |\n\n\n\n#### 字典\n\n**内部实现机理**\n\n- map： **map内部实现了一个红黑树**，该结构具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素，因此，**对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了map的效率。**\n- unordered_map: unordered_map内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的\n\n#### map红黑树使用\n\n**存入**\n\n```\nmap<int,int> count;\ncount[i]=1;\n```\n\n**查找**\n\n```\n如果key存在，则find返回key对应的迭代器，如果key不存在，则find返回尾后迭代器 .end()。可以参考下面的示例来判断key值是否存在\n\nif (mymap.find(key) == mymap.end())\n    cout << \"没有这个key\" << endl;\n```\n\n**统计次数**\n\n```\ncount函数\ncount函数用于统计key值在map中出现的次数，map的key不允许重复，因此如果key存在返回1，不存在返回0\n\nif (mymap.count(key) == 0)\n```\n\n**取值**\n\nMap中元素取值主要有at和[ ]两种操作，at会作下标检查，而[]不会。\n\n\n\n**删除**\n\n```\n// 删除迭代器指向位置的键值对，并返回一个指向下一元素的迭代器\niterator erase( iterator pos )\n\n// 删除一定范围内的元素，并返回一个指向下一元素的迭代器\niterator erase( const_iterator first, const_iterator last );\n\n// 根据Key来进行删除， 返回删除的元素数量，在map里结果非0即1\nsize_t erase( const key_type& key );\n\n// 清空map，清空后的size为0\nvoid clear();\n```\n\n\n\n**遍历**\n\n```\n map<int, int>::iterator iter;\n    iter = _map.begin();\n    while(iter != _map.end()) {\n        cout << iter->first << \" : \" << iter->second << endl;\n        iter++;\n    }\n```\n\n\n\n\n\n#### vector 使用\n\n**初始化大小**\n\n```\nvector<int> ans(10,0); 10个0\nvector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中// 相当于切片\n```\n\n**插入**\n\n\n- void push_back(const T& x):向量尾部增加一个元素X\n- iterator insert(iterator it,const T& x):向量中迭代器指向元素前增加一个元素x\n\n\n\n**遍历**\n\n```\n    cout<<\"直接利用数组：\"; \n    for(int i=0;i<10;i++)//方法一 \n    {\n        cout<<obj[i]<<\" \";\n    }\n \n    cout<<endl; \n    cout<<\"利用迭代器：\" ;\n    //方法二，使用迭代器将容器中数据输出 \n    vector<int>::iterator it;//声明一个迭代器，来访问vector容器，作用：遍历或者指向vector容器的元素 \n    for(it=obj.begin();it!=obj.end();it++)\n    {\n        cout<<*it<<\" \";\n    }\n```\n\n\n\n\n\n**删除函数**\n\n- iterator erase(iterator it):删除向量中迭代器指向元素\n- iterator erase(iterator first,iterator last):删除向量中[first,last)中元素\n- void pop_back():删除向量中最后一个元素\n\n- iterator insert(iterator it,const_iterator first,const_iterator last):向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据\n\n\n\n\n\n#### set 库\n\n**存入**\n\n```\na.insert(i);\n```\n\n**统计**\n\n**count()** 用来查找set中某个某个键值出现的次数。这个函数在set并不是很实用，因为一个键值在set只可能出现0或1次，这样就变成了判断某一键值是否在set出现过了。\n\n**查找**\n\n```\nfind()  ，返回给定值值得定位器，如果没找到则返回end()。\n```\n\n\n\n\n\n**查找邻近元素**\n\n```\nlower_bound(key_value) ，返回第一个大于等于key_value的定位器\n\nupper_bound(key_value)，返回最后一个大于等于key_value的定位器\n```\n\n\n\n\n\n**删除**\n\n```\nerase(iterator)  ,删除定位器iterator指向的值\n\nerase(first,second),删除定位器first和second之间的值\n\nerase(key_value),删除键值key_value的值\n```\n\n\n\n\n\n#### 栈\n\n和其他序列容器相比，stack 是一类存储机制简单、所提供操作较少的容器。下面是 stack 容器可以提供的一套完整操作：\n\n- top()：返回一个栈顶元素的引用，类型为 T&。如果栈为空，返回值未定义。\n- push(const T& obj)：可以将对象副本压入栈顶。这是通过调用底层容器的 push_back() 函数完成的。\n- push(T&& obj)：以移动对象的方式将对象压入栈顶。这是通过调用底层容器的有右值引用参数的 push_back() 函数完成的。\n- pop()：弹出栈顶元素。\n- size()：返回栈中元素的个数。\n- empty()：在栈中没有元素的情况下返回 true。\n- emplace()：用传入的参数调用构造函数，在栈顶生成对象。\n- swap(stack<T> & other_stack)：将当前栈中的元素和参数中的元素交换。参数所包含元素的类型必须和当前栈的相同。对于 stack 对象有一个特例化的全局函数 swap() 可以使用。\n\n\n\n#### 优先级队列（默认是最大堆）\n\n```\n#include <queue>\n```\n\n具体方法\n\n和队列基本操作相同:\n\n- top 访问队头元素\n- empty 队列是否为空\n- size 返回队列内元素个数\n- push 插入元素到队尾 (并排序)\n- emplace 原地构造一个元素并插入队列\n- pop 弹出队头元素\n- swap 交换内容\n\n定义：`priority_queue<Type, Container, Functional>`\n\n**默认是最大堆**\n\n**最后一个参数是比较函数**\n\n```\n#include <iostream>\n#include <queue>\nusing namespace std;\n\n//方法1\nstruct tmp1 //运算符重载<\n{\n    int x;\n    tmp1(int a) {x = a;}\n    bool operator<(const tmp1& a) const\n    {\n        return x < a.x; //大顶堆\n    }\n};\n\n//方法2\nstruct tmp2 //重写仿函数\n{\n    bool operator() (tmp1 a, tmp1 b) \n    {\n        return a.x < b.x; //大顶堆\n    }\n};\n\nint main() \n{\n    tmp1 a(1);\n    tmp1 b(2);\n    tmp1 c(3);\n    priority_queue<tmp1> d;\n    d.push(b);\n    d.push(c);\n    d.push(a);\n    while (!d.empty()) \n    {\n        cout << d.top().x << '\\n';\n        d.pop();\n    }\n    cout << endl;\n\n    priority_queue<tmp1, vector<tmp1>, tmp2> f;\n    f.push(c);\n    f.push(b);\n    f.push(a);\n    while (!f.empty()) \n    {\n        cout << f.top().x << '\\n';\n        f.pop();\n    }\n}\n\n```\n\n\n\n\n\n\n\n### algorithm库得方法\n\n**排序**\n\n```\nvector\nbool compare(int a,int b) \n{ \n    return a< b; //升序排列，如果改为return a>b，则为降序 \n} \nint a[20]={2,4,1,23,5,76,0,43,24,65},i; \nfor(i=0;i<20;i++) \n    cout<< a[i]<< endl; \nsort(a,a+20,compare);\nsort(a.begin(), a.end(), cmp) //或者\n```\n\n\n\n**反转**vector\n\n```\nreverse(ans.begin(), ans.end());\n```\n\n这里是引用过去得，相当于直接改变了\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n### 基本数据类型\n\nC++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了**七种基本的 C++ 数据类型**：\n\n| 类型     | 关键字  |\n| :------- | :------ |\n| 布尔型   | bool    |\n| 字符型   | char    |\n| 整型     | int     |\n| 浮点型   | float   |\n| 双浮点型 | double  |\n| 无类型   | void    |\n| 宽字符型 | wchar_t |\n\n### 修饰符\n\n类型还可以用关键字修饰\n\n- signed\n- unsigned\n- short\n- long\n\n举例：\n\n| 类型               | 位            | 范围                                                         |\n| :----------------- | :------------ | :----------------------------------------------------------- |\n| char               | 1 个字节      | -128 到 127 或者 0 到 255                                    |\n| unsigned char      | 1 个字节      | 0 到 255                                                     |\n| signed char        | 1 个字节      | -128 到 127                                                  |\n| int                | 4 个字节      | -2147483648 到 2147483647                                    |\n| unsigned int       | 4 个字节      | 0 到 4294967295                                              |\n| signed int         | 4 个字节      | -2147483648 到 2147483647                                    |\n| short int          | 2 个字节      | -32768 到 32767                                              |\n| unsigned short int | 2 个字节      | 0 到 65,535                                                  |\n| signed short int   | 2 个字节      | -32768 到 32767                                              |\n| long int           | 8 个字节      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807      |\n| signed long int    | 8 个字节      | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807      |\n| unsigned long int  | 8 个字节      | 0 到 18,446,744,073,709,551,615                              |\n| float              | 4 个字节      | 精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字) |\n| double             | 8 个字节      | 双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字) |\n| long double        | 16 个字节     | 长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。 |\n| wchar_t            | 2 或 4 个字节 | 1 个宽字符                                                   |\n\n\n\n### 关于&&和||运算得优先级\n\n要注意这里面是有着短路得运算得思路得。\n\n而且对于一个队列得判断，应该先判断这个队列是否为空，在对队列就进行引用。\n\n`while (!working.empty() && working.top().startTime <= ts )`\n\n\n\n### typedef 声明\n\n您可以使用 **typedef** 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法：\n\n```\ntypedef type newname; \n```\n\n### 枚举类型\n\n枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。\n\n如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓\"枚举\"是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。\n\n创建枚举，需要使用关键字 **enum**。枚举类型的一般形式为：\n\n```\nenum 枚举名{ \n     标识符[=整型常数], \n     标识符[=整型常数], \n... \n    标识符[=整型常数]\n} 枚举变量;\n    \n```\n\n如果枚举没有初始化, 即省掉\"=整型常数\"时, 则从第一个标识符开始。\n\n\n\n\n\n### C++ 中的变量声明\n\n变量声明向编译器保证变量以给定的类型和名称存在，**这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译**。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。\n\n\n\n```\n// 函数声明\nint func(); // 如果没有这句就会报错\n \nint main()\n{\n    // 函数调用\n    int i = func();\n}\n \n// 函数定义\nint func()\n{\n    return 0;\n}\n```\n\n### 变量作用域\n\n**全局变量**\n\n**在所有函数外部定义的变量（通常是在程序的头部），称为全局变量**。全局变量的值在程序的整个生命周期内都是有效的。\n\n全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。下面的实例使用了全局变量和局部变量：\n\n\n\n### 常量#define 和 const\n\n**宏定义 #define 和常量 const 的区别**\n\n**类型和安全检查不同**\n\n宏定义是字符替换，没有数据类型的区别，同时这种替换没有类型安全检查，可能产生边际效应等错误；\n\nconst常量是常量的声明，有类型区别，需要在编译阶段进行类型检查\n\n**编译器处理不同**\n\n宏定义是一个\"编译时\"概念，在预处理阶段展开，不能对宏定义进行调试，生命周期结束与编译时期；\n\nconst常量是一个\"运行时\"概念，在程序运行使用，类似于一个只读行数据\n\n**存储方式不同**\n\n宏定义是直接替换，不会分配内存，存储与程序的代码段中；\n\nconst常量需要进行内存分配，存储与程序的数据段中\n\n**定义域不同**\n\n```\nvoid f1 ()\n{\n    #define N 12\n    const int n 12;\n}\nvoid f2 ()\n{\n    cout<<N <<endl; //正确，N已经定义过，不受定义域限制\n    cout<<n <<endl; //错误，n定义域只在f1函数中\n}\n```\n\n**定义后能否取消**\n\n宏定义可以通过#undef来使之前的宏定义失效\n\nconst常量定义后将在定义域内永久有效\n\n\n\n### goto语句\n\nC++ 中 **goto** 语句的语法：\n\n```\ngoto label;\n..\n.\nlabel: statement;\n```\n\n\n\n\n\n### 函数参数\n\n如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的**形式参数**。\n\n形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。\n\n当调用函数时，有三种向函数传递参数的方式：\n\n| 调用类型                                                     | 描述                                                         |\n| :----------------------------------------------------------- | :----------------------------------------------------------- |\n| [传值调用](https://www.runoob.com/cplusplus/cpp-function-call-by-value.html) | 该方法把参数的实际值赋值给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。 |\n| [指针调用](https://www.runoob.com/cplusplus/cpp-function-call-by-pointer.html) | 该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 |\n| [引用调用](https://www.runoob.com/cplusplus/cpp-function-call-by-reference.html) | 该方法把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 |\n\n\n\n### C++ 随机数\n\n在许多情况下，需要生成随机数。关于随机数生成器，有两个相关的函数。一个是 **rand()**，该函数只返回一个伪随机数。生成随机数之前必须先调用 **srand()** 函数。\n\n下面是一个关于生成随机数的简单实例。实例中使用了 **time()** 函数来获取系统时间的秒数，通过调用 rand() 函数来生成随机数：\n\n实例\n\n```\n#include <iostream>\n#include <ctime>\n#include <cstdlib>\n \nusing namespace std;\n \nint main ()\n{\n   int i,j;\n \n   // 设置种子\n   srand( (unsigned)time( NULL ) );\n \n   /* 生成 10 个随机数 */\n   for( i = 0; i < 10; i++ )\n   {\n      // 生成实际的随机数\n      j= rand();\n      cout <<\"随机数： \" << j << endl;\n   }\n \n   return 0;\n}\n```\n\n### 数组\n\n\n在 C++ 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示：\n\n```\ntype arrayName [ arraySize ];\n```\n\n**初始化数组**\n\n```\ndouble balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0};\n```\n\n**多维数组**\n\n```\ntype name[size1][size2]...[sizeN];\n```\n\n\n\n### 字符串\n\n这里只讲**string**\n\n| 序号 | 函数 & 目的                                                  |\n| :--- | :----------------------------------------------------------- |\n| 1    | **strcpy(s1, s2);** 复制字符串 s2 到字符串 s1。              |\n| 2    | **strcat(s1, s2);** 连接字符串 s2 到字符串 s1 的末尾。连接字符串也可以用 **+** 号，例如: `string str1 = \"runoob\"; string str2 = \"google\"; string str = str1 + str2;` |\n| 3    | **strlen(s1);** 返回字符串 s1 的长度。                       |\n| 4    | **strcmp(s1, s2);** 如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回值小于 0；如果 s1>s2 则返回值大于 0。 |\n| 5    | **strchr(s1, ch);** 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 |\n| 6    | **strstr(s1, s2);** 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 |\n\n注意，**字符和字符串不一样**\n\n```\nchar c = 'c';\nstring s= \"string\";\nchar a = s[0];\n```\n\n一个单引号，一个双。\n\n\n\n### 字符串转换成数字\n\n- stoi() string类型字符串转换为int\n- stod() string类型字符串转换为double\n- to_string() 重载方法，将一些整形，浮点型等转换为string类型字符串\n\n\n\n### cctype 数据类型判断\n\n- isalnum() 判断一个字符是不是alphanumeric，即大小写英文字母或是数字\n- isalpha() 判断一个字符是不是alphabetic，即英文字母\n- isdigit() 判断一个字符是不是数字\n- tolower() 将大写转换为小写\n- toupper() 将小写转换为大写\n\n### 指针\n\n#### 定义\n\n**指针**是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：\n\n```\ntype *var-name;\n```\n\n```\nint    *ip;    /* 一个整型的指针 */\ndouble *dp;    /* 一个 double 型的指针 */\nfloat  *fp;    /* 一个浮点型的指针 */\nchar   *ch;    /* 一个字符型的指针 */\n```\n\n\n\n#### 关于&和*\n\n符号&代表取值，符号*代表解引用：\n\n| 符号 | 意义   |\n| ---- | ------ |\n| &    | 取地址 |\n| *    | 解引用 |\n\n\n\n#### **指针与数组**\n\n我们知道，一维数组名本身就是一个指针\n\n```cpp\nint arr[] = {1, 2, 3, 4, 5};\nint* p1 = arr;\nint* p2 = &arr[0];\nint* p3 = &arr;    //报错\n```\n\n在定义了指向数组首元素的指针变量后，我们可以通过这个指针变量来访问数组元素：\n\n```cpp\n int arr[] = { 1,2,3,4,5 };\n  int* p1 = arr;\n  int length = sizeof(arr) / sizeof(int);\n  for (int i = 0; i < length; i++)\n  {\n    cout << p1[i] << endl;\n    cout << *(p1 + i) << endl;\n  }\n```\n\n\n\n**数组名作为函数传递的时候，会退化成一个指针**\n\n\n\n### 引用\n\n引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。\n\n```\n实例\n#include <iostream>\n \nusing namespace std;\n \nint main ()\n{\n   // 声明简单的变量\n   int    i;\n   double d;\n \n   // 声明引用变量\n   int&    r = i;\n   double& s = d;\n   \n   i = 5;\n   cout << \"Value of i : \" << i << endl;\n   cout << \"Value of i reference : \" << r  << endl;\n \n   d = 11.7;\n   cout << \"Value of d : \" << d << endl;\n   cout << \"Value of d reference : \" << s  << endl;\n   \n   return 0;\n}\n```\n\n引用传递得意思。\n\n\n\n","slug":"综合/C++复习","published":1,"date":"2023-02-26T15:28:35.056Z","updated":"2023-02-27T11:34:33.141Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsyce001d0gcnzfic5tmg","content":"<h1 id=\"C-复习\"><a href=\"#C-复习\" class=\"headerlink\" title=\"C++复习\"></a>C++复习</h1><h3 id=\"常用头文件\"><a href=\"#常用头文件\" class=\"headerlink\" title=\"常用头文件\"></a>常用头文件</h3><pre><code>#include&lt;iostream&gt; \n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;stack&gt;\n#include &lt;queue&gt;\n#include &lt;set&gt;\n#include &lt;map&gt;\n#include &lt;ctime&gt;\n#include &lt;algorithm&gt;\n#include &lt;cmath&gt;\n#include&lt;bits/stdc++.h&gt;\n\n\n\nusing namespace std;\n\n//常见常量与等价定义 \ntypedef long long int64;\ntypedef pair&lt;int, int&gt; ii;\nconst double eps = 1e-6;\nconst int INF = 1 &lt;&lt; 29;\nconst int MOD = 1e9 + 7;\nconst int MAXN = 100;</code></pre><h3 id=\"标准IO\"><a href=\"#标准IO\" class=\"headerlink\" title=\"标准IO\"></a>标准IO</h3><table>\n<thead>\n<tr>\n<th align=\"left\">头文件</th>\n<th align=\"left\">函数和描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><iostream></iostream></td>\n<td align=\"left\">该文件定义了 <strong>cin、cout、cerr</strong> 和 <strong>clog</strong> 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。</td>\n</tr>\n<tr>\n<td align=\"left\"><iomanip></iomanip></td>\n<td align=\"left\">该文件通过所谓的参数化的流操纵器（比如 <strong>setw</strong> 和 <strong>setprecision</strong>），来声明对执行标准化 I/O 有用的服务。</td>\n</tr>\n<tr>\n<td align=\"left\"><fstream></fstream></td>\n<td align=\"left\">该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。</td>\n</tr>\n</tbody></table>\n<h4 id=\"关于scanf\"><a href=\"#关于scanf\" class=\"headerlink\" title=\"关于scanf\"></a>关于scanf</h4><ul>\n<li><p>输入string</p>\n<pre><code>    char s[100100];\n\n    while(scanf(&quot;%s&quot;, s) != EOF){\n    int len = strlen(s); //#include&lt;bits/stdc++.h&gt;\n</code></pre></li>\n</ul>\n<ul>\n<li></li>\n</ul>\n<h3 id=\"STL模板\"><a href=\"#STL模板\" class=\"headerlink\" title=\"STL模板\"></a>STL模板</h3><p>C++ 标准模板库的核心包括以下三个组件：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">组件</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">容器（Containers）</td>\n<td align=\"left\">容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。</td>\n</tr>\n<tr>\n<td align=\"left\">算法（Algorithms）</td>\n<td align=\"left\">算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。</td>\n</tr>\n<tr>\n<td align=\"left\">迭代器（iterators）</td>\n<td align=\"left\">迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。</td>\n</tr>\n</tbody></table>\n<h4 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h4><p><strong>内部实现机理</strong></p>\n<ul>\n<li>map： <strong>map内部实现了一个红黑树</strong>，该结构具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素，因此，<strong>对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了map的效率。</strong></li>\n<li>unordered_map: unordered_map内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的</li>\n</ul>\n<h4 id=\"map红黑树使用\"><a href=\"#map红黑树使用\" class=\"headerlink\" title=\"map红黑树使用\"></a>map红黑树使用</h4><p><strong>存入</strong></p>\n<pre><code>map&lt;int,int&gt; count;\ncount[i]=1;</code></pre><p><strong>查找</strong></p>\n<pre><code>如果key存在，则find返回key对应的迭代器，如果key不存在，则find返回尾后迭代器 .end()。可以参考下面的示例来判断key值是否存在\n\nif (mymap.find(key) == mymap.end())\n    cout &lt;&lt; &quot;没有这个key&quot; &lt;&lt; endl;</code></pre><p><strong>统计次数</strong></p>\n<pre><code>count函数\ncount函数用于统计key值在map中出现的次数，map的key不允许重复，因此如果key存在返回1，不存在返回0\n\nif (mymap.count(key) == 0)</code></pre><p><strong>取值</strong></p>\n<p>Map中元素取值主要有at和[ ]两种操作，at会作下标检查，而[]不会。</p>\n<p><strong>删除</strong></p>\n<pre><code>// 删除迭代器指向位置的键值对，并返回一个指向下一元素的迭代器\niterator erase( iterator pos )\n\n// 删除一定范围内的元素，并返回一个指向下一元素的迭代器\niterator erase( const_iterator first, const_iterator last );\n\n// 根据Key来进行删除， 返回删除的元素数量，在map里结果非0即1\nsize_t erase( const key_type&amp; key );\n\n// 清空map，清空后的size为0\nvoid clear();</code></pre><p><strong>遍历</strong></p>\n<pre><code> map&lt;int, int&gt;::iterator iter;\n    iter = _map.begin();\n    while(iter != _map.end()) {\n        cout &lt;&lt; iter-&gt;first &lt;&lt; &quot; : &quot; &lt;&lt; iter-&gt;second &lt;&lt; endl;\n        iter++;\n    }</code></pre><h4 id=\"vector-使用\"><a href=\"#vector-使用\" class=\"headerlink\" title=\"vector 使用\"></a>vector 使用</h4><p><strong>初始化大小</strong></p>\n<pre><code>vector&lt;int&gt; ans(10,0); 10个0\nvector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中// 相当于切片</code></pre><p><strong>插入</strong></p>\n<ul>\n<li>void push_back(const T&amp; x):向量尾部增加一个元素X</li>\n<li>iterator insert(iterator it,const T&amp; x):向量中迭代器指向元素前增加一个元素x</li>\n</ul>\n<p><strong>遍历</strong></p>\n<pre><code>    cout&lt;&lt;&quot;直接利用数组：&quot;; \n    for(int i=0;i&lt;10;i++)//方法一 \n    {\n        cout&lt;&lt;obj[i]&lt;&lt;&quot; &quot;;\n    }\n\n    cout&lt;&lt;endl; \n    cout&lt;&lt;&quot;利用迭代器：&quot; ;\n    //方法二，使用迭代器将容器中数据输出 \n    vector&lt;int&gt;::iterator it;//声明一个迭代器，来访问vector容器，作用：遍历或者指向vector容器的元素 \n    for(it=obj.begin();it!=obj.end();it++)\n    {\n        cout&lt;&lt;*it&lt;&lt;&quot; &quot;;\n    }</code></pre><p><strong>删除函数</strong></p>\n<ul>\n<li><p>iterator erase(iterator it):删除向量中迭代器指向元素</p>\n</li>\n<li><p>iterator erase(iterator first,iterator last):删除向量中[first,last)中元素</p>\n</li>\n<li><p>void pop_back():删除向量中最后一个元素</p>\n</li>\n<li><p>iterator insert(iterator it,const_iterator first,const_iterator last):向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据</p>\n</li>\n</ul>\n<h4 id=\"set-库\"><a href=\"#set-库\" class=\"headerlink\" title=\"set 库\"></a>set 库</h4><p><strong>存入</strong></p>\n<pre><code>a.insert(i);</code></pre><p><strong>统计</strong></p>\n<p><strong>count()</strong> 用来查找set中某个某个键值出现的次数。这个函数在set并不是很实用，因为一个键值在set只可能出现0或1次，这样就变成了判断某一键值是否在set出现过了。</p>\n<p><strong>查找</strong></p>\n<pre><code>find()  ，返回给定值值得定位器，如果没找到则返回end()。</code></pre><p><strong>查找邻近元素</strong></p>\n<pre><code>lower_bound(key_value) ，返回第一个大于等于key_value的定位器\n\nupper_bound(key_value)，返回最后一个大于等于key_value的定位器</code></pre><p><strong>删除</strong></p>\n<pre><code>erase(iterator)  ,删除定位器iterator指向的值\n\nerase(first,second),删除定位器first和second之间的值\n\nerase(key_value),删除键值key_value的值</code></pre><h4 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h4><p>和其他序列容器相比，stack 是一类存储机制简单、所提供操作较少的容器。下面是 stack 容器可以提供的一套完整操作：</p>\n<ul>\n<li>top()：返回一个栈顶元素的引用，类型为 T&amp;。如果栈为空，返回值未定义。</li>\n<li>push(const T&amp; obj)：可以将对象副本压入栈顶。这是通过调用底层容器的 push_back() 函数完成的。</li>\n<li>push(T&amp;&amp; obj)：以移动对象的方式将对象压入栈顶。这是通过调用底层容器的有右值引用参数的 push_back() 函数完成的。</li>\n<li>pop()：弹出栈顶元素。</li>\n<li>size()：返回栈中元素的个数。</li>\n<li>empty()：在栈中没有元素的情况下返回 true。</li>\n<li>emplace()：用传入的参数调用构造函数，在栈顶生成对象。</li>\n<li>swap(stack<t> &amp; other_stack)：将当前栈中的元素和参数中的元素交换。参数所包含元素的类型必须和当前栈的相同。对于 stack 对象有一个特例化的全局函数 swap() 可以使用。</t></li>\n</ul>\n<h4 id=\"优先级队列（默认是最大堆）\"><a href=\"#优先级队列（默认是最大堆）\" class=\"headerlink\" title=\"优先级队列（默认是最大堆）\"></a>优先级队列（默认是最大堆）</h4><pre><code>#include &lt;queue&gt;</code></pre><p>具体方法</p>\n<p>和队列基本操作相同:</p>\n<ul>\n<li>top 访问队头元素</li>\n<li>empty 队列是否为空</li>\n<li>size 返回队列内元素个数</li>\n<li>push 插入元素到队尾 (并排序)</li>\n<li>emplace 原地构造一个元素并插入队列</li>\n<li>pop 弹出队头元素</li>\n<li>swap 交换内容</li>\n</ul>\n<p>定义：<code>priority_queue&lt;Type, Container, Functional&gt;</code></p>\n<p><strong>默认是最大堆</strong></p>\n<p><strong>最后一个参数是比较函数</strong></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\nusing namespace std;\n\n//方法1\nstruct tmp1 //运算符重载&lt;\n{\n    int x;\n    tmp1(int a) {x = a;}\n    bool operator&lt;(const tmp1&amp; a) const\n    {\n        return x &lt; a.x; //大顶堆\n    }\n};\n\n//方法2\nstruct tmp2 //重写仿函数\n{\n    bool operator() (tmp1 a, tmp1 b) \n    {\n        return a.x &lt; b.x; //大顶堆\n    }\n};\n\nint main() \n{\n    tmp1 a(1);\n    tmp1 b(2);\n    tmp1 c(3);\n    priority_queue&lt;tmp1&gt; d;\n    d.push(b);\n    d.push(c);\n    d.push(a);\n    while (!d.empty()) \n    {\n        cout &lt;&lt; d.top().x &lt;&lt; &#39;\\n&#39;;\n        d.pop();\n    }\n    cout &lt;&lt; endl;\n\n    priority_queue&lt;tmp1, vector&lt;tmp1&gt;, tmp2&gt; f;\n    f.push(c);\n    f.push(b);\n    f.push(a);\n    while (!f.empty()) \n    {\n        cout &lt;&lt; f.top().x &lt;&lt; &#39;\\n&#39;;\n        f.pop();\n    }\n}\n</code></pre><h3 id=\"algorithm库得方法\"><a href=\"#algorithm库得方法\" class=\"headerlink\" title=\"algorithm库得方法\"></a>algorithm库得方法</h3><p><strong>排序</strong></p>\n<pre><code>vector\nbool compare(int a,int b) \n{ \n    return a&lt; b; //升序排列，如果改为return a&gt;b，则为降序 \n} \nint a[20]={2,4,1,23,5,76,0,43,24,65},i; \nfor(i=0;i&lt;20;i++) \n    cout&lt;&lt; a[i]&lt;&lt; endl; \nsort(a,a+20,compare);\nsort(a.begin(), a.end(), cmp) //或者</code></pre><p><strong>反转</strong>vector</p>\n<pre><code>reverse(ans.begin(), ans.end());</code></pre><p>这里是引用过去得，相当于直接改变了</p>\n<h3 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h3><p>C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了<strong>七种基本的 C++ 数据类型</strong>：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">类型</th>\n<th align=\"left\">关键字</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">布尔型</td>\n<td align=\"left\">bool</td>\n</tr>\n<tr>\n<td align=\"left\">字符型</td>\n<td align=\"left\">char</td>\n</tr>\n<tr>\n<td align=\"left\">整型</td>\n<td align=\"left\">int</td>\n</tr>\n<tr>\n<td align=\"left\">浮点型</td>\n<td align=\"left\">float</td>\n</tr>\n<tr>\n<td align=\"left\">双浮点型</td>\n<td align=\"left\">double</td>\n</tr>\n<tr>\n<td align=\"left\">无类型</td>\n<td align=\"left\">void</td>\n</tr>\n<tr>\n<td align=\"left\">宽字符型</td>\n<td align=\"left\">wchar_t</td>\n</tr>\n</tbody></table>\n<h3 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h3><p>类型还可以用关键字修饰</p>\n<ul>\n<li>signed</li>\n<li>unsigned</li>\n<li>short</li>\n<li>long</li>\n</ul>\n<p>举例：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">类型</th>\n<th align=\"left\">位</th>\n<th align=\"left\">范围</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">char</td>\n<td align=\"left\">1 个字节</td>\n<td align=\"left\">-128 到 127 或者 0 到 255</td>\n</tr>\n<tr>\n<td align=\"left\">unsigned char</td>\n<td align=\"left\">1 个字节</td>\n<td align=\"left\">0 到 255</td>\n</tr>\n<tr>\n<td align=\"left\">signed char</td>\n<td align=\"left\">1 个字节</td>\n<td align=\"left\">-128 到 127</td>\n</tr>\n<tr>\n<td align=\"left\">int</td>\n<td align=\"left\">4 个字节</td>\n<td align=\"left\">-2147483648 到 2147483647</td>\n</tr>\n<tr>\n<td align=\"left\">unsigned int</td>\n<td align=\"left\">4 个字节</td>\n<td align=\"left\">0 到 4294967295</td>\n</tr>\n<tr>\n<td align=\"left\">signed int</td>\n<td align=\"left\">4 个字节</td>\n<td align=\"left\">-2147483648 到 2147483647</td>\n</tr>\n<tr>\n<td align=\"left\">short int</td>\n<td align=\"left\">2 个字节</td>\n<td align=\"left\">-32768 到 32767</td>\n</tr>\n<tr>\n<td align=\"left\">unsigned short int</td>\n<td align=\"left\">2 个字节</td>\n<td align=\"left\">0 到 65,535</td>\n</tr>\n<tr>\n<td align=\"left\">signed short int</td>\n<td align=\"left\">2 个字节</td>\n<td align=\"left\">-32768 到 32767</td>\n</tr>\n<tr>\n<td align=\"left\">long int</td>\n<td align=\"left\">8 个字节</td>\n<td align=\"left\">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>\n</tr>\n<tr>\n<td align=\"left\">signed long int</td>\n<td align=\"left\">8 个字节</td>\n<td align=\"left\">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>\n</tr>\n<tr>\n<td align=\"left\">unsigned long int</td>\n<td align=\"left\">8 个字节</td>\n<td align=\"left\">0 到 18,446,744,073,709,551,615</td>\n</tr>\n<tr>\n<td align=\"left\">float</td>\n<td align=\"left\">4 个字节</td>\n<td align=\"left\">精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字)</td>\n</tr>\n<tr>\n<td align=\"left\">double</td>\n<td align=\"left\">8 个字节</td>\n<td align=\"left\">双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字)</td>\n</tr>\n<tr>\n<td align=\"left\">long double</td>\n<td align=\"left\">16 个字节</td>\n<td align=\"left\">长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。</td>\n</tr>\n<tr>\n<td align=\"left\">wchar_t</td>\n<td align=\"left\">2 或 4 个字节</td>\n<td align=\"left\">1 个宽字符</td>\n</tr>\n</tbody></table>\n<h3 id=\"关于-amp-amp-和-运算得优先级\"><a href=\"#关于-amp-amp-和-运算得优先级\" class=\"headerlink\" title=\"关于&amp;&amp;和||运算得优先级\"></a>关于&amp;&amp;和||运算得优先级</h3><p>要注意这里面是有着短路得运算得思路得。</p>\n<p>而且对于一个队列得判断，应该先判断这个队列是否为空，在对队列就进行引用。</p>\n<p><code>while (!working.empty() &amp;&amp; working.top().startTime &lt;= ts )</code></p>\n<h3 id=\"typedef-声明\"><a href=\"#typedef-声明\" class=\"headerlink\" title=\"typedef 声明\"></a>typedef 声明</h3><p>您可以使用 <strong>typedef</strong> 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法：</p>\n<pre><code>typedef type newname; </code></pre><h3 id=\"枚举类型\"><a href=\"#枚举类型\" class=\"headerlink\" title=\"枚举类型\"></a>枚举类型</h3><p>枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。</p>\n<p>如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓”枚举”是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。</p>\n<p>创建枚举，需要使用关键字 <strong>enum</strong>。枚举类型的一般形式为：</p>\n<pre><code>enum 枚举名{ \n     标识符[=整型常数], \n     标识符[=整型常数], \n... \n    标识符[=整型常数]\n} 枚举变量;\n</code></pre><p>如果枚举没有初始化, 即省掉”=整型常数”时, 则从第一个标识符开始。</p>\n<h3 id=\"C-中的变量声明\"><a href=\"#C-中的变量声明\" class=\"headerlink\" title=\"C++ 中的变量声明\"></a>C++ 中的变量声明</h3><p>变量声明向编译器保证变量以给定的类型和名称存在，<strong>这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译</strong>。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。</p>\n<pre><code>// 函数声明\nint func(); // 如果没有这句就会报错\n\nint main()\n{\n    // 函数调用\n    int i = func();\n}\n\n// 函数定义\nint func()\n{\n    return 0;\n}</code></pre><h3 id=\"变量作用域\"><a href=\"#变量作用域\" class=\"headerlink\" title=\"变量作用域\"></a>变量作用域</h3><p><strong>全局变量</strong></p>\n<p><strong>在所有函数外部定义的变量（通常是在程序的头部），称为全局变量</strong>。全局变量的值在程序的整个生命周期内都是有效的。</p>\n<p>全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。下面的实例使用了全局变量和局部变量：</p>\n<h3 id=\"常量-define-和-const\"><a href=\"#常量-define-和-const\" class=\"headerlink\" title=\"常量#define 和 const\"></a>常量#define 和 const</h3><p><strong>宏定义 #define 和常量 const 的区别</strong></p>\n<p><strong>类型和安全检查不同</strong></p>\n<p>宏定义是字符替换，没有数据类型的区别，同时这种替换没有类型安全检查，可能产生边际效应等错误；</p>\n<p>const常量是常量的声明，有类型区别，需要在编译阶段进行类型检查</p>\n<p><strong>编译器处理不同</strong></p>\n<p>宏定义是一个”编译时”概念，在预处理阶段展开，不能对宏定义进行调试，生命周期结束与编译时期；</p>\n<p>const常量是一个”运行时”概念，在程序运行使用，类似于一个只读行数据</p>\n<p><strong>存储方式不同</strong></p>\n<p>宏定义是直接替换，不会分配内存，存储与程序的代码段中；</p>\n<p>const常量需要进行内存分配，存储与程序的数据段中</p>\n<p><strong>定义域不同</strong></p>\n<pre><code>void f1 ()\n{\n    #define N 12\n    const int n 12;\n}\nvoid f2 ()\n{\n    cout&lt;&lt;N &lt;&lt;endl; //正确，N已经定义过，不受定义域限制\n    cout&lt;&lt;n &lt;&lt;endl; //错误，n定义域只在f1函数中\n}</code></pre><p><strong>定义后能否取消</strong></p>\n<p>宏定义可以通过#undef来使之前的宏定义失效</p>\n<p>const常量定义后将在定义域内永久有效</p>\n<h3 id=\"goto语句\"><a href=\"#goto语句\" class=\"headerlink\" title=\"goto语句\"></a>goto语句</h3><p>C++ 中 <strong>goto</strong> 语句的语法：</p>\n<pre><code>goto label;\n..\n.\nlabel: statement;</code></pre><h3 id=\"函数参数\"><a href=\"#函数参数\" class=\"headerlink\" title=\"函数参数\"></a>函数参数</h3><p>如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的<strong>形式参数</strong>。</p>\n<p>形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。</p>\n<p>当调用函数时，有三种向函数传递参数的方式：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">调用类型</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/cplusplus/cpp-function-call-by-value.html\" target=\"_blank\" rel=\"noopener\">传值调用</a></td>\n<td align=\"left\">该方法把参数的实际值赋值给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/cplusplus/cpp-function-call-by-pointer.html\" target=\"_blank\" rel=\"noopener\">指针调用</a></td>\n<td align=\"left\">该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/cplusplus/cpp-function-call-by-reference.html\" target=\"_blank\" rel=\"noopener\">引用调用</a></td>\n<td align=\"left\">该方法把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</td>\n</tr>\n</tbody></table>\n<h3 id=\"C-随机数\"><a href=\"#C-随机数\" class=\"headerlink\" title=\"C++ 随机数\"></a>C++ 随机数</h3><p>在许多情况下，需要生成随机数。关于随机数生成器，有两个相关的函数。一个是 <strong>rand()</strong>，该函数只返回一个伪随机数。生成随机数之前必须先调用 <strong>srand()</strong> 函数。</p>\n<p>下面是一个关于生成随机数的简单实例。实例中使用了 <strong>time()</strong> 函数来获取系统时间的秒数，通过调用 rand() 函数来生成随机数：</p>\n<p>实例</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;ctime&gt;\n#include &lt;cstdlib&gt;\n\nusing namespace std;\n\nint main ()\n{\n   int i,j;\n\n   // 设置种子\n   srand( (unsigned)time( NULL ) );\n\n   /* 生成 10 个随机数 */\n   for( i = 0; i &lt; 10; i++ )\n   {\n      // 生成实际的随机数\n      j= rand();\n      cout &lt;&lt;&quot;随机数： &quot; &lt;&lt; j &lt;&lt; endl;\n   }\n\n   return 0;\n}</code></pre><h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>在 C++ 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示：</p>\n<pre><code>type arrayName [ arraySize ];</code></pre><p><strong>初始化数组</strong></p>\n<pre><code>double balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0};</code></pre><p><strong>多维数组</strong></p>\n<pre><code>type name[size1][size2]...[sizeN];</code></pre><h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>这里只讲<strong>string</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">函数 &amp; 目的</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\"><strong>strcpy(s1, s2);</strong> 复制字符串 s2 到字符串 s1。</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\"><strong>strcat(s1, s2);</strong> 连接字符串 s2 到字符串 s1 的末尾。连接字符串也可以用 <strong>+</strong> 号，例如: <code>string str1 = &quot;runoob&quot;; string str2 = &quot;google&quot;; string str = str1 + str2;</code></td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\"><strong>strlen(s1);</strong> 返回字符串 s1 的长度。</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\"><strong>strcmp(s1, s2);</strong> 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回值小于 0；如果 s1&gt;s2 则返回值大于 0。</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\"><strong>strchr(s1, ch);</strong> 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\"><strong>strstr(s1, s2);</strong> 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td>\n</tr>\n</tbody></table>\n<p>注意，<strong>字符和字符串不一样</strong></p>\n<pre><code>char c = &#39;c&#39;;\nstring s= &quot;string&quot;;\nchar a = s[0];</code></pre><p>一个单引号，一个双。</p>\n<h3 id=\"字符串转换成数字\"><a href=\"#字符串转换成数字\" class=\"headerlink\" title=\"字符串转换成数字\"></a>字符串转换成数字</h3><ul>\n<li>stoi() string类型字符串转换为int</li>\n<li>stod() string类型字符串转换为double</li>\n<li>to_string() 重载方法，将一些整形，浮点型等转换为string类型字符串</li>\n</ul>\n<h3 id=\"cctype-数据类型判断\"><a href=\"#cctype-数据类型判断\" class=\"headerlink\" title=\"cctype 数据类型判断\"></a>cctype 数据类型判断</h3><ul>\n<li>isalnum() 判断一个字符是不是alphanumeric，即大小写英文字母或是数字</li>\n<li>isalpha() 判断一个字符是不是alphabetic，即英文字母</li>\n<li>isdigit() 判断一个字符是不是数字</li>\n<li>tolower() 将大写转换为小写</li>\n<li>toupper() 将小写转换为大写</li>\n</ul>\n<h3 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h3><h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p><strong>指针</strong>是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：</p>\n<pre><code>type *var-name;</code></pre><pre><code>int    *ip;    /* 一个整型的指针 */\ndouble *dp;    /* 一个 double 型的指针 */\nfloat  *fp;    /* 一个浮点型的指针 */\nchar   *ch;    /* 一个字符型的指针 */</code></pre><h4 id=\"关于-amp-和\"><a href=\"#关于-amp-和\" class=\"headerlink\" title=\"关于&amp;和*\"></a>关于&amp;和*</h4><p>符号&amp;代表取值，符号*代表解引用：</p>\n<table>\n<thead>\n<tr>\n<th>符号</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&amp;</td>\n<td>取地址</td>\n</tr>\n<tr>\n<td>*</td>\n<td>解引用</td>\n</tr>\n</tbody></table>\n<h4 id=\"指针与数组\"><a href=\"#指针与数组\" class=\"headerlink\" title=\"指针与数组\"></a><strong>指针与数组</strong></h4><p>我们知道，一维数组名本身就是一个指针</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"><span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span><span class=\"token operator\">*</span> p1 <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span><span class=\"token operator\">*</span> p2 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>arr<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span><span class=\"token operator\">*</span> p3 <span class=\"token operator\">=</span> <span class=\"token operator\">&amp;</span>arr<span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">//报错</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>在定义了指向数组首元素的指针变量后，我们可以通过这个指针变量来访问数组元素：</p>\n<pre class=\"line-numbers language-cpp\"><code class=\"language-cpp\"> <span class=\"token keyword\">int</span> arr<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">int</span><span class=\"token operator\">*</span> p1 <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">int</span> length <span class=\"token operator\">=</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token keyword\">sizeof</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">{</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> p1<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n    cout <span class=\"token operator\">&lt;&lt;</span> <span class=\"token operator\">*</span><span class=\"token punctuation\">(</span>p1 <span class=\"token operator\">+</span> i<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> endl<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p><strong>数组名作为函数传递的时候，会退化成一个指针</strong></p>\n<h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><p>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</p>\n<pre><code>实例\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main ()\n{\n   // 声明简单的变量\n   int    i;\n   double d;\n\n   // 声明引用变量\n   int&amp;    r = i;\n   double&amp; s = d;\n\n   i = 5;\n   cout &lt;&lt; &quot;Value of i : &quot; &lt;&lt; i &lt;&lt; endl;\n   cout &lt;&lt; &quot;Value of i reference : &quot; &lt;&lt; r  &lt;&lt; endl;\n\n   d = 11.7;\n   cout &lt;&lt; &quot;Value of d : &quot; &lt;&lt; d &lt;&lt; endl;\n   cout &lt;&lt; &quot;Value of d reference : &quot; &lt;&lt; s  &lt;&lt; endl;\n\n   return 0;\n}</code></pre><p>引用传递得意思。</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"C-复习\"><a href=\"#C-复习\" class=\"headerlink\" title=\"C++复习\"></a>C++复习</h1><h3 id=\"常用头文件\"><a href=\"#常用头文件\" class=\"headerlink\" title=\"常用头文件\"></a>常用头文件</h3><pre><code>#include&lt;iostream&gt; \n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;stack&gt;\n#include &lt;queue&gt;\n#include &lt;set&gt;\n#include &lt;map&gt;\n#include &lt;ctime&gt;\n#include &lt;algorithm&gt;\n#include &lt;cmath&gt;\n#include&lt;bits/stdc++.h&gt;\n\n\n\nusing namespace std;\n\n//常见常量与等价定义 \ntypedef long long int64;\ntypedef pair&lt;int, int&gt; ii;\nconst double eps = 1e-6;\nconst int INF = 1 &lt;&lt; 29;\nconst int MOD = 1e9 + 7;\nconst int MAXN = 100;</code></pre><h3 id=\"标准IO\"><a href=\"#标准IO\" class=\"headerlink\" title=\"标准IO\"></a>标准IO</h3><table>\n<thead>\n<tr>\n<th align=\"left\">头文件</th>\n<th align=\"left\">函数和描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><iostream></iostream></td>\n<td align=\"left\">该文件定义了 <strong>cin、cout、cerr</strong> 和 <strong>clog</strong> 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。</td>\n</tr>\n<tr>\n<td align=\"left\"><iomanip></iomanip></td>\n<td align=\"left\">该文件通过所谓的参数化的流操纵器（比如 <strong>setw</strong> 和 <strong>setprecision</strong>），来声明对执行标准化 I/O 有用的服务。</td>\n</tr>\n<tr>\n<td align=\"left\"><fstream></fstream></td>\n<td align=\"left\">该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。</td>\n</tr>\n</tbody></table>\n<h4 id=\"关于scanf\"><a href=\"#关于scanf\" class=\"headerlink\" title=\"关于scanf\"></a>关于scanf</h4><ul>\n<li><p>输入string</p>\n<pre><code>    char s[100100];\n\n    while(scanf(&quot;%s&quot;, s) != EOF){\n    int len = strlen(s); //#include&lt;bits/stdc++.h&gt;\n</code></pre></li>\n</ul>\n<ul>\n<li></li>\n</ul>\n<h3 id=\"STL模板\"><a href=\"#STL模板\" class=\"headerlink\" title=\"STL模板\"></a>STL模板</h3><p>C++ 标准模板库的核心包括以下三个组件：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">组件</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">容器（Containers）</td>\n<td align=\"left\">容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。</td>\n</tr>\n<tr>\n<td align=\"left\">算法（Algorithms）</td>\n<td align=\"left\">算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。</td>\n</tr>\n<tr>\n<td align=\"left\">迭代器（iterators）</td>\n<td align=\"left\">迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。</td>\n</tr>\n</tbody></table>\n<h4 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h4><p><strong>内部实现机理</strong></p>\n<ul>\n<li>map： <strong>map内部实现了一个红黑树</strong>，该结构具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素，因此，<strong>对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了map的效率。</strong></li>\n<li>unordered_map: unordered_map内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的</li>\n</ul>\n<h4 id=\"map红黑树使用\"><a href=\"#map红黑树使用\" class=\"headerlink\" title=\"map红黑树使用\"></a>map红黑树使用</h4><p><strong>存入</strong></p>\n<pre><code>map&lt;int,int&gt; count;\ncount[i]=1;</code></pre><p><strong>查找</strong></p>\n<pre><code>如果key存在，则find返回key对应的迭代器，如果key不存在，则find返回尾后迭代器 .end()。可以参考下面的示例来判断key值是否存在\n\nif (mymap.find(key) == mymap.end())\n    cout &lt;&lt; &quot;没有这个key&quot; &lt;&lt; endl;</code></pre><p><strong>统计次数</strong></p>\n<pre><code>count函数\ncount函数用于统计key值在map中出现的次数，map的key不允许重复，因此如果key存在返回1，不存在返回0\n\nif (mymap.count(key) == 0)</code></pre><p><strong>取值</strong></p>\n<p>Map中元素取值主要有at和[ ]两种操作，at会作下标检查，而[]不会。</p>\n<p><strong>删除</strong></p>\n<pre><code>// 删除迭代器指向位置的键值对，并返回一个指向下一元素的迭代器\niterator erase( iterator pos )\n\n// 删除一定范围内的元素，并返回一个指向下一元素的迭代器\niterator erase( const_iterator first, const_iterator last );\n\n// 根据Key来进行删除， 返回删除的元素数量，在map里结果非0即1\nsize_t erase( const key_type&amp; key );\n\n// 清空map，清空后的size为0\nvoid clear();</code></pre><p><strong>遍历</strong></p>\n<pre><code> map&lt;int, int&gt;::iterator iter;\n    iter = _map.begin();\n    while(iter != _map.end()) {\n        cout &lt;&lt; iter-&gt;first &lt;&lt; &quot; : &quot; &lt;&lt; iter-&gt;second &lt;&lt; endl;\n        iter++;\n    }</code></pre><h4 id=\"vector-使用\"><a href=\"#vector-使用\" class=\"headerlink\" title=\"vector 使用\"></a>vector 使用</h4><p><strong>初始化大小</strong></p>\n<pre><code>vector&lt;int&gt; ans(10,0); 10个0\nvector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中// 相当于切片</code></pre><p><strong>插入</strong></p>\n<ul>\n<li>void push_back(const T&amp; x):向量尾部增加一个元素X</li>\n<li>iterator insert(iterator it,const T&amp; x):向量中迭代器指向元素前增加一个元素x</li>\n</ul>\n<p><strong>遍历</strong></p>\n<pre><code>    cout&lt;&lt;&quot;直接利用数组：&quot;; \n    for(int i=0;i&lt;10;i++)//方法一 \n    {\n        cout&lt;&lt;obj[i]&lt;&lt;&quot; &quot;;\n    }\n\n    cout&lt;&lt;endl; \n    cout&lt;&lt;&quot;利用迭代器：&quot; ;\n    //方法二，使用迭代器将容器中数据输出 \n    vector&lt;int&gt;::iterator it;//声明一个迭代器，来访问vector容器，作用：遍历或者指向vector容器的元素 \n    for(it=obj.begin();it!=obj.end();it++)\n    {\n        cout&lt;&lt;*it&lt;&lt;&quot; &quot;;\n    }</code></pre><p><strong>删除函数</strong></p>\n<ul>\n<li><p>iterator erase(iterator it):删除向量中迭代器指向元素</p>\n</li>\n<li><p>iterator erase(iterator first,iterator last):删除向量中[first,last)中元素</p>\n</li>\n<li><p>void pop_back():删除向量中最后一个元素</p>\n</li>\n<li><p>iterator insert(iterator it,const_iterator first,const_iterator last):向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据</p>\n</li>\n</ul>\n<h4 id=\"set-库\"><a href=\"#set-库\" class=\"headerlink\" title=\"set 库\"></a>set 库</h4><p><strong>存入</strong></p>\n<pre><code>a.insert(i);</code></pre><p><strong>统计</strong></p>\n<p><strong>count()</strong> 用来查找set中某个某个键值出现的次数。这个函数在set并不是很实用，因为一个键值在set只可能出现0或1次，这样就变成了判断某一键值是否在set出现过了。</p>\n<p><strong>查找</strong></p>\n<pre><code>find()  ，返回给定值值得定位器，如果没找到则返回end()。</code></pre><p><strong>查找邻近元素</strong></p>\n<pre><code>lower_bound(key_value) ，返回第一个大于等于key_value的定位器\n\nupper_bound(key_value)，返回最后一个大于等于key_value的定位器</code></pre><p><strong>删除</strong></p>\n<pre><code>erase(iterator)  ,删除定位器iterator指向的值\n\nerase(first,second),删除定位器first和second之间的值\n\nerase(key_value),删除键值key_value的值</code></pre><h4 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h4><p>和其他序列容器相比，stack 是一类存储机制简单、所提供操作较少的容器。下面是 stack 容器可以提供的一套完整操作：</p>\n<ul>\n<li>top()：返回一个栈顶元素的引用，类型为 T&amp;。如果栈为空，返回值未定义。</li>\n<li>push(const T&amp; obj)：可以将对象副本压入栈顶。这是通过调用底层容器的 push_back() 函数完成的。</li>\n<li>push(T&amp;&amp; obj)：以移动对象的方式将对象压入栈顶。这是通过调用底层容器的有右值引用参数的 push_back() 函数完成的。</li>\n<li>pop()：弹出栈顶元素。</li>\n<li>size()：返回栈中元素的个数。</li>\n<li>empty()：在栈中没有元素的情况下返回 true。</li>\n<li>emplace()：用传入的参数调用构造函数，在栈顶生成对象。</li>\n<li>swap(stack<t> &amp; other_stack)：将当前栈中的元素和参数中的元素交换。参数所包含元素的类型必须和当前栈的相同。对于 stack 对象有一个特例化的全局函数 swap() 可以使用。</t></li>\n</ul>\n<h4 id=\"优先级队列（默认是最大堆）\"><a href=\"#优先级队列（默认是最大堆）\" class=\"headerlink\" title=\"优先级队列（默认是最大堆）\"></a>优先级队列（默认是最大堆）</h4><pre><code>#include &lt;queue&gt;</code></pre><p>具体方法</p>\n<p>和队列基本操作相同:</p>\n<ul>\n<li>top 访问队头元素</li>\n<li>empty 队列是否为空</li>\n<li>size 返回队列内元素个数</li>\n<li>push 插入元素到队尾 (并排序)</li>\n<li>emplace 原地构造一个元素并插入队列</li>\n<li>pop 弹出队头元素</li>\n<li>swap 交换内容</li>\n</ul>\n<p>定义：<code>priority_queue&lt;Type, Container, Functional&gt;</code></p>\n<p><strong>默认是最大堆</strong></p>\n<p><strong>最后一个参数是比较函数</strong></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\nusing namespace std;\n\n//方法1\nstruct tmp1 //运算符重载&lt;\n{\n    int x;\n    tmp1(int a) {x = a;}\n    bool operator&lt;(const tmp1&amp; a) const\n    {\n        return x &lt; a.x; //大顶堆\n    }\n};\n\n//方法2\nstruct tmp2 //重写仿函数\n{\n    bool operator() (tmp1 a, tmp1 b) \n    {\n        return a.x &lt; b.x; //大顶堆\n    }\n};\n\nint main() \n{\n    tmp1 a(1);\n    tmp1 b(2);\n    tmp1 c(3);\n    priority_queue&lt;tmp1&gt; d;\n    d.push(b);\n    d.push(c);\n    d.push(a);\n    while (!d.empty()) \n    {\n        cout &lt;&lt; d.top().x &lt;&lt; &#39;\\n&#39;;\n        d.pop();\n    }\n    cout &lt;&lt; endl;\n\n    priority_queue&lt;tmp1, vector&lt;tmp1&gt;, tmp2&gt; f;\n    f.push(c);\n    f.push(b);\n    f.push(a);\n    while (!f.empty()) \n    {\n        cout &lt;&lt; f.top().x &lt;&lt; &#39;\\n&#39;;\n        f.pop();\n    }\n}\n</code></pre><h3 id=\"algorithm库得方法\"><a href=\"#algorithm库得方法\" class=\"headerlink\" title=\"algorithm库得方法\"></a>algorithm库得方法</h3><p><strong>排序</strong></p>\n<pre><code>vector\nbool compare(int a,int b) \n{ \n    return a&lt; b; //升序排列，如果改为return a&gt;b，则为降序 \n} \nint a[20]={2,4,1,23,5,76,0,43,24,65},i; \nfor(i=0;i&lt;20;i++) \n    cout&lt;&lt; a[i]&lt;&lt; endl; \nsort(a,a+20,compare);\nsort(a.begin(), a.end(), cmp) //或者</code></pre><p><strong>反转</strong>vector</p>\n<pre><code>reverse(ans.begin(), ans.end());</code></pre><p>这里是引用过去得，相当于直接改变了</p>\n<h3 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h3><p>C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了<strong>七种基本的 C++ 数据类型</strong>：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">类型</th>\n<th align=\"left\">关键字</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">布尔型</td>\n<td align=\"left\">bool</td>\n</tr>\n<tr>\n<td align=\"left\">字符型</td>\n<td align=\"left\">char</td>\n</tr>\n<tr>\n<td align=\"left\">整型</td>\n<td align=\"left\">int</td>\n</tr>\n<tr>\n<td align=\"left\">浮点型</td>\n<td align=\"left\">float</td>\n</tr>\n<tr>\n<td align=\"left\">双浮点型</td>\n<td align=\"left\">double</td>\n</tr>\n<tr>\n<td align=\"left\">无类型</td>\n<td align=\"left\">void</td>\n</tr>\n<tr>\n<td align=\"left\">宽字符型</td>\n<td align=\"left\">wchar_t</td>\n</tr>\n</tbody></table>\n<h3 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h3><p>类型还可以用关键字修饰</p>\n<ul>\n<li>signed</li>\n<li>unsigned</li>\n<li>short</li>\n<li>long</li>\n</ul>\n<p>举例：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">类型</th>\n<th align=\"left\">位</th>\n<th align=\"left\">范围</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">char</td>\n<td align=\"left\">1 个字节</td>\n<td align=\"left\">-128 到 127 或者 0 到 255</td>\n</tr>\n<tr>\n<td align=\"left\">unsigned char</td>\n<td align=\"left\">1 个字节</td>\n<td align=\"left\">0 到 255</td>\n</tr>\n<tr>\n<td align=\"left\">signed char</td>\n<td align=\"left\">1 个字节</td>\n<td align=\"left\">-128 到 127</td>\n</tr>\n<tr>\n<td align=\"left\">int</td>\n<td align=\"left\">4 个字节</td>\n<td align=\"left\">-2147483648 到 2147483647</td>\n</tr>\n<tr>\n<td align=\"left\">unsigned int</td>\n<td align=\"left\">4 个字节</td>\n<td align=\"left\">0 到 4294967295</td>\n</tr>\n<tr>\n<td align=\"left\">signed int</td>\n<td align=\"left\">4 个字节</td>\n<td align=\"left\">-2147483648 到 2147483647</td>\n</tr>\n<tr>\n<td align=\"left\">short int</td>\n<td align=\"left\">2 个字节</td>\n<td align=\"left\">-32768 到 32767</td>\n</tr>\n<tr>\n<td align=\"left\">unsigned short int</td>\n<td align=\"left\">2 个字节</td>\n<td align=\"left\">0 到 65,535</td>\n</tr>\n<tr>\n<td align=\"left\">signed short int</td>\n<td align=\"left\">2 个字节</td>\n<td align=\"left\">-32768 到 32767</td>\n</tr>\n<tr>\n<td align=\"left\">long int</td>\n<td align=\"left\">8 个字节</td>\n<td align=\"left\">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>\n</tr>\n<tr>\n<td align=\"left\">signed long int</td>\n<td align=\"left\">8 个字节</td>\n<td align=\"left\">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>\n</tr>\n<tr>\n<td align=\"left\">unsigned long int</td>\n<td align=\"left\">8 个字节</td>\n<td align=\"left\">0 到 18,446,744,073,709,551,615</td>\n</tr>\n<tr>\n<td align=\"left\">float</td>\n<td align=\"left\">4 个字节</td>\n<td align=\"left\">精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字)</td>\n</tr>\n<tr>\n<td align=\"left\">double</td>\n<td align=\"left\">8 个字节</td>\n<td align=\"left\">双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字)</td>\n</tr>\n<tr>\n<td align=\"left\">long double</td>\n<td align=\"left\">16 个字节</td>\n<td align=\"left\">长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。</td>\n</tr>\n<tr>\n<td align=\"left\">wchar_t</td>\n<td align=\"left\">2 或 4 个字节</td>\n<td align=\"left\">1 个宽字符</td>\n</tr>\n</tbody></table>\n<h3 id=\"关于-amp-amp-和-运算得优先级\"><a href=\"#关于-amp-amp-和-运算得优先级\" class=\"headerlink\" title=\"关于&amp;&amp;和||运算得优先级\"></a>关于&amp;&amp;和||运算得优先级</h3><p>要注意这里面是有着短路得运算得思路得。</p>\n<p>而且对于一个队列得判断，应该先判断这个队列是否为空，在对队列就进行引用。</p>\n<p><code>while (!working.empty() &amp;&amp; working.top().startTime &lt;= ts )</code></p>\n<h3 id=\"typedef-声明\"><a href=\"#typedef-声明\" class=\"headerlink\" title=\"typedef 声明\"></a>typedef 声明</h3><p>您可以使用 <strong>typedef</strong> 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法：</p>\n<pre><code>typedef type newname; </code></pre><h3 id=\"枚举类型\"><a href=\"#枚举类型\" class=\"headerlink\" title=\"枚举类型\"></a>枚举类型</h3><p>枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。</p>\n<p>如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓”枚举”是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。</p>\n<p>创建枚举，需要使用关键字 <strong>enum</strong>。枚举类型的一般形式为：</p>\n<pre><code>enum 枚举名{ \n     标识符[=整型常数], \n     标识符[=整型常数], \n... \n    标识符[=整型常数]\n} 枚举变量;\n</code></pre><p>如果枚举没有初始化, 即省掉”=整型常数”时, 则从第一个标识符开始。</p>\n<h3 id=\"C-中的变量声明\"><a href=\"#C-中的变量声明\" class=\"headerlink\" title=\"C++ 中的变量声明\"></a>C++ 中的变量声明</h3><p>变量声明向编译器保证变量以给定的类型和名称存在，<strong>这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译</strong>。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。</p>\n<pre><code>// 函数声明\nint func(); // 如果没有这句就会报错\n\nint main()\n{\n    // 函数调用\n    int i = func();\n}\n\n// 函数定义\nint func()\n{\n    return 0;\n}</code></pre><h3 id=\"变量作用域\"><a href=\"#变量作用域\" class=\"headerlink\" title=\"变量作用域\"></a>变量作用域</h3><p><strong>全局变量</strong></p>\n<p><strong>在所有函数外部定义的变量（通常是在程序的头部），称为全局变量</strong>。全局变量的值在程序的整个生命周期内都是有效的。</p>\n<p>全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。下面的实例使用了全局变量和局部变量：</p>\n<h3 id=\"常量-define-和-const\"><a href=\"#常量-define-和-const\" class=\"headerlink\" title=\"常量#define 和 const\"></a>常量#define 和 const</h3><p><strong>宏定义 #define 和常量 const 的区别</strong></p>\n<p><strong>类型和安全检查不同</strong></p>\n<p>宏定义是字符替换，没有数据类型的区别，同时这种替换没有类型安全检查，可能产生边际效应等错误；</p>\n<p>const常量是常量的声明，有类型区别，需要在编译阶段进行类型检查</p>\n<p><strong>编译器处理不同</strong></p>\n<p>宏定义是一个”编译时”概念，在预处理阶段展开，不能对宏定义进行调试，生命周期结束与编译时期；</p>\n<p>const常量是一个”运行时”概念，在程序运行使用，类似于一个只读行数据</p>\n<p><strong>存储方式不同</strong></p>\n<p>宏定义是直接替换，不会分配内存，存储与程序的代码段中；</p>\n<p>const常量需要进行内存分配，存储与程序的数据段中</p>\n<p><strong>定义域不同</strong></p>\n<pre><code>void f1 ()\n{\n    #define N 12\n    const int n 12;\n}\nvoid f2 ()\n{\n    cout&lt;&lt;N &lt;&lt;endl; //正确，N已经定义过，不受定义域限制\n    cout&lt;&lt;n &lt;&lt;endl; //错误，n定义域只在f1函数中\n}</code></pre><p><strong>定义后能否取消</strong></p>\n<p>宏定义可以通过#undef来使之前的宏定义失效</p>\n<p>const常量定义后将在定义域内永久有效</p>\n<h3 id=\"goto语句\"><a href=\"#goto语句\" class=\"headerlink\" title=\"goto语句\"></a>goto语句</h3><p>C++ 中 <strong>goto</strong> 语句的语法：</p>\n<pre><code>goto label;\n..\n.\nlabel: statement;</code></pre><h3 id=\"函数参数\"><a href=\"#函数参数\" class=\"headerlink\" title=\"函数参数\"></a>函数参数</h3><p>如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的<strong>形式参数</strong>。</p>\n<p>形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。</p>\n<p>当调用函数时，有三种向函数传递参数的方式：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">调用类型</th>\n<th align=\"left\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/cplusplus/cpp-function-call-by-value.html\" target=\"_blank\" rel=\"noopener\">传值调用</a></td>\n<td align=\"left\">该方法把参数的实际值赋值给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/cplusplus/cpp-function-call-by-pointer.html\" target=\"_blank\" rel=\"noopener\">指针调用</a></td>\n<td align=\"left\">该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://www.runoob.com/cplusplus/cpp-function-call-by-reference.html\" target=\"_blank\" rel=\"noopener\">引用调用</a></td>\n<td align=\"left\">该方法把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。</td>\n</tr>\n</tbody></table>\n<h3 id=\"C-随机数\"><a href=\"#C-随机数\" class=\"headerlink\" title=\"C++ 随机数\"></a>C++ 随机数</h3><p>在许多情况下，需要生成随机数。关于随机数生成器，有两个相关的函数。一个是 <strong>rand()</strong>，该函数只返回一个伪随机数。生成随机数之前必须先调用 <strong>srand()</strong> 函数。</p>\n<p>下面是一个关于生成随机数的简单实例。实例中使用了 <strong>time()</strong> 函数来获取系统时间的秒数，通过调用 rand() 函数来生成随机数：</p>\n<p>实例</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;ctime&gt;\n#include &lt;cstdlib&gt;\n\nusing namespace std;\n\nint main ()\n{\n   int i,j;\n\n   // 设置种子\n   srand( (unsigned)time( NULL ) );\n\n   /* 生成 10 个随机数 */\n   for( i = 0; i &lt; 10; i++ )\n   {\n      // 生成实际的随机数\n      j= rand();\n      cout &lt;&lt;&quot;随机数： &quot; &lt;&lt; j &lt;&lt; endl;\n   }\n\n   return 0;\n}</code></pre><h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>在 C++ 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示：</p>\n<pre><code>type arrayName [ arraySize ];</code></pre><p><strong>初始化数组</strong></p>\n<pre><code>double balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0};</code></pre><p><strong>多维数组</strong></p>\n<pre><code>type name[size1][size2]...[sizeN];</code></pre><h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>这里只讲<strong>string</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">函数 &amp; 目的</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\"><strong>strcpy(s1, s2);</strong> 复制字符串 s2 到字符串 s1。</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\"><strong>strcat(s1, s2);</strong> 连接字符串 s2 到字符串 s1 的末尾。连接字符串也可以用 <strong>+</strong> 号，例如: <code>string str1 = &quot;runoob&quot;; string str2 = &quot;google&quot;; string str = str1 + str2;</code></td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\"><strong>strlen(s1);</strong> 返回字符串 s1 的长度。</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\"><strong>strcmp(s1, s2);</strong> 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回值小于 0；如果 s1&gt;s2 则返回值大于 0。</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\"><strong>strchr(s1, ch);</strong> 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\"><strong>strstr(s1, s2);</strong> 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td>\n</tr>\n</tbody></table>\n<p>注意，<strong>字符和字符串不一样</strong></p>\n<pre><code>char c = &#39;c&#39;;\nstring s= &quot;string&quot;;\nchar a = s[0];</code></pre><p>一个单引号，一个双。</p>\n<h3 id=\"字符串转换成数字\"><a href=\"#字符串转换成数字\" class=\"headerlink\" title=\"字符串转换成数字\"></a>字符串转换成数字</h3><ul>\n<li>stoi() string类型字符串转换为int</li>\n<li>stod() string类型字符串转换为double</li>\n<li>to_string() 重载方法，将一些整形，浮点型等转换为string类型字符串</li>\n</ul>\n<h3 id=\"cctype-数据类型判断\"><a href=\"#cctype-数据类型判断\" class=\"headerlink\" title=\"cctype 数据类型判断\"></a>cctype 数据类型判断</h3><ul>\n<li>isalnum() 判断一个字符是不是alphanumeric，即大小写英文字母或是数字</li>\n<li>isalpha() 判断一个字符是不是alphabetic，即英文字母</li>\n<li>isdigit() 判断一个字符是不是数字</li>\n<li>tolower() 将大写转换为小写</li>\n<li>toupper() 将小写转换为大写</li>\n</ul>\n<h3 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h3><h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p><strong>指针</strong>是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：</p>\n<pre><code>type *var-name;</code></pre><pre><code>int    *ip;    /* 一个整型的指针 */\ndouble *dp;    /* 一个 double 型的指针 */\nfloat  *fp;    /* 一个浮点型的指针 */\nchar   *ch;    /* 一个字符型的指针 */</code></pre><h4 id=\"关于-amp-和\"><a href=\"#关于-amp-和\" class=\"headerlink\" title=\"关于&amp;和*\"></a>关于&amp;和*</h4><p>符号&amp;代表取值，符号*代表解引用：</p>\n<table>\n<thead>\n<tr>\n<th>符号</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&amp;</td>\n<td>取地址</td>\n</tr>\n<tr>\n<td>*</td>\n<td>解引用</td>\n</tr>\n</tbody></table>\n<h4 id=\"指针与数组\"><a href=\"#指针与数组\" class=\"headerlink\" title=\"指针与数组\"></a><strong>指针与数组</strong></h4><p>我们知道，一维数组名本身就是一个指针</p>\n<pre><code class=\"cpp\">int arr[] = {1, 2, 3, 4, 5};\nint* p1 = arr;\nint* p2 = &amp;arr[0];\nint* p3 = &amp;arr;    //报错</code></pre>\n<p>在定义了指向数组首元素的指针变量后，我们可以通过这个指针变量来访问数组元素：</p>\n<pre><code class=\"cpp\"> int arr[] = { 1,2,3,4,5 };\n  int* p1 = arr;\n  int length = sizeof(arr) / sizeof(int);\n  for (int i = 0; i &lt; length; i++)\n  {\n    cout &lt;&lt; p1[i] &lt;&lt; endl;\n    cout &lt;&lt; *(p1 + i) &lt;&lt; endl;\n  }</code></pre>\n<p><strong>数组名作为函数传递的时候，会退化成一个指针</strong></p>\n<h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><p>引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</p>\n<pre><code>实例\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main ()\n{\n   // 声明简单的变量\n   int    i;\n   double d;\n\n   // 声明引用变量\n   int&amp;    r = i;\n   double&amp; s = d;\n\n   i = 5;\n   cout &lt;&lt; &quot;Value of i : &quot; &lt;&lt; i &lt;&lt; endl;\n   cout &lt;&lt; &quot;Value of i reference : &quot; &lt;&lt; r  &lt;&lt; endl;\n\n   d = 11.7;\n   cout &lt;&lt; &quot;Value of d : &quot; &lt;&lt; d &lt;&lt; endl;\n   cout &lt;&lt; &quot;Value of d reference : &quot; &lt;&lt; s  &lt;&lt; endl;\n\n   return 0;\n}</code></pre><p>引用传递得意思。</p>\n"},{"_content":"# 常见连接服务器方式\n\n## 密码\n\n输入密码连接，符合直觉高效。\n\n缺点：不安全，尤其是一些弱密码\n\n\n\n## 秘钥登录服务器\n\n生成秘钥\n\n```\nssh-keygen\n```\n\n![image-20230113162239303](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/691a708e850e02dce427debbb2f5a7fe/b7ea389ea57bcd57b016567deeb9676e.png)\n\n将公钥添加到服务器的某个账户上，然后在客户端利用私钥即可完成认证并登录。这样一来，没有私钥，任何人都无法通过 SSH 暴力破解你的密码来远程登录到系统\n\n其中\n\nid_rsa：是访问本地端的私钥\n\nid_rsa.pub：是放在服务器端的公钥\n\n\n\n\n\n### 设置 SSH，打开密钥登录功能\n\n将公钥放入服务器\n\n**直接将id_rsa.pub里面的东西复制到另一台的$USER/.ssh/authorized_keys里面**\n\n\n\n\n\n编辑 /etc/ssh/sshd_config 文件，进行如下设置：\n\n```\nRSAAuthentication yes\nPubkeyAuthentication yes\n```\n\n另外，请留意 root 用户能否通过 SSH 登录：\n\n```\nPermitRootLogin yes\n```\n\n当你完成全部设置，并以密钥方式登录成功后，再禁用密码登录：(可以同时开启秘钥登录和密码登录)\n\n```\nPasswordAuthentication no\n```\n\n最后，重启 SSH 服务：\n\n```\nservice sshd restart\n```\n\n\n\n\n\n## vscode配置本地秘钥登录\n\n```\nHost gpu2.csubot.cn\n  HostName gpu2.csubot.cn\n  User liuwenlong\n  IdentityFile /Users/lwl/.ssh/id_rsa\n```\n\n","source":"_posts/服务器相关/ssh连接服务器.md","raw":"# 常见连接服务器方式\n\n## 密码\n\n输入密码连接，符合直觉高效。\n\n缺点：不安全，尤其是一些弱密码\n\n\n\n## 秘钥登录服务器\n\n生成秘钥\n\n```\nssh-keygen\n```\n\n![image-20230113162239303](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/691a708e850e02dce427debbb2f5a7fe/b7ea389ea57bcd57b016567deeb9676e.png)\n\n将公钥添加到服务器的某个账户上，然后在客户端利用私钥即可完成认证并登录。这样一来，没有私钥，任何人都无法通过 SSH 暴力破解你的密码来远程登录到系统\n\n其中\n\nid_rsa：是访问本地端的私钥\n\nid_rsa.pub：是放在服务器端的公钥\n\n\n\n\n\n### 设置 SSH，打开密钥登录功能\n\n将公钥放入服务器\n\n**直接将id_rsa.pub里面的东西复制到另一台的$USER/.ssh/authorized_keys里面**\n\n\n\n\n\n编辑 /etc/ssh/sshd_config 文件，进行如下设置：\n\n```\nRSAAuthentication yes\nPubkeyAuthentication yes\n```\n\n另外，请留意 root 用户能否通过 SSH 登录：\n\n```\nPermitRootLogin yes\n```\n\n当你完成全部设置，并以密钥方式登录成功后，再禁用密码登录：(可以同时开启秘钥登录和密码登录)\n\n```\nPasswordAuthentication no\n```\n\n最后，重启 SSH 服务：\n\n```\nservice sshd restart\n```\n\n\n\n\n\n## vscode配置本地秘钥登录\n\n```\nHost gpu2.csubot.cn\n  HostName gpu2.csubot.cn\n  User liuwenlong\n  IdentityFile /Users/lwl/.ssh/id_rsa\n```\n\n","slug":"服务器相关/ssh连接服务器","published":1,"date":"2023-02-27T11:33:23.587Z","updated":"2023-02-27T11:34:33.146Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsycf001e0gcnl237cplh","content":"<h1 id=\"常见连接服务器方式\"><a href=\"#常见连接服务器方式\" class=\"headerlink\" title=\"常见连接服务器方式\"></a>常见连接服务器方式</h1><h2 id=\"密码\"><a href=\"#密码\" class=\"headerlink\" title=\"密码\"></a>密码</h2><p>输入密码连接，符合直觉高效。</p>\n<p>缺点：不安全，尤其是一些弱密码</p>\n<h2 id=\"秘钥登录服务器\"><a href=\"#秘钥登录服务器\" class=\"headerlink\" title=\"秘钥登录服务器\"></a>秘钥登录服务器</h2><p>生成秘钥</p>\n<pre><code>ssh-keygen</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/691a708e850e02dce427debbb2f5a7fe/b7ea389ea57bcd57b016567deeb9676e.png\" alt=\"image-20230113162239303\"></p>\n<p>将公钥添加到服务器的某个账户上，然后在客户端利用私钥即可完成认证并登录。这样一来，没有私钥，任何人都无法通过 SSH 暴力破解你的密码来远程登录到系统</p>\n<p>其中</p>\n<p>id_rsa：是访问本地端的私钥</p>\n<p>id_rsa.pub：是放在服务器端的公钥</p>\n<h3 id=\"设置-SSH，打开密钥登录功能\"><a href=\"#设置-SSH，打开密钥登录功能\" class=\"headerlink\" title=\"设置 SSH，打开密钥登录功能\"></a>设置 SSH，打开密钥登录功能</h3><p>将公钥放入服务器</p>\n<p><strong>直接将id_rsa.pub里面的东西复制到另一台的$USER/.ssh/authorized_keys里面</strong></p>\n<p>编辑 /etc/ssh/sshd_config 文件，进行如下设置：</p>\n<pre><code>RSAAuthentication yes\nPubkeyAuthentication yes</code></pre><p>另外，请留意 root 用户能否通过 SSH 登录：</p>\n<pre><code>PermitRootLogin yes</code></pre><p>当你完成全部设置，并以密钥方式登录成功后，再禁用密码登录：(可以同时开启秘钥登录和密码登录)</p>\n<pre><code>PasswordAuthentication no</code></pre><p>最后，重启 SSH 服务：</p>\n<pre><code>service sshd restart</code></pre><h2 id=\"vscode配置本地秘钥登录\"><a href=\"#vscode配置本地秘钥登录\" class=\"headerlink\" title=\"vscode配置本地秘钥登录\"></a>vscode配置本地秘钥登录</h2><pre><code>Host gpu2.csubot.cn\n  HostName gpu2.csubot.cn\n  User liuwenlong\n  IdentityFile /Users/lwl/.ssh/id_rsa</code></pre>","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"常见连接服务器方式\"><a href=\"#常见连接服务器方式\" class=\"headerlink\" title=\"常见连接服务器方式\"></a>常见连接服务器方式</h1><h2 id=\"密码\"><a href=\"#密码\" class=\"headerlink\" title=\"密码\"></a>密码</h2><p>输入密码连接，符合直觉高效。</p>\n<p>缺点：不安全，尤其是一些弱密码</p>\n<h2 id=\"秘钥登录服务器\"><a href=\"#秘钥登录服务器\" class=\"headerlink\" title=\"秘钥登录服务器\"></a>秘钥登录服务器</h2><p>生成秘钥</p>\n<pre><code>ssh-keygen</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/691a708e850e02dce427debbb2f5a7fe/b7ea389ea57bcd57b016567deeb9676e.png\" alt=\"image-20230113162239303\"></p>\n<p>将公钥添加到服务器的某个账户上，然后在客户端利用私钥即可完成认证并登录。这样一来，没有私钥，任何人都无法通过 SSH 暴力破解你的密码来远程登录到系统</p>\n<p>其中</p>\n<p>id_rsa：是访问本地端的私钥</p>\n<p>id_rsa.pub：是放在服务器端的公钥</p>\n<h3 id=\"设置-SSH，打开密钥登录功能\"><a href=\"#设置-SSH，打开密钥登录功能\" class=\"headerlink\" title=\"设置 SSH，打开密钥登录功能\"></a>设置 SSH，打开密钥登录功能</h3><p>将公钥放入服务器</p>\n<p><strong>直接将id_rsa.pub里面的东西复制到另一台的$USER/.ssh/authorized_keys里面</strong></p>\n<p>编辑 /etc/ssh/sshd_config 文件，进行如下设置：</p>\n<pre><code>RSAAuthentication yes\nPubkeyAuthentication yes</code></pre><p>另外，请留意 root 用户能否通过 SSH 登录：</p>\n<pre><code>PermitRootLogin yes</code></pre><p>当你完成全部设置，并以密钥方式登录成功后，再禁用密码登录：(可以同时开启秘钥登录和密码登录)</p>\n<pre><code>PasswordAuthentication no</code></pre><p>最后，重启 SSH 服务：</p>\n<pre><code>service sshd restart</code></pre><h2 id=\"vscode配置本地秘钥登录\"><a href=\"#vscode配置本地秘钥登录\" class=\"headerlink\" title=\"vscode配置本地秘钥登录\"></a>vscode配置本地秘钥登录</h2><pre><code>Host gpu2.csubot.cn\n  HostName gpu2.csubot.cn\n  User liuwenlong\n  IdentityFile /Users/lwl/.ssh/id_rsa</code></pre>"},{"_content":"# echarts 网络图的绘制\n\n文档与相关资源\n[官方的文档](https://github.com/pyecharts/pyecharts-gallery)\n[官方样例网站](https://echarts.apache.org/examples/en/index.html#chart-type-graph)\n[不错的教程](https://blog.csdn.net/LSGO_MYP/article/details/117463653)\n\n\n[数据](https://echarts.apache.org/examples/data/asset/data/)\n\n## 基本demo\n\n代码,这里是指输入到jupyter中的输出框中\n```\nfrom pyecharts import options as opts\nfrom pyecharts.charts import Graph\nfrom pyecharts.globals import CurrentConfig, NotebookType\nCurrentConfig.NOTEBOOK_TYPE = NotebookType.JUPYTER_NOTEBOOK # 不能省略，解决依赖问题\n\nnodes = [\n    opts.GraphNode(name=\"结点1\", symbol_size=10),\n    opts.GraphNode(name=\"结点2\", symbol_size=20),\n    opts.GraphNode(name=\"结点3\", symbol_size=30),\n    opts.GraphNode(name=\"结点4\", symbol_size=40),\n    opts.GraphNode(name=\"结点5\", symbol_size=50),\n]\nlinks = [\n    opts.GraphLink(source=\"结点1\", target=\"结点2\", value=2, linestyle_opts=opts.LineStyleOpts(width=2),),\n    opts.GraphLink(source=\"结点2\", target=\"结点3\", value=3, linestyle_opts=opts.LineStyleOpts(width=3),),\n    opts.GraphLink(source=\"结点3\", target=\"结点4\", value=4, linestyle_opts=opts.LineStyleOpts(width=4),),\n    opts.GraphLink(source=\"结点4\", target=\"结点5\", value=5, linestyle_opts=opts.LineStyleOpts(width=5)),\n    opts.GraphLink(source=\"结点5\", target=\"结点3\", value=6, linestyle_opts=opts.LineStyleOpts(width=6)),\n]\nc = (\n    Graph()\n    .add(\"\", nodes, links, repulsion=4000,\n         edge_label=opts.LabelOpts(is_show=True,position=\"middle\",formatter=\"{c}\")\n         )\n    .set_global_opts(title_opts=opts.TitleOpts(title=\"Graph-GraphNode-GraphLink\"))\n)\n\nc.render_notebook()\n```\n结果\n\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/74d9467d0f68679807eade1929f22c8e/d7394b4a8be8595f7371311cdbcd4ea3.png)\n\n## 各种属性设置\n\n上面demo中的add函数可以更改以下属性\n```\ndef add(\n    # 系列名称，用于 tooltip 的显示，legend 的图例筛选。\n    series_name: str,\n\n    # 关系图节点数据项列表，参考 `opts.GraphNode`\n    nodes: Sequence[Union[opts.GraphNode, dict]],\n\n    # 关系图节点间关系数据项列表，参考 `opts.GraphLink`\n    links: Sequence[Union[opts.GraphLink, dict]],\n\n    # 关系图节点分类的类目列表，参考 `opts.GraphCategory`\n    categories: Union[Sequence[Union[opts.GraphCategory, dict]], None] = None,\n\n    # 是否选中图例。\n    is_selected: bool = True,\n\n    # 是否在鼠标移到节点上的时候突出显示节点以及节点的边和邻接节点。\n    is_focusnode: bool = True,\n\n    # 是否开启鼠标缩放和平移漫游。\n    is_roam: bool = True,\n\n    # 节点是否可拖拽，只在使用力引导布局的时候有用。\n    is_draggable: bool = False,\n\n    # 是否旋转标签，默认不旋转。\n    is_rotate_label: bool = False,\n\n    # 图的布局。可选：\n    # 'none' 不采用任何布局，使用节点中提供的 x， y 作为节点的位置。\n    # 'circular' 采用环形布局。\n    # 'force' 采用力引导布局。\n    layout: str = \"force\",\n\n    # 关系图节点标记的图形。\n    # ECharts 提供的标记类型包括 'circle', 'rect', 'roundRect', 'triangle', \n    # 'diamond', 'pin', 'arrow', 'none'\n    # 可以通过 'image://url' 设置为图片，其中 URL 为图片的链接，或者 dataURI。\n    symbol: Optional[str] = None,\n\n    # 关系图节点标记的大小\n    # 可以设置成诸如 10 这样单一的数字\n    # 也可以用数组分开表示宽和高，例如 [20, 10] 表示标记宽为20，高为10。\n    symbol_size: types.Numeric = 10,\n\n    # 边的两个节点之间的距离，这个距离也会受 repulsion。\n    # 支持设置成数组表达边长的范围，此时不同大小的值会线性映射到不同的长度。值越小则长度越长。\n    edge_length: Numeric = 50,\n\n    # 节点受到的向中心的引力因子。该值越大节点越往中心点靠拢。\n    gravity: Numeric = 0.2,\n\n    # 节点之间的斥力因子。\n    # 支持设置成数组表达斥力的范围，此时不同大小的值会线性映射到不同的斥力。值越大则斥力越大\n    repulsion: Numeric = 50,\n\n     # Graph 图节点边的 Label 配置（即在边上显示数据或标注的配置）\n    edge_label: types.Label = None,\n\n    # 边两端的标记类型，可以是一个数组分别指定两端，也可以是单个统一指定。\n    # 默认不显示标记，常见的可以设置为箭头，如下：edgeSymbol: ['circle', 'arrow']\n    edge_symbol: Optional[str] = None,\n\n    # 边两端的标记大小，可以是一个数组分别指定两端，也可以是单个统一指定。\n    edge_symbol_size: Numeric = 10,\n\n    # 标签配置项，参考 `series_options.LabelOpts`\n    label_opts: Union[opts.LabelOpts, dict] = opts.LabelOpts(),\n\n    # 关系边的公用线条样式。\n    linestyle_opts: Union[opts.LineStyleOpts, dict] = opts.LineStyleOpts(),\n\n    # 提示框组件配置项，参考 `series_options.TooltipOpts`\n    tooltip_opts: Union[opts.TooltipOpts, dict, None] = None,\n\n    # 图元样式配置项，参考 `series_options.ItemStyleOpts`\n    itemstyle_opts: Union[opts.ItemStyleOpts, dict, None] = None,\n)\n\n```\n\n### 节点属性设置\n在添加的时候可以设置\n```\nnodes = [\n    opts.GraphNode(\n        name= node['name'],\n        symbol_size=10, # 节点的显示大小\n        value=20, #节点值，点击节点就会显示\n        category=node['category'], # 种类\n        x,y#属性只有在特定的layout下才能生效\n    )\n    for node in data['nodes']\n]\n```\n节点的颜色可以用种类的不同区分，不同的种类会自动分配不同颜色。\n\n### 边的属性设置\n边的属性设置如下\n```\nlinks = [\n    opts.GraphLink(\n        source=edge['source'],\n        target=edge['target'],\n        value=10,# 设置线的值\n        #设置线的宽度和曲度\n        linestyle_opts=opts.LineStyleOpts(width=1, curve=0.2)\n    )\n    for edge in data['links']\n]\n```\n\n### label开启标签显示\n在add函数中显示\n```\n点的label\nlabel_opts=opts.LabelOpts(is_show=True),\n\n# 边的label\nedge_label=opts.LabelOpts(is_show=True, position='middle', formatter='{b}的数据{c}')\n\n```\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/74d9467d0f68679807eade1929f22c8e/7809717571c0f8d65568ac57726720ef.png)\n\n\n### 显示侧边种类\n```\nG.set_global_opts(\n    legend_opts=opts.LegendOpts(is_show=True,orient='vertical', pos_left='2%', pos_top='20%')\n\n)\n```\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/74d9467d0f68679807eade1929f22c8e/f804ceb357d17ee616fc07a180a815ca.png)\n\n\n### 重力的设置\n重力是控制所有的节点向中心聚集的引力\n\n默认是0.2，我们改成1\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/74d9467d0f68679807eade1929f22c8e/bbf3e9748703343c0d30120b442b0c18.png)\n\n### 关于斥力的设置\nrepulsion=50：节点之间的斥力因子，支持设置成数组表达斥力的范围，此时不同大小的值会线性映射到不同的斥力。值越大则斥力越大\n\n","source":"_posts/综合/echarts 网络图的绘制.md","raw":"# echarts 网络图的绘制\n\n文档与相关资源\n[官方的文档](https://github.com/pyecharts/pyecharts-gallery)\n[官方样例网站](https://echarts.apache.org/examples/en/index.html#chart-type-graph)\n[不错的教程](https://blog.csdn.net/LSGO_MYP/article/details/117463653)\n\n\n[数据](https://echarts.apache.org/examples/data/asset/data/)\n\n## 基本demo\n\n代码,这里是指输入到jupyter中的输出框中\n```\nfrom pyecharts import options as opts\nfrom pyecharts.charts import Graph\nfrom pyecharts.globals import CurrentConfig, NotebookType\nCurrentConfig.NOTEBOOK_TYPE = NotebookType.JUPYTER_NOTEBOOK # 不能省略，解决依赖问题\n\nnodes = [\n    opts.GraphNode(name=\"结点1\", symbol_size=10),\n    opts.GraphNode(name=\"结点2\", symbol_size=20),\n    opts.GraphNode(name=\"结点3\", symbol_size=30),\n    opts.GraphNode(name=\"结点4\", symbol_size=40),\n    opts.GraphNode(name=\"结点5\", symbol_size=50),\n]\nlinks = [\n    opts.GraphLink(source=\"结点1\", target=\"结点2\", value=2, linestyle_opts=opts.LineStyleOpts(width=2),),\n    opts.GraphLink(source=\"结点2\", target=\"结点3\", value=3, linestyle_opts=opts.LineStyleOpts(width=3),),\n    opts.GraphLink(source=\"结点3\", target=\"结点4\", value=4, linestyle_opts=opts.LineStyleOpts(width=4),),\n    opts.GraphLink(source=\"结点4\", target=\"结点5\", value=5, linestyle_opts=opts.LineStyleOpts(width=5)),\n    opts.GraphLink(source=\"结点5\", target=\"结点3\", value=6, linestyle_opts=opts.LineStyleOpts(width=6)),\n]\nc = (\n    Graph()\n    .add(\"\", nodes, links, repulsion=4000,\n         edge_label=opts.LabelOpts(is_show=True,position=\"middle\",formatter=\"{c}\")\n         )\n    .set_global_opts(title_opts=opts.TitleOpts(title=\"Graph-GraphNode-GraphLink\"))\n)\n\nc.render_notebook()\n```\n结果\n\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/74d9467d0f68679807eade1929f22c8e/d7394b4a8be8595f7371311cdbcd4ea3.png)\n\n## 各种属性设置\n\n上面demo中的add函数可以更改以下属性\n```\ndef add(\n    # 系列名称，用于 tooltip 的显示，legend 的图例筛选。\n    series_name: str,\n\n    # 关系图节点数据项列表，参考 `opts.GraphNode`\n    nodes: Sequence[Union[opts.GraphNode, dict]],\n\n    # 关系图节点间关系数据项列表，参考 `opts.GraphLink`\n    links: Sequence[Union[opts.GraphLink, dict]],\n\n    # 关系图节点分类的类目列表，参考 `opts.GraphCategory`\n    categories: Union[Sequence[Union[opts.GraphCategory, dict]], None] = None,\n\n    # 是否选中图例。\n    is_selected: bool = True,\n\n    # 是否在鼠标移到节点上的时候突出显示节点以及节点的边和邻接节点。\n    is_focusnode: bool = True,\n\n    # 是否开启鼠标缩放和平移漫游。\n    is_roam: bool = True,\n\n    # 节点是否可拖拽，只在使用力引导布局的时候有用。\n    is_draggable: bool = False,\n\n    # 是否旋转标签，默认不旋转。\n    is_rotate_label: bool = False,\n\n    # 图的布局。可选：\n    # 'none' 不采用任何布局，使用节点中提供的 x， y 作为节点的位置。\n    # 'circular' 采用环形布局。\n    # 'force' 采用力引导布局。\n    layout: str = \"force\",\n\n    # 关系图节点标记的图形。\n    # ECharts 提供的标记类型包括 'circle', 'rect', 'roundRect', 'triangle', \n    # 'diamond', 'pin', 'arrow', 'none'\n    # 可以通过 'image://url' 设置为图片，其中 URL 为图片的链接，或者 dataURI。\n    symbol: Optional[str] = None,\n\n    # 关系图节点标记的大小\n    # 可以设置成诸如 10 这样单一的数字\n    # 也可以用数组分开表示宽和高，例如 [20, 10] 表示标记宽为20，高为10。\n    symbol_size: types.Numeric = 10,\n\n    # 边的两个节点之间的距离，这个距离也会受 repulsion。\n    # 支持设置成数组表达边长的范围，此时不同大小的值会线性映射到不同的长度。值越小则长度越长。\n    edge_length: Numeric = 50,\n\n    # 节点受到的向中心的引力因子。该值越大节点越往中心点靠拢。\n    gravity: Numeric = 0.2,\n\n    # 节点之间的斥力因子。\n    # 支持设置成数组表达斥力的范围，此时不同大小的值会线性映射到不同的斥力。值越大则斥力越大\n    repulsion: Numeric = 50,\n\n     # Graph 图节点边的 Label 配置（即在边上显示数据或标注的配置）\n    edge_label: types.Label = None,\n\n    # 边两端的标记类型，可以是一个数组分别指定两端，也可以是单个统一指定。\n    # 默认不显示标记，常见的可以设置为箭头，如下：edgeSymbol: ['circle', 'arrow']\n    edge_symbol: Optional[str] = None,\n\n    # 边两端的标记大小，可以是一个数组分别指定两端，也可以是单个统一指定。\n    edge_symbol_size: Numeric = 10,\n\n    # 标签配置项，参考 `series_options.LabelOpts`\n    label_opts: Union[opts.LabelOpts, dict] = opts.LabelOpts(),\n\n    # 关系边的公用线条样式。\n    linestyle_opts: Union[opts.LineStyleOpts, dict] = opts.LineStyleOpts(),\n\n    # 提示框组件配置项，参考 `series_options.TooltipOpts`\n    tooltip_opts: Union[opts.TooltipOpts, dict, None] = None,\n\n    # 图元样式配置项，参考 `series_options.ItemStyleOpts`\n    itemstyle_opts: Union[opts.ItemStyleOpts, dict, None] = None,\n)\n\n```\n\n### 节点属性设置\n在添加的时候可以设置\n```\nnodes = [\n    opts.GraphNode(\n        name= node['name'],\n        symbol_size=10, # 节点的显示大小\n        value=20, #节点值，点击节点就会显示\n        category=node['category'], # 种类\n        x,y#属性只有在特定的layout下才能生效\n    )\n    for node in data['nodes']\n]\n```\n节点的颜色可以用种类的不同区分，不同的种类会自动分配不同颜色。\n\n### 边的属性设置\n边的属性设置如下\n```\nlinks = [\n    opts.GraphLink(\n        source=edge['source'],\n        target=edge['target'],\n        value=10,# 设置线的值\n        #设置线的宽度和曲度\n        linestyle_opts=opts.LineStyleOpts(width=1, curve=0.2)\n    )\n    for edge in data['links']\n]\n```\n\n### label开启标签显示\n在add函数中显示\n```\n点的label\nlabel_opts=opts.LabelOpts(is_show=True),\n\n# 边的label\nedge_label=opts.LabelOpts(is_show=True, position='middle', formatter='{b}的数据{c}')\n\n```\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/74d9467d0f68679807eade1929f22c8e/7809717571c0f8d65568ac57726720ef.png)\n\n\n### 显示侧边种类\n```\nG.set_global_opts(\n    legend_opts=opts.LegendOpts(is_show=True,orient='vertical', pos_left='2%', pos_top='20%')\n\n)\n```\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/74d9467d0f68679807eade1929f22c8e/f804ceb357d17ee616fc07a180a815ca.png)\n\n\n### 重力的设置\n重力是控制所有的节点向中心聚集的引力\n\n默认是0.2，我们改成1\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/74d9467d0f68679807eade1929f22c8e/bbf3e9748703343c0d30120b442b0c18.png)\n\n### 关于斥力的设置\nrepulsion=50：节点之间的斥力因子，支持设置成数组表达斥力的范围，此时不同大小的值会线性映射到不同的斥力。值越大则斥力越大\n\n","slug":"综合/echarts 网络图的绘制","published":1,"date":"2023-02-26T15:28:35.059Z","updated":"2023-02-27T11:34:33.139Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsycf001f0gcnwthebjen","content":"<h1 id=\"echarts-网络图的绘制\"><a href=\"#echarts-网络图的绘制\" class=\"headerlink\" title=\"echarts 网络图的绘制\"></a>echarts 网络图的绘制</h1><p>文档与相关资源<br><a href=\"https://github.com/pyecharts/pyecharts-gallery\" target=\"_blank\" rel=\"noopener\">官方的文档</a><br><a href=\"https://echarts.apache.org/examples/en/index.html#chart-type-graph\" target=\"_blank\" rel=\"noopener\">官方样例网站</a><br><a href=\"https://blog.csdn.net/LSGO_MYP/article/details/117463653\" target=\"_blank\" rel=\"noopener\">不错的教程</a></p>\n<p><a href=\"https://echarts.apache.org/examples/data/asset/data/\" target=\"_blank\" rel=\"noopener\">数据</a></p>\n<h2 id=\"基本demo\"><a href=\"#基本demo\" class=\"headerlink\" title=\"基本demo\"></a>基本demo</h2><p>代码,这里是指输入到jupyter中的输出框中</p>\n<pre><code>from pyecharts import options as opts\nfrom pyecharts.charts import Graph\nfrom pyecharts.globals import CurrentConfig, NotebookType\nCurrentConfig.NOTEBOOK_TYPE = NotebookType.JUPYTER_NOTEBOOK # 不能省略，解决依赖问题\n\nnodes = [\n    opts.GraphNode(name=&quot;结点1&quot;, symbol_size=10),\n    opts.GraphNode(name=&quot;结点2&quot;, symbol_size=20),\n    opts.GraphNode(name=&quot;结点3&quot;, symbol_size=30),\n    opts.GraphNode(name=&quot;结点4&quot;, symbol_size=40),\n    opts.GraphNode(name=&quot;结点5&quot;, symbol_size=50),\n]\nlinks = [\n    opts.GraphLink(source=&quot;结点1&quot;, target=&quot;结点2&quot;, value=2, linestyle_opts=opts.LineStyleOpts(width=2),),\n    opts.GraphLink(source=&quot;结点2&quot;, target=&quot;结点3&quot;, value=3, linestyle_opts=opts.LineStyleOpts(width=3),),\n    opts.GraphLink(source=&quot;结点3&quot;, target=&quot;结点4&quot;, value=4, linestyle_opts=opts.LineStyleOpts(width=4),),\n    opts.GraphLink(source=&quot;结点4&quot;, target=&quot;结点5&quot;, value=5, linestyle_opts=opts.LineStyleOpts(width=5)),\n    opts.GraphLink(source=&quot;结点5&quot;, target=&quot;结点3&quot;, value=6, linestyle_opts=opts.LineStyleOpts(width=6)),\n]\nc = (\n    Graph()\n    .add(&quot;&quot;, nodes, links, repulsion=4000,\n         edge_label=opts.LabelOpts(is_show=True,position=&quot;middle&quot;,formatter=&quot;{c}&quot;)\n         )\n    .set_global_opts(title_opts=opts.TitleOpts(title=&quot;Graph-GraphNode-GraphLink&quot;))\n)\n\nc.render_notebook()</code></pre><p>结果</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/74d9467d0f68679807eade1929f22c8e/d7394b4a8be8595f7371311cdbcd4ea3.png\" alt></p>\n<h2 id=\"各种属性设置\"><a href=\"#各种属性设置\" class=\"headerlink\" title=\"各种属性设置\"></a>各种属性设置</h2><p>上面demo中的add函数可以更改以下属性</p>\n<pre><code>def add(\n    # 系列名称，用于 tooltip 的显示，legend 的图例筛选。\n    series_name: str,\n\n    # 关系图节点数据项列表，参考 `opts.GraphNode`\n    nodes: Sequence[Union[opts.GraphNode, dict]],\n\n    # 关系图节点间关系数据项列表，参考 `opts.GraphLink`\n    links: Sequence[Union[opts.GraphLink, dict]],\n\n    # 关系图节点分类的类目列表，参考 `opts.GraphCategory`\n    categories: Union[Sequence[Union[opts.GraphCategory, dict]], None] = None,\n\n    # 是否选中图例。\n    is_selected: bool = True,\n\n    # 是否在鼠标移到节点上的时候突出显示节点以及节点的边和邻接节点。\n    is_focusnode: bool = True,\n\n    # 是否开启鼠标缩放和平移漫游。\n    is_roam: bool = True,\n\n    # 节点是否可拖拽，只在使用力引导布局的时候有用。\n    is_draggable: bool = False,\n\n    # 是否旋转标签，默认不旋转。\n    is_rotate_label: bool = False,\n\n    # 图的布局。可选：\n    # &#39;none&#39; 不采用任何布局，使用节点中提供的 x， y 作为节点的位置。\n    # &#39;circular&#39; 采用环形布局。\n    # &#39;force&#39; 采用力引导布局。\n    layout: str = &quot;force&quot;,\n\n    # 关系图节点标记的图形。\n    # ECharts 提供的标记类型包括 &#39;circle&#39;, &#39;rect&#39;, &#39;roundRect&#39;, &#39;triangle&#39;, \n    # &#39;diamond&#39;, &#39;pin&#39;, &#39;arrow&#39;, &#39;none&#39;\n    # 可以通过 &#39;image://url&#39; 设置为图片，其中 URL 为图片的链接，或者 dataURI。\n    symbol: Optional[str] = None,\n\n    # 关系图节点标记的大小\n    # 可以设置成诸如 10 这样单一的数字\n    # 也可以用数组分开表示宽和高，例如 [20, 10] 表示标记宽为20，高为10。\n    symbol_size: types.Numeric = 10,\n\n    # 边的两个节点之间的距离，这个距离也会受 repulsion。\n    # 支持设置成数组表达边长的范围，此时不同大小的值会线性映射到不同的长度。值越小则长度越长。\n    edge_length: Numeric = 50,\n\n    # 节点受到的向中心的引力因子。该值越大节点越往中心点靠拢。\n    gravity: Numeric = 0.2,\n\n    # 节点之间的斥力因子。\n    # 支持设置成数组表达斥力的范围，此时不同大小的值会线性映射到不同的斥力。值越大则斥力越大\n    repulsion: Numeric = 50,\n\n     # Graph 图节点边的 Label 配置（即在边上显示数据或标注的配置）\n    edge_label: types.Label = None,\n\n    # 边两端的标记类型，可以是一个数组分别指定两端，也可以是单个统一指定。\n    # 默认不显示标记，常见的可以设置为箭头，如下：edgeSymbol: [&#39;circle&#39;, &#39;arrow&#39;]\n    edge_symbol: Optional[str] = None,\n\n    # 边两端的标记大小，可以是一个数组分别指定两端，也可以是单个统一指定。\n    edge_symbol_size: Numeric = 10,\n\n    # 标签配置项，参考 `series_options.LabelOpts`\n    label_opts: Union[opts.LabelOpts, dict] = opts.LabelOpts(),\n\n    # 关系边的公用线条样式。\n    linestyle_opts: Union[opts.LineStyleOpts, dict] = opts.LineStyleOpts(),\n\n    # 提示框组件配置项，参考 `series_options.TooltipOpts`\n    tooltip_opts: Union[opts.TooltipOpts, dict, None] = None,\n\n    # 图元样式配置项，参考 `series_options.ItemStyleOpts`\n    itemstyle_opts: Union[opts.ItemStyleOpts, dict, None] = None,\n)\n</code></pre><h3 id=\"节点属性设置\"><a href=\"#节点属性设置\" class=\"headerlink\" title=\"节点属性设置\"></a>节点属性设置</h3><p>在添加的时候可以设置</p>\n<pre><code>nodes = [\n    opts.GraphNode(\n        name= node[&#39;name&#39;],\n        symbol_size=10, # 节点的显示大小\n        value=20, #节点值，点击节点就会显示\n        category=node[&#39;category&#39;], # 种类\n        x,y#属性只有在特定的layout下才能生效\n    )\n    for node in data[&#39;nodes&#39;]\n]</code></pre><p>节点的颜色可以用种类的不同区分，不同的种类会自动分配不同颜色。</p>\n<h3 id=\"边的属性设置\"><a href=\"#边的属性设置\" class=\"headerlink\" title=\"边的属性设置\"></a>边的属性设置</h3><p>边的属性设置如下</p>\n<pre><code>links = [\n    opts.GraphLink(\n        source=edge[&#39;source&#39;],\n        target=edge[&#39;target&#39;],\n        value=10,# 设置线的值\n        #设置线的宽度和曲度\n        linestyle_opts=opts.LineStyleOpts(width=1, curve=0.2)\n    )\n    for edge in data[&#39;links&#39;]\n]</code></pre><h3 id=\"label开启标签显示\"><a href=\"#label开启标签显示\" class=\"headerlink\" title=\"label开启标签显示\"></a>label开启标签显示</h3><p>在add函数中显示</p>\n<pre><code>点的label\nlabel_opts=opts.LabelOpts(is_show=True),\n\n# 边的label\nedge_label=opts.LabelOpts(is_show=True, position=&#39;middle&#39;, formatter=&#39;{b}的数据{c}&#39;)\n</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/74d9467d0f68679807eade1929f22c8e/7809717571c0f8d65568ac57726720ef.png\" alt></p>\n<h3 id=\"显示侧边种类\"><a href=\"#显示侧边种类\" class=\"headerlink\" title=\"显示侧边种类\"></a>显示侧边种类</h3><pre><code>G.set_global_opts(\n    legend_opts=opts.LegendOpts(is_show=True,orient=&#39;vertical&#39;, pos_left=&#39;2%&#39;, pos_top=&#39;20%&#39;)\n\n)</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/74d9467d0f68679807eade1929f22c8e/f804ceb357d17ee616fc07a180a815ca.png\" alt></p>\n<h3 id=\"重力的设置\"><a href=\"#重力的设置\" class=\"headerlink\" title=\"重力的设置\"></a>重力的设置</h3><p>重力是控制所有的节点向中心聚集的引力</p>\n<p>默认是0.2，我们改成1<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/74d9467d0f68679807eade1929f22c8e/bbf3e9748703343c0d30120b442b0c18.png\" alt></p>\n<h3 id=\"关于斥力的设置\"><a href=\"#关于斥力的设置\" class=\"headerlink\" title=\"关于斥力的设置\"></a>关于斥力的设置</h3><p>repulsion=50：节点之间的斥力因子，支持设置成数组表达斥力的范围，此时不同大小的值会线性映射到不同的斥力。值越大则斥力越大</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"echarts-网络图的绘制\"><a href=\"#echarts-网络图的绘制\" class=\"headerlink\" title=\"echarts 网络图的绘制\"></a>echarts 网络图的绘制</h1><p>文档与相关资源<br><a href=\"https://github.com/pyecharts/pyecharts-gallery\" target=\"_blank\" rel=\"noopener\">官方的文档</a><br><a href=\"https://echarts.apache.org/examples/en/index.html#chart-type-graph\" target=\"_blank\" rel=\"noopener\">官方样例网站</a><br><a href=\"https://blog.csdn.net/LSGO_MYP/article/details/117463653\" target=\"_blank\" rel=\"noopener\">不错的教程</a></p>\n<p><a href=\"https://echarts.apache.org/examples/data/asset/data/\" target=\"_blank\" rel=\"noopener\">数据</a></p>\n<h2 id=\"基本demo\"><a href=\"#基本demo\" class=\"headerlink\" title=\"基本demo\"></a>基本demo</h2><p>代码,这里是指输入到jupyter中的输出框中</p>\n<pre><code>from pyecharts import options as opts\nfrom pyecharts.charts import Graph\nfrom pyecharts.globals import CurrentConfig, NotebookType\nCurrentConfig.NOTEBOOK_TYPE = NotebookType.JUPYTER_NOTEBOOK # 不能省略，解决依赖问题\n\nnodes = [\n    opts.GraphNode(name=&quot;结点1&quot;, symbol_size=10),\n    opts.GraphNode(name=&quot;结点2&quot;, symbol_size=20),\n    opts.GraphNode(name=&quot;结点3&quot;, symbol_size=30),\n    opts.GraphNode(name=&quot;结点4&quot;, symbol_size=40),\n    opts.GraphNode(name=&quot;结点5&quot;, symbol_size=50),\n]\nlinks = [\n    opts.GraphLink(source=&quot;结点1&quot;, target=&quot;结点2&quot;, value=2, linestyle_opts=opts.LineStyleOpts(width=2),),\n    opts.GraphLink(source=&quot;结点2&quot;, target=&quot;结点3&quot;, value=3, linestyle_opts=opts.LineStyleOpts(width=3),),\n    opts.GraphLink(source=&quot;结点3&quot;, target=&quot;结点4&quot;, value=4, linestyle_opts=opts.LineStyleOpts(width=4),),\n    opts.GraphLink(source=&quot;结点4&quot;, target=&quot;结点5&quot;, value=5, linestyle_opts=opts.LineStyleOpts(width=5)),\n    opts.GraphLink(source=&quot;结点5&quot;, target=&quot;结点3&quot;, value=6, linestyle_opts=opts.LineStyleOpts(width=6)),\n]\nc = (\n    Graph()\n    .add(&quot;&quot;, nodes, links, repulsion=4000,\n         edge_label=opts.LabelOpts(is_show=True,position=&quot;middle&quot;,formatter=&quot;{c}&quot;)\n         )\n    .set_global_opts(title_opts=opts.TitleOpts(title=&quot;Graph-GraphNode-GraphLink&quot;))\n)\n\nc.render_notebook()</code></pre><p>结果</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/74d9467d0f68679807eade1929f22c8e/d7394b4a8be8595f7371311cdbcd4ea3.png\" alt></p>\n<h2 id=\"各种属性设置\"><a href=\"#各种属性设置\" class=\"headerlink\" title=\"各种属性设置\"></a>各种属性设置</h2><p>上面demo中的add函数可以更改以下属性</p>\n<pre><code>def add(\n    # 系列名称，用于 tooltip 的显示，legend 的图例筛选。\n    series_name: str,\n\n    # 关系图节点数据项列表，参考 `opts.GraphNode`\n    nodes: Sequence[Union[opts.GraphNode, dict]],\n\n    # 关系图节点间关系数据项列表，参考 `opts.GraphLink`\n    links: Sequence[Union[opts.GraphLink, dict]],\n\n    # 关系图节点分类的类目列表，参考 `opts.GraphCategory`\n    categories: Union[Sequence[Union[opts.GraphCategory, dict]], None] = None,\n\n    # 是否选中图例。\n    is_selected: bool = True,\n\n    # 是否在鼠标移到节点上的时候突出显示节点以及节点的边和邻接节点。\n    is_focusnode: bool = True,\n\n    # 是否开启鼠标缩放和平移漫游。\n    is_roam: bool = True,\n\n    # 节点是否可拖拽，只在使用力引导布局的时候有用。\n    is_draggable: bool = False,\n\n    # 是否旋转标签，默认不旋转。\n    is_rotate_label: bool = False,\n\n    # 图的布局。可选：\n    # &#39;none&#39; 不采用任何布局，使用节点中提供的 x， y 作为节点的位置。\n    # &#39;circular&#39; 采用环形布局。\n    # &#39;force&#39; 采用力引导布局。\n    layout: str = &quot;force&quot;,\n\n    # 关系图节点标记的图形。\n    # ECharts 提供的标记类型包括 &#39;circle&#39;, &#39;rect&#39;, &#39;roundRect&#39;, &#39;triangle&#39;, \n    # &#39;diamond&#39;, &#39;pin&#39;, &#39;arrow&#39;, &#39;none&#39;\n    # 可以通过 &#39;image://url&#39; 设置为图片，其中 URL 为图片的链接，或者 dataURI。\n    symbol: Optional[str] = None,\n\n    # 关系图节点标记的大小\n    # 可以设置成诸如 10 这样单一的数字\n    # 也可以用数组分开表示宽和高，例如 [20, 10] 表示标记宽为20，高为10。\n    symbol_size: types.Numeric = 10,\n\n    # 边的两个节点之间的距离，这个距离也会受 repulsion。\n    # 支持设置成数组表达边长的范围，此时不同大小的值会线性映射到不同的长度。值越小则长度越长。\n    edge_length: Numeric = 50,\n\n    # 节点受到的向中心的引力因子。该值越大节点越往中心点靠拢。\n    gravity: Numeric = 0.2,\n\n    # 节点之间的斥力因子。\n    # 支持设置成数组表达斥力的范围，此时不同大小的值会线性映射到不同的斥力。值越大则斥力越大\n    repulsion: Numeric = 50,\n\n     # Graph 图节点边的 Label 配置（即在边上显示数据或标注的配置）\n    edge_label: types.Label = None,\n\n    # 边两端的标记类型，可以是一个数组分别指定两端，也可以是单个统一指定。\n    # 默认不显示标记，常见的可以设置为箭头，如下：edgeSymbol: [&#39;circle&#39;, &#39;arrow&#39;]\n    edge_symbol: Optional[str] = None,\n\n    # 边两端的标记大小，可以是一个数组分别指定两端，也可以是单个统一指定。\n    edge_symbol_size: Numeric = 10,\n\n    # 标签配置项，参考 `series_options.LabelOpts`\n    label_opts: Union[opts.LabelOpts, dict] = opts.LabelOpts(),\n\n    # 关系边的公用线条样式。\n    linestyle_opts: Union[opts.LineStyleOpts, dict] = opts.LineStyleOpts(),\n\n    # 提示框组件配置项，参考 `series_options.TooltipOpts`\n    tooltip_opts: Union[opts.TooltipOpts, dict, None] = None,\n\n    # 图元样式配置项，参考 `series_options.ItemStyleOpts`\n    itemstyle_opts: Union[opts.ItemStyleOpts, dict, None] = None,\n)\n</code></pre><h3 id=\"节点属性设置\"><a href=\"#节点属性设置\" class=\"headerlink\" title=\"节点属性设置\"></a>节点属性设置</h3><p>在添加的时候可以设置</p>\n<pre><code>nodes = [\n    opts.GraphNode(\n        name= node[&#39;name&#39;],\n        symbol_size=10, # 节点的显示大小\n        value=20, #节点值，点击节点就会显示\n        category=node[&#39;category&#39;], # 种类\n        x,y#属性只有在特定的layout下才能生效\n    )\n    for node in data[&#39;nodes&#39;]\n]</code></pre><p>节点的颜色可以用种类的不同区分，不同的种类会自动分配不同颜色。</p>\n<h3 id=\"边的属性设置\"><a href=\"#边的属性设置\" class=\"headerlink\" title=\"边的属性设置\"></a>边的属性设置</h3><p>边的属性设置如下</p>\n<pre><code>links = [\n    opts.GraphLink(\n        source=edge[&#39;source&#39;],\n        target=edge[&#39;target&#39;],\n        value=10,# 设置线的值\n        #设置线的宽度和曲度\n        linestyle_opts=opts.LineStyleOpts(width=1, curve=0.2)\n    )\n    for edge in data[&#39;links&#39;]\n]</code></pre><h3 id=\"label开启标签显示\"><a href=\"#label开启标签显示\" class=\"headerlink\" title=\"label开启标签显示\"></a>label开启标签显示</h3><p>在add函数中显示</p>\n<pre><code>点的label\nlabel_opts=opts.LabelOpts(is_show=True),\n\n# 边的label\nedge_label=opts.LabelOpts(is_show=True, position=&#39;middle&#39;, formatter=&#39;{b}的数据{c}&#39;)\n</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/74d9467d0f68679807eade1929f22c8e/7809717571c0f8d65568ac57726720ef.png\" alt></p>\n<h3 id=\"显示侧边种类\"><a href=\"#显示侧边种类\" class=\"headerlink\" title=\"显示侧边种类\"></a>显示侧边种类</h3><pre><code>G.set_global_opts(\n    legend_opts=opts.LegendOpts(is_show=True,orient=&#39;vertical&#39;, pos_left=&#39;2%&#39;, pos_top=&#39;20%&#39;)\n\n)</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/74d9467d0f68679807eade1929f22c8e/f804ceb357d17ee616fc07a180a815ca.png\" alt></p>\n<h3 id=\"重力的设置\"><a href=\"#重力的设置\" class=\"headerlink\" title=\"重力的设置\"></a>重力的设置</h3><p>重力是控制所有的节点向中心聚集的引力</p>\n<p>默认是0.2，我们改成1<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/74d9467d0f68679807eade1929f22c8e/bbf3e9748703343c0d30120b442b0c18.png\" alt></p>\n<h3 id=\"关于斥力的设置\"><a href=\"#关于斥力的设置\" class=\"headerlink\" title=\"关于斥力的设置\"></a>关于斥力的设置</h3><p>repulsion=50：节点之间的斥力因子，支持设置成数组表达斥力的范围，此时不同大小的值会线性映射到不同的斥力。值越大则斥力越大</p>\n"},{"_content":"# 前置环境安装\n\n- node   v12.16.2\n- npm插件安装(要进入到相关目录下面)\n\n```\nnpm i hexo-cli -g\nnpm install\n```\n\n\n\n\n\n\n\n\n\n### git\n\n模板\n\n```\nhexo clean\nhexo g\ncd public\n\n\n# 初始化\ngit init\n\n# 设置账号\ngit config user.name \"name\"\ngit config user.email \"email\"\n\n# commit\ngit add .\ngit commit -m \"$(date) Update from Action\"\n\n# 本地切换分支\ngit branch gh-pages \ngit checkout gh-pages \n\n# 强制上传\ngit push --force --quiet \"https://kengerlwl:${GITHUB_TOKEN}@github.com/kengerlwl/kengerlwl.github.io.git\"  gh-pages    \n\n```\n\n\n\n\n\n\n\n我本地测试\n\n```\nhexo clean\nhexo g\ncd public\n\n\n# 初始化\ngit init\n\n# 设置账号\ngit config --global user.name “kengerlwl”\ngit config --global user.email \"kengerlwl@qq.com\"\n\n# commit\ngit add .\ngit commit -m \"$(date) Update from Action\"\n\n# 本地切换分支\ngit branch gh-pages \ngit checkout gh-pages \n\n# 强制上传\ngit push --force --quiet \"https://kengerlwl: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@github.com/kengerlwl/kengerlwl.github.io.git\"  gh-pages       \n```\n\n\n\n","source":"_posts/综合/hexo静态博客搭建.md","raw":"# 前置环境安装\n\n- node   v12.16.2\n- npm插件安装(要进入到相关目录下面)\n\n```\nnpm i hexo-cli -g\nnpm install\n```\n\n\n\n\n\n\n\n\n\n### git\n\n模板\n\n```\nhexo clean\nhexo g\ncd public\n\n\n# 初始化\ngit init\n\n# 设置账号\ngit config user.name \"name\"\ngit config user.email \"email\"\n\n# commit\ngit add .\ngit commit -m \"$(date) Update from Action\"\n\n# 本地切换分支\ngit branch gh-pages \ngit checkout gh-pages \n\n# 强制上传\ngit push --force --quiet \"https://kengerlwl:${GITHUB_TOKEN}@github.com/kengerlwl/kengerlwl.github.io.git\"  gh-pages    \n\n```\n\n\n\n\n\n\n\n我本地测试\n\n```\nhexo clean\nhexo g\ncd public\n\n\n# 初始化\ngit init\n\n# 设置账号\ngit config --global user.name “kengerlwl”\ngit config --global user.email \"kengerlwl@qq.com\"\n\n# commit\ngit add .\ngit commit -m \"$(date) Update from Action\"\n\n# 本地切换分支\ngit branch gh-pages \ngit checkout gh-pages \n\n# 强制上传\ngit push --force --quiet \"https://kengerlwl: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@github.com/kengerlwl/kengerlwl.github.io.git\"  gh-pages       \n```\n\n\n\n","slug":"综合/hexo静态博客搭建","published":1,"date":"2023-02-26T15:28:35.059Z","updated":"2023-02-27T11:34:33.140Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsycg001g0gcnuktecgcm","content":"<h1 id=\"前置环境安装\"><a href=\"#前置环境安装\" class=\"headerlink\" title=\"前置环境安装\"></a>前置环境安装</h1><ul>\n<li>node   v12.16.2</li>\n<li>npm插件安装(要进入到相关目录下面)</li>\n</ul>\n<pre><code>npm i hexo-cli -g\nnpm install</code></pre><h3 id=\"git\"><a href=\"#git\" class=\"headerlink\" title=\"git\"></a>git</h3><p>模板</p>\n<pre><code>hexo clean\nhexo g\ncd public\n\n\n# 初始化\ngit init\n\n# 设置账号\ngit config user.name &quot;name&quot;\ngit config user.email &quot;email&quot;\n\n# commit\ngit add .\ngit commit -m &quot;$(date) Update from Action&quot;\n\n# 本地切换分支\ngit branch gh-pages \ngit checkout gh-pages \n\n# 强制上传\ngit push --force --quiet &quot;https://kengerlwl:${GITHUB_TOKEN}@github.com/kengerlwl/kengerlwl.github.io.git&quot;  gh-pages    \n</code></pre><p>我本地测试</p>\n<pre><code>hexo clean\nhexo g\ncd public\n\n\n# 初始化\ngit init\n\n# 设置账号\ngit config --global user.name “kengerlwl”\ngit config --global user.email &quot;kengerlwl@qq.com&quot;\n\n# commit\ngit add .\ngit commit -m &quot;$(date) Update from Action&quot;\n\n# 本地切换分支\ngit branch gh-pages \ngit checkout gh-pages \n\n# 强制上传\ngit push --force --quiet &quot;https://kengerlwl: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@github.com/kengerlwl/kengerlwl.github.io.git&quot;  gh-pages       </code></pre>","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"前置环境安装\"><a href=\"#前置环境安装\" class=\"headerlink\" title=\"前置环境安装\"></a>前置环境安装</h1><ul>\n<li>node   v12.16.2</li>\n<li>npm插件安装(要进入到相关目录下面)</li>\n</ul>\n<pre><code>npm i hexo-cli -g\nnpm install</code></pre><h3 id=\"git\"><a href=\"#git\" class=\"headerlink\" title=\"git\"></a>git</h3><p>模板</p>\n<pre><code>hexo clean\nhexo g\ncd public\n\n\n# 初始化\ngit init\n\n# 设置账号\ngit config user.name &quot;name&quot;\ngit config user.email &quot;email&quot;\n\n# commit\ngit add .\ngit commit -m &quot;$(date) Update from Action&quot;\n\n# 本地切换分支\ngit branch gh-pages \ngit checkout gh-pages \n\n# 强制上传\ngit push --force --quiet &quot;https://kengerlwl:${GITHUB_TOKEN}@github.com/kengerlwl/kengerlwl.github.io.git&quot;  gh-pages    \n</code></pre><p>我本地测试</p>\n<pre><code>hexo clean\nhexo g\ncd public\n\n\n# 初始化\ngit init\n\n# 设置账号\ngit config --global user.name “kengerlwl”\ngit config --global user.email &quot;kengerlwl@qq.com&quot;\n\n# commit\ngit add .\ngit commit -m &quot;$(date) Update from Action&quot;\n\n# 本地切换分支\ngit branch gh-pages \ngit checkout gh-pages \n\n# 强制上传\ngit push --force --quiet &quot;https://kengerlwl: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@github.com/kengerlwl/kengerlwl.github.io.git&quot;  gh-pages       </code></pre>"},{"_content":"# Python Redis，rabbitMQ以及Mysql使用操作教程\n先redis\n\n## Redis知识点\nRedis的数据通常是存储在内存之中的，但是Redis支持数据的持久化，可以将内存的数据保存在磁盘中。\nRedis 除了做缓存之外，也经常用来做分布式锁，甚至是消息队列。\n\n### Redis 除了做缓存，还能做什么？\n- 分布式锁 ： 通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。相关阅读：《分布式锁中的王者方案 - Redisson》open in new window。\n- 限流 ：一般是通过 Redis + Lua 脚本的方式来实现限流。相关阅读：《我司用了 6 年的 Redis 分布式限流器，可以说是非常厉害了！》open in new window。\n- 消息队列 ：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。\n- 复杂业务场景 ：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。\n\n\n\n## 安装以及配置\n\n1. 下载源码或者可执行文件地址[link](https://github.com/tporadowski/redis/releases)\n2. 进行配置redis.conf文件（不同系统上可能有一定区别）\n    2.1 添加密码：在文件中加入`requirepass 123456   #这个是密码`\n    2.2 如果发现连接不上，需要修改redis.conf中的bind地址，bind意思是允许访问的主机：\n            ```\n            0.0.0.0：允许任意外部主机访问（推荐）\n            127.0.0.1：只允许本机访问\n            ```\n3. 启动redis。在可执行文件目录下执行`redis-server.exe redis.windows.conf`\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/28ad227c312ac77ff864ee30af2ad98b/16e2c421d46d1fa0805f02ef701b9225.png)\n\n4. 用redis的客户端查看\n```\n# 在服务器开始运行之后，运行命令\nredis-cli.exe\n```\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/28ad227c312ac77ff864ee30af2ad98b/70891fa074145dd529d88fb0e307b478.png)\n\n\n5. 最终的配置文件\n```\n\n#这个是密码\nrequirepass 123456  \n\n# 允许访问主机地址\nbind 0.0.0.0 \n```\n\n## Python 进行连接使用\n\n我们使用类`StrictRedis`。\n```\nfrom redis import StrictRedis\n\nredis = StrictRedis(host='localhost', port=6379, db=0, password='123456')\nredis.set('name', 'GEJI')\nprint(redis.get('name'))\n```\n\n\n这样连接好后，就可以进行正常使用了。我们可以把redis当做一个离线的hashmap进行使用\n\n\n总得来说，redis是比较灵活的。和python的map类似。里面可以有不同类型的value\n- 键操作 \n- 列表操作 \n- 集合操作 \n- 有序集合操作 \n- 散列操作\n\n### 过期\n默认是永不过期\n\n\n一些常见的函数操作可以参考[链接](https://cloud.tencent.com/developer/article/1151834)\n\n\n# rabbitMQ使用操作教程\n\n[rabbitmq的几大工作模式](https://xie.infoq.cn/article/02f4007cb22f991ee49882efa)\n\n我这里已经把redis和rabbitmq打包到docker里面去了。\n可以去pull下来\n\n\n\n关于rabbitmq的启动：\n```\n/root/Lib/RabbitMQ/bin/rabbitmq-server start &  # 启动rabbitmq\n/root/Lib/RabbitMQ/bin/rabbitmq-plugins enable rabbitmq_management & # 打开web服务界面\n\n# 停止过服务\n# rabbitmqctl stop\n\n```\n\n对rabbitmq进行用户添加以及设置权限分组\n```\n\n rabbitmqctl add_user developer（用户名） 123456（密码） #新增用户以及密码\n \n rabbitmqctl delete_user developer  # 删除服务用户\n \n rabbitmqctl set_user_tags developer administrator（用户的权限组）#进行管理权限分组\n\nrabbitmqctl set_permissions -p / developer（用户名） \".*\" \".*\" \".*\" # 设置访问权限\n\n```\n\n\n\n## rabbitMQ的使用demo\n\nsend.py\n```\n# coding:utf-8\nimport pika\n\nusername = ''\npassword = ''\nhost = ''\ncredentials = pika.PlainCredentials(username, password)\nconnection = pika.BlockingConnection(pika.ConnectionParameters(host=host, credentials=credentials, port=5672))\nchannel = connection.channel()\n\nchannel.queue_declare(queue='qr_list',durable = True)\n\nchannel.basic_publish(exchange='',\n                      routing_key='qr_list',\n                      body='Hello World!')\n\nprint(\"[x] Sent 'Hello World!'\")\nconnection.close()\n\n```\n\nrevieve.py\n```\n# coding:utf-8\nimport pika\nimport time\n\nusername = ''\npassword = ''\nhost = ''\n\ncredentials = pika.PlainCredentials(username, password)\nconnection = pika.BlockingConnection(pika.ConnectionParameters(\n    host=host, credentials=credentials, port=5672\n))\nchannel = connection.channel()\n\nchannel.queue_declare(queue='qr_list',durable = True)\n\n\ndef callback(ch, method, properties, body):\n    print(\" [x] Received %r\" % (body,))\n    time.sleep(3)\n    print(\" [x] Done\")\n    # 确认消息\n    ch.basic_ack(delivery_tag = method.delivery_tag)\n\n\nif __name__ == '__main__':   \n    channel.basic_consume('qr_list',callback,auto_ack = False)\n    \n    print(' [*] Waiting for messages. To exit press CTRL+C')\n    channel.start_consuming()\n```\n\n\n\n\n# mqsql 的安装使用\n执行命令启动容器\n```\ndocker run -it -p 0122:22 -p 6379:6379 -p 5672:5672 -p 15672:15672 --privileged centos_redis_and_rabbitmq init\n解释：\n-p： 进行端口映射\n--privileged：优先级\ninit，设置/usr/sbin/init 为一号进程，方便后序的systemctl使用。\n```\n\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/28ad227c312ac77ff864ee30af2ad98b/29245237bf8fe4e2b891c4bd15054ed0.png)\n\n\n# docker compose使用\n上面介绍的是三个服务装在一个docker容器里面运行，实际上这并不符合docker的运行规则。\n\ndocker的设计思路是每个容器运行一个程序，不同的程序分隔开来。\n\n所以为了管理多个容器，引入了docker-compose。\n\n这里简单讲讲我的配置文件吧。\n\n## 首先有个文件目录如下\n```\n.\n├── docker-compose.yml\n├── mysql\n│   ├── data\n│   └── my.cnf\n└── redis\n    ├── data  \n    └── redis.conf\n#里面的两个data目录可以不用管，后面生成的\n```\n\n## 几个文件的配置\n**mysql.my.cnf**\n```\n[client]\n port = 3306\n socket = /var/lib/mysql/data/mysql.sock\n[mysqld]\n # 针对5.7版本执行group by字句出错问题解决\n sql_mode='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION'\n # 一般配置选项\n basedir = /var/lib/mysql\n datadir = /var/lib/mysql/data\n port = 3306\n# Accept connections from any IP address\n bind-address\t            = 0.0.0.0\n socket = /var/lib/mysql/data/mysql.sock\n lc-messages-dir = /usr/share/mysql # 务必配置此项，否则执行sql出错时，只能显示错误代码而不显示具体错误消息\n character-set-server=utf8\n back_log = 300\n max_connections = 3000\n max_connect_errors = 50\n table_open_cache = 4096\n max_allowed_packet = 32M\n #binlog_cache_size = 4M\n max_heap_table_size = 128M\n read_rnd_buffer_size = 16M\n sort_buffer_size = 16M\n join_buffer_size = 16M\n thread_cache_size = 16\n query_cache_size = 64M\n query_cache_limit = 4M\n ft_min_word_len = 8\n thread_stack = 512K\n transaction_isolation = REPEATABLE-READ\n tmp_table_size = 64M\n #log-bin=mysql-bin\n long_query_time = 6\n server_id=1\n innodb_buffer_pool_size = 256M\n innodb_thread_concurrency = 16\n innodb_log_buffer_size = 16M\n```\n\n**redis.redis.conf**\n```\ndaemonize no     ## 若使用开机启动，生成pid，该项必须设置为诶yes，否则redis将不能够正常执行开机启动(systemctl start redis,执行后一直卡着，直到超时)\n\nprotected-mode no  ## 允许其他机器上的客户端连接当前redis，配置文件设置该项，则开机启动处就可以去掉--protected no \n\n#这个是密码\nrequirepass 123456\n\n# 允许访问主机地址\nbind 0.0.0.0 \n```\n\n**docker-compose.yml**\n\n```\nversion: '3'\nservices:\n  mysql:\n    hostname: mysql\n    image: mysql/mysql-server:5.7.26\n    # network_mode: \"host\" # 如果需要容器使用宿主机IP(内网IP)，则可以配置此项,默认桥接模式\n    container_name: mysql # 指定容器名称，如果不设置此参数，则由系统自动生成\n    restart: always # 设置容器自启模式\n    command: mysqld --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci # 设置utf8字符集\n    environment:\n      - TZ=Asia/Shanghai # 设置容器时区与宿主机保持一致\n      - MYSQL_ROOT_PASSWORD=123456 # 设置root密码\n    volumes:\n       - /etc/localtime:/etc/localtime:ro # 设置容器时区与宿主机保持一致\n       - ./mysql/data:/var/lib/mysql/data # 映射数据库保存目录到宿主机，防止数据丢失\n       - ./mysql/my.cnf:/etc/mysql/my.cnf # 映射数据库配置文件\n    ports:\n        - \"3306:3306\"\n\n  redis:  \n    hostname: redis\n    image: redis:5.0.4\n    container_name: redis\n    restart: always\n    command: redis-server /etc/redis.conf # 启动redis命令\n    environment:\n      - TZ=Asia/Shanghai\n    volumes:\n      - /etc/localtime:/etc/localtime:ro # 设置容器时区与宿主机保持一致\n      - ./redis/data:/data\n      - ./redis/redis.conf:/etc/redis.conf\n    ports:\n        - \"6379:6379\"\n\n  rabbitmq:\n    image: rabbitmq:management-alpine\n    container_name: rabbitmq\n    environment:                      #设置用户名和密码\n      - RABBITMQ_DEFAULT_USER=lwl\n      - RABBITMQ_DEFAULT_PASS=123456\n    restart: always\n    ports:\n      - \"15672:15672\"\n      - \"5672:5672\"\n    logging:\n      driver: \"json-file\"\n      options:\n        max-size: \"200k\"\n        max-file: \"10\"\n```\n\n\n\n\n## 运行与配置\n\n在这个目录下运行`docker-compose -f docker-compose.yml up -d`\n\n\n可以看到三个容器和镜像\n```\n❯ docker ps -a\nCONTAINER ID   IMAGE                        COMMAND                  CREATED             STATUS                      PORTS     NAMES\n67e41a460801   rabbitmq:management-alpine   \"docker-entrypoint.s…\"   About an hour ago   Exited (0) 14 minutes ago             rabbitmq\n532bb3a9f99d   redis:5.0.4                  \"docker-entrypoint.s…\"   About an hour ago   Exited (1) 15 minutes ago             redis\nef1306403160   mysql/mysql-server:5.7.26    \"/entrypoint.sh mysq…\"   About an hour ago   Exited (0) 15 minutes ago             mysql\n```\n\n如果有哪个容器不对劲，按照之前的办法，可以通过`docker exec -it xxxxxxxx`命令去进行调试。\n\n关于mysql没有链接上的问题,可以查看[link](https://blog.51cto.com/u_14349334/3485237)\n```\nGRANT USAGE ON *.* TO 'lwl'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION;\n```\n\n\n# docker compose的具体配置文件\n\n具体参考详见[link](https://www.jianshu.com/p/2217cfed29d7)","source":"_posts/综合/Python Redis，rabbitMQ以及Mysql使用操作教程.md","raw":"# Python Redis，rabbitMQ以及Mysql使用操作教程\n先redis\n\n## Redis知识点\nRedis的数据通常是存储在内存之中的，但是Redis支持数据的持久化，可以将内存的数据保存在磁盘中。\nRedis 除了做缓存之外，也经常用来做分布式锁，甚至是消息队列。\n\n### Redis 除了做缓存，还能做什么？\n- 分布式锁 ： 通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。相关阅读：《分布式锁中的王者方案 - Redisson》open in new window。\n- 限流 ：一般是通过 Redis + Lua 脚本的方式来实现限流。相关阅读：《我司用了 6 年的 Redis 分布式限流器，可以说是非常厉害了！》open in new window。\n- 消息队列 ：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。\n- 复杂业务场景 ：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。\n\n\n\n## 安装以及配置\n\n1. 下载源码或者可执行文件地址[link](https://github.com/tporadowski/redis/releases)\n2. 进行配置redis.conf文件（不同系统上可能有一定区别）\n    2.1 添加密码：在文件中加入`requirepass 123456   #这个是密码`\n    2.2 如果发现连接不上，需要修改redis.conf中的bind地址，bind意思是允许访问的主机：\n            ```\n            0.0.0.0：允许任意外部主机访问（推荐）\n            127.0.0.1：只允许本机访问\n            ```\n3. 启动redis。在可执行文件目录下执行`redis-server.exe redis.windows.conf`\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/28ad227c312ac77ff864ee30af2ad98b/16e2c421d46d1fa0805f02ef701b9225.png)\n\n4. 用redis的客户端查看\n```\n# 在服务器开始运行之后，运行命令\nredis-cli.exe\n```\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/28ad227c312ac77ff864ee30af2ad98b/70891fa074145dd529d88fb0e307b478.png)\n\n\n5. 最终的配置文件\n```\n\n#这个是密码\nrequirepass 123456  \n\n# 允许访问主机地址\nbind 0.0.0.0 \n```\n\n## Python 进行连接使用\n\n我们使用类`StrictRedis`。\n```\nfrom redis import StrictRedis\n\nredis = StrictRedis(host='localhost', port=6379, db=0, password='123456')\nredis.set('name', 'GEJI')\nprint(redis.get('name'))\n```\n\n\n这样连接好后，就可以进行正常使用了。我们可以把redis当做一个离线的hashmap进行使用\n\n\n总得来说，redis是比较灵活的。和python的map类似。里面可以有不同类型的value\n- 键操作 \n- 列表操作 \n- 集合操作 \n- 有序集合操作 \n- 散列操作\n\n### 过期\n默认是永不过期\n\n\n一些常见的函数操作可以参考[链接](https://cloud.tencent.com/developer/article/1151834)\n\n\n# rabbitMQ使用操作教程\n\n[rabbitmq的几大工作模式](https://xie.infoq.cn/article/02f4007cb22f991ee49882efa)\n\n我这里已经把redis和rabbitmq打包到docker里面去了。\n可以去pull下来\n\n\n\n关于rabbitmq的启动：\n```\n/root/Lib/RabbitMQ/bin/rabbitmq-server start &  # 启动rabbitmq\n/root/Lib/RabbitMQ/bin/rabbitmq-plugins enable rabbitmq_management & # 打开web服务界面\n\n# 停止过服务\n# rabbitmqctl stop\n\n```\n\n对rabbitmq进行用户添加以及设置权限分组\n```\n\n rabbitmqctl add_user developer（用户名） 123456（密码） #新增用户以及密码\n \n rabbitmqctl delete_user developer  # 删除服务用户\n \n rabbitmqctl set_user_tags developer administrator（用户的权限组）#进行管理权限分组\n\nrabbitmqctl set_permissions -p / developer（用户名） \".*\" \".*\" \".*\" # 设置访问权限\n\n```\n\n\n\n## rabbitMQ的使用demo\n\nsend.py\n```\n# coding:utf-8\nimport pika\n\nusername = ''\npassword = ''\nhost = ''\ncredentials = pika.PlainCredentials(username, password)\nconnection = pika.BlockingConnection(pika.ConnectionParameters(host=host, credentials=credentials, port=5672))\nchannel = connection.channel()\n\nchannel.queue_declare(queue='qr_list',durable = True)\n\nchannel.basic_publish(exchange='',\n                      routing_key='qr_list',\n                      body='Hello World!')\n\nprint(\"[x] Sent 'Hello World!'\")\nconnection.close()\n\n```\n\nrevieve.py\n```\n# coding:utf-8\nimport pika\nimport time\n\nusername = ''\npassword = ''\nhost = ''\n\ncredentials = pika.PlainCredentials(username, password)\nconnection = pika.BlockingConnection(pika.ConnectionParameters(\n    host=host, credentials=credentials, port=5672\n))\nchannel = connection.channel()\n\nchannel.queue_declare(queue='qr_list',durable = True)\n\n\ndef callback(ch, method, properties, body):\n    print(\" [x] Received %r\" % (body,))\n    time.sleep(3)\n    print(\" [x] Done\")\n    # 确认消息\n    ch.basic_ack(delivery_tag = method.delivery_tag)\n\n\nif __name__ == '__main__':   \n    channel.basic_consume('qr_list',callback,auto_ack = False)\n    \n    print(' [*] Waiting for messages. To exit press CTRL+C')\n    channel.start_consuming()\n```\n\n\n\n\n# mqsql 的安装使用\n执行命令启动容器\n```\ndocker run -it -p 0122:22 -p 6379:6379 -p 5672:5672 -p 15672:15672 --privileged centos_redis_and_rabbitmq init\n解释：\n-p： 进行端口映射\n--privileged：优先级\ninit，设置/usr/sbin/init 为一号进程，方便后序的systemctl使用。\n```\n\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/28ad227c312ac77ff864ee30af2ad98b/29245237bf8fe4e2b891c4bd15054ed0.png)\n\n\n# docker compose使用\n上面介绍的是三个服务装在一个docker容器里面运行，实际上这并不符合docker的运行规则。\n\ndocker的设计思路是每个容器运行一个程序，不同的程序分隔开来。\n\n所以为了管理多个容器，引入了docker-compose。\n\n这里简单讲讲我的配置文件吧。\n\n## 首先有个文件目录如下\n```\n.\n├── docker-compose.yml\n├── mysql\n│   ├── data\n│   └── my.cnf\n└── redis\n    ├── data  \n    └── redis.conf\n#里面的两个data目录可以不用管，后面生成的\n```\n\n## 几个文件的配置\n**mysql.my.cnf**\n```\n[client]\n port = 3306\n socket = /var/lib/mysql/data/mysql.sock\n[mysqld]\n # 针对5.7版本执行group by字句出错问题解决\n sql_mode='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION'\n # 一般配置选项\n basedir = /var/lib/mysql\n datadir = /var/lib/mysql/data\n port = 3306\n# Accept connections from any IP address\n bind-address\t            = 0.0.0.0\n socket = /var/lib/mysql/data/mysql.sock\n lc-messages-dir = /usr/share/mysql # 务必配置此项，否则执行sql出错时，只能显示错误代码而不显示具体错误消息\n character-set-server=utf8\n back_log = 300\n max_connections = 3000\n max_connect_errors = 50\n table_open_cache = 4096\n max_allowed_packet = 32M\n #binlog_cache_size = 4M\n max_heap_table_size = 128M\n read_rnd_buffer_size = 16M\n sort_buffer_size = 16M\n join_buffer_size = 16M\n thread_cache_size = 16\n query_cache_size = 64M\n query_cache_limit = 4M\n ft_min_word_len = 8\n thread_stack = 512K\n transaction_isolation = REPEATABLE-READ\n tmp_table_size = 64M\n #log-bin=mysql-bin\n long_query_time = 6\n server_id=1\n innodb_buffer_pool_size = 256M\n innodb_thread_concurrency = 16\n innodb_log_buffer_size = 16M\n```\n\n**redis.redis.conf**\n```\ndaemonize no     ## 若使用开机启动，生成pid，该项必须设置为诶yes，否则redis将不能够正常执行开机启动(systemctl start redis,执行后一直卡着，直到超时)\n\nprotected-mode no  ## 允许其他机器上的客户端连接当前redis，配置文件设置该项，则开机启动处就可以去掉--protected no \n\n#这个是密码\nrequirepass 123456\n\n# 允许访问主机地址\nbind 0.0.0.0 \n```\n\n**docker-compose.yml**\n\n```\nversion: '3'\nservices:\n  mysql:\n    hostname: mysql\n    image: mysql/mysql-server:5.7.26\n    # network_mode: \"host\" # 如果需要容器使用宿主机IP(内网IP)，则可以配置此项,默认桥接模式\n    container_name: mysql # 指定容器名称，如果不设置此参数，则由系统自动生成\n    restart: always # 设置容器自启模式\n    command: mysqld --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci # 设置utf8字符集\n    environment:\n      - TZ=Asia/Shanghai # 设置容器时区与宿主机保持一致\n      - MYSQL_ROOT_PASSWORD=123456 # 设置root密码\n    volumes:\n       - /etc/localtime:/etc/localtime:ro # 设置容器时区与宿主机保持一致\n       - ./mysql/data:/var/lib/mysql/data # 映射数据库保存目录到宿主机，防止数据丢失\n       - ./mysql/my.cnf:/etc/mysql/my.cnf # 映射数据库配置文件\n    ports:\n        - \"3306:3306\"\n\n  redis:  \n    hostname: redis\n    image: redis:5.0.4\n    container_name: redis\n    restart: always\n    command: redis-server /etc/redis.conf # 启动redis命令\n    environment:\n      - TZ=Asia/Shanghai\n    volumes:\n      - /etc/localtime:/etc/localtime:ro # 设置容器时区与宿主机保持一致\n      - ./redis/data:/data\n      - ./redis/redis.conf:/etc/redis.conf\n    ports:\n        - \"6379:6379\"\n\n  rabbitmq:\n    image: rabbitmq:management-alpine\n    container_name: rabbitmq\n    environment:                      #设置用户名和密码\n      - RABBITMQ_DEFAULT_USER=lwl\n      - RABBITMQ_DEFAULT_PASS=123456\n    restart: always\n    ports:\n      - \"15672:15672\"\n      - \"5672:5672\"\n    logging:\n      driver: \"json-file\"\n      options:\n        max-size: \"200k\"\n        max-file: \"10\"\n```\n\n\n\n\n## 运行与配置\n\n在这个目录下运行`docker-compose -f docker-compose.yml up -d`\n\n\n可以看到三个容器和镜像\n```\n❯ docker ps -a\nCONTAINER ID   IMAGE                        COMMAND                  CREATED             STATUS                      PORTS     NAMES\n67e41a460801   rabbitmq:management-alpine   \"docker-entrypoint.s…\"   About an hour ago   Exited (0) 14 minutes ago             rabbitmq\n532bb3a9f99d   redis:5.0.4                  \"docker-entrypoint.s…\"   About an hour ago   Exited (1) 15 minutes ago             redis\nef1306403160   mysql/mysql-server:5.7.26    \"/entrypoint.sh mysq…\"   About an hour ago   Exited (0) 15 minutes ago             mysql\n```\n\n如果有哪个容器不对劲，按照之前的办法，可以通过`docker exec -it xxxxxxxx`命令去进行调试。\n\n关于mysql没有链接上的问题,可以查看[link](https://blog.51cto.com/u_14349334/3485237)\n```\nGRANT USAGE ON *.* TO 'lwl'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION;\n```\n\n\n# docker compose的具体配置文件\n\n具体参考详见[link](https://www.jianshu.com/p/2217cfed29d7)","slug":"综合/Python Redis，rabbitMQ以及Mysql使用操作教程","published":1,"date":"2023-02-26T15:28:35.057Z","updated":"2023-02-27T11:34:33.141Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsycg001h0gcnpy8ju0e4","content":"<h1 id=\"Python-Redis，rabbitMQ以及Mysql使用操作教程\"><a href=\"#Python-Redis，rabbitMQ以及Mysql使用操作教程\" class=\"headerlink\" title=\"Python Redis，rabbitMQ以及Mysql使用操作教程\"></a>Python Redis，rabbitMQ以及Mysql使用操作教程</h1><p>先redis</p>\n<h2 id=\"Redis知识点\"><a href=\"#Redis知识点\" class=\"headerlink\" title=\"Redis知识点\"></a>Redis知识点</h2><p>Redis的数据通常是存储在内存之中的，但是Redis支持数据的持久化，可以将内存的数据保存在磁盘中。<br>Redis 除了做缓存之外，也经常用来做分布式锁，甚至是消息队列。</p>\n<h3 id=\"Redis-除了做缓存，还能做什么？\"><a href=\"#Redis-除了做缓存，还能做什么？\" class=\"headerlink\" title=\"Redis 除了做缓存，还能做什么？\"></a>Redis 除了做缓存，还能做什么？</h3><ul>\n<li>分布式锁 ： 通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。相关阅读：《分布式锁中的王者方案 - Redisson》open in new window。</li>\n<li>限流 ：一般是通过 Redis + Lua 脚本的方式来实现限流。相关阅读：《我司用了 6 年的 Redis 分布式限流器，可以说是非常厉害了！》open in new window。</li>\n<li>消息队列 ：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。</li>\n<li>复杂业务场景 ：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。</li>\n</ul>\n<h2 id=\"安装以及配置\"><a href=\"#安装以及配置\" class=\"headerlink\" title=\"安装以及配置\"></a>安装以及配置</h2><ol>\n<li><p>下载源码或者可执行文件地址<a href=\"https://github.com/tporadowski/redis/releases\" target=\"_blank\" rel=\"noopener\">link</a></p>\n</li>\n<li><p>进行配置redis.conf文件（不同系统上可能有一定区别）<br> 2.1 添加密码：在文件中加入<code>requirepass 123456   #这个是密码</code><br> 2.2 如果发现连接不上，需要修改redis.conf中的bind地址，bind意思是允许访问的主机：</p>\n<pre><code>     ```\n     0.0.0.0：允许任意外部主机访问（推荐）\n     127.0.0.1：只允许本机访问\n     ```</code></pre></li>\n<li><p>启动redis。在可执行文件目录下执行<code>redis-server.exe redis.windows.conf</code><br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/28ad227c312ac77ff864ee30af2ad98b/16e2c421d46d1fa0805f02ef701b9225.png\" alt></p>\n</li>\n<li><p>用redis的客户端查看</p>\n<pre><code># 在服务器开始运行之后，运行命令\nredis-cli.exe</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/28ad227c312ac77ff864ee30af2ad98b/70891fa074145dd529d88fb0e307b478.png\" alt></p>\n</li>\n</ol>\n<ol start=\"5\">\n<li>最终的配置文件<pre><code></code></pre></li>\n</ol>\n<p>#这个是密码<br>requirepass 123456  </p>\n<h1 id=\"允许访问主机地址\"><a href=\"#允许访问主机地址\" class=\"headerlink\" title=\"允许访问主机地址\"></a>允许访问主机地址</h1><p>bind 0.0.0.0 </p>\n<pre><code>\n## Python 进行连接使用\n\n我们使用类`StrictRedis`。</code></pre><p>from redis import StrictRedis</p>\n<p>redis = StrictRedis(host=’localhost’, port=6379, db=0, password=’123456’)<br>redis.set(‘name’, ‘GEJI’)<br>print(redis.get(‘name’))</p>\n<pre><code>\n\n这样连接好后，就可以进行正常使用了。我们可以把redis当做一个离线的hashmap进行使用\n\n\n总得来说，redis是比较灵活的。和python的map类似。里面可以有不同类型的value\n- 键操作 \n- 列表操作 \n- 集合操作 \n- 有序集合操作 \n- 散列操作\n\n### 过期\n默认是永不过期\n\n\n一些常见的函数操作可以参考[链接](https://cloud.tencent.com/developer/article/1151834)\n\n\n# rabbitMQ使用操作教程\n\n[rabbitmq的几大工作模式](https://xie.infoq.cn/article/02f4007cb22f991ee49882efa)\n\n我这里已经把redis和rabbitmq打包到docker里面去了。\n可以去pull下来\n\n\n\n关于rabbitmq的启动：</code></pre><p>/root/Lib/RabbitMQ/bin/rabbitmq-server start &amp;  # 启动rabbitmq<br>/root/Lib/RabbitMQ/bin/rabbitmq-plugins enable rabbitmq_management &amp; # 打开web服务界面</p>\n<h1 id=\"停止过服务\"><a href=\"#停止过服务\" class=\"headerlink\" title=\"停止过服务\"></a>停止过服务</h1><h1 id=\"rabbitmqctl-stop\"><a href=\"#rabbitmqctl-stop\" class=\"headerlink\" title=\"rabbitmqctl stop\"></a>rabbitmqctl stop</h1><pre><code>\n对rabbitmq进行用户添加以及设置权限分组</code></pre><p> rabbitmqctl add_user developer（用户名） 123456（密码） #新增用户以及密码</p>\n<p> rabbitmqctl delete_user developer  # 删除服务用户</p>\n<p> rabbitmqctl set_user_tags developer administrator（用户的权限组）#进行管理权限分组</p>\n<p>rabbitmqctl set_permissions -p / developer（用户名） “.*” “.*” “.*” # 设置访问权限</p>\n<pre><code>\n\n\n## rabbitMQ的使用demo\n\nsend.py</code></pre><h1 id=\"coding-utf-8\"><a href=\"#coding-utf-8\" class=\"headerlink\" title=\"coding:utf-8\"></a>coding:utf-8</h1><p>import pika</p>\n<p>username = ‘’<br>password = ‘’<br>host = ‘’<br>credentials = pika.PlainCredentials(username, password)<br>connection = pika.BlockingConnection(pika.ConnectionParameters(host=host, credentials=credentials, port=5672))<br>channel = connection.channel()</p>\n<p>channel.queue_declare(queue=’qr_list’,durable = True)</p>\n<p>channel.basic_publish(exchange=’’,<br>                      routing_key=’qr_list’,<br>                      body=’Hello World!’)</p>\n<p>print(“[x] Sent ‘Hello World!’”)<br>connection.close()</p>\n<pre><code>\nrevieve.py</code></pre><h1 id=\"coding-utf-8-1\"><a href=\"#coding-utf-8-1\" class=\"headerlink\" title=\"coding:utf-8\"></a>coding:utf-8</h1><p>import pika<br>import time</p>\n<p>username = ‘’<br>password = ‘’<br>host = ‘’</p>\n<p>credentials = pika.PlainCredentials(username, password)<br>connection = pika.BlockingConnection(pika.ConnectionParameters(<br>    host=host, credentials=credentials, port=5672<br>))<br>channel = connection.channel()</p>\n<p>channel.queue_declare(queue=’qr_list’,durable = True)</p>\n<p>def callback(ch, method, properties, body):<br>    print(“ [x] Received %r” % (body,))<br>    time.sleep(3)<br>    print(“ [x] Done”)<br>    # 确认消息<br>    ch.basic_ack(delivery_tag = method.delivery_tag)</p>\n<p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    channel.basic_consume(‘qr_list’,callback,auto_ack = False)</p>\n<pre><code>print(&#39; [*] Waiting for messages. To exit press CTRL+C&#39;)\nchannel.start_consuming()</code></pre><pre><code>\n\n\n\n# mqsql 的安装使用\n执行命令启动容器</code></pre><p>docker run -it -p 0122:22 -p 6379:6379 -p 5672:5672 -p 15672:15672 –privileged centos_redis_and_rabbitmq init<br>解释：<br>-p： 进行端口映射<br>–privileged：优先级<br>init，设置/usr/sbin/init 为一号进程，方便后序的systemctl使用。</p>\n<pre><code>\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/28ad227c312ac77ff864ee30af2ad98b/29245237bf8fe4e2b891c4bd15054ed0.png)\n\n\n# docker compose使用\n上面介绍的是三个服务装在一个docker容器里面运行，实际上这并不符合docker的运行规则。\n\ndocker的设计思路是每个容器运行一个程序，不同的程序分隔开来。\n\n所以为了管理多个容器，引入了docker-compose。\n\n这里简单讲讲我的配置文件吧。\n\n## 首先有个文件目录如下</code></pre><p>.<br>├── docker-compose.yml<br>├── mysql<br>│   ├── data<br>│   └── my.cnf<br>└── redis<br>    ├── data<br>    └── redis.conf</p>\n<p>#里面的两个data目录可以不用管，后面生成的</p>\n<pre><code>\n## 几个文件的配置\n**mysql.my.cnf**</code></pre><p>[client]<br> port = 3306<br> socket = /var/lib/mysql/data/mysql.sock<br>[mysqld]</p>\n<h1 id=\"针对5-7版本执行group-by字句出错问题解决\"><a href=\"#针对5-7版本执行group-by字句出错问题解决\" class=\"headerlink\" title=\"针对5.7版本执行group by字句出错问题解决\"></a>针对5.7版本执行group by字句出错问题解决</h1><p> sql_mode=’STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION’</p>\n<h1 id=\"一般配置选项\"><a href=\"#一般配置选项\" class=\"headerlink\" title=\"一般配置选项\"></a>一般配置选项</h1><p> basedir = /var/lib/mysql<br> datadir = /var/lib/mysql/data<br> port = 3306</p>\n<h1 id=\"Accept-connections-from-any-IP-address\"><a href=\"#Accept-connections-from-any-IP-address\" class=\"headerlink\" title=\"Accept connections from any IP address\"></a>Accept connections from any IP address</h1><p> bind-address                = 0.0.0.0<br> socket = /var/lib/mysql/data/mysql.sock<br> lc-messages-dir = /usr/share/mysql # 务必配置此项，否则执行sql出错时，只能显示错误代码而不显示具体错误消息<br> character-set-server=utf8<br> back_log = 300<br> max_connections = 3000<br> max_connect_errors = 50<br> table_open_cache = 4096<br> max_allowed_packet = 32M</p>\n<p> #binlog_cache_size = 4M<br> max_heap_table_size = 128M<br> read_rnd_buffer_size = 16M<br> sort_buffer_size = 16M<br> join_buffer_size = 16M<br> thread_cache_size = 16<br> query_cache_size = 64M<br> query_cache_limit = 4M<br> ft_min_word_len = 8<br> thread_stack = 512K<br> transaction_isolation = REPEATABLE-READ<br> tmp_table_size = 64M</p>\n<p> #log-bin=mysql-bin<br> long_query_time = 6<br> server_id=1<br> innodb_buffer_pool_size = 256M<br> innodb_thread_concurrency = 16<br> innodb_log_buffer_size = 16M</p>\n<pre><code>\n**redis.redis.conf**</code></pre><p>daemonize no     ## 若使用开机启动，生成pid，该项必须设置为诶yes，否则redis将不能够正常执行开机启动(systemctl start redis,执行后一直卡着，直到超时)</p>\n<p>protected-mode no  ## 允许其他机器上的客户端连接当前redis，配置文件设置该项，则开机启动处就可以去掉–protected no </p>\n<p>#这个是密码<br>requirepass 123456</p>\n<h1 id=\"允许访问主机地址-1\"><a href=\"#允许访问主机地址-1\" class=\"headerlink\" title=\"允许访问主机地址\"></a>允许访问主机地址</h1><p>bind 0.0.0.0 </p>\n<pre><code>\n**docker-compose.yml**\n</code></pre><p>version: ‘3’<br>services:<br>  mysql:<br>    hostname: mysql<br>    image: mysql/mysql-server:5.7.26<br>    # network_mode: “host” # 如果需要容器使用宿主机IP(内网IP)，则可以配置此项,默认桥接模式<br>    container_name: mysql # 指定容器名称，如果不设置此参数，则由系统自动生成<br>    restart: always # 设置容器自启模式<br>    command: mysqld –character-set-server=utf8mb4 –collation-server=utf8mb4_unicode_ci # 设置utf8字符集<br>    environment:<br>      - TZ=Asia/Shanghai # 设置容器时区与宿主机保持一致<br>      - MYSQL_ROOT_PASSWORD=123456 # 设置root密码<br>    volumes:<br>       - /etc/localtime:/etc/localtime:ro # 设置容器时区与宿主机保持一致<br>       - ./mysql/data:/var/lib/mysql/data # 映射数据库保存目录到宿主机，防止数据丢失<br>       - ./mysql/my.cnf:/etc/mysql/my.cnf # 映射数据库配置文件<br>    ports:<br>        - “3306:3306”</p>\n<p>  redis:<br>    hostname: redis<br>    image: redis:5.0.4<br>    container_name: redis<br>    restart: always<br>    command: redis-server /etc/redis.conf # 启动redis命令<br>    environment:<br>      - TZ=Asia/Shanghai<br>    volumes:<br>      - /etc/localtime:/etc/localtime:ro # 设置容器时区与宿主机保持一致<br>      - ./redis/data:/data<br>      - ./redis/redis.conf:/etc/redis.conf<br>    ports:<br>        - “6379:6379”</p>\n<p>  rabbitmq:<br>    image: rabbitmq:management-alpine<br>    container_name: rabbitmq<br>    environment:                      #设置用户名和密码<br>      - RABBITMQ_DEFAULT_USER=lwl<br>      - RABBITMQ_DEFAULT_PASS=123456<br>    restart: always<br>    ports:<br>      - “15672:15672”<br>      - “5672:5672”<br>    logging:<br>      driver: “json-file”<br>      options:<br>        max-size: “200k”<br>        max-file: “10”</p>\n<pre><code>\n\n\n\n## 运行与配置\n\n在这个目录下运行`docker-compose -f docker-compose.yml up -d`\n\n\n可以看到三个容器和镜像</code></pre><p>❯ docker ps -a<br>CONTAINER ID   IMAGE                        COMMAND                  CREATED             STATUS                      PORTS     NAMES<br>67e41a460801   rabbitmq:management-alpine   “docker-entrypoint.s…”   About an hour ago   Exited (0) 14 minutes ago             rabbitmq<br>532bb3a9f99d   redis:5.0.4                  “docker-entrypoint.s…”   About an hour ago   Exited (1) 15 minutes ago             redis<br>ef1306403160   mysql/mysql-server:5.7.26    “/entrypoint.sh mysq…”   About an hour ago   Exited (0) 15 minutes ago             mysql</p>\n<pre><code>\n如果有哪个容器不对劲，按照之前的办法，可以通过`docker exec -it xxxxxxxx`命令去进行调试。\n\n关于mysql没有链接上的问题,可以查看[link](https://blog.51cto.com/u_14349334/3485237)</code></pre><p>GRANT USAGE ON <em>.</em> TO ‘lwl’@’%’ IDENTIFIED BY ‘123456’ WITH GRANT OPTION;<br>```</p>\n<h1 id=\"docker-compose的具体配置文件\"><a href=\"#docker-compose的具体配置文件\" class=\"headerlink\" title=\"docker compose的具体配置文件\"></a>docker compose的具体配置文件</h1><p>具体参考详见<a href=\"https://www.jianshu.com/p/2217cfed29d7\" target=\"_blank\" rel=\"noopener\">link</a></p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"Python-Redis，rabbitMQ以及Mysql使用操作教程\"><a href=\"#Python-Redis，rabbitMQ以及Mysql使用操作教程\" class=\"headerlink\" title=\"Python Redis，rabbitMQ以及Mysql使用操作教程\"></a>Python Redis，rabbitMQ以及Mysql使用操作教程</h1><p>先redis</p>\n<h2 id=\"Redis知识点\"><a href=\"#Redis知识点\" class=\"headerlink\" title=\"Redis知识点\"></a>Redis知识点</h2><p>Redis的数据通常是存储在内存之中的，但是Redis支持数据的持久化，可以将内存的数据保存在磁盘中。<br>Redis 除了做缓存之外，也经常用来做分布式锁，甚至是消息队列。</p>\n<h3 id=\"Redis-除了做缓存，还能做什么？\"><a href=\"#Redis-除了做缓存，还能做什么？\" class=\"headerlink\" title=\"Redis 除了做缓存，还能做什么？\"></a>Redis 除了做缓存，还能做什么？</h3><ul>\n<li>分布式锁 ： 通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。相关阅读：《分布式锁中的王者方案 - Redisson》open in new window。</li>\n<li>限流 ：一般是通过 Redis + Lua 脚本的方式来实现限流。相关阅读：《我司用了 6 年的 Redis 分布式限流器，可以说是非常厉害了！》open in new window。</li>\n<li>消息队列 ：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。</li>\n<li>复杂业务场景 ：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。</li>\n</ul>\n<h2 id=\"安装以及配置\"><a href=\"#安装以及配置\" class=\"headerlink\" title=\"安装以及配置\"></a>安装以及配置</h2><ol>\n<li><p>下载源码或者可执行文件地址<a href=\"https://github.com/tporadowski/redis/releases\" target=\"_blank\" rel=\"noopener\">link</a></p>\n</li>\n<li><p>进行配置redis.conf文件（不同系统上可能有一定区别）<br> 2.1 添加密码：在文件中加入<code>requirepass 123456   #这个是密码</code><br> 2.2 如果发现连接不上，需要修改redis.conf中的bind地址，bind意思是允许访问的主机：</p>\n<pre><code>     ```\n     0.0.0.0：允许任意外部主机访问（推荐）\n     127.0.0.1：只允许本机访问\n     ```</code></pre></li>\n<li><p>启动redis。在可执行文件目录下执行<code>redis-server.exe redis.windows.conf</code><br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/28ad227c312ac77ff864ee30af2ad98b/16e2c421d46d1fa0805f02ef701b9225.png\" alt></p>\n</li>\n<li><p>用redis的客户端查看</p>\n<pre><code># 在服务器开始运行之后，运行命令\nredis-cli.exe</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/28ad227c312ac77ff864ee30af2ad98b/70891fa074145dd529d88fb0e307b478.png\" alt></p>\n</li>\n</ol>\n<ol start=\"5\">\n<li>最终的配置文件<pre><code></code></pre></li>\n</ol>\n<p>#这个是密码<br>requirepass 123456  </p>\n<h1 id=\"允许访问主机地址\"><a href=\"#允许访问主机地址\" class=\"headerlink\" title=\"允许访问主机地址\"></a>允许访问主机地址</h1><p>bind 0.0.0.0 </p>\n<pre><code>\n## Python 进行连接使用\n\n我们使用类`StrictRedis`。</code></pre><p>from redis import StrictRedis</p>\n<p>redis = StrictRedis(host=’localhost’, port=6379, db=0, password=’123456’)<br>redis.set(‘name’, ‘GEJI’)<br>print(redis.get(‘name’))</p>\n<pre><code>\n\n这样连接好后，就可以进行正常使用了。我们可以把redis当做一个离线的hashmap进行使用\n\n\n总得来说，redis是比较灵活的。和python的map类似。里面可以有不同类型的value\n- 键操作 \n- 列表操作 \n- 集合操作 \n- 有序集合操作 \n- 散列操作\n\n### 过期\n默认是永不过期\n\n\n一些常见的函数操作可以参考[链接](https://cloud.tencent.com/developer/article/1151834)\n\n\n# rabbitMQ使用操作教程\n\n[rabbitmq的几大工作模式](https://xie.infoq.cn/article/02f4007cb22f991ee49882efa)\n\n我这里已经把redis和rabbitmq打包到docker里面去了。\n可以去pull下来\n\n\n\n关于rabbitmq的启动：</code></pre><p>/root/Lib/RabbitMQ/bin/rabbitmq-server start &amp;  # 启动rabbitmq<br>/root/Lib/RabbitMQ/bin/rabbitmq-plugins enable rabbitmq_management &amp; # 打开web服务界面</p>\n<h1 id=\"停止过服务\"><a href=\"#停止过服务\" class=\"headerlink\" title=\"停止过服务\"></a>停止过服务</h1><h1 id=\"rabbitmqctl-stop\"><a href=\"#rabbitmqctl-stop\" class=\"headerlink\" title=\"rabbitmqctl stop\"></a>rabbitmqctl stop</h1><pre><code>\n对rabbitmq进行用户添加以及设置权限分组</code></pre><p> rabbitmqctl add_user developer（用户名） 123456（密码） #新增用户以及密码</p>\n<p> rabbitmqctl delete_user developer  # 删除服务用户</p>\n<p> rabbitmqctl set_user_tags developer administrator（用户的权限组）#进行管理权限分组</p>\n<p>rabbitmqctl set_permissions -p / developer（用户名） “.*” “.*” “.*” # 设置访问权限</p>\n<pre><code>\n\n\n## rabbitMQ的使用demo\n\nsend.py</code></pre><h1 id=\"coding-utf-8\"><a href=\"#coding-utf-8\" class=\"headerlink\" title=\"coding:utf-8\"></a>coding:utf-8</h1><p>import pika</p>\n<p>username = ‘’<br>password = ‘’<br>host = ‘’<br>credentials = pika.PlainCredentials(username, password)<br>connection = pika.BlockingConnection(pika.ConnectionParameters(host=host, credentials=credentials, port=5672))<br>channel = connection.channel()</p>\n<p>channel.queue_declare(queue=’qr_list’,durable = True)</p>\n<p>channel.basic_publish(exchange=’’,<br>                      routing_key=’qr_list’,<br>                      body=’Hello World!’)</p>\n<p>print(“[x] Sent ‘Hello World!’”)<br>connection.close()</p>\n<pre><code>\nrevieve.py</code></pre><h1 id=\"coding-utf-8-1\"><a href=\"#coding-utf-8-1\" class=\"headerlink\" title=\"coding:utf-8\"></a>coding:utf-8</h1><p>import pika<br>import time</p>\n<p>username = ‘’<br>password = ‘’<br>host = ‘’</p>\n<p>credentials = pika.PlainCredentials(username, password)<br>connection = pika.BlockingConnection(pika.ConnectionParameters(<br>    host=host, credentials=credentials, port=5672<br>))<br>channel = connection.channel()</p>\n<p>channel.queue_declare(queue=’qr_list’,durable = True)</p>\n<p>def callback(ch, method, properties, body):<br>    print(“ [x] Received %r” % (body,))<br>    time.sleep(3)<br>    print(“ [x] Done”)<br>    # 确认消息<br>    ch.basic_ack(delivery_tag = method.delivery_tag)</p>\n<p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    channel.basic_consume(‘qr_list’,callback,auto_ack = False)</p>\n<pre><code>print(&#39; [*] Waiting for messages. To exit press CTRL+C&#39;)\nchannel.start_consuming()</code></pre><pre><code>\n\n\n\n# mqsql 的安装使用\n执行命令启动容器</code></pre><p>docker run -it -p 0122:22 -p 6379:6379 -p 5672:5672 -p 15672:15672 –privileged centos_redis_and_rabbitmq init<br>解释：<br>-p： 进行端口映射<br>–privileged：优先级<br>init，设置/usr/sbin/init 为一号进程，方便后序的systemctl使用。</p>\n<pre><code>\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/28ad227c312ac77ff864ee30af2ad98b/29245237bf8fe4e2b891c4bd15054ed0.png)\n\n\n# docker compose使用\n上面介绍的是三个服务装在一个docker容器里面运行，实际上这并不符合docker的运行规则。\n\ndocker的设计思路是每个容器运行一个程序，不同的程序分隔开来。\n\n所以为了管理多个容器，引入了docker-compose。\n\n这里简单讲讲我的配置文件吧。\n\n## 首先有个文件目录如下</code></pre><p>.<br>├── docker-compose.yml<br>├── mysql<br>│   ├── data<br>│   └── my.cnf<br>└── redis<br>    ├── data<br>    └── redis.conf</p>\n<p>#里面的两个data目录可以不用管，后面生成的</p>\n<pre><code>\n## 几个文件的配置\n**mysql.my.cnf**</code></pre><p>[client]<br> port = 3306<br> socket = /var/lib/mysql/data/mysql.sock<br>[mysqld]</p>\n<h1 id=\"针对5-7版本执行group-by字句出错问题解决\"><a href=\"#针对5-7版本执行group-by字句出错问题解决\" class=\"headerlink\" title=\"针对5.7版本执行group by字句出错问题解决\"></a>针对5.7版本执行group by字句出错问题解决</h1><p> sql_mode=’STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION’</p>\n<h1 id=\"一般配置选项\"><a href=\"#一般配置选项\" class=\"headerlink\" title=\"一般配置选项\"></a>一般配置选项</h1><p> basedir = /var/lib/mysql<br> datadir = /var/lib/mysql/data<br> port = 3306</p>\n<h1 id=\"Accept-connections-from-any-IP-address\"><a href=\"#Accept-connections-from-any-IP-address\" class=\"headerlink\" title=\"Accept connections from any IP address\"></a>Accept connections from any IP address</h1><p> bind-address                = 0.0.0.0<br> socket = /var/lib/mysql/data/mysql.sock<br> lc-messages-dir = /usr/share/mysql # 务必配置此项，否则执行sql出错时，只能显示错误代码而不显示具体错误消息<br> character-set-server=utf8<br> back_log = 300<br> max_connections = 3000<br> max_connect_errors = 50<br> table_open_cache = 4096<br> max_allowed_packet = 32M</p>\n<p> #binlog_cache_size = 4M<br> max_heap_table_size = 128M<br> read_rnd_buffer_size = 16M<br> sort_buffer_size = 16M<br> join_buffer_size = 16M<br> thread_cache_size = 16<br> query_cache_size = 64M<br> query_cache_limit = 4M<br> ft_min_word_len = 8<br> thread_stack = 512K<br> transaction_isolation = REPEATABLE-READ<br> tmp_table_size = 64M</p>\n<p> #log-bin=mysql-bin<br> long_query_time = 6<br> server_id=1<br> innodb_buffer_pool_size = 256M<br> innodb_thread_concurrency = 16<br> innodb_log_buffer_size = 16M</p>\n<pre><code>\n**redis.redis.conf**</code></pre><p>daemonize no     ## 若使用开机启动，生成pid，该项必须设置为诶yes，否则redis将不能够正常执行开机启动(systemctl start redis,执行后一直卡着，直到超时)</p>\n<p>protected-mode no  ## 允许其他机器上的客户端连接当前redis，配置文件设置该项，则开机启动处就可以去掉–protected no </p>\n<p>#这个是密码<br>requirepass 123456</p>\n<h1 id=\"允许访问主机地址-1\"><a href=\"#允许访问主机地址-1\" class=\"headerlink\" title=\"允许访问主机地址\"></a>允许访问主机地址</h1><p>bind 0.0.0.0 </p>\n<pre><code>\n**docker-compose.yml**\n</code></pre><p>version: ‘3’<br>services:<br>  mysql:<br>    hostname: mysql<br>    image: mysql/mysql-server:5.7.26<br>    # network_mode: “host” # 如果需要容器使用宿主机IP(内网IP)，则可以配置此项,默认桥接模式<br>    container_name: mysql # 指定容器名称，如果不设置此参数，则由系统自动生成<br>    restart: always # 设置容器自启模式<br>    command: mysqld –character-set-server=utf8mb4 –collation-server=utf8mb4_unicode_ci # 设置utf8字符集<br>    environment:<br>      - TZ=Asia/Shanghai # 设置容器时区与宿主机保持一致<br>      - MYSQL_ROOT_PASSWORD=123456 # 设置root密码<br>    volumes:<br>       - /etc/localtime:/etc/localtime:ro # 设置容器时区与宿主机保持一致<br>       - ./mysql/data:/var/lib/mysql/data # 映射数据库保存目录到宿主机，防止数据丢失<br>       - ./mysql/my.cnf:/etc/mysql/my.cnf # 映射数据库配置文件<br>    ports:<br>        - “3306:3306”</p>\n<p>  redis:<br>    hostname: redis<br>    image: redis:5.0.4<br>    container_name: redis<br>    restart: always<br>    command: redis-server /etc/redis.conf # 启动redis命令<br>    environment:<br>      - TZ=Asia/Shanghai<br>    volumes:<br>      - /etc/localtime:/etc/localtime:ro # 设置容器时区与宿主机保持一致<br>      - ./redis/data:/data<br>      - ./redis/redis.conf:/etc/redis.conf<br>    ports:<br>        - “6379:6379”</p>\n<p>  rabbitmq:<br>    image: rabbitmq:management-alpine<br>    container_name: rabbitmq<br>    environment:                      #设置用户名和密码<br>      - RABBITMQ_DEFAULT_USER=lwl<br>      - RABBITMQ_DEFAULT_PASS=123456<br>    restart: always<br>    ports:<br>      - “15672:15672”<br>      - “5672:5672”<br>    logging:<br>      driver: “json-file”<br>      options:<br>        max-size: “200k”<br>        max-file: “10”</p>\n<pre><code>\n\n\n\n## 运行与配置\n\n在这个目录下运行`docker-compose -f docker-compose.yml up -d`\n\n\n可以看到三个容器和镜像</code></pre><p>❯ docker ps -a<br>CONTAINER ID   IMAGE                        COMMAND                  CREATED             STATUS                      PORTS     NAMES<br>67e41a460801   rabbitmq:management-alpine   “docker-entrypoint.s…”   About an hour ago   Exited (0) 14 minutes ago             rabbitmq<br>532bb3a9f99d   redis:5.0.4                  “docker-entrypoint.s…”   About an hour ago   Exited (1) 15 minutes ago             redis<br>ef1306403160   mysql/mysql-server:5.7.26    “/entrypoint.sh mysq…”   About an hour ago   Exited (0) 15 minutes ago             mysql</p>\n<pre><code>\n如果有哪个容器不对劲，按照之前的办法，可以通过`docker exec -it xxxxxxxx`命令去进行调试。\n\n关于mysql没有链接上的问题,可以查看[link](https://blog.51cto.com/u_14349334/3485237)</code></pre><p>GRANT USAGE ON <em>.</em> TO ‘lwl’@’%’ IDENTIFIED BY ‘123456’ WITH GRANT OPTION;<br>```</p>\n<h1 id=\"docker-compose的具体配置文件\"><a href=\"#docker-compose的具体配置文件\" class=\"headerlink\" title=\"docker compose的具体配置文件\"></a>docker compose的具体配置文件</h1><p>具体参考详见<a href=\"https://www.jianshu.com/p/2217cfed29d7\" target=\"_blank\" rel=\"noopener\">link</a></p>\n"},{"_content":"## 目的\n\n搭建一个多平台的文件同步系统。\n\n无论是linux还是win，还是安卓什么的。\n\n\n\n\n\n## Syncthing是啥\n\n是一个开源的文件同步系统，性能非常优秀。\n\n总体上来说是一个点对点的去中心化的同步系统。\n\n如果在局域网内部，那么就会在内部网络做文件同步，很高效。也可以选择用公网服务器做同步，但是很消耗带宽。\n\n推荐使用场景：\n\n- 跨设备跨平台同步；比如 PC 端和移动端；\n- 小范围（熟人间）资源共享；\n- 企业内网之间多设备同步文件。\n\n\n\n\n\n## 基于docker使用Syncthing做同步\n\nSyncthing是一个类似frp的开远软件，如果直接基于源程序的方式去使用太不优雅的。而且版本管理，开机启动都要做管理，麻烦且没必要。\n\n这里用docker新建一个Syncthing容器。\n\n```\ndocker run --name syncthing -d -p 8384:8384 -p 22000:22000 -v 待同步的目录:/var/syncthing syncthing/syncthing\n```\n\n注意，因为使用docker，导致动态域名解析失败，因此，需要手动填入相应的域名（这里填的IP）。\n\n\n\n### 先添加设备\n\n![image-20221123221058166](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/028e0d396c15ec22f145eac2e43acb96/b38ce5a9fef6d80c46c71406bdb9cf12.png)\n\n填入目标设备ID\n\n![image-20221123221134471](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/028e0d396c15ec22f145eac2e43acb96/4420cd0ce37e63ad779ee1d1b8378f38.png)\n\n填入目标设备IP。\n\n**坑点：不知道为什么如果按照提示使用`（\"tcp://ip:port\", \"tcp://host:port\"）`反而会出错**\n\n![image-20221123221209755](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/028e0d396c15ec22f145eac2e43acb96/5dd593bdeba2248a8922019afa939b4d.png)\n\n\n\n\n\n### 设置同的文件夹\n\n不同设备间，这个标识符应该唯一\n\n![image-20221123221257440](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/028e0d396c15ec22f145eac2e43acb96/733fb24aa80c637fcc89d4982d97ab28.png)\n\n设置待同步的设备\n\n![image-20221123221333920](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/028e0d396c15ec22f145eac2e43acb96/1f3717eca7ac3567df1150996a643a55.png)\n\n\n\n\n\n### 主动扫描同步\n\n![image-20221123221358020](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/028e0d396c15ec22f145eac2e43acb96/9ff9441e9f8c3122a1537efa4a4658fa.png)\n\n点击就会同步给共享中的设备。\n\n\n\n\n\n## 一些技术实践的方案\n\n\n\n\n\n### 通过公网服务器做中间节点\n\n![image-20221124212741062](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/028e0d396c15ec22f145eac2e43acb96/713088de8e208fe801e7e9f241b509a8.png)\n\n要点：\n\n- 通过服务器的同步服务关闭自动扫描，或者设置为只有每晚凌晨时候才扫描，因为服务器的带宽很小。\n- 宿舍服务器用来做一个文件备份\n\n\n\n\n\n### 直接内网穿透代理\n\n为了解决不在局域网的情况，新增一个内网穿透22000端口呆公网。这样可以有效实现公网和内网穿插使用。\n\n\n\n\n\n## 注意的坑点\n\n### win一定要注意权限问题\n\n如果你把目录建立在C盘根目录下面，那么很有可能导致没有写权限。\n\n那么就会单方向导致文件同步失败。\n\n\n\n","source":"_posts/综合/Syncthing多平台文件同步.md","raw":"## 目的\n\n搭建一个多平台的文件同步系统。\n\n无论是linux还是win，还是安卓什么的。\n\n\n\n\n\n## Syncthing是啥\n\n是一个开源的文件同步系统，性能非常优秀。\n\n总体上来说是一个点对点的去中心化的同步系统。\n\n如果在局域网内部，那么就会在内部网络做文件同步，很高效。也可以选择用公网服务器做同步，但是很消耗带宽。\n\n推荐使用场景：\n\n- 跨设备跨平台同步；比如 PC 端和移动端；\n- 小范围（熟人间）资源共享；\n- 企业内网之间多设备同步文件。\n\n\n\n\n\n## 基于docker使用Syncthing做同步\n\nSyncthing是一个类似frp的开远软件，如果直接基于源程序的方式去使用太不优雅的。而且版本管理，开机启动都要做管理，麻烦且没必要。\n\n这里用docker新建一个Syncthing容器。\n\n```\ndocker run --name syncthing -d -p 8384:8384 -p 22000:22000 -v 待同步的目录:/var/syncthing syncthing/syncthing\n```\n\n注意，因为使用docker，导致动态域名解析失败，因此，需要手动填入相应的域名（这里填的IP）。\n\n\n\n### 先添加设备\n\n![image-20221123221058166](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/028e0d396c15ec22f145eac2e43acb96/b38ce5a9fef6d80c46c71406bdb9cf12.png)\n\n填入目标设备ID\n\n![image-20221123221134471](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/028e0d396c15ec22f145eac2e43acb96/4420cd0ce37e63ad779ee1d1b8378f38.png)\n\n填入目标设备IP。\n\n**坑点：不知道为什么如果按照提示使用`（\"tcp://ip:port\", \"tcp://host:port\"）`反而会出错**\n\n![image-20221123221209755](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/028e0d396c15ec22f145eac2e43acb96/5dd593bdeba2248a8922019afa939b4d.png)\n\n\n\n\n\n### 设置同的文件夹\n\n不同设备间，这个标识符应该唯一\n\n![image-20221123221257440](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/028e0d396c15ec22f145eac2e43acb96/733fb24aa80c637fcc89d4982d97ab28.png)\n\n设置待同步的设备\n\n![image-20221123221333920](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/028e0d396c15ec22f145eac2e43acb96/1f3717eca7ac3567df1150996a643a55.png)\n\n\n\n\n\n### 主动扫描同步\n\n![image-20221123221358020](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/028e0d396c15ec22f145eac2e43acb96/9ff9441e9f8c3122a1537efa4a4658fa.png)\n\n点击就会同步给共享中的设备。\n\n\n\n\n\n## 一些技术实践的方案\n\n\n\n\n\n### 通过公网服务器做中间节点\n\n![image-20221124212741062](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/028e0d396c15ec22f145eac2e43acb96/713088de8e208fe801e7e9f241b509a8.png)\n\n要点：\n\n- 通过服务器的同步服务关闭自动扫描，或者设置为只有每晚凌晨时候才扫描，因为服务器的带宽很小。\n- 宿舍服务器用来做一个文件备份\n\n\n\n\n\n### 直接内网穿透代理\n\n为了解决不在局域网的情况，新增一个内网穿透22000端口呆公网。这样可以有效实现公网和内网穿插使用。\n\n\n\n\n\n## 注意的坑点\n\n### win一定要注意权限问题\n\n如果你把目录建立在C盘根目录下面，那么很有可能导致没有写权限。\n\n那么就会单方向导致文件同步失败。\n\n\n\n","slug":"综合/Syncthing多平台文件同步","published":1,"date":"2023-02-26T15:28:35.058Z","updated":"2023-02-27T11:34:33.137Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsyci001i0gcn5yicx1j3","content":"<h2 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h2><p>搭建一个多平台的文件同步系统。</p>\n<p>无论是linux还是win，还是安卓什么的。</p>\n<h2 id=\"Syncthing是啥\"><a href=\"#Syncthing是啥\" class=\"headerlink\" title=\"Syncthing是啥\"></a>Syncthing是啥</h2><p>是一个开源的文件同步系统，性能非常优秀。</p>\n<p>总体上来说是一个点对点的去中心化的同步系统。</p>\n<p>如果在局域网内部，那么就会在内部网络做文件同步，很高效。也可以选择用公网服务器做同步，但是很消耗带宽。</p>\n<p>推荐使用场景：</p>\n<ul>\n<li>跨设备跨平台同步；比如 PC 端和移动端；</li>\n<li>小范围（熟人间）资源共享；</li>\n<li>企业内网之间多设备同步文件。</li>\n</ul>\n<h2 id=\"基于docker使用Syncthing做同步\"><a href=\"#基于docker使用Syncthing做同步\" class=\"headerlink\" title=\"基于docker使用Syncthing做同步\"></a>基于docker使用Syncthing做同步</h2><p>Syncthing是一个类似frp的开远软件，如果直接基于源程序的方式去使用太不优雅的。而且版本管理，开机启动都要做管理，麻烦且没必要。</p>\n<p>这里用docker新建一个Syncthing容器。</p>\n<pre><code>docker run --name syncthing -d -p 8384:8384 -p 22000:22000 -v 待同步的目录:/var/syncthing syncthing/syncthing</code></pre><p>注意，因为使用docker，导致动态域名解析失败，因此，需要手动填入相应的域名（这里填的IP）。</p>\n<h3 id=\"先添加设备\"><a href=\"#先添加设备\" class=\"headerlink\" title=\"先添加设备\"></a>先添加设备</h3><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/028e0d396c15ec22f145eac2e43acb96/b38ce5a9fef6d80c46c71406bdb9cf12.png\" alt=\"image-20221123221058166\"></p>\n<p>填入目标设备ID</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/028e0d396c15ec22f145eac2e43acb96/4420cd0ce37e63ad779ee1d1b8378f38.png\" alt=\"image-20221123221134471\"></p>\n<p>填入目标设备IP。</p>\n<p><strong>坑点：不知道为什么如果按照提示使用<code>（&quot;tcp://ip:port&quot;, &quot;tcp://host:port&quot;）</code>反而会出错</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/028e0d396c15ec22f145eac2e43acb96/5dd593bdeba2248a8922019afa939b4d.png\" alt=\"image-20221123221209755\"></p>\n<h3 id=\"设置同的文件夹\"><a href=\"#设置同的文件夹\" class=\"headerlink\" title=\"设置同的文件夹\"></a>设置同的文件夹</h3><p>不同设备间，这个标识符应该唯一</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/028e0d396c15ec22f145eac2e43acb96/733fb24aa80c637fcc89d4982d97ab28.png\" alt=\"image-20221123221257440\"></p>\n<p>设置待同步的设备</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/028e0d396c15ec22f145eac2e43acb96/1f3717eca7ac3567df1150996a643a55.png\" alt=\"image-20221123221333920\"></p>\n<h3 id=\"主动扫描同步\"><a href=\"#主动扫描同步\" class=\"headerlink\" title=\"主动扫描同步\"></a>主动扫描同步</h3><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/028e0d396c15ec22f145eac2e43acb96/9ff9441e9f8c3122a1537efa4a4658fa.png\" alt=\"image-20221123221358020\"></p>\n<p>点击就会同步给共享中的设备。</p>\n<h2 id=\"一些技术实践的方案\"><a href=\"#一些技术实践的方案\" class=\"headerlink\" title=\"一些技术实践的方案\"></a>一些技术实践的方案</h2><h3 id=\"通过公网服务器做中间节点\"><a href=\"#通过公网服务器做中间节点\" class=\"headerlink\" title=\"通过公网服务器做中间节点\"></a>通过公网服务器做中间节点</h3><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/028e0d396c15ec22f145eac2e43acb96/713088de8e208fe801e7e9f241b509a8.png\" alt=\"image-20221124212741062\"></p>\n<p>要点：</p>\n<ul>\n<li>通过服务器的同步服务关闭自动扫描，或者设置为只有每晚凌晨时候才扫描，因为服务器的带宽很小。</li>\n<li>宿舍服务器用来做一个文件备份</li>\n</ul>\n<h3 id=\"直接内网穿透代理\"><a href=\"#直接内网穿透代理\" class=\"headerlink\" title=\"直接内网穿透代理\"></a>直接内网穿透代理</h3><p>为了解决不在局域网的情况，新增一个内网穿透22000端口呆公网。这样可以有效实现公网和内网穿插使用。</p>\n<h2 id=\"注意的坑点\"><a href=\"#注意的坑点\" class=\"headerlink\" title=\"注意的坑点\"></a>注意的坑点</h2><h3 id=\"win一定要注意权限问题\"><a href=\"#win一定要注意权限问题\" class=\"headerlink\" title=\"win一定要注意权限问题\"></a>win一定要注意权限问题</h3><p>如果你把目录建立在C盘根目录下面，那么很有可能导致没有写权限。</p>\n<p>那么就会单方向导致文件同步失败。</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h2 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h2><p>搭建一个多平台的文件同步系统。</p>\n<p>无论是linux还是win，还是安卓什么的。</p>\n<h2 id=\"Syncthing是啥\"><a href=\"#Syncthing是啥\" class=\"headerlink\" title=\"Syncthing是啥\"></a>Syncthing是啥</h2><p>是一个开源的文件同步系统，性能非常优秀。</p>\n<p>总体上来说是一个点对点的去中心化的同步系统。</p>\n<p>如果在局域网内部，那么就会在内部网络做文件同步，很高效。也可以选择用公网服务器做同步，但是很消耗带宽。</p>\n<p>推荐使用场景：</p>\n<ul>\n<li>跨设备跨平台同步；比如 PC 端和移动端；</li>\n<li>小范围（熟人间）资源共享；</li>\n<li>企业内网之间多设备同步文件。</li>\n</ul>\n<h2 id=\"基于docker使用Syncthing做同步\"><a href=\"#基于docker使用Syncthing做同步\" class=\"headerlink\" title=\"基于docker使用Syncthing做同步\"></a>基于docker使用Syncthing做同步</h2><p>Syncthing是一个类似frp的开远软件，如果直接基于源程序的方式去使用太不优雅的。而且版本管理，开机启动都要做管理，麻烦且没必要。</p>\n<p>这里用docker新建一个Syncthing容器。</p>\n<pre><code>docker run --name syncthing -d -p 8384:8384 -p 22000:22000 -v 待同步的目录:/var/syncthing syncthing/syncthing</code></pre><p>注意，因为使用docker，导致动态域名解析失败，因此，需要手动填入相应的域名（这里填的IP）。</p>\n<h3 id=\"先添加设备\"><a href=\"#先添加设备\" class=\"headerlink\" title=\"先添加设备\"></a>先添加设备</h3><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/028e0d396c15ec22f145eac2e43acb96/b38ce5a9fef6d80c46c71406bdb9cf12.png\" alt=\"image-20221123221058166\"></p>\n<p>填入目标设备ID</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/028e0d396c15ec22f145eac2e43acb96/4420cd0ce37e63ad779ee1d1b8378f38.png\" alt=\"image-20221123221134471\"></p>\n<p>填入目标设备IP。</p>\n<p><strong>坑点：不知道为什么如果按照提示使用<code>（&quot;tcp://ip:port&quot;, &quot;tcp://host:port&quot;）</code>反而会出错</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/028e0d396c15ec22f145eac2e43acb96/5dd593bdeba2248a8922019afa939b4d.png\" alt=\"image-20221123221209755\"></p>\n<h3 id=\"设置同的文件夹\"><a href=\"#设置同的文件夹\" class=\"headerlink\" title=\"设置同的文件夹\"></a>设置同的文件夹</h3><p>不同设备间，这个标识符应该唯一</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/028e0d396c15ec22f145eac2e43acb96/733fb24aa80c637fcc89d4982d97ab28.png\" alt=\"image-20221123221257440\"></p>\n<p>设置待同步的设备</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/028e0d396c15ec22f145eac2e43acb96/1f3717eca7ac3567df1150996a643a55.png\" alt=\"image-20221123221333920\"></p>\n<h3 id=\"主动扫描同步\"><a href=\"#主动扫描同步\" class=\"headerlink\" title=\"主动扫描同步\"></a>主动扫描同步</h3><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/028e0d396c15ec22f145eac2e43acb96/9ff9441e9f8c3122a1537efa4a4658fa.png\" alt=\"image-20221123221358020\"></p>\n<p>点击就会同步给共享中的设备。</p>\n<h2 id=\"一些技术实践的方案\"><a href=\"#一些技术实践的方案\" class=\"headerlink\" title=\"一些技术实践的方案\"></a>一些技术实践的方案</h2><h3 id=\"通过公网服务器做中间节点\"><a href=\"#通过公网服务器做中间节点\" class=\"headerlink\" title=\"通过公网服务器做中间节点\"></a>通过公网服务器做中间节点</h3><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/028e0d396c15ec22f145eac2e43acb96/713088de8e208fe801e7e9f241b509a8.png\" alt=\"image-20221124212741062\"></p>\n<p>要点：</p>\n<ul>\n<li>通过服务器的同步服务关闭自动扫描，或者设置为只有每晚凌晨时候才扫描，因为服务器的带宽很小。</li>\n<li>宿舍服务器用来做一个文件备份</li>\n</ul>\n<h3 id=\"直接内网穿透代理\"><a href=\"#直接内网穿透代理\" class=\"headerlink\" title=\"直接内网穿透代理\"></a>直接内网穿透代理</h3><p>为了解决不在局域网的情况，新增一个内网穿透22000端口呆公网。这样可以有效实现公网和内网穿插使用。</p>\n<h2 id=\"注意的坑点\"><a href=\"#注意的坑点\" class=\"headerlink\" title=\"注意的坑点\"></a>注意的坑点</h2><h3 id=\"win一定要注意权限问题\"><a href=\"#win一定要注意权限问题\" class=\"headerlink\" title=\"win一定要注意权限问题\"></a>win一定要注意权限问题</h3><p>如果你把目录建立在C盘根目录下面，那么很有可能导致没有写权限。</p>\n<p>那么就会单方向导致文件同步失败。</p>\n"},{"_content":"# 介绍\n\nGitHub Actions是GitHub 官方出品的持续集成工具，非常优秀的 CI/CD 工具。\n\n在软件工程中，CI/CD或CICD通常指的是持续集成和持续交付或持续部署的组合实践。\n\n### **简单来说**\n\n就是一个自动化来对提交的代码进行打包，集成，运维部署，测试，同步等操作。\n\n\n\n### 优点\n\n支持平台很多\n\nGithub支持自建容器\n\n支持基于事件触发：push / issue 创建 / PR 提交都可以触发，完全可以基于此完成一套自动化维护项目的流程。\n\n\n\n### 概念/术语\n\n1. Workflow：GitHub 是对一次 CI/CD 的过程定义为 Workflow，中间可能经历过代码拉取，编译，测试，打包，发布，通知等多个过程。\n2. Action： 一个独立的运行任务，多个 Action 组成 steps 来创建一个 Job。一组 Action（Actions） 逻辑相同就可以被复用，可以发布到 Actions Marketplace 供他人使用。\n3. Steps：一个多个 Actions 形成的步骤。一个 step 可以只是一个命令，也可以是一个 Action。\n4. Job：Steps 中的 Action 一个一个走完就完成了一个 Job。Job 下的所有 step 是运行在同一个容器中的，所以可以共享文件系统。\n5. Workflow File：Workflow 的配置文件，yaml 格式。GitHub 规定需要存放在 `{$REPO_HOME}/.github/workflow/`。\n\n\n\n\n\n# demo讲解\n\n### action与step结构\n\n- step会一个接着一个依次执行\n- step可以直接引入其他开发者的开源插件\n- step也可以是一段命令\n\n```yaml\nname: github pages # 工作流的名称\n\n# 触发工作流的事件 Event 下面设置的是当 push 到 source 分支后触发\n# 其他的事件还有：pull_request/page_build/release\n# 可参考：https://help.github.com/en/actions/reference/events-that-trigger-workflows\non:\t\n  push:\n    branches:\n    - source\n\n# jobs 即工作流中的执行任务\njobs:\n  build-deploy: # job-id\n    runs-on: ubuntu-18.04 # 容器环境\n    # needs: other-job 如果有依赖其他的 job 可以如此配置\n    \n    # 任务步骤集合\n    steps:\n    - name: Checkout\t# 步骤名称\n      uses: actions/checkout@v2\t# 引用可重用的 actions，比如这个就是 GitHub 官方的用于拉取代码的actions `@` 后面可以跟指定的分支或者 release 的版本或者特定的commit\n      with:\t# 当前 actions 的一些配置\n        submodules: true # 如果项目有依赖 Git 子项目时可以设为 true，拉取的时候会一并拉取下来\n\n    - name: Setup Hugo\n      uses: peaceiris/actions-hugo@v2\t# 这也是一个开源的 actions 用于安装 Hugo\n      with:\n        hugo-version: 'latest'\n        # extended: true\n\n\t\t# 单运行命令\n    - name: Build\n      run: hugo --minify # 一个 step 也可以直接用 run 执行命令。如果有多个命令可以如下使用\n      #run: |\n    \t\t#npm ci\n    \t\t#npm run build\n\n    - name: Deploy\n      uses: peaceiris/actions-gh-pages@v3 # 开源 actions 用于部署\n      with:\n        github_token: ${{ secrets.GITHUB_TOKEN}} # GitHub 读写仓库的权限token，自动生成无需关心\n        publish_branch: master\n```\n\n\n\n\n\n### 1. github每个yml文件对应一个action\n\n```\n. .github目录\n└── workflows\n    ├── action.yml\n    └── action2.yml\n\n```\n\n- 每个文件对应一个action\n- 支持同时运行多个action\n\n![image-20230226162215015](/Users/lwl/Library/Application Support/typora-user-images/image-20230226162215015.png)\n\n\n\n### 2. 事件触发器\n\n- 可以通过指定事件来触发工作流程\n\n```\non:\n  push:\n    branches: # 指定以master 分支或名称 以 releases/ 开头的分支 \n    - master  \n    - 'releases/**'\n    paths: # 仅仅docs目录下面的改变才会触发\n    - 'docs/**'\n  pull_request: # 指定新的pull request\n    branches:\n    - master\n    - 'releases/**'\n```\n\n### 3.矩阵参数组合执行\n\n很多时候对于一些复杂环境，例如我这里有一个服务器。然后里面有许多参数组合不同，我想要组合执行一遍。\n\n那么可以用这个方案\n\n```\nname: CI\n\non: [push]\n\njobs:    \n  build:\n    runs-on: ubuntu-latest\n\n    strategy:    \n      matrix:\n        cc: [gcc, clang]\n        curl: [openssl, gnutls, nss]\n        kerberos: [libkrb5, heimdal]\n\n    steps:\n    - name: Install dependencies\n      run: |\n        sudo apt-get update\n        sudo apt-get install -y ${{ matrix.cc }} \\\n                                libcurl4-${{ matrix.curl }}-dev \\\n                                ${{ matrix.kerberos }}-dev\n    - name: Display Configuration\n      run: |\n        echo \"C Compiler:\"\n        ${CC} --version\n        echo \"\"\n        echo \"Curl configuration:\"\n        curl-config --ssl-backends --version\n        echo \"\"\n        echo \"Kerberos configuration:\"\n        krb5-config --all\n      env:\n        CC: ${{ matrix.cc }}\n\n    - name: Checkout\n      uses: actions/checkout@v1\n\n    - name: Build\n      run: ./configure && make test\n```\n\n结果，执行的时候会自动替换成相应的变量\n\n![image](https://user-images.githubusercontent.com/3297411/77169169-07952200-6af4-11ea-8770-f381ddfaa7eb.png)\n\n\n\n### 4.平台指定\n\n以下面的代码为例，就指定了多个平台分别作为一个job，执行代码检查任务\n\n```\n# test\nname: CI\n\non: [push]\n\njobs: #可以有多个job\n  linux:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout\n      uses: actions/checkout@v1\n    - name: Build\n      run: make\n\n  windows:\n    runs-on: windows-latest\n    steps:\n    - name: Checkout\n      uses: actions/checkout@v1\n    - name: Build\n      run: make\n\n  macos:\n    runs-on: macos-latest\n    steps:\n    - name: Checkout\n      uses: actions/checkout@v1\n    - name: Build\n      run: make\n      \n```\n\n### 5. run命令，同时运行多行\n\nrun可以执行命令，支持同时运行多行\n\n```\nname: CI\n\non: [push]\n\njobs: #可以有多个job\n  linux:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v1\n      - name: Build\n        run: make\n        run: |  #同时运行多行\n          npm ci\n          npm run build\n          npm test\n```\n\n\n\n**注意！！！**\n\n**注意，如果在一个 step 中 cd 到某个目录下，那么后续的 step 是不受影响的，还是在原来的目录中。**\n\n\n\n### 6.Github密码\n\n##### 6.1 可以自己设置一些变量\n\n![image-20230226193445352](/Users/lwl/Library/Application Support/typora-user-images/image-20230226193445352.png)\n\n要使用该密码，你可以在工作流中使用上下文 `secrets` 来引用它。如果你有一个密码的名字 `SECRET_KEY`，你可以将其称为 `$`。\n\n```yaml\nname: Publish Documentation\n\n\non:\n  push:\n    branches:\n    - master\n\n\njobs:\n  build:\n    name: Build\n    runs-on: ubuntu-latest\n    steps:\n      - run: |\n          VERSION=$(date +%s)\n          docker login -u ethomson -p ${{ secrets.SECRET_KEY }}\n          docker build . --file Dockerfile --tag ethomson/app:${VERSION}\n          docker push ethomson/app:${VERSION}\n```\n\n \n\n\n\n#####  **`GITHUB_TOKEN`**\n\nGitHub Actions会为每次运行的工作流**自动在存储库中设置一个密码 `GITHUB_TOKEN`。该令牌使你可以与存储库进行交互，而无需自己创建新令牌或设置密码。**\n\n该令牌为你提供了对存储库本身，issue和[GitHub Packages](https://www.edwardthomson.com/blog/github_actions_9_deploy_to_github_packages.html)进行读写的有限访问权限。但是它不能完全访问所有内容──你无法与组织中的其他存储库一起使用，也无法发布到GitHub Pages──因此，对于某些工作流，你可能仍需要设置令牌。\n\n\n\n\n\n### 7. 缓存\n\n在很多情况下，我们会需要用到缓存，例如node的一大堆库，如果每次都去下载就太耗时了。非常没必要。\n\n可以选择使用缓存\n\n```\n      # 3. 安装nodejs\n      - name: Set node version to ${{ matrix.node_version }}\n        uses: actions/setup-node@v2\n        with:\n          node-version: ${{ matrix.node_version }}\n          cache: \"npm\" # 缓存\n          cache-dependency-path: package-lock.json\n```\n\n![image-20230227171954386](/Users/lwl/Library/Application Support/typora-user-images/image-20230227171954386.png)\n\n\n\n# Github Action在线调试配置\n\n```\nname: buildx\non:\n  push:\n    branches: [ master ]\n\njobs:\n  hello:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v1\n      - uses: shaowenchen/debugger-action@v1\n        name: debugger\n        timeout-minutes: 30\n        continue-on-error: true\n        with:\n          frp_server_addr: ${{ secrets.FRP_SERVER_ADDR }}\n          frp_server_port: ${{ secrets.FRP_SERVER_PORT }}\n          frp_token: ${{ secrets.FRP_TOKEN }}\n          ssh_port: 29001\n\n```\n\n\n\n我的本地环境\n\n\n```\n      - uses: shaowenchen/debugger-action@v1\n        name: debugger\n        timeout-minutes: 30\n        continue-on-error: true\n        with:\n          frp_server_addr: 110.40.204.239\n          frp_server_port: 7000\n          frp_token: 123456\n          ssh_port: 29001\n\n```\n\n连接\n\n```\nssh root@frp_server_addr -p ssh_port \n```\n\n输入 root 密码: root\n\n**说明**\n\n- 进去后默认额目录是`/home/runner`\n- 一般下载的目录包，也就是我们的执行程序在`work`目录下面\n\n```\n/home/runner/work/kengerlwl.github.io/kengerlwl.github.io\n```\n\n\n\n测试\n\n```\n\ncat public/index.html\n```\n\n\n\n# ref\n\n[使用 GitHub Action 持续集成你的博客](https://blog.xiaohei.im/posts/github-action-guide/)\n\n[GitHub Actions 第11天：密码（Secrets）](https://qiwihui.com/qiwihui-blog-94/)\n\n[请在该页面检索action](https://qiwihui.com/archives/)\n\n[github action 在线进行调试](https://www.chenshaowen.com/blog/a-debugger-for-actions.html#3-%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8-debugger-action)","source":"_posts/综合/Github Action学习CI:CD自动化.md","raw":"# 介绍\n\nGitHub Actions是GitHub 官方出品的持续集成工具，非常优秀的 CI/CD 工具。\n\n在软件工程中，CI/CD或CICD通常指的是持续集成和持续交付或持续部署的组合实践。\n\n### **简单来说**\n\n就是一个自动化来对提交的代码进行打包，集成，运维部署，测试，同步等操作。\n\n\n\n### 优点\n\n支持平台很多\n\nGithub支持自建容器\n\n支持基于事件触发：push / issue 创建 / PR 提交都可以触发，完全可以基于此完成一套自动化维护项目的流程。\n\n\n\n### 概念/术语\n\n1. Workflow：GitHub 是对一次 CI/CD 的过程定义为 Workflow，中间可能经历过代码拉取，编译，测试，打包，发布，通知等多个过程。\n2. Action： 一个独立的运行任务，多个 Action 组成 steps 来创建一个 Job。一组 Action（Actions） 逻辑相同就可以被复用，可以发布到 Actions Marketplace 供他人使用。\n3. Steps：一个多个 Actions 形成的步骤。一个 step 可以只是一个命令，也可以是一个 Action。\n4. Job：Steps 中的 Action 一个一个走完就完成了一个 Job。Job 下的所有 step 是运行在同一个容器中的，所以可以共享文件系统。\n5. Workflow File：Workflow 的配置文件，yaml 格式。GitHub 规定需要存放在 `{$REPO_HOME}/.github/workflow/`。\n\n\n\n\n\n# demo讲解\n\n### action与step结构\n\n- step会一个接着一个依次执行\n- step可以直接引入其他开发者的开源插件\n- step也可以是一段命令\n\n```yaml\nname: github pages # 工作流的名称\n\n# 触发工作流的事件 Event 下面设置的是当 push 到 source 分支后触发\n# 其他的事件还有：pull_request/page_build/release\n# 可参考：https://help.github.com/en/actions/reference/events-that-trigger-workflows\non:\t\n  push:\n    branches:\n    - source\n\n# jobs 即工作流中的执行任务\njobs:\n  build-deploy: # job-id\n    runs-on: ubuntu-18.04 # 容器环境\n    # needs: other-job 如果有依赖其他的 job 可以如此配置\n    \n    # 任务步骤集合\n    steps:\n    - name: Checkout\t# 步骤名称\n      uses: actions/checkout@v2\t# 引用可重用的 actions，比如这个就是 GitHub 官方的用于拉取代码的actions `@` 后面可以跟指定的分支或者 release 的版本或者特定的commit\n      with:\t# 当前 actions 的一些配置\n        submodules: true # 如果项目有依赖 Git 子项目时可以设为 true，拉取的时候会一并拉取下来\n\n    - name: Setup Hugo\n      uses: peaceiris/actions-hugo@v2\t# 这也是一个开源的 actions 用于安装 Hugo\n      with:\n        hugo-version: 'latest'\n        # extended: true\n\n\t\t# 单运行命令\n    - name: Build\n      run: hugo --minify # 一个 step 也可以直接用 run 执行命令。如果有多个命令可以如下使用\n      #run: |\n    \t\t#npm ci\n    \t\t#npm run build\n\n    - name: Deploy\n      uses: peaceiris/actions-gh-pages@v3 # 开源 actions 用于部署\n      with:\n        github_token: ${{ secrets.GITHUB_TOKEN}} # GitHub 读写仓库的权限token，自动生成无需关心\n        publish_branch: master\n```\n\n\n\n\n\n### 1. github每个yml文件对应一个action\n\n```\n. .github目录\n└── workflows\n    ├── action.yml\n    └── action2.yml\n\n```\n\n- 每个文件对应一个action\n- 支持同时运行多个action\n\n![image-20230226162215015](/Users/lwl/Library/Application Support/typora-user-images/image-20230226162215015.png)\n\n\n\n### 2. 事件触发器\n\n- 可以通过指定事件来触发工作流程\n\n```\non:\n  push:\n    branches: # 指定以master 分支或名称 以 releases/ 开头的分支 \n    - master  \n    - 'releases/**'\n    paths: # 仅仅docs目录下面的改变才会触发\n    - 'docs/**'\n  pull_request: # 指定新的pull request\n    branches:\n    - master\n    - 'releases/**'\n```\n\n### 3.矩阵参数组合执行\n\n很多时候对于一些复杂环境，例如我这里有一个服务器。然后里面有许多参数组合不同，我想要组合执行一遍。\n\n那么可以用这个方案\n\n```\nname: CI\n\non: [push]\n\njobs:    \n  build:\n    runs-on: ubuntu-latest\n\n    strategy:    \n      matrix:\n        cc: [gcc, clang]\n        curl: [openssl, gnutls, nss]\n        kerberos: [libkrb5, heimdal]\n\n    steps:\n    - name: Install dependencies\n      run: |\n        sudo apt-get update\n        sudo apt-get install -y ${{ matrix.cc }} \\\n                                libcurl4-${{ matrix.curl }}-dev \\\n                                ${{ matrix.kerberos }}-dev\n    - name: Display Configuration\n      run: |\n        echo \"C Compiler:\"\n        ${CC} --version\n        echo \"\"\n        echo \"Curl configuration:\"\n        curl-config --ssl-backends --version\n        echo \"\"\n        echo \"Kerberos configuration:\"\n        krb5-config --all\n      env:\n        CC: ${{ matrix.cc }}\n\n    - name: Checkout\n      uses: actions/checkout@v1\n\n    - name: Build\n      run: ./configure && make test\n```\n\n结果，执行的时候会自动替换成相应的变量\n\n![image](https://user-images.githubusercontent.com/3297411/77169169-07952200-6af4-11ea-8770-f381ddfaa7eb.png)\n\n\n\n### 4.平台指定\n\n以下面的代码为例，就指定了多个平台分别作为一个job，执行代码检查任务\n\n```\n# test\nname: CI\n\non: [push]\n\njobs: #可以有多个job\n  linux:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout\n      uses: actions/checkout@v1\n    - name: Build\n      run: make\n\n  windows:\n    runs-on: windows-latest\n    steps:\n    - name: Checkout\n      uses: actions/checkout@v1\n    - name: Build\n      run: make\n\n  macos:\n    runs-on: macos-latest\n    steps:\n    - name: Checkout\n      uses: actions/checkout@v1\n    - name: Build\n      run: make\n      \n```\n\n### 5. run命令，同时运行多行\n\nrun可以执行命令，支持同时运行多行\n\n```\nname: CI\n\non: [push]\n\njobs: #可以有多个job\n  linux:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v1\n      - name: Build\n        run: make\n        run: |  #同时运行多行\n          npm ci\n          npm run build\n          npm test\n```\n\n\n\n**注意！！！**\n\n**注意，如果在一个 step 中 cd 到某个目录下，那么后续的 step 是不受影响的，还是在原来的目录中。**\n\n\n\n### 6.Github密码\n\n##### 6.1 可以自己设置一些变量\n\n![image-20230226193445352](/Users/lwl/Library/Application Support/typora-user-images/image-20230226193445352.png)\n\n要使用该密码，你可以在工作流中使用上下文 `secrets` 来引用它。如果你有一个密码的名字 `SECRET_KEY`，你可以将其称为 `$`。\n\n```yaml\nname: Publish Documentation\n\n\non:\n  push:\n    branches:\n    - master\n\n\njobs:\n  build:\n    name: Build\n    runs-on: ubuntu-latest\n    steps:\n      - run: |\n          VERSION=$(date +%s)\n          docker login -u ethomson -p ${{ secrets.SECRET_KEY }}\n          docker build . --file Dockerfile --tag ethomson/app:${VERSION}\n          docker push ethomson/app:${VERSION}\n```\n\n \n\n\n\n#####  **`GITHUB_TOKEN`**\n\nGitHub Actions会为每次运行的工作流**自动在存储库中设置一个密码 `GITHUB_TOKEN`。该令牌使你可以与存储库进行交互，而无需自己创建新令牌或设置密码。**\n\n该令牌为你提供了对存储库本身，issue和[GitHub Packages](https://www.edwardthomson.com/blog/github_actions_9_deploy_to_github_packages.html)进行读写的有限访问权限。但是它不能完全访问所有内容──你无法与组织中的其他存储库一起使用，也无法发布到GitHub Pages──因此，对于某些工作流，你可能仍需要设置令牌。\n\n\n\n\n\n### 7. 缓存\n\n在很多情况下，我们会需要用到缓存，例如node的一大堆库，如果每次都去下载就太耗时了。非常没必要。\n\n可以选择使用缓存\n\n```\n      # 3. 安装nodejs\n      - name: Set node version to ${{ matrix.node_version }}\n        uses: actions/setup-node@v2\n        with:\n          node-version: ${{ matrix.node_version }}\n          cache: \"npm\" # 缓存\n          cache-dependency-path: package-lock.json\n```\n\n![image-20230227171954386](/Users/lwl/Library/Application Support/typora-user-images/image-20230227171954386.png)\n\n\n\n# Github Action在线调试配置\n\n```\nname: buildx\non:\n  push:\n    branches: [ master ]\n\njobs:\n  hello:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v1\n      - uses: shaowenchen/debugger-action@v1\n        name: debugger\n        timeout-minutes: 30\n        continue-on-error: true\n        with:\n          frp_server_addr: ${{ secrets.FRP_SERVER_ADDR }}\n          frp_server_port: ${{ secrets.FRP_SERVER_PORT }}\n          frp_token: ${{ secrets.FRP_TOKEN }}\n          ssh_port: 29001\n\n```\n\n\n\n我的本地环境\n\n\n```\n      - uses: shaowenchen/debugger-action@v1\n        name: debugger\n        timeout-minutes: 30\n        continue-on-error: true\n        with:\n          frp_server_addr: 110.40.204.239\n          frp_server_port: 7000\n          frp_token: 123456\n          ssh_port: 29001\n\n```\n\n连接\n\n```\nssh root@frp_server_addr -p ssh_port \n```\n\n输入 root 密码: root\n\n**说明**\n\n- 进去后默认额目录是`/home/runner`\n- 一般下载的目录包，也就是我们的执行程序在`work`目录下面\n\n```\n/home/runner/work/kengerlwl.github.io/kengerlwl.github.io\n```\n\n\n\n测试\n\n```\n\ncat public/index.html\n```\n\n\n\n# ref\n\n[使用 GitHub Action 持续集成你的博客](https://blog.xiaohei.im/posts/github-action-guide/)\n\n[GitHub Actions 第11天：密码（Secrets）](https://qiwihui.com/qiwihui-blog-94/)\n\n[请在该页面检索action](https://qiwihui.com/archives/)\n\n[github action 在线进行调试](https://www.chenshaowen.com/blog/a-debugger-for-actions.html#3-%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8-debugger-action)","slug":"综合/Github Action学习CI:CD自动化","published":1,"date":"2023-02-26T15:28:35.057Z","updated":"2023-02-27T11:34:33.138Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsyck001j0gcnhdb1ojph","content":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>GitHub Actions是GitHub 官方出品的持续集成工具，非常优秀的 CI/CD 工具。</p>\n<p>在软件工程中，CI/CD或CICD通常指的是持续集成和持续交付或持续部署的组合实践。</p>\n<h3 id=\"简单来说\"><a href=\"#简单来说\" class=\"headerlink\" title=\"简单来说\"></a><strong>简单来说</strong></h3><p>就是一个自动化来对提交的代码进行打包，集成，运维部署，测试，同步等操作。</p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>支持平台很多</p>\n<p>Github支持自建容器</p>\n<p>支持基于事件触发：push / issue 创建 / PR 提交都可以触发，完全可以基于此完成一套自动化维护项目的流程。</p>\n<h3 id=\"概念-术语\"><a href=\"#概念-术语\" class=\"headerlink\" title=\"概念/术语\"></a>概念/术语</h3><ol>\n<li>Workflow：GitHub 是对一次 CI/CD 的过程定义为 Workflow，中间可能经历过代码拉取，编译，测试，打包，发布，通知等多个过程。</li>\n<li>Action： 一个独立的运行任务，多个 Action 组成 steps 来创建一个 Job。一组 Action（Actions） 逻辑相同就可以被复用，可以发布到 Actions Marketplace 供他人使用。</li>\n<li>Steps：一个多个 Actions 形成的步骤。一个 step 可以只是一个命令，也可以是一个 Action。</li>\n<li>Job：Steps 中的 Action 一个一个走完就完成了一个 Job。Job 下的所有 step 是运行在同一个容器中的，所以可以共享文件系统。</li>\n<li>Workflow File：Workflow 的配置文件，yaml 格式。GitHub 规定需要存放在 <code>{$REPO_HOME}/.github/workflow/</code>。</li>\n</ol>\n<h1 id=\"demo讲解\"><a href=\"#demo讲解\" class=\"headerlink\" title=\"demo讲解\"></a>demo讲解</h1><h3 id=\"action与step结构\"><a href=\"#action与step结构\" class=\"headerlink\" title=\"action与step结构\"></a>action与step结构</h3><ul>\n<li>step会一个接着一个依次执行</li>\n<li>step可以直接引入其他开发者的开源插件</li>\n<li>step也可以是一段命令</li>\n</ul>\n<pre class=\"line-numbers language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> github pages <span class=\"token comment\" spellcheck=\"true\"># 工作流的名称</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 触发工作流的事件 Event 下面设置的是当 push 到 source 分支后触发</span>\n<span class=\"token comment\" spellcheck=\"true\"># 其他的事件还有：pull_request/page_build/release</span>\n<span class=\"token comment\" spellcheck=\"true\"># 可参考：https://help.github.com/en/actions/reference/events-that-trigger-workflows</span>\n<span class=\"token key atrule\">on</span><span class=\"token punctuation\">:</span>    \n  <span class=\"token key atrule\">push</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">branches</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> source\n\n<span class=\"token comment\" spellcheck=\"true\"># jobs 即工作流中的执行任务</span>\n<span class=\"token key atrule\">jobs</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">build-deploy</span><span class=\"token punctuation\">:</span> <span class=\"token comment\" spellcheck=\"true\"># job-id</span>\n    <span class=\"token key atrule\">runs-on</span><span class=\"token punctuation\">:</span> ubuntu<span class=\"token punctuation\">-</span><span class=\"token number\">18.04 </span><span class=\"token comment\" spellcheck=\"true\"># 容器环境</span>\n    <span class=\"token comment\" spellcheck=\"true\"># needs: other-job 如果有依赖其他的 job 可以如此配置</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># 任务步骤集合</span>\n    <span class=\"token key atrule\">steps</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Checkout    <span class=\"token comment\" spellcheck=\"true\"># 步骤名称</span>\n      <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> actions/checkout@v2    <span class=\"token comment\" spellcheck=\"true\"># 引用可重用的 actions，比如这个就是 GitHub 官方的用于拉取代码的actions `@` 后面可以跟指定的分支或者 release 的版本或者特定的commit</span>\n      <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>    <span class=\"token comment\" spellcheck=\"true\"># 当前 actions 的一些配置</span>\n        <span class=\"token key atrule\">submodules</span><span class=\"token punctuation\">:</span> <span class=\"token boolean important\">true </span><span class=\"token comment\" spellcheck=\"true\"># 如果项目有依赖 Git 子项目时可以设为 true，拉取的时候会一并拉取下来</span>\n\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Setup Hugo\n      <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> peaceiris/actions<span class=\"token punctuation\">-</span>hugo@v2    <span class=\"token comment\" spellcheck=\"true\"># 这也是一个开源的 actions 用于安装 Hugo</span>\n      <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">hugo-version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'latest'</span>\n        <span class=\"token comment\" spellcheck=\"true\"># extended: true</span>\n\n        <span class=\"token comment\" spellcheck=\"true\"># 单运行命令</span>\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Build\n      <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span> hugo <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>minify <span class=\"token comment\" spellcheck=\"true\"># 一个 step 也可以直接用 run 执行命令。如果有多个命令可以如下使用</span>\n      <span class=\"token comment\" spellcheck=\"true\">#run: |</span><span class=\"token scalar string\">\n            #npm ci\n            #npm run build</span>\n\n    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Deploy\n      <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> peaceiris/actions<span class=\"token punctuation\">-</span>gh<span class=\"token punctuation\">-</span>pages@v3 <span class=\"token comment\" spellcheck=\"true\"># 开源 actions 用于部署</span>\n      <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">github_token</span><span class=\"token punctuation\">:</span> $<span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span> secrets.GITHUB_TOKEN<span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span> <span class=\"token comment\" spellcheck=\"true\"># GitHub 读写仓库的权限token，自动生成无需关心</span>\n        <span class=\"token key atrule\">publish_branch</span><span class=\"token punctuation\">:</span> master<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"1-github每个yml文件对应一个action\"><a href=\"#1-github每个yml文件对应一个action\" class=\"headerlink\" title=\"1. github每个yml文件对应一个action\"></a>1. github每个yml文件对应一个action</h3><pre><code>. .github目录\n└── workflows\n    ├── action.yml\n    └── action2.yml\n</code></pre><ul>\n<li>每个文件对应一个action</li>\n<li>支持同时运行多个action</li>\n</ul>\n<p>![image-20230226162215015](/Users/lwl/Library/Application Support/typora-user-images/image-20230226162215015.png)</p>\n<h3 id=\"2-事件触发器\"><a href=\"#2-事件触发器\" class=\"headerlink\" title=\"2. 事件触发器\"></a>2. 事件触发器</h3><ul>\n<li>可以通过指定事件来触发工作流程</li>\n</ul>\n<pre><code>on:\n  push:\n    branches: # 指定以master 分支或名称 以 releases/ 开头的分支 \n    - master  \n    - &#39;releases/**&#39;\n    paths: # 仅仅docs目录下面的改变才会触发\n    - &#39;docs/**&#39;\n  pull_request: # 指定新的pull request\n    branches:\n    - master\n    - &#39;releases/**&#39;</code></pre><h3 id=\"3-矩阵参数组合执行\"><a href=\"#3-矩阵参数组合执行\" class=\"headerlink\" title=\"3.矩阵参数组合执行\"></a>3.矩阵参数组合执行</h3><p>很多时候对于一些复杂环境，例如我这里有一个服务器。然后里面有许多参数组合不同，我想要组合执行一遍。</p>\n<p>那么可以用这个方案</p>\n<pre><code>name: CI\n\non: [push]\n\njobs:    \n  build:\n    runs-on: ubuntu-latest\n\n    strategy:    \n      matrix:\n        cc: [gcc, clang]\n        curl: [openssl, gnutls, nss]\n        kerberos: [libkrb5, heimdal]\n\n    steps:\n    - name: Install dependencies\n      run: |\n        sudo apt-get update\n        sudo apt-get install -y ${{ matrix.cc }} \\\n                                libcurl4-${{ matrix.curl }}-dev \\\n                                ${{ matrix.kerberos }}-dev\n    - name: Display Configuration\n      run: |\n        echo &quot;C Compiler:&quot;\n        ${CC} --version\n        echo &quot;&quot;\n        echo &quot;Curl configuration:&quot;\n        curl-config --ssl-backends --version\n        echo &quot;&quot;\n        echo &quot;Kerberos configuration:&quot;\n        krb5-config --all\n      env:\n        CC: ${{ matrix.cc }}\n\n    - name: Checkout\n      uses: actions/checkout@v1\n\n    - name: Build\n      run: ./configure &amp;&amp; make test</code></pre><p>结果，执行的时候会自动替换成相应的变量</p>\n<p><img src=\"https://user-images.githubusercontent.com/3297411/77169169-07952200-6af4-11ea-8770-f381ddfaa7eb.png\" alt=\"image\"></p>\n<h3 id=\"4-平台指定\"><a href=\"#4-平台指定\" class=\"headerlink\" title=\"4.平台指定\"></a>4.平台指定</h3><p>以下面的代码为例，就指定了多个平台分别作为一个job，执行代码检查任务</p>\n<pre><code># test\nname: CI\n\non: [push]\n\njobs: #可以有多个job\n  linux:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout\n      uses: actions/checkout@v1\n    - name: Build\n      run: make\n\n  windows:\n    runs-on: windows-latest\n    steps:\n    - name: Checkout\n      uses: actions/checkout@v1\n    - name: Build\n      run: make\n\n  macos:\n    runs-on: macos-latest\n    steps:\n    - name: Checkout\n      uses: actions/checkout@v1\n    - name: Build\n      run: make\n</code></pre><h3 id=\"5-run命令，同时运行多行\"><a href=\"#5-run命令，同时运行多行\" class=\"headerlink\" title=\"5. run命令，同时运行多行\"></a>5. run命令，同时运行多行</h3><p>run可以执行命令，支持同时运行多行</p>\n<pre><code>name: CI\n\non: [push]\n\njobs: #可以有多个job\n  linux:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v1\n      - name: Build\n        run: make\n        run: |  #同时运行多行\n          npm ci\n          npm run build\n          npm test</code></pre><p><strong>注意！！！</strong></p>\n<p><strong>注意，如果在一个 step 中 cd 到某个目录下，那么后续的 step 是不受影响的，还是在原来的目录中。</strong></p>\n<h3 id=\"6-Github密码\"><a href=\"#6-Github密码\" class=\"headerlink\" title=\"6.Github密码\"></a>6.Github密码</h3><h5 id=\"6-1-可以自己设置一些变量\"><a href=\"#6-1-可以自己设置一些变量\" class=\"headerlink\" title=\"6.1 可以自己设置一些变量\"></a>6.1 可以自己设置一些变量</h5><p>![image-20230226193445352](/Users/lwl/Library/Application Support/typora-user-images/image-20230226193445352.png)</p>\n<p>要使用该密码，你可以在工作流中使用上下文 <code>secrets</code> 来引用它。如果你有一个密码的名字 <code>SECRET_KEY</code>，你可以将其称为 <code>$</code>。</p>\n<pre class=\"line-numbers language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Publish Documentation\n\n\n<span class=\"token key atrule\">on</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">push</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">branches</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> master\n\n\n<span class=\"token key atrule\">jobs</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">build</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Build\n    <span class=\"token key atrule\">runs-on</span><span class=\"token punctuation\">:</span> ubuntu<span class=\"token punctuation\">-</span>latest\n    <span class=\"token key atrule\">steps</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">|</span><span class=\"token scalar string\">\n          VERSION=$(date +%s)\n          docker login -u ethomson -p ${{ secrets.SECRET_KEY }}\n          docker build . --file Dockerfile --tag ethomson/app:${VERSION}\n          docker push ethomson/app:${VERSION}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h5 id=\"GITHUB-TOKEN\"><a href=\"#GITHUB-TOKEN\" class=\"headerlink\" title=\"GITHUB_TOKEN\"></a><strong><code>GITHUB_TOKEN</code></strong></h5><p>GitHub Actions会为每次运行的工作流<strong>自动在存储库中设置一个密码 <code>GITHUB_TOKEN</code>。该令牌使你可以与存储库进行交互，而无需自己创建新令牌或设置密码。</strong></p>\n<p>该令牌为你提供了对存储库本身，issue和<a href=\"https://www.edwardthomson.com/blog/github_actions_9_deploy_to_github_packages.html\" target=\"_blank\" rel=\"noopener\">GitHub Packages</a>进行读写的有限访问权限。但是它不能完全访问所有内容──你无法与组织中的其他存储库一起使用，也无法发布到GitHub Pages──因此，对于某些工作流，你可能仍需要设置令牌。</p>\n<h3 id=\"7-缓存\"><a href=\"#7-缓存\" class=\"headerlink\" title=\"7. 缓存\"></a>7. 缓存</h3><p>在很多情况下，我们会需要用到缓存，例如node的一大堆库，如果每次都去下载就太耗时了。非常没必要。</p>\n<p>可以选择使用缓存</p>\n<pre><code>      # 3. 安装nodejs\n      - name: Set node version to ${{ matrix.node_version }}\n        uses: actions/setup-node@v2\n        with:\n          node-version: ${{ matrix.node_version }}\n          cache: &quot;npm&quot; # 缓存\n          cache-dependency-path: package-lock.json</code></pre><p>![image-20230227171954386](/Users/lwl/Library/Application Support/typora-user-images/image-20230227171954386.png)</p>\n<h1 id=\"Github-Action在线调试配置\"><a href=\"#Github-Action在线调试配置\" class=\"headerlink\" title=\"Github Action在线调试配置\"></a>Github Action在线调试配置</h1><pre><code>name: buildx\non:\n  push:\n    branches: [ master ]\n\njobs:\n  hello:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v1\n      - uses: shaowenchen/debugger-action@v1\n        name: debugger\n        timeout-minutes: 30\n        continue-on-error: true\n        with:\n          frp_server_addr: ${{ secrets.FRP_SERVER_ADDR }}\n          frp_server_port: ${{ secrets.FRP_SERVER_PORT }}\n          frp_token: ${{ secrets.FRP_TOKEN }}\n          ssh_port: 29001\n</code></pre><p>我的本地环境</p>\n<pre><code>      - uses: shaowenchen/debugger-action@v1\n        name: debugger\n        timeout-minutes: 30\n        continue-on-error: true\n        with:\n          frp_server_addr: 110.40.204.239\n          frp_server_port: 7000\n          frp_token: 123456\n          ssh_port: 29001\n</code></pre><p>连接</p>\n<pre><code>ssh root@frp_server_addr -p ssh_port </code></pre><p>输入 root 密码: root</p>\n<p><strong>说明</strong></p>\n<ul>\n<li>进去后默认额目录是<code>/home/runner</code></li>\n<li>一般下载的目录包，也就是我们的执行程序在<code>work</code>目录下面</li>\n</ul>\n<pre><code>/home/runner/work/kengerlwl.github.io/kengerlwl.github.io</code></pre><p>测试</p>\n<pre><code>\ncat public/index.html</code></pre><h1 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h1><p><a href=\"https://blog.xiaohei.im/posts/github-action-guide/\" target=\"_blank\" rel=\"noopener\">使用 GitHub Action 持续集成你的博客</a></p>\n<p><a href=\"https://qiwihui.com/qiwihui-blog-94/\" target=\"_blank\" rel=\"noopener\">GitHub Actions 第11天：密码（Secrets）</a></p>\n<p><a href=\"https://qiwihui.com/archives/\" target=\"_blank\" rel=\"noopener\">请在该页面检索action</a></p>\n<p><a href=\"https://www.chenshaowen.com/blog/a-debugger-for-actions.html#3-%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8-debugger-action\" target=\"_blank\" rel=\"noopener\">github action 在线进行调试</a></p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>GitHub Actions是GitHub 官方出品的持续集成工具，非常优秀的 CI/CD 工具。</p>\n<p>在软件工程中，CI/CD或CICD通常指的是持续集成和持续交付或持续部署的组合实践。</p>\n<h3 id=\"简单来说\"><a href=\"#简单来说\" class=\"headerlink\" title=\"简单来说\"></a><strong>简单来说</strong></h3><p>就是一个自动化来对提交的代码进行打包，集成，运维部署，测试，同步等操作。</p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>支持平台很多</p>\n<p>Github支持自建容器</p>\n<p>支持基于事件触发：push / issue 创建 / PR 提交都可以触发，完全可以基于此完成一套自动化维护项目的流程。</p>\n<h3 id=\"概念-术语\"><a href=\"#概念-术语\" class=\"headerlink\" title=\"概念/术语\"></a>概念/术语</h3><ol>\n<li>Workflow：GitHub 是对一次 CI/CD 的过程定义为 Workflow，中间可能经历过代码拉取，编译，测试，打包，发布，通知等多个过程。</li>\n<li>Action： 一个独立的运行任务，多个 Action 组成 steps 来创建一个 Job。一组 Action（Actions） 逻辑相同就可以被复用，可以发布到 Actions Marketplace 供他人使用。</li>\n<li>Steps：一个多个 Actions 形成的步骤。一个 step 可以只是一个命令，也可以是一个 Action。</li>\n<li>Job：Steps 中的 Action 一个一个走完就完成了一个 Job。Job 下的所有 step 是运行在同一个容器中的，所以可以共享文件系统。</li>\n<li>Workflow File：Workflow 的配置文件，yaml 格式。GitHub 规定需要存放在 <code>{$REPO_HOME}/.github/workflow/</code>。</li>\n</ol>\n<h1 id=\"demo讲解\"><a href=\"#demo讲解\" class=\"headerlink\" title=\"demo讲解\"></a>demo讲解</h1><h3 id=\"action与step结构\"><a href=\"#action与step结构\" class=\"headerlink\" title=\"action与step结构\"></a>action与step结构</h3><ul>\n<li>step会一个接着一个依次执行</li>\n<li>step可以直接引入其他开发者的开源插件</li>\n<li>step也可以是一段命令</li>\n</ul>\n<pre><code class=\"yaml\">name: github pages # 工作流的名称\n\n# 触发工作流的事件 Event 下面设置的是当 push 到 source 分支后触发\n# 其他的事件还有：pull_request/page_build/release\n# 可参考：https://help.github.com/en/actions/reference/events-that-trigger-workflows\non:    \n  push:\n    branches:\n    - source\n\n# jobs 即工作流中的执行任务\njobs:\n  build-deploy: # job-id\n    runs-on: ubuntu-18.04 # 容器环境\n    # needs: other-job 如果有依赖其他的 job 可以如此配置\n\n    # 任务步骤集合\n    steps:\n    - name: Checkout    # 步骤名称\n      uses: actions/checkout@v2    # 引用可重用的 actions，比如这个就是 GitHub 官方的用于拉取代码的actions `@` 后面可以跟指定的分支或者 release 的版本或者特定的commit\n      with:    # 当前 actions 的一些配置\n        submodules: true # 如果项目有依赖 Git 子项目时可以设为 true，拉取的时候会一并拉取下来\n\n    - name: Setup Hugo\n      uses: peaceiris/actions-hugo@v2    # 这也是一个开源的 actions 用于安装 Hugo\n      with:\n        hugo-version: &#39;latest&#39;\n        # extended: true\n\n        # 单运行命令\n    - name: Build\n      run: hugo --minify # 一个 step 也可以直接用 run 执行命令。如果有多个命令可以如下使用\n      #run: |\n            #npm ci\n            #npm run build\n\n    - name: Deploy\n      uses: peaceiris/actions-gh-pages@v3 # 开源 actions 用于部署\n      with:\n        github_token: ${{ secrets.GITHUB_TOKEN}} # GitHub 读写仓库的权限token，自动生成无需关心\n        publish_branch: master</code></pre>\n<h3 id=\"1-github每个yml文件对应一个action\"><a href=\"#1-github每个yml文件对应一个action\" class=\"headerlink\" title=\"1. github每个yml文件对应一个action\"></a>1. github每个yml文件对应一个action</h3><pre><code>. .github目录\n└── workflows\n    ├── action.yml\n    └── action2.yml\n</code></pre><ul>\n<li>每个文件对应一个action</li>\n<li>支持同时运行多个action</li>\n</ul>\n<p>![image-20230226162215015](/Users/lwl/Library/Application Support/typora-user-images/image-20230226162215015.png)</p>\n<h3 id=\"2-事件触发器\"><a href=\"#2-事件触发器\" class=\"headerlink\" title=\"2. 事件触发器\"></a>2. 事件触发器</h3><ul>\n<li>可以通过指定事件来触发工作流程</li>\n</ul>\n<pre><code>on:\n  push:\n    branches: # 指定以master 分支或名称 以 releases/ 开头的分支 \n    - master  \n    - &#39;releases/**&#39;\n    paths: # 仅仅docs目录下面的改变才会触发\n    - &#39;docs/**&#39;\n  pull_request: # 指定新的pull request\n    branches:\n    - master\n    - &#39;releases/**&#39;</code></pre><h3 id=\"3-矩阵参数组合执行\"><a href=\"#3-矩阵参数组合执行\" class=\"headerlink\" title=\"3.矩阵参数组合执行\"></a>3.矩阵参数组合执行</h3><p>很多时候对于一些复杂环境，例如我这里有一个服务器。然后里面有许多参数组合不同，我想要组合执行一遍。</p>\n<p>那么可以用这个方案</p>\n<pre><code>name: CI\n\non: [push]\n\njobs:    \n  build:\n    runs-on: ubuntu-latest\n\n    strategy:    \n      matrix:\n        cc: [gcc, clang]\n        curl: [openssl, gnutls, nss]\n        kerberos: [libkrb5, heimdal]\n\n    steps:\n    - name: Install dependencies\n      run: |\n        sudo apt-get update\n        sudo apt-get install -y ${{ matrix.cc }} \\\n                                libcurl4-${{ matrix.curl }}-dev \\\n                                ${{ matrix.kerberos }}-dev\n    - name: Display Configuration\n      run: |\n        echo &quot;C Compiler:&quot;\n        ${CC} --version\n        echo &quot;&quot;\n        echo &quot;Curl configuration:&quot;\n        curl-config --ssl-backends --version\n        echo &quot;&quot;\n        echo &quot;Kerberos configuration:&quot;\n        krb5-config --all\n      env:\n        CC: ${{ matrix.cc }}\n\n    - name: Checkout\n      uses: actions/checkout@v1\n\n    - name: Build\n      run: ./configure &amp;&amp; make test</code></pre><p>结果，执行的时候会自动替换成相应的变量</p>\n<p><img src=\"https://user-images.githubusercontent.com/3297411/77169169-07952200-6af4-11ea-8770-f381ddfaa7eb.png\" alt=\"image\"></p>\n<h3 id=\"4-平台指定\"><a href=\"#4-平台指定\" class=\"headerlink\" title=\"4.平台指定\"></a>4.平台指定</h3><p>以下面的代码为例，就指定了多个平台分别作为一个job，执行代码检查任务</p>\n<pre><code># test\nname: CI\n\non: [push]\n\njobs: #可以有多个job\n  linux:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout\n      uses: actions/checkout@v1\n    - name: Build\n      run: make\n\n  windows:\n    runs-on: windows-latest\n    steps:\n    - name: Checkout\n      uses: actions/checkout@v1\n    - name: Build\n      run: make\n\n  macos:\n    runs-on: macos-latest\n    steps:\n    - name: Checkout\n      uses: actions/checkout@v1\n    - name: Build\n      run: make\n</code></pre><h3 id=\"5-run命令，同时运行多行\"><a href=\"#5-run命令，同时运行多行\" class=\"headerlink\" title=\"5. run命令，同时运行多行\"></a>5. run命令，同时运行多行</h3><p>run可以执行命令，支持同时运行多行</p>\n<pre><code>name: CI\n\non: [push]\n\njobs: #可以有多个job\n  linux:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v1\n      - name: Build\n        run: make\n        run: |  #同时运行多行\n          npm ci\n          npm run build\n          npm test</code></pre><p><strong>注意！！！</strong></p>\n<p><strong>注意，如果在一个 step 中 cd 到某个目录下，那么后续的 step 是不受影响的，还是在原来的目录中。</strong></p>\n<h3 id=\"6-Github密码\"><a href=\"#6-Github密码\" class=\"headerlink\" title=\"6.Github密码\"></a>6.Github密码</h3><h5 id=\"6-1-可以自己设置一些变量\"><a href=\"#6-1-可以自己设置一些变量\" class=\"headerlink\" title=\"6.1 可以自己设置一些变量\"></a>6.1 可以自己设置一些变量</h5><p>![image-20230226193445352](/Users/lwl/Library/Application Support/typora-user-images/image-20230226193445352.png)</p>\n<p>要使用该密码，你可以在工作流中使用上下文 <code>secrets</code> 来引用它。如果你有一个密码的名字 <code>SECRET_KEY</code>，你可以将其称为 <code>$</code>。</p>\n<pre><code class=\"yaml\">name: Publish Documentation\n\n\non:\n  push:\n    branches:\n    - master\n\n\njobs:\n  build:\n    name: Build\n    runs-on: ubuntu-latest\n    steps:\n      - run: |\n          VERSION=$(date +%s)\n          docker login -u ethomson -p ${{ secrets.SECRET_KEY }}\n          docker build . --file Dockerfile --tag ethomson/app:${VERSION}\n          docker push ethomson/app:${VERSION}</code></pre>\n<h5 id=\"GITHUB-TOKEN\"><a href=\"#GITHUB-TOKEN\" class=\"headerlink\" title=\"GITHUB_TOKEN\"></a><strong><code>GITHUB_TOKEN</code></strong></h5><p>GitHub Actions会为每次运行的工作流<strong>自动在存储库中设置一个密码 <code>GITHUB_TOKEN</code>。该令牌使你可以与存储库进行交互，而无需自己创建新令牌或设置密码。</strong></p>\n<p>该令牌为你提供了对存储库本身，issue和<a href=\"https://www.edwardthomson.com/blog/github_actions_9_deploy_to_github_packages.html\" target=\"_blank\" rel=\"noopener\">GitHub Packages</a>进行读写的有限访问权限。但是它不能完全访问所有内容──你无法与组织中的其他存储库一起使用，也无法发布到GitHub Pages──因此，对于某些工作流，你可能仍需要设置令牌。</p>\n<h3 id=\"7-缓存\"><a href=\"#7-缓存\" class=\"headerlink\" title=\"7. 缓存\"></a>7. 缓存</h3><p>在很多情况下，我们会需要用到缓存，例如node的一大堆库，如果每次都去下载就太耗时了。非常没必要。</p>\n<p>可以选择使用缓存</p>\n<pre><code>      # 3. 安装nodejs\n      - name: Set node version to ${{ matrix.node_version }}\n        uses: actions/setup-node@v2\n        with:\n          node-version: ${{ matrix.node_version }}\n          cache: &quot;npm&quot; # 缓存\n          cache-dependency-path: package-lock.json</code></pre><p>![image-20230227171954386](/Users/lwl/Library/Application Support/typora-user-images/image-20230227171954386.png)</p>\n<h1 id=\"Github-Action在线调试配置\"><a href=\"#Github-Action在线调试配置\" class=\"headerlink\" title=\"Github Action在线调试配置\"></a>Github Action在线调试配置</h1><pre><code>name: buildx\non:\n  push:\n    branches: [ master ]\n\njobs:\n  hello:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v1\n      - uses: shaowenchen/debugger-action@v1\n        name: debugger\n        timeout-minutes: 30\n        continue-on-error: true\n        with:\n          frp_server_addr: ${{ secrets.FRP_SERVER_ADDR }}\n          frp_server_port: ${{ secrets.FRP_SERVER_PORT }}\n          frp_token: ${{ secrets.FRP_TOKEN }}\n          ssh_port: 29001\n</code></pre><p>我的本地环境</p>\n<pre><code>      - uses: shaowenchen/debugger-action@v1\n        name: debugger\n        timeout-minutes: 30\n        continue-on-error: true\n        with:\n          frp_server_addr: 110.40.204.239\n          frp_server_port: 7000\n          frp_token: 123456\n          ssh_port: 29001\n</code></pre><p>连接</p>\n<pre><code>ssh root@frp_server_addr -p ssh_port </code></pre><p>输入 root 密码: root</p>\n<p><strong>说明</strong></p>\n<ul>\n<li>进去后默认额目录是<code>/home/runner</code></li>\n<li>一般下载的目录包，也就是我们的执行程序在<code>work</code>目录下面</li>\n</ul>\n<pre><code>/home/runner/work/kengerlwl.github.io/kengerlwl.github.io</code></pre><p>测试</p>\n<pre><code>\ncat public/index.html</code></pre><h1 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h1><p><a href=\"https://blog.xiaohei.im/posts/github-action-guide/\" target=\"_blank\" rel=\"noopener\">使用 GitHub Action 持续集成你的博客</a></p>\n<p><a href=\"https://qiwihui.com/qiwihui-blog-94/\" target=\"_blank\" rel=\"noopener\">GitHub Actions 第11天：密码（Secrets）</a></p>\n<p><a href=\"https://qiwihui.com/archives/\" target=\"_blank\" rel=\"noopener\">请在该页面检索action</a></p>\n<p><a href=\"https://www.chenshaowen.com/blog/a-debugger-for-actions.html#3-%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8-debugger-action\" target=\"_blank\" rel=\"noopener\">github action 在线进行调试</a></p>\n"},{"_content":"# docker 学习与使用\n\n## docker介绍\nDocker：容器，可以理解成一个“黑盒”。在项目变得庞大以后，往往我们会疲于管理整个项目的部署和维护。如果我们将整个项目用一个“容器”装起来，那么我们仅仅只用维护一个配置文件告诉计算机每次部署要把什么东西装进“容器”，甚至借用一些工具把这个过程自动化，部署就会变得很方便。\n\n### docker 结构\nDocker 包含三个基本概念，分别是镜像（Image）、容器（Container）和仓库（Repository）。镜像是 Docker 运行容器的前提，仓库是存放镜像的场所，可见镜像更是Docker的核心。\n\n## docker安装\n\n- windows直接去官网下载应用程序\n- linux可以直接用包管理工具下载安装包\n\n\n## docker的配置\n\n先在项目下创建一个文件`Dockerfile`。\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/ebe096f1da2738297e7b6413ebbe2ee8.png)\n\n编辑`Dockerfile`文件：\n`Dockerfile`文件的详解[link](https://blog.csdn.net/qq_39626154/article/details/82787528)\n我这里以一个flask项目为例。运行hello程序在`./app/test.py`\n```\n#基于的基础镜像\nFROM python:3.7.9\n#代码添加到flaskhello文件夹\nADD . /flaskhello\n# 设置flaskhello文件夹是工作目录\nWORKDIR /flaskhello\n\n\n# 安装支持,安装依赖文件，执行前置，可以执行很多命令。\nRUN pip install -r requirements.txt\nCMD [\"python\", \"./app/test.py\"]  #最后运行的启动命令\n```\n\n**Dockerfile详解**\n```\ndockerfile常用命令\nFROM：基础镜像，FROM命令必须是dockfile的首个命令\nLABEL：为镜像生成元数据标签信息。\nUSER：指定运行容器时的用户名或UID，后续RUN也会使用指定用户\nRUN：RUN命令是Dockfile执行命令的核心部分。它接受命令作为参数并用于创建镜像。每条RUN命令在当前镜像基础上执行，并且会提交一个新镜像层。\nWORKDIR：设置CMD指明的命令的运行目录。为后续的RUN、CMD、ENTRYPOINT、ADD指令配置工作目录。\nENV：容器启动的环境变量\nARG：构建环境的环境变量\nCOPY：复制文件到镜像中,格式： COPY 源路径 目标路径 ：COPY指令和ADD指令功能和使用方式类似。只是COPY指令不会做自动解压工作。\nADD： 拷复制文件到镜像中,格式： ADD 源路径 目标路径\nCMD：容器运行时执行的默认命令\nENTRYPOINT：指定容器的“入口”\nHEALTHCHECK：容器健康状态检查\n```\n\n**关于CMD命令**：\n一定要使得该命令运行后保持前台，否则容器就会自动关闭。这是docker容器本质上是进程的概念\n\n## 构建镜像与运行\n\n构建：\n```\n\n# 先跳转到项目根文件目录下（也就是含有Dockerfile的文件目录下）\ndocker build -t dockerdemo:v1 . # 最后一个.实际指定当前的构建目录，dockerdemo(注意只能用小写)是该docker的名字,v1是tag\n```\n结果\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/1dd8e2ef74b08c85edaff3ce485a9f8b.png)\n\n\n\n运行\n```\n# 3000是你要映射到服务器上的端口，5000是容器里面需要被映射出来的端口，demo:v1 是需要运行的容器\ndocker run -p 3000:5000 demo:v1\n\n```\n\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/938487a0270762fa06ef9dd805703815.png)\n\n访问\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/6a0342a07e2f7e40cc52440c80091133.png)\n\n\n## 容器的管理\n\n\n删除不需要的镜像，和容器\n\n查看所有的容器\n```\ndocker ps -a\n```\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/fa18eadc8f8e7155bd9f2cc67aa308de.png)\n\n\n停止和删除容器\n```\n#如何停止容器\ndocker stop + 容器id\n# 删除容器id\ndocker rm + 容器id\n\n```\n\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/11454b741864a4a26be4f6f7550d5187.png)\n\n\n要先把镜像的容器都关了，才能删除相关镜像\n\n查看当前有哪些镜像\n```\ndocker images # 查看所有镜像及其信息\n\ndocker images -q  # 输出所有镜像的id\n```\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/edb762924a89a9174f15ad4eff34b4ca.png)\n\n删除镜像\n删除images（镜像），通过image的id来指定删除谁\n```\ndocker rmi <image id>\n```\n要删除全部image（镜像）的话\n```\ndocker rmi $(docker images -q)\n```\n只删除未被使用的资源\n- Docker 提供了方便的 docker system prune 命令来删除那些已停止的容器、dangling 镜像、未被容器引用的 network 和构建过程中的 cache：\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/98587da7500a3158d54cd67bfc4fb1aa.png)\n\n\n在本地的镜像更新之后，就会出现类似图中红框内的 <none> 镜像。这表示旧的镜像已经不再被引用了，此时它们就变成了 dangling images。如果使用 -a 参数，你还会发现另外一种类型的 <none> 镜像，它们的 repository 和 tag 列都表现为 <none>：\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/fa2ce9e682aa051bef2a1ef757d8f6ff.png)\n    这些镜像被称为 intermediate 镜像(就是其它镜像依赖的层)。\n\n**我们还可在不同在子命令下执行 prune，这样删除的就是某类资源：**\n```\ndocker container prune # 删除所有退出状态的容器\ndocker volume prune # 删除未被使用的数据卷\ndocker image prune # 删除 dangling 或所有未被使用的镜像\n```\n\n\n\n\n\n## 容器的网络模式\n[参考文](https://www.cnblogs.com/feng0815/p/14192177.html)\n    \n\n### 关于docker的端口映射增改问题。\n\n一般来说，在镜像运行成容器后就不能再更改端口映射了，并且下次启动原来的映射配置也在。\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/4c63fcb2c8fe102955cc0ad9140dd734.png)\n\n想要改变两个办法。\n**法一：**\n    更改配置docker文件，具体上网查询\n**法二：**\n    把现在的容器commit成镜像，然后再把镜像运行成容器，并且在运行的时候声明端口映射。\n\n## 进入容器内部\n好文的连接[link](https://cloud.tencent.com/developer/article/1691352)\n    \n    \n### 1,新建centos的镜像和容器。\n```\ndocker pull centos\n```\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/3ce9b6dbbc468ae90b1064260374b386.png)\n\n### 2,对这个镜像创建容器（也就是说运行它）\n\n    docker container run -it -p 8888:8080 -v /opt/app:/opt/app --name=python-server 470671670cac bash\n\n命令文档查看：docker container run --help\n\n-it : 交互式终端（interactive terminal） ，也就是创建容器后进入容器。\n\n-p 8888:8080 :  端口映射（port），将容器端口映射到宿主机端口（8888：宿主机端口，8080：容器端口），宿主机端口 8888 确认能被外网访问。\n\n-v /opt/app:/opt/app：数据卷（volumn），将宿主机的数据（应用程序代码，配置文件等等）挂载到容器指定路径下，实现数据存储的持久化（如果没有数据挂载的话，容器销毁，容器中的数据会自动消失）。\n\n--name=python-server: 新的容器的名称\n\n 470671670cac：镜像ID（imageID），当然也可以是 imageName + tag（docker.io/centos:latest）\n\nbash：跟 -it 命令结合在一起操作，使容器创建后处于前端，一般是 /bin/bash，我这是bash。\n    \n结果：\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/45ca190d5f75ee947bc815474dd06af7.png)\n\n查看所有容器\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/7bd6c5162f6f969d5ee8377a9ac7e86d.png)\n\n**不中断退出容器**\n可以通过 Ctrl+p，Ctrl+q 退出容器，但容器还是处于运行状态（Up）。\n或者输入命令`exit`可以直接退出，但是容器也关闭了\n\n\n#### 查看容器的信息（例如ip等）\n`docker inspect container_id`\n\n然后有结果\n\n\n![image-20220821221517801](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/c267da1bddcfbf8c21c0375ef8dea4a6.png)    \n### 进入容器\n\n**方法一**\n`docker container exec -it 5de4e81a2e20(containerID或者容器的名字) bash（这个bash可以换成其他命令）`\n\n执行命令的方式：\n- 先启动容器\n- 然后使用exec命令去执行命令\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/18d30748b5631941cae418fdc85bd5f3.png)\n\n\n其他容器命令\n```\n容器其他相关操作命令：\n\n查看容器 ip（退出容器，在宿主机上，最好另起一个客户端）: docker container inspect  1427087a62a7（containerID）\n\n\n容器启动（交互式）：docker container start  -i containerID\n\n关闭容器：docker container stop containerID\n\n容器重启动：docker container restart containerID\n\n删除容器（-f : force 强制删除，能删除处于运行状态的容器）：docker container rm -f  containerID\n\n查看所有容器的容器ID：docker container ls -a -q\n\n删除所有容器：docker contianer rm $(docker container ls -a -q)\n\n在交互式容器中退出，退出启动容器： Ctrl + d\n\n在交互式容器中退出，但是不退出启动容器：先按 Ctrl + p 后 Ctrl + q\n\n使用 -d 启动容器并一直在后台运行 SSH作为第一进程启动：docker container run -d -p 50001:22 imageID /usr/sbin/sshd -D \n```\n\n\n​    \n### 容器内的使用\n\n我这里用的centos最新版也就是centos8.\n执行yum有个bug:`Failed to download metadata for repo 'appstream......`\n办法是进入容器执行\n```\ncd /etc/yum.repos.d/\nsed -i 's/mirrorlist/#mirrorlist/g' /etc/yum.repos.d/CentOS-*\nsed -i 's|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g' /etc/yum.repos.d/CentOS-* \n```\n\n然后就可以使用yum安装各种库和程序了\n    \n\n**改变系统的密码**\n```\n    安装 passwd（设置密码）： yum install -y passwd\n    设置密码：passwd root\n\n```\n\n**安装ssh并启动**\n\n```\n作为 python 服务的守护程序，防止容器闪退（一直夯在容器中）；\n\n安装命令： yum install -y openssh-server\n\nssh 配置文件 sshd_config 路径： /etc/ssh/sshd_config\n\nssh 启动文件路径：/usr/sbin/\n启动 SSH: /usr/sbin/sshd\n\n\n```\n启动前修改\n修改/etc/ssh/sshd_config这个ssh配置文件\n    \n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/ae0cd55ec6eb40ecc231bb3147e68e58.png)\n\n退出后访问\n\n\n### 将容器打包成镜像\n\n在运行容器时指定映射端口运行后，如果想要添加新的端口映射，可以使用以下两种方式：\n\n**方式一：将现有的容器打包成镜像，然后在使用新的镜像运行容器时重新指定要映射的端口**\n\n大概过程如下：\n\n先停止现有容器\n\n`docker stop container-name`\n将容器commit成为一个镜像\n\n`docker commit container-name  new-image-name`\n用新镜像运行容器\n    \n结果\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/a5336f35ba2098dc9cb5ba845c33baf3.png)\n\n然后运行新的镜像\n`docker run -it -d --name container-name（or id） -p p1:p1 -p p2:p2 new-image-name`\n\n两个 -p 指定多个端口映射\n\n**宿主机ssh连接入容器  **  \n\n我这里将外部的2020端口映射到容器里面的22端口。\n用特定的连接工具**MobaXterm**\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/6cf0b06d120b3f20740f150e072e9efd.png)\n\n然后输入用户名和密码：成功\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/d7bd208b5e78d93bd4304461bf75d008.png)\n\n## docker Hub的使用\n\n先在hub中建立一个名叫centos_demo的仓库，我的用户名是`${username}`\n\n在本地登录docker\n```\n#docker login\nLogin with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.\nUsername: ${username}\nPassword:\nLogin Succeeded\n```\n\n准备在本地提交，先给images打标签\n\n```\ndocker tag 镜像名 账号名/仓库名：版本号\n账号名是登陆的账号名，仓库是远端配置的仓库名，版本号自己定义一个就好。到时候pull下来也是pull这个账号名/仓库名：版本号就好\n```\n\n然后提交镜像push\n```\ndocker push 账号名/仓库名：版本号\n```","source":"_posts/综合/docker 使用简单教程.md","raw":"# docker 学习与使用\n\n## docker介绍\nDocker：容器，可以理解成一个“黑盒”。在项目变得庞大以后，往往我们会疲于管理整个项目的部署和维护。如果我们将整个项目用一个“容器”装起来，那么我们仅仅只用维护一个配置文件告诉计算机每次部署要把什么东西装进“容器”，甚至借用一些工具把这个过程自动化，部署就会变得很方便。\n\n### docker 结构\nDocker 包含三个基本概念，分别是镜像（Image）、容器（Container）和仓库（Repository）。镜像是 Docker 运行容器的前提，仓库是存放镜像的场所，可见镜像更是Docker的核心。\n\n## docker安装\n\n- windows直接去官网下载应用程序\n- linux可以直接用包管理工具下载安装包\n\n\n## docker的配置\n\n先在项目下创建一个文件`Dockerfile`。\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/ebe096f1da2738297e7b6413ebbe2ee8.png)\n\n编辑`Dockerfile`文件：\n`Dockerfile`文件的详解[link](https://blog.csdn.net/qq_39626154/article/details/82787528)\n我这里以一个flask项目为例。运行hello程序在`./app/test.py`\n```\n#基于的基础镜像\nFROM python:3.7.9\n#代码添加到flaskhello文件夹\nADD . /flaskhello\n# 设置flaskhello文件夹是工作目录\nWORKDIR /flaskhello\n\n\n# 安装支持,安装依赖文件，执行前置，可以执行很多命令。\nRUN pip install -r requirements.txt\nCMD [\"python\", \"./app/test.py\"]  #最后运行的启动命令\n```\n\n**Dockerfile详解**\n```\ndockerfile常用命令\nFROM：基础镜像，FROM命令必须是dockfile的首个命令\nLABEL：为镜像生成元数据标签信息。\nUSER：指定运行容器时的用户名或UID，后续RUN也会使用指定用户\nRUN：RUN命令是Dockfile执行命令的核心部分。它接受命令作为参数并用于创建镜像。每条RUN命令在当前镜像基础上执行，并且会提交一个新镜像层。\nWORKDIR：设置CMD指明的命令的运行目录。为后续的RUN、CMD、ENTRYPOINT、ADD指令配置工作目录。\nENV：容器启动的环境变量\nARG：构建环境的环境变量\nCOPY：复制文件到镜像中,格式： COPY 源路径 目标路径 ：COPY指令和ADD指令功能和使用方式类似。只是COPY指令不会做自动解压工作。\nADD： 拷复制文件到镜像中,格式： ADD 源路径 目标路径\nCMD：容器运行时执行的默认命令\nENTRYPOINT：指定容器的“入口”\nHEALTHCHECK：容器健康状态检查\n```\n\n**关于CMD命令**：\n一定要使得该命令运行后保持前台，否则容器就会自动关闭。这是docker容器本质上是进程的概念\n\n## 构建镜像与运行\n\n构建：\n```\n\n# 先跳转到项目根文件目录下（也就是含有Dockerfile的文件目录下）\ndocker build -t dockerdemo:v1 . # 最后一个.实际指定当前的构建目录，dockerdemo(注意只能用小写)是该docker的名字,v1是tag\n```\n结果\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/1dd8e2ef74b08c85edaff3ce485a9f8b.png)\n\n\n\n运行\n```\n# 3000是你要映射到服务器上的端口，5000是容器里面需要被映射出来的端口，demo:v1 是需要运行的容器\ndocker run -p 3000:5000 demo:v1\n\n```\n\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/938487a0270762fa06ef9dd805703815.png)\n\n访问\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/6a0342a07e2f7e40cc52440c80091133.png)\n\n\n## 容器的管理\n\n\n删除不需要的镜像，和容器\n\n查看所有的容器\n```\ndocker ps -a\n```\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/fa18eadc8f8e7155bd9f2cc67aa308de.png)\n\n\n停止和删除容器\n```\n#如何停止容器\ndocker stop + 容器id\n# 删除容器id\ndocker rm + 容器id\n\n```\n\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/11454b741864a4a26be4f6f7550d5187.png)\n\n\n要先把镜像的容器都关了，才能删除相关镜像\n\n查看当前有哪些镜像\n```\ndocker images # 查看所有镜像及其信息\n\ndocker images -q  # 输出所有镜像的id\n```\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/edb762924a89a9174f15ad4eff34b4ca.png)\n\n删除镜像\n删除images（镜像），通过image的id来指定删除谁\n```\ndocker rmi <image id>\n```\n要删除全部image（镜像）的话\n```\ndocker rmi $(docker images -q)\n```\n只删除未被使用的资源\n- Docker 提供了方便的 docker system prune 命令来删除那些已停止的容器、dangling 镜像、未被容器引用的 network 和构建过程中的 cache：\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/98587da7500a3158d54cd67bfc4fb1aa.png)\n\n\n在本地的镜像更新之后，就会出现类似图中红框内的 <none> 镜像。这表示旧的镜像已经不再被引用了，此时它们就变成了 dangling images。如果使用 -a 参数，你还会发现另外一种类型的 <none> 镜像，它们的 repository 和 tag 列都表现为 <none>：\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/fa2ce9e682aa051bef2a1ef757d8f6ff.png)\n    这些镜像被称为 intermediate 镜像(就是其它镜像依赖的层)。\n\n**我们还可在不同在子命令下执行 prune，这样删除的就是某类资源：**\n```\ndocker container prune # 删除所有退出状态的容器\ndocker volume prune # 删除未被使用的数据卷\ndocker image prune # 删除 dangling 或所有未被使用的镜像\n```\n\n\n\n\n\n## 容器的网络模式\n[参考文](https://www.cnblogs.com/feng0815/p/14192177.html)\n    \n\n### 关于docker的端口映射增改问题。\n\n一般来说，在镜像运行成容器后就不能再更改端口映射了，并且下次启动原来的映射配置也在。\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/4c63fcb2c8fe102955cc0ad9140dd734.png)\n\n想要改变两个办法。\n**法一：**\n    更改配置docker文件，具体上网查询\n**法二：**\n    把现在的容器commit成镜像，然后再把镜像运行成容器，并且在运行的时候声明端口映射。\n\n## 进入容器内部\n好文的连接[link](https://cloud.tencent.com/developer/article/1691352)\n    \n    \n### 1,新建centos的镜像和容器。\n```\ndocker pull centos\n```\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/3ce9b6dbbc468ae90b1064260374b386.png)\n\n### 2,对这个镜像创建容器（也就是说运行它）\n\n    docker container run -it -p 8888:8080 -v /opt/app:/opt/app --name=python-server 470671670cac bash\n\n命令文档查看：docker container run --help\n\n-it : 交互式终端（interactive terminal） ，也就是创建容器后进入容器。\n\n-p 8888:8080 :  端口映射（port），将容器端口映射到宿主机端口（8888：宿主机端口，8080：容器端口），宿主机端口 8888 确认能被外网访问。\n\n-v /opt/app:/opt/app：数据卷（volumn），将宿主机的数据（应用程序代码，配置文件等等）挂载到容器指定路径下，实现数据存储的持久化（如果没有数据挂载的话，容器销毁，容器中的数据会自动消失）。\n\n--name=python-server: 新的容器的名称\n\n 470671670cac：镜像ID（imageID），当然也可以是 imageName + tag（docker.io/centos:latest）\n\nbash：跟 -it 命令结合在一起操作，使容器创建后处于前端，一般是 /bin/bash，我这是bash。\n    \n结果：\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/45ca190d5f75ee947bc815474dd06af7.png)\n\n查看所有容器\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/7bd6c5162f6f969d5ee8377a9ac7e86d.png)\n\n**不中断退出容器**\n可以通过 Ctrl+p，Ctrl+q 退出容器，但容器还是处于运行状态（Up）。\n或者输入命令`exit`可以直接退出，但是容器也关闭了\n\n\n#### 查看容器的信息（例如ip等）\n`docker inspect container_id`\n\n然后有结果\n\n\n![image-20220821221517801](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/c267da1bddcfbf8c21c0375ef8dea4a6.png)    \n### 进入容器\n\n**方法一**\n`docker container exec -it 5de4e81a2e20(containerID或者容器的名字) bash（这个bash可以换成其他命令）`\n\n执行命令的方式：\n- 先启动容器\n- 然后使用exec命令去执行命令\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/18d30748b5631941cae418fdc85bd5f3.png)\n\n\n其他容器命令\n```\n容器其他相关操作命令：\n\n查看容器 ip（退出容器，在宿主机上，最好另起一个客户端）: docker container inspect  1427087a62a7（containerID）\n\n\n容器启动（交互式）：docker container start  -i containerID\n\n关闭容器：docker container stop containerID\n\n容器重启动：docker container restart containerID\n\n删除容器（-f : force 强制删除，能删除处于运行状态的容器）：docker container rm -f  containerID\n\n查看所有容器的容器ID：docker container ls -a -q\n\n删除所有容器：docker contianer rm $(docker container ls -a -q)\n\n在交互式容器中退出，退出启动容器： Ctrl + d\n\n在交互式容器中退出，但是不退出启动容器：先按 Ctrl + p 后 Ctrl + q\n\n使用 -d 启动容器并一直在后台运行 SSH作为第一进程启动：docker container run -d -p 50001:22 imageID /usr/sbin/sshd -D \n```\n\n\n​    \n### 容器内的使用\n\n我这里用的centos最新版也就是centos8.\n执行yum有个bug:`Failed to download metadata for repo 'appstream......`\n办法是进入容器执行\n```\ncd /etc/yum.repos.d/\nsed -i 's/mirrorlist/#mirrorlist/g' /etc/yum.repos.d/CentOS-*\nsed -i 's|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g' /etc/yum.repos.d/CentOS-* \n```\n\n然后就可以使用yum安装各种库和程序了\n    \n\n**改变系统的密码**\n```\n    安装 passwd（设置密码）： yum install -y passwd\n    设置密码：passwd root\n\n```\n\n**安装ssh并启动**\n\n```\n作为 python 服务的守护程序，防止容器闪退（一直夯在容器中）；\n\n安装命令： yum install -y openssh-server\n\nssh 配置文件 sshd_config 路径： /etc/ssh/sshd_config\n\nssh 启动文件路径：/usr/sbin/\n启动 SSH: /usr/sbin/sshd\n\n\n```\n启动前修改\n修改/etc/ssh/sshd_config这个ssh配置文件\n    \n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/ae0cd55ec6eb40ecc231bb3147e68e58.png)\n\n退出后访问\n\n\n### 将容器打包成镜像\n\n在运行容器时指定映射端口运行后，如果想要添加新的端口映射，可以使用以下两种方式：\n\n**方式一：将现有的容器打包成镜像，然后在使用新的镜像运行容器时重新指定要映射的端口**\n\n大概过程如下：\n\n先停止现有容器\n\n`docker stop container-name`\n将容器commit成为一个镜像\n\n`docker commit container-name  new-image-name`\n用新镜像运行容器\n    \n结果\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/a5336f35ba2098dc9cb5ba845c33baf3.png)\n\n然后运行新的镜像\n`docker run -it -d --name container-name（or id） -p p1:p1 -p p2:p2 new-image-name`\n\n两个 -p 指定多个端口映射\n\n**宿主机ssh连接入容器  **  \n\n我这里将外部的2020端口映射到容器里面的22端口。\n用特定的连接工具**MobaXterm**\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/6cf0b06d120b3f20740f150e072e9efd.png)\n\n然后输入用户名和密码：成功\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/d7bd208b5e78d93bd4304461bf75d008.png)\n\n## docker Hub的使用\n\n先在hub中建立一个名叫centos_demo的仓库，我的用户名是`${username}`\n\n在本地登录docker\n```\n#docker login\nLogin with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.\nUsername: ${username}\nPassword:\nLogin Succeeded\n```\n\n准备在本地提交，先给images打标签\n\n```\ndocker tag 镜像名 账号名/仓库名：版本号\n账号名是登陆的账号名，仓库是远端配置的仓库名，版本号自己定义一个就好。到时候pull下来也是pull这个账号名/仓库名：版本号就好\n```\n\n然后提交镜像push\n```\ndocker push 账号名/仓库名：版本号\n```","slug":"综合/docker 使用简单教程","published":1,"date":"2023-02-26T15:28:35.058Z","updated":"2023-02-27T11:34:33.138Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsyck001k0gcnwo28ua4z","content":"<h1 id=\"docker-学习与使用\"><a href=\"#docker-学习与使用\" class=\"headerlink\" title=\"docker 学习与使用\"></a>docker 学习与使用</h1><h2 id=\"docker介绍\"><a href=\"#docker介绍\" class=\"headerlink\" title=\"docker介绍\"></a>docker介绍</h2><p>Docker：容器，可以理解成一个“黑盒”。在项目变得庞大以后，往往我们会疲于管理整个项目的部署和维护。如果我们将整个项目用一个“容器”装起来，那么我们仅仅只用维护一个配置文件告诉计算机每次部署要把什么东西装进“容器”，甚至借用一些工具把这个过程自动化，部署就会变得很方便。</p>\n<h3 id=\"docker-结构\"><a href=\"#docker-结构\" class=\"headerlink\" title=\"docker 结构\"></a>docker 结构</h3><p>Docker 包含三个基本概念，分别是镜像（Image）、容器（Container）和仓库（Repository）。镜像是 Docker 运行容器的前提，仓库是存放镜像的场所，可见镜像更是Docker的核心。</p>\n<h2 id=\"docker安装\"><a href=\"#docker安装\" class=\"headerlink\" title=\"docker安装\"></a>docker安装</h2><ul>\n<li>windows直接去官网下载应用程序</li>\n<li>linux可以直接用包管理工具下载安装包</li>\n</ul>\n<h2 id=\"docker的配置\"><a href=\"#docker的配置\" class=\"headerlink\" title=\"docker的配置\"></a>docker的配置</h2><p>先在项目下创建一个文件<code>Dockerfile</code>。<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/ebe096f1da2738297e7b6413ebbe2ee8.png\" alt></p>\n<p>编辑<code>Dockerfile</code>文件：<br><code>Dockerfile</code>文件的详解<a href=\"https://blog.csdn.net/qq_39626154/article/details/82787528\" target=\"_blank\" rel=\"noopener\">link</a><br>我这里以一个flask项目为例。运行hello程序在<code>./app/test.py</code></p>\n<pre><code>#基于的基础镜像\nFROM python:3.7.9\n#代码添加到flaskhello文件夹\nADD . /flaskhello\n# 设置flaskhello文件夹是工作目录\nWORKDIR /flaskhello\n\n\n# 安装支持,安装依赖文件，执行前置，可以执行很多命令。\nRUN pip install -r requirements.txt\nCMD [&quot;python&quot;, &quot;./app/test.py&quot;]  #最后运行的启动命令</code></pre><p><strong>Dockerfile详解</strong></p>\n<pre><code>dockerfile常用命令\nFROM：基础镜像，FROM命令必须是dockfile的首个命令\nLABEL：为镜像生成元数据标签信息。\nUSER：指定运行容器时的用户名或UID，后续RUN也会使用指定用户\nRUN：RUN命令是Dockfile执行命令的核心部分。它接受命令作为参数并用于创建镜像。每条RUN命令在当前镜像基础上执行，并且会提交一个新镜像层。\nWORKDIR：设置CMD指明的命令的运行目录。为后续的RUN、CMD、ENTRYPOINT、ADD指令配置工作目录。\nENV：容器启动的环境变量\nARG：构建环境的环境变量\nCOPY：复制文件到镜像中,格式： COPY 源路径 目标路径 ：COPY指令和ADD指令功能和使用方式类似。只是COPY指令不会做自动解压工作。\nADD： 拷复制文件到镜像中,格式： ADD 源路径 目标路径\nCMD：容器运行时执行的默认命令\nENTRYPOINT：指定容器的“入口”\nHEALTHCHECK：容器健康状态检查</code></pre><p><strong>关于CMD命令</strong>：<br>一定要使得该命令运行后保持前台，否则容器就会自动关闭。这是docker容器本质上是进程的概念</p>\n<h2 id=\"构建镜像与运行\"><a href=\"#构建镜像与运行\" class=\"headerlink\" title=\"构建镜像与运行\"></a>构建镜像与运行</h2><p>构建：</p>\n<pre><code>\n# 先跳转到项目根文件目录下（也就是含有Dockerfile的文件目录下）\ndocker build -t dockerdemo:v1 . # 最后一个.实际指定当前的构建目录，dockerdemo(注意只能用小写)是该docker的名字,v1是tag</code></pre><p>结果<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/1dd8e2ef74b08c85edaff3ce485a9f8b.png\" alt></p>\n<p>运行</p>\n<pre><code># 3000是你要映射到服务器上的端口，5000是容器里面需要被映射出来的端口，demo:v1 是需要运行的容器\ndocker run -p 3000:5000 demo:v1\n</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/938487a0270762fa06ef9dd805703815.png\" alt></p>\n<p>访问<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/6a0342a07e2f7e40cc52440c80091133.png\" alt></p>\n<h2 id=\"容器的管理\"><a href=\"#容器的管理\" class=\"headerlink\" title=\"容器的管理\"></a>容器的管理</h2><p>删除不需要的镜像，和容器</p>\n<p>查看所有的容器</p>\n<pre><code>docker ps -a</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/fa18eadc8f8e7155bd9f2cc67aa308de.png\" alt></p>\n<p>停止和删除容器</p>\n<pre><code>#如何停止容器\ndocker stop + 容器id\n# 删除容器id\ndocker rm + 容器id\n</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/11454b741864a4a26be4f6f7550d5187.png\" alt></p>\n<p>要先把镜像的容器都关了，才能删除相关镜像</p>\n<p>查看当前有哪些镜像</p>\n<pre><code>docker images # 查看所有镜像及其信息\n\ndocker images -q  # 输出所有镜像的id</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/edb762924a89a9174f15ad4eff34b4ca.png\" alt></p>\n<p>删除镜像<br>删除images（镜像），通过image的id来指定删除谁</p>\n<pre><code>docker rmi &lt;image id&gt;</code></pre><p>要删除全部image（镜像）的话</p>\n<pre><code>docker rmi $(docker images -q)</code></pre><p>只删除未被使用的资源</p>\n<ul>\n<li>Docker 提供了方便的 docker system prune 命令来删除那些已停止的容器、dangling 镜像、未被容器引用的 network 和构建过程中的 cache：<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/98587da7500a3158d54cd67bfc4fb1aa.png\" alt></li>\n</ul>\n<p>在本地的镜像更新之后，就会出现类似图中红框内的 <none> 镜像。这表示旧的镜像已经不再被引用了，此时它们就变成了 dangling images。如果使用 -a 参数，你还会发现另外一种类型的 <none> 镜像，它们的 repository 和 tag 列都表现为 <none>：<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/fa2ce9e682aa051bef2a1ef757d8f6ff.png\" alt><br>    这些镜像被称为 intermediate 镜像(就是其它镜像依赖的层)。</none></none></none></p>\n<p><strong>我们还可在不同在子命令下执行 prune，这样删除的就是某类资源：</strong></p>\n<pre><code>docker container prune # 删除所有退出状态的容器\ndocker volume prune # 删除未被使用的数据卷\ndocker image prune # 删除 dangling 或所有未被使用的镜像</code></pre><h2 id=\"容器的网络模式\"><a href=\"#容器的网络模式\" class=\"headerlink\" title=\"容器的网络模式\"></a>容器的网络模式</h2><p><a href=\"https://www.cnblogs.com/feng0815/p/14192177.html\" target=\"_blank\" rel=\"noopener\">参考文</a></p>\n<h3 id=\"关于docker的端口映射增改问题。\"><a href=\"#关于docker的端口映射增改问题。\" class=\"headerlink\" title=\"关于docker的端口映射增改问题。\"></a>关于docker的端口映射增改问题。</h3><p>一般来说，在镜像运行成容器后就不能再更改端口映射了，并且下次启动原来的映射配置也在。<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/4c63fcb2c8fe102955cc0ad9140dd734.png\" alt></p>\n<p>想要改变两个办法。<br><strong>法一：</strong><br>    更改配置docker文件，具体上网查询<br><strong>法二：</strong><br>    把现在的容器commit成镜像，然后再把镜像运行成容器，并且在运行的时候声明端口映射。</p>\n<h2 id=\"进入容器内部\"><a href=\"#进入容器内部\" class=\"headerlink\" title=\"进入容器内部\"></a>进入容器内部</h2><p>好文的连接<a href=\"https://cloud.tencent.com/developer/article/1691352\" target=\"_blank\" rel=\"noopener\">link</a></p>\n<h3 id=\"1-新建centos的镜像和容器。\"><a href=\"#1-新建centos的镜像和容器。\" class=\"headerlink\" title=\"1,新建centos的镜像和容器。\"></a>1,新建centos的镜像和容器。</h3><pre><code>docker pull centos</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/3ce9b6dbbc468ae90b1064260374b386.png\" alt></p>\n<h3 id=\"2-对这个镜像创建容器（也就是说运行它）\"><a href=\"#2-对这个镜像创建容器（也就是说运行它）\" class=\"headerlink\" title=\"2,对这个镜像创建容器（也就是说运行它）\"></a>2,对这个镜像创建容器（也就是说运行它）</h3><pre><code>docker container run -it -p 8888:8080 -v /opt/app:/opt/app --name=python-server 470671670cac bash</code></pre><p>命令文档查看：docker container run –help</p>\n<p>-it : 交互式终端（interactive terminal） ，也就是创建容器后进入容器。</p>\n<p>-p 8888:8080 :  端口映射（port），将容器端口映射到宿主机端口（8888：宿主机端口，8080：容器端口），宿主机端口 8888 确认能被外网访问。</p>\n<p>-v /opt/app:/opt/app：数据卷（volumn），将宿主机的数据（应用程序代码，配置文件等等）挂载到容器指定路径下，实现数据存储的持久化（如果没有数据挂载的话，容器销毁，容器中的数据会自动消失）。</p>\n<p>–name=python-server: 新的容器的名称</p>\n<p> 470671670cac：镜像ID（imageID），当然也可以是 imageName + tag（docker.io/centos:latest）</p>\n<p>bash：跟 -it 命令结合在一起操作，使容器创建后处于前端，一般是 /bin/bash，我这是bash。</p>\n<p>结果：<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/45ca190d5f75ee947bc815474dd06af7.png\" alt></p>\n<p>查看所有容器<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/7bd6c5162f6f969d5ee8377a9ac7e86d.png\" alt></p>\n<p><strong>不中断退出容器</strong><br>可以通过 Ctrl+p，Ctrl+q 退出容器，但容器还是处于运行状态（Up）。<br>或者输入命令<code>exit</code>可以直接退出，但是容器也关闭了</p>\n<h4 id=\"查看容器的信息（例如ip等）\"><a href=\"#查看容器的信息（例如ip等）\" class=\"headerlink\" title=\"查看容器的信息（例如ip等）\"></a>查看容器的信息（例如ip等）</h4><p><code>docker inspect container_id</code></p>\n<p>然后有结果</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/c267da1bddcfbf8c21c0375ef8dea4a6.png\" alt=\"image-20220821221517801\">    </p>\n<h3 id=\"进入容器\"><a href=\"#进入容器\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h3><p><strong>方法一</strong><br><code>docker container exec -it 5de4e81a2e20(containerID或者容器的名字) bash（这个bash可以换成其他命令）</code></p>\n<p>执行命令的方式：</p>\n<ul>\n<li>先启动容器</li>\n<li>然后使用exec命令去执行命令<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/18d30748b5631941cae418fdc85bd5f3.png\" alt></li>\n</ul>\n<p>其他容器命令</p>\n<pre><code>容器其他相关操作命令：\n\n查看容器 ip（退出容器，在宿主机上，最好另起一个客户端）: docker container inspect  1427087a62a7（containerID）\n\n\n容器启动（交互式）：docker container start  -i containerID\n\n关闭容器：docker container stop containerID\n\n容器重启动：docker container restart containerID\n\n删除容器（-f : force 强制删除，能删除处于运行状态的容器）：docker container rm -f  containerID\n\n查看所有容器的容器ID：docker container ls -a -q\n\n删除所有容器：docker contianer rm $(docker container ls -a -q)\n\n在交互式容器中退出，退出启动容器： Ctrl + d\n\n在交互式容器中退出，但是不退出启动容器：先按 Ctrl + p 后 Ctrl + q\n\n使用 -d 启动容器并一直在后台运行 SSH作为第一进程启动：docker container run -d -p 50001:22 imageID /usr/sbin/sshd -D </code></pre><p>​    </p>\n<h3 id=\"容器内的使用\"><a href=\"#容器内的使用\" class=\"headerlink\" title=\"容器内的使用\"></a>容器内的使用</h3><p>我这里用的centos最新版也就是centos8.<br>执行yum有个bug:<code>Failed to download metadata for repo &#39;appstream......</code><br>办法是进入容器执行</p>\n<pre><code>cd /etc/yum.repos.d/\nsed -i &#39;s/mirrorlist/#mirrorlist/g&#39; /etc/yum.repos.d/CentOS-*\nsed -i &#39;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#39; /etc/yum.repos.d/CentOS-* </code></pre><p>然后就可以使用yum安装各种库和程序了</p>\n<p><strong>改变系统的密码</strong></p>\n<pre><code>    安装 passwd（设置密码）： yum install -y passwd\n    设置密码：passwd root\n</code></pre><p><strong>安装ssh并启动</strong></p>\n<pre><code>作为 python 服务的守护程序，防止容器闪退（一直夯在容器中）；\n\n安装命令： yum install -y openssh-server\n\nssh 配置文件 sshd_config 路径： /etc/ssh/sshd_config\n\nssh 启动文件路径：/usr/sbin/\n启动 SSH: /usr/sbin/sshd\n\n</code></pre><p>启动前修改<br>修改/etc/ssh/sshd_config这个ssh配置文件</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/ae0cd55ec6eb40ecc231bb3147e68e58.png\" alt></p>\n<p>退出后访问</p>\n<h3 id=\"将容器打包成镜像\"><a href=\"#将容器打包成镜像\" class=\"headerlink\" title=\"将容器打包成镜像\"></a>将容器打包成镜像</h3><p>在运行容器时指定映射端口运行后，如果想要添加新的端口映射，可以使用以下两种方式：</p>\n<p><strong>方式一：将现有的容器打包成镜像，然后在使用新的镜像运行容器时重新指定要映射的端口</strong></p>\n<p>大概过程如下：</p>\n<p>先停止现有容器</p>\n<p><code>docker stop container-name</code><br>将容器commit成为一个镜像</p>\n<p><code>docker commit container-name  new-image-name</code><br>用新镜像运行容器</p>\n<p>结果<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/a5336f35ba2098dc9cb5ba845c33baf3.png\" alt></p>\n<p>然后运行新的镜像<br><code>docker run -it -d --name container-name（or id） -p p1:p1 -p p2:p2 new-image-name</code></p>\n<p>两个 -p 指定多个端口映射</p>\n<p>*<em>宿主机ssh连接入容器  *</em>  </p>\n<p>我这里将外部的2020端口映射到容器里面的22端口。<br>用特定的连接工具<strong>MobaXterm</strong><br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/6cf0b06d120b3f20740f150e072e9efd.png\" alt></p>\n<p>然后输入用户名和密码：成功<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/d7bd208b5e78d93bd4304461bf75d008.png\" alt></p>\n<h2 id=\"docker-Hub的使用\"><a href=\"#docker-Hub的使用\" class=\"headerlink\" title=\"docker Hub的使用\"></a>docker Hub的使用</h2><p>先在hub中建立一个名叫centos_demo的仓库，我的用户名是<code>${username}</code></p>\n<p>在本地登录docker</p>\n<pre><code>#docker login\nLogin with your Docker ID to push and pull images from Docker Hub. If you don&#39;t have a Docker ID, head over to https://hub.docker.com to create one.\nUsername: ${username}\nPassword:\nLogin Succeeded</code></pre><p>准备在本地提交，先给images打标签</p>\n<pre><code>docker tag 镜像名 账号名/仓库名：版本号\n账号名是登陆的账号名，仓库是远端配置的仓库名，版本号自己定义一个就好。到时候pull下来也是pull这个账号名/仓库名：版本号就好</code></pre><p>然后提交镜像push</p>\n<pre><code>docker push 账号名/仓库名：版本号</code></pre>","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"docker-学习与使用\"><a href=\"#docker-学习与使用\" class=\"headerlink\" title=\"docker 学习与使用\"></a>docker 学习与使用</h1><h2 id=\"docker介绍\"><a href=\"#docker介绍\" class=\"headerlink\" title=\"docker介绍\"></a>docker介绍</h2><p>Docker：容器，可以理解成一个“黑盒”。在项目变得庞大以后，往往我们会疲于管理整个项目的部署和维护。如果我们将整个项目用一个“容器”装起来，那么我们仅仅只用维护一个配置文件告诉计算机每次部署要把什么东西装进“容器”，甚至借用一些工具把这个过程自动化，部署就会变得很方便。</p>\n<h3 id=\"docker-结构\"><a href=\"#docker-结构\" class=\"headerlink\" title=\"docker 结构\"></a>docker 结构</h3><p>Docker 包含三个基本概念，分别是镜像（Image）、容器（Container）和仓库（Repository）。镜像是 Docker 运行容器的前提，仓库是存放镜像的场所，可见镜像更是Docker的核心。</p>\n<h2 id=\"docker安装\"><a href=\"#docker安装\" class=\"headerlink\" title=\"docker安装\"></a>docker安装</h2><ul>\n<li>windows直接去官网下载应用程序</li>\n<li>linux可以直接用包管理工具下载安装包</li>\n</ul>\n<h2 id=\"docker的配置\"><a href=\"#docker的配置\" class=\"headerlink\" title=\"docker的配置\"></a>docker的配置</h2><p>先在项目下创建一个文件<code>Dockerfile</code>。<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/ebe096f1da2738297e7b6413ebbe2ee8.png\" alt></p>\n<p>编辑<code>Dockerfile</code>文件：<br><code>Dockerfile</code>文件的详解<a href=\"https://blog.csdn.net/qq_39626154/article/details/82787528\" target=\"_blank\" rel=\"noopener\">link</a><br>我这里以一个flask项目为例。运行hello程序在<code>./app/test.py</code></p>\n<pre><code>#基于的基础镜像\nFROM python:3.7.9\n#代码添加到flaskhello文件夹\nADD . /flaskhello\n# 设置flaskhello文件夹是工作目录\nWORKDIR /flaskhello\n\n\n# 安装支持,安装依赖文件，执行前置，可以执行很多命令。\nRUN pip install -r requirements.txt\nCMD [&quot;python&quot;, &quot;./app/test.py&quot;]  #最后运行的启动命令</code></pre><p><strong>Dockerfile详解</strong></p>\n<pre><code>dockerfile常用命令\nFROM：基础镜像，FROM命令必须是dockfile的首个命令\nLABEL：为镜像生成元数据标签信息。\nUSER：指定运行容器时的用户名或UID，后续RUN也会使用指定用户\nRUN：RUN命令是Dockfile执行命令的核心部分。它接受命令作为参数并用于创建镜像。每条RUN命令在当前镜像基础上执行，并且会提交一个新镜像层。\nWORKDIR：设置CMD指明的命令的运行目录。为后续的RUN、CMD、ENTRYPOINT、ADD指令配置工作目录。\nENV：容器启动的环境变量\nARG：构建环境的环境变量\nCOPY：复制文件到镜像中,格式： COPY 源路径 目标路径 ：COPY指令和ADD指令功能和使用方式类似。只是COPY指令不会做自动解压工作。\nADD： 拷复制文件到镜像中,格式： ADD 源路径 目标路径\nCMD：容器运行时执行的默认命令\nENTRYPOINT：指定容器的“入口”\nHEALTHCHECK：容器健康状态检查</code></pre><p><strong>关于CMD命令</strong>：<br>一定要使得该命令运行后保持前台，否则容器就会自动关闭。这是docker容器本质上是进程的概念</p>\n<h2 id=\"构建镜像与运行\"><a href=\"#构建镜像与运行\" class=\"headerlink\" title=\"构建镜像与运行\"></a>构建镜像与运行</h2><p>构建：</p>\n<pre><code>\n# 先跳转到项目根文件目录下（也就是含有Dockerfile的文件目录下）\ndocker build -t dockerdemo:v1 . # 最后一个.实际指定当前的构建目录，dockerdemo(注意只能用小写)是该docker的名字,v1是tag</code></pre><p>结果<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/1dd8e2ef74b08c85edaff3ce485a9f8b.png\" alt></p>\n<p>运行</p>\n<pre><code># 3000是你要映射到服务器上的端口，5000是容器里面需要被映射出来的端口，demo:v1 是需要运行的容器\ndocker run -p 3000:5000 demo:v1\n</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/938487a0270762fa06ef9dd805703815.png\" alt></p>\n<p>访问<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/6a0342a07e2f7e40cc52440c80091133.png\" alt></p>\n<h2 id=\"容器的管理\"><a href=\"#容器的管理\" class=\"headerlink\" title=\"容器的管理\"></a>容器的管理</h2><p>删除不需要的镜像，和容器</p>\n<p>查看所有的容器</p>\n<pre><code>docker ps -a</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/fa18eadc8f8e7155bd9f2cc67aa308de.png\" alt></p>\n<p>停止和删除容器</p>\n<pre><code>#如何停止容器\ndocker stop + 容器id\n# 删除容器id\ndocker rm + 容器id\n</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/11454b741864a4a26be4f6f7550d5187.png\" alt></p>\n<p>要先把镜像的容器都关了，才能删除相关镜像</p>\n<p>查看当前有哪些镜像</p>\n<pre><code>docker images # 查看所有镜像及其信息\n\ndocker images -q  # 输出所有镜像的id</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/edb762924a89a9174f15ad4eff34b4ca.png\" alt></p>\n<p>删除镜像<br>删除images（镜像），通过image的id来指定删除谁</p>\n<pre><code>docker rmi &lt;image id&gt;</code></pre><p>要删除全部image（镜像）的话</p>\n<pre><code>docker rmi $(docker images -q)</code></pre><p>只删除未被使用的资源</p>\n<ul>\n<li>Docker 提供了方便的 docker system prune 命令来删除那些已停止的容器、dangling 镜像、未被容器引用的 network 和构建过程中的 cache：<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/98587da7500a3158d54cd67bfc4fb1aa.png\" alt></li>\n</ul>\n<p>在本地的镜像更新之后，就会出现类似图中红框内的 <none> 镜像。这表示旧的镜像已经不再被引用了，此时它们就变成了 dangling images。如果使用 -a 参数，你还会发现另外一种类型的 <none> 镜像，它们的 repository 和 tag 列都表现为 <none>：<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/fa2ce9e682aa051bef2a1ef757d8f6ff.png\" alt><br>    这些镜像被称为 intermediate 镜像(就是其它镜像依赖的层)。</none></none></none></p>\n<p><strong>我们还可在不同在子命令下执行 prune，这样删除的就是某类资源：</strong></p>\n<pre><code>docker container prune # 删除所有退出状态的容器\ndocker volume prune # 删除未被使用的数据卷\ndocker image prune # 删除 dangling 或所有未被使用的镜像</code></pre><h2 id=\"容器的网络模式\"><a href=\"#容器的网络模式\" class=\"headerlink\" title=\"容器的网络模式\"></a>容器的网络模式</h2><p><a href=\"https://www.cnblogs.com/feng0815/p/14192177.html\" target=\"_blank\" rel=\"noopener\">参考文</a></p>\n<h3 id=\"关于docker的端口映射增改问题。\"><a href=\"#关于docker的端口映射增改问题。\" class=\"headerlink\" title=\"关于docker的端口映射增改问题。\"></a>关于docker的端口映射增改问题。</h3><p>一般来说，在镜像运行成容器后就不能再更改端口映射了，并且下次启动原来的映射配置也在。<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/4c63fcb2c8fe102955cc0ad9140dd734.png\" alt></p>\n<p>想要改变两个办法。<br><strong>法一：</strong><br>    更改配置docker文件，具体上网查询<br><strong>法二：</strong><br>    把现在的容器commit成镜像，然后再把镜像运行成容器，并且在运行的时候声明端口映射。</p>\n<h2 id=\"进入容器内部\"><a href=\"#进入容器内部\" class=\"headerlink\" title=\"进入容器内部\"></a>进入容器内部</h2><p>好文的连接<a href=\"https://cloud.tencent.com/developer/article/1691352\" target=\"_blank\" rel=\"noopener\">link</a></p>\n<h3 id=\"1-新建centos的镜像和容器。\"><a href=\"#1-新建centos的镜像和容器。\" class=\"headerlink\" title=\"1,新建centos的镜像和容器。\"></a>1,新建centos的镜像和容器。</h3><pre><code>docker pull centos</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/3ce9b6dbbc468ae90b1064260374b386.png\" alt></p>\n<h3 id=\"2-对这个镜像创建容器（也就是说运行它）\"><a href=\"#2-对这个镜像创建容器（也就是说运行它）\" class=\"headerlink\" title=\"2,对这个镜像创建容器（也就是说运行它）\"></a>2,对这个镜像创建容器（也就是说运行它）</h3><pre><code>docker container run -it -p 8888:8080 -v /opt/app:/opt/app --name=python-server 470671670cac bash</code></pre><p>命令文档查看：docker container run –help</p>\n<p>-it : 交互式终端（interactive terminal） ，也就是创建容器后进入容器。</p>\n<p>-p 8888:8080 :  端口映射（port），将容器端口映射到宿主机端口（8888：宿主机端口，8080：容器端口），宿主机端口 8888 确认能被外网访问。</p>\n<p>-v /opt/app:/opt/app：数据卷（volumn），将宿主机的数据（应用程序代码，配置文件等等）挂载到容器指定路径下，实现数据存储的持久化（如果没有数据挂载的话，容器销毁，容器中的数据会自动消失）。</p>\n<p>–name=python-server: 新的容器的名称</p>\n<p> 470671670cac：镜像ID（imageID），当然也可以是 imageName + tag（docker.io/centos:latest）</p>\n<p>bash：跟 -it 命令结合在一起操作，使容器创建后处于前端，一般是 /bin/bash，我这是bash。</p>\n<p>结果：<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/45ca190d5f75ee947bc815474dd06af7.png\" alt></p>\n<p>查看所有容器<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/7bd6c5162f6f969d5ee8377a9ac7e86d.png\" alt></p>\n<p><strong>不中断退出容器</strong><br>可以通过 Ctrl+p，Ctrl+q 退出容器，但容器还是处于运行状态（Up）。<br>或者输入命令<code>exit</code>可以直接退出，但是容器也关闭了</p>\n<h4 id=\"查看容器的信息（例如ip等）\"><a href=\"#查看容器的信息（例如ip等）\" class=\"headerlink\" title=\"查看容器的信息（例如ip等）\"></a>查看容器的信息（例如ip等）</h4><p><code>docker inspect container_id</code></p>\n<p>然后有结果</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/c267da1bddcfbf8c21c0375ef8dea4a6.png\" alt=\"image-20220821221517801\">    </p>\n<h3 id=\"进入容器\"><a href=\"#进入容器\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h3><p><strong>方法一</strong><br><code>docker container exec -it 5de4e81a2e20(containerID或者容器的名字) bash（这个bash可以换成其他命令）</code></p>\n<p>执行命令的方式：</p>\n<ul>\n<li>先启动容器</li>\n<li>然后使用exec命令去执行命令<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/18d30748b5631941cae418fdc85bd5f3.png\" alt></li>\n</ul>\n<p>其他容器命令</p>\n<pre><code>容器其他相关操作命令：\n\n查看容器 ip（退出容器，在宿主机上，最好另起一个客户端）: docker container inspect  1427087a62a7（containerID）\n\n\n容器启动（交互式）：docker container start  -i containerID\n\n关闭容器：docker container stop containerID\n\n容器重启动：docker container restart containerID\n\n删除容器（-f : force 强制删除，能删除处于运行状态的容器）：docker container rm -f  containerID\n\n查看所有容器的容器ID：docker container ls -a -q\n\n删除所有容器：docker contianer rm $(docker container ls -a -q)\n\n在交互式容器中退出，退出启动容器： Ctrl + d\n\n在交互式容器中退出，但是不退出启动容器：先按 Ctrl + p 后 Ctrl + q\n\n使用 -d 启动容器并一直在后台运行 SSH作为第一进程启动：docker container run -d -p 50001:22 imageID /usr/sbin/sshd -D </code></pre><p>​    </p>\n<h3 id=\"容器内的使用\"><a href=\"#容器内的使用\" class=\"headerlink\" title=\"容器内的使用\"></a>容器内的使用</h3><p>我这里用的centos最新版也就是centos8.<br>执行yum有个bug:<code>Failed to download metadata for repo &#39;appstream......</code><br>办法是进入容器执行</p>\n<pre><code>cd /etc/yum.repos.d/\nsed -i &#39;s/mirrorlist/#mirrorlist/g&#39; /etc/yum.repos.d/CentOS-*\nsed -i &#39;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#39; /etc/yum.repos.d/CentOS-* </code></pre><p>然后就可以使用yum安装各种库和程序了</p>\n<p><strong>改变系统的密码</strong></p>\n<pre><code>    安装 passwd（设置密码）： yum install -y passwd\n    设置密码：passwd root\n</code></pre><p><strong>安装ssh并启动</strong></p>\n<pre><code>作为 python 服务的守护程序，防止容器闪退（一直夯在容器中）；\n\n安装命令： yum install -y openssh-server\n\nssh 配置文件 sshd_config 路径： /etc/ssh/sshd_config\n\nssh 启动文件路径：/usr/sbin/\n启动 SSH: /usr/sbin/sshd\n\n</code></pre><p>启动前修改<br>修改/etc/ssh/sshd_config这个ssh配置文件</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/ae0cd55ec6eb40ecc231bb3147e68e58.png\" alt></p>\n<p>退出后访问</p>\n<h3 id=\"将容器打包成镜像\"><a href=\"#将容器打包成镜像\" class=\"headerlink\" title=\"将容器打包成镜像\"></a>将容器打包成镜像</h3><p>在运行容器时指定映射端口运行后，如果想要添加新的端口映射，可以使用以下两种方式：</p>\n<p><strong>方式一：将现有的容器打包成镜像，然后在使用新的镜像运行容器时重新指定要映射的端口</strong></p>\n<p>大概过程如下：</p>\n<p>先停止现有容器</p>\n<p><code>docker stop container-name</code><br>将容器commit成为一个镜像</p>\n<p><code>docker commit container-name  new-image-name</code><br>用新镜像运行容器</p>\n<p>结果<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/a5336f35ba2098dc9cb5ba845c33baf3.png\" alt></p>\n<p>然后运行新的镜像<br><code>docker run -it -d --name container-name（or id） -p p1:p1 -p p2:p2 new-image-name</code></p>\n<p>两个 -p 指定多个端口映射</p>\n<p>*<em>宿主机ssh连接入容器  *</em>  </p>\n<p>我这里将外部的2020端口映射到容器里面的22端口。<br>用特定的连接工具<strong>MobaXterm</strong><br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/6cf0b06d120b3f20740f150e072e9efd.png\" alt></p>\n<p>然后输入用户名和密码：成功<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/91e15ed4a577cd55d7e4a4843d293fe7/d7bd208b5e78d93bd4304461bf75d008.png\" alt></p>\n<h2 id=\"docker-Hub的使用\"><a href=\"#docker-Hub的使用\" class=\"headerlink\" title=\"docker Hub的使用\"></a>docker Hub的使用</h2><p>先在hub中建立一个名叫centos_demo的仓库，我的用户名是<code>${username}</code></p>\n<p>在本地登录docker</p>\n<pre><code>#docker login\nLogin with your Docker ID to push and pull images from Docker Hub. If you don&#39;t have a Docker ID, head over to https://hub.docker.com to create one.\nUsername: ${username}\nPassword:\nLogin Succeeded</code></pre><p>准备在本地提交，先给images打标签</p>\n<pre><code>docker tag 镜像名 账号名/仓库名：版本号\n账号名是登陆的账号名，仓库是远端配置的仓库名，版本号自己定义一个就好。到时候pull下来也是pull这个账号名/仓库名：版本号就好</code></pre><p>然后提交镜像push</p>\n<pre><code>docker push 账号名/仓库名：版本号</code></pre>"},{"_content":"# pipenv虚拟环境管理\n\n## 安装\n运行以下命令安装：\n```\npip install pipenv\n```\n\n查看是否安装成功\n\n```\npipenv --help\n```\n\n## 进行环境配置\n\n进入项目文件夹下，安装虚拟环境\n```\npipenv install\n```\n\n进入虚拟环境\n```\npipenv shell\n```\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/f4c8bb88e70a139f1a1b6fd1fbe46230/0c5e1eed2297e846bea8335613d5262c.png)\n\n\n推出虚拟环境\n```\nexit\n```\n\n\n安装库\n```\npipenv install flask\n```\n\n\n## 关于配置文件\n\npipenv 相对于可以做到虚拟环境的隔离，而且用pienv进行的库管理也更加合理。相对于pip freeze  > requirement的的库管理。pipenv更能分清依赖。能够分清哪些是项目用到的库，哪些是库需要的库。\n\n例如一个pipfile\n```\n[[source]]\nurl = \"https://pypi.org/simple\"\nverify_ssl = true\nname = \"pypi\"\n\n[packages]\nflask = \"*\"\nflask-cors = \"*\"\ndbutils = \"*\"\nrequests = \"*\"\nldap3 = \"*\"\npasslib = \"*\"\nrequests-toolbelt = \"*\"\npycryptodome = \"*\"\nxmltodict = \"*\"\nredis = \"*\"\nqrcode = \"*\"\npillow = \"*\"\npyzbar = {extras = [\"scripts\"], version = \"*\"}\n[dev-packages]\n\n[requires]\npython_version = \"3.7\"\n\n```\n\n\n## 常用的命令\n\n```\npipenv --where                 列出本地工程路径\npipenv --venv                  列出虚拟环境路径\npipenv --py                    列出虚拟环境的Python可执行文件\npipenv install                 创建虚拟环境\npipenv isntall [moduel]        安装包\npipenv install [moduel] --dev  安装包到开发环境\npipenv uninstall[module]       卸载包\npipenv uninstall --all         卸载所有包\npipenv graph                   查看包依赖\npipenv lock                    生成lockfile\npipenv run python [pyfile]     运行py文件\npipenv --rm                    删除虚拟环境,在虚拟环境的目录下运行\n```\n\n查看安装的库\n```\n# 方法一\npipenv run pip list\n\n#方法二\npipenv requirements \n```\n\n卸载\n`pipenv uninstall package_name`卸载包\n\n\n\n","source":"_posts/综合/pipenv虚拟环境实用.md","raw":"# pipenv虚拟环境管理\n\n## 安装\n运行以下命令安装：\n```\npip install pipenv\n```\n\n查看是否安装成功\n\n```\npipenv --help\n```\n\n## 进行环境配置\n\n进入项目文件夹下，安装虚拟环境\n```\npipenv install\n```\n\n进入虚拟环境\n```\npipenv shell\n```\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/f4c8bb88e70a139f1a1b6fd1fbe46230/0c5e1eed2297e846bea8335613d5262c.png)\n\n\n推出虚拟环境\n```\nexit\n```\n\n\n安装库\n```\npipenv install flask\n```\n\n\n## 关于配置文件\n\npipenv 相对于可以做到虚拟环境的隔离，而且用pienv进行的库管理也更加合理。相对于pip freeze  > requirement的的库管理。pipenv更能分清依赖。能够分清哪些是项目用到的库，哪些是库需要的库。\n\n例如一个pipfile\n```\n[[source]]\nurl = \"https://pypi.org/simple\"\nverify_ssl = true\nname = \"pypi\"\n\n[packages]\nflask = \"*\"\nflask-cors = \"*\"\ndbutils = \"*\"\nrequests = \"*\"\nldap3 = \"*\"\npasslib = \"*\"\nrequests-toolbelt = \"*\"\npycryptodome = \"*\"\nxmltodict = \"*\"\nredis = \"*\"\nqrcode = \"*\"\npillow = \"*\"\npyzbar = {extras = [\"scripts\"], version = \"*\"}\n[dev-packages]\n\n[requires]\npython_version = \"3.7\"\n\n```\n\n\n## 常用的命令\n\n```\npipenv --where                 列出本地工程路径\npipenv --venv                  列出虚拟环境路径\npipenv --py                    列出虚拟环境的Python可执行文件\npipenv install                 创建虚拟环境\npipenv isntall [moduel]        安装包\npipenv install [moduel] --dev  安装包到开发环境\npipenv uninstall[module]       卸载包\npipenv uninstall --all         卸载所有包\npipenv graph                   查看包依赖\npipenv lock                    生成lockfile\npipenv run python [pyfile]     运行py文件\npipenv --rm                    删除虚拟环境,在虚拟环境的目录下运行\n```\n\n查看安装的库\n```\n# 方法一\npipenv run pip list\n\n#方法二\npipenv requirements \n```\n\n卸载\n`pipenv uninstall package_name`卸载包\n\n\n\n","slug":"综合/pipenv虚拟环境实用","published":1,"date":"2023-02-26T15:28:35.061Z","updated":"2023-02-27T11:34:33.136Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsycl001l0gcnxf4rwcpq","content":"<h1 id=\"pipenv虚拟环境管理\"><a href=\"#pipenv虚拟环境管理\" class=\"headerlink\" title=\"pipenv虚拟环境管理\"></a>pipenv虚拟环境管理</h1><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>运行以下命令安装：</p>\n<pre><code>pip install pipenv</code></pre><p>查看是否安装成功</p>\n<pre><code>pipenv --help</code></pre><h2 id=\"进行环境配置\"><a href=\"#进行环境配置\" class=\"headerlink\" title=\"进行环境配置\"></a>进行环境配置</h2><p>进入项目文件夹下，安装虚拟环境</p>\n<pre><code>pipenv install</code></pre><p>进入虚拟环境</p>\n<pre><code>pipenv shell</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/f4c8bb88e70a139f1a1b6fd1fbe46230/0c5e1eed2297e846bea8335613d5262c.png\" alt></p>\n<p>推出虚拟环境</p>\n<pre><code>exit</code></pre><p>安装库</p>\n<pre><code>pipenv install flask</code></pre><h2 id=\"关于配置文件\"><a href=\"#关于配置文件\" class=\"headerlink\" title=\"关于配置文件\"></a>关于配置文件</h2><p>pipenv 相对于可以做到虚拟环境的隔离，而且用pienv进行的库管理也更加合理。相对于pip freeze  &gt; requirement的的库管理。pipenv更能分清依赖。能够分清哪些是项目用到的库，哪些是库需要的库。</p>\n<p>例如一个pipfile</p>\n<pre><code>[[source]]\nurl = &quot;https://pypi.org/simple&quot;\nverify_ssl = true\nname = &quot;pypi&quot;\n\n[packages]\nflask = &quot;*&quot;\nflask-cors = &quot;*&quot;\ndbutils = &quot;*&quot;\nrequests = &quot;*&quot;\nldap3 = &quot;*&quot;\npasslib = &quot;*&quot;\nrequests-toolbelt = &quot;*&quot;\npycryptodome = &quot;*&quot;\nxmltodict = &quot;*&quot;\nredis = &quot;*&quot;\nqrcode = &quot;*&quot;\npillow = &quot;*&quot;\npyzbar = {extras = [&quot;scripts&quot;], version = &quot;*&quot;}\n[dev-packages]\n\n[requires]\npython_version = &quot;3.7&quot;\n</code></pre><h2 id=\"常用的命令\"><a href=\"#常用的命令\" class=\"headerlink\" title=\"常用的命令\"></a>常用的命令</h2><pre><code>pipenv --where                 列出本地工程路径\npipenv --venv                  列出虚拟环境路径\npipenv --py                    列出虚拟环境的Python可执行文件\npipenv install                 创建虚拟环境\npipenv isntall [moduel]        安装包\npipenv install [moduel] --dev  安装包到开发环境\npipenv uninstall[module]       卸载包\npipenv uninstall --all         卸载所有包\npipenv graph                   查看包依赖\npipenv lock                    生成lockfile\npipenv run python [pyfile]     运行py文件\npipenv --rm                    删除虚拟环境,在虚拟环境的目录下运行</code></pre><p>查看安装的库</p>\n<pre><code># 方法一\npipenv run pip list\n\n#方法二\npipenv requirements </code></pre><p>卸载<br><code>pipenv uninstall package_name</code>卸载包</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"pipenv虚拟环境管理\"><a href=\"#pipenv虚拟环境管理\" class=\"headerlink\" title=\"pipenv虚拟环境管理\"></a>pipenv虚拟环境管理</h1><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>运行以下命令安装：</p>\n<pre><code>pip install pipenv</code></pre><p>查看是否安装成功</p>\n<pre><code>pipenv --help</code></pre><h2 id=\"进行环境配置\"><a href=\"#进行环境配置\" class=\"headerlink\" title=\"进行环境配置\"></a>进行环境配置</h2><p>进入项目文件夹下，安装虚拟环境</p>\n<pre><code>pipenv install</code></pre><p>进入虚拟环境</p>\n<pre><code>pipenv shell</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/f4c8bb88e70a139f1a1b6fd1fbe46230/0c5e1eed2297e846bea8335613d5262c.png\" alt></p>\n<p>推出虚拟环境</p>\n<pre><code>exit</code></pre><p>安装库</p>\n<pre><code>pipenv install flask</code></pre><h2 id=\"关于配置文件\"><a href=\"#关于配置文件\" class=\"headerlink\" title=\"关于配置文件\"></a>关于配置文件</h2><p>pipenv 相对于可以做到虚拟环境的隔离，而且用pienv进行的库管理也更加合理。相对于pip freeze  &gt; requirement的的库管理。pipenv更能分清依赖。能够分清哪些是项目用到的库，哪些是库需要的库。</p>\n<p>例如一个pipfile</p>\n<pre><code>[[source]]\nurl = &quot;https://pypi.org/simple&quot;\nverify_ssl = true\nname = &quot;pypi&quot;\n\n[packages]\nflask = &quot;*&quot;\nflask-cors = &quot;*&quot;\ndbutils = &quot;*&quot;\nrequests = &quot;*&quot;\nldap3 = &quot;*&quot;\npasslib = &quot;*&quot;\nrequests-toolbelt = &quot;*&quot;\npycryptodome = &quot;*&quot;\nxmltodict = &quot;*&quot;\nredis = &quot;*&quot;\nqrcode = &quot;*&quot;\npillow = &quot;*&quot;\npyzbar = {extras = [&quot;scripts&quot;], version = &quot;*&quot;}\n[dev-packages]\n\n[requires]\npython_version = &quot;3.7&quot;\n</code></pre><h2 id=\"常用的命令\"><a href=\"#常用的命令\" class=\"headerlink\" title=\"常用的命令\"></a>常用的命令</h2><pre><code>pipenv --where                 列出本地工程路径\npipenv --venv                  列出虚拟环境路径\npipenv --py                    列出虚拟环境的Python可执行文件\npipenv install                 创建虚拟环境\npipenv isntall [moduel]        安装包\npipenv install [moduel] --dev  安装包到开发环境\npipenv uninstall[module]       卸载包\npipenv uninstall --all         卸载所有包\npipenv graph                   查看包依赖\npipenv lock                    生成lockfile\npipenv run python [pyfile]     运行py文件\npipenv --rm                    删除虚拟环境,在虚拟环境的目录下运行</code></pre><p>查看安装的库</p>\n<pre><code># 方法一\npipenv run pip list\n\n#方法二\npipenv requirements </code></pre><p>卸载<br><code>pipenv uninstall package_name</code>卸载包</p>\n"},{"_content":"# python 请求重试机制tenacity\n\n优秀的参考\n [ref](https://www.cnblogs.com/wuzhibinsuib/p/13443622.html)\n`from tenacity import *`\n\n\n\n# 正常看到错误就重试\n```\n@retry\ndef test_retry1():\n    print(\"等待重试.....\")\n    raise Exception  # 通过raise直接返回一个错误\n```\n\n\n# 设置最大的重试次数\n```\n@retry(stop=stop_after_attempt(5))\ndef test_retry2():\n    print(\"等待重试.....\")\n    raise Exception\n```\n\n# 设置最大重试时间， 这里的意思是5秒内如果还错误就继续执行\n```\n@retry(stop=stop_after_delay(5))\ndef test_retry3():\n    print(\"等待重试.....\")\n    return \"hello\" + 1\n```\n\n# 指定特定的错误类型\n\n```\n@retry(retry=retry_if_exception_type(TypeError))\ndef test_retry4():\n    print(\"等待重试.....\")\n    raise TypeError # 捕获类型错误，当出现类型错误时重试\n```\n\n\n# 同时设置多个参数\n```\nfrom tenacity import retry, stop_after_delay, stop_after_attempt\n\n@retry(stop=(stop_after_delay(5) | stop_after_attempt(7)))\ndef test_retry():\n    print(\"等待重试....\")\n    raise Exception\n\ntest_retry()\n\n```\n\n# 自定义\n```\n\n\n# 首先定义了一个函数symbol，它的作用是判断传入的值是否为None；它返回一个布尔值，如果结果value=None，则返回true，否则返回False\ndef symbol(value):\n    return value is None\n\n\n# 装饰器中retry=retry_if_result(symbol)，表示把test_retry函数的结果传入symbol，判断test_retry的结果是否为None，\n# 如果=None，就进行重试(retry),如果不等于None，就结束并返回函数值（所以达成重试的条件是test_retry的结果是否为条件函数定义的结果）\n@retry(stop=stop_after_attempt(3), retry=retry_if_result(symbol), reraise=True)\ndef test_retry():\n    print(\"等待重试.....\")\n    return None\n\nif __name__ == '__main__':\n    test_retry5()\n````","source":"_posts/综合/python 请求重试机制tenacity.md","raw":"# python 请求重试机制tenacity\n\n优秀的参考\n [ref](https://www.cnblogs.com/wuzhibinsuib/p/13443622.html)\n`from tenacity import *`\n\n\n\n# 正常看到错误就重试\n```\n@retry\ndef test_retry1():\n    print(\"等待重试.....\")\n    raise Exception  # 通过raise直接返回一个错误\n```\n\n\n# 设置最大的重试次数\n```\n@retry(stop=stop_after_attempt(5))\ndef test_retry2():\n    print(\"等待重试.....\")\n    raise Exception\n```\n\n# 设置最大重试时间， 这里的意思是5秒内如果还错误就继续执行\n```\n@retry(stop=stop_after_delay(5))\ndef test_retry3():\n    print(\"等待重试.....\")\n    return \"hello\" + 1\n```\n\n# 指定特定的错误类型\n\n```\n@retry(retry=retry_if_exception_type(TypeError))\ndef test_retry4():\n    print(\"等待重试.....\")\n    raise TypeError # 捕获类型错误，当出现类型错误时重试\n```\n\n\n# 同时设置多个参数\n```\nfrom tenacity import retry, stop_after_delay, stop_after_attempt\n\n@retry(stop=(stop_after_delay(5) | stop_after_attempt(7)))\ndef test_retry():\n    print(\"等待重试....\")\n    raise Exception\n\ntest_retry()\n\n```\n\n# 自定义\n```\n\n\n# 首先定义了一个函数symbol，它的作用是判断传入的值是否为None；它返回一个布尔值，如果结果value=None，则返回true，否则返回False\ndef symbol(value):\n    return value is None\n\n\n# 装饰器中retry=retry_if_result(symbol)，表示把test_retry函数的结果传入symbol，判断test_retry的结果是否为None，\n# 如果=None，就进行重试(retry),如果不等于None，就结束并返回函数值（所以达成重试的条件是test_retry的结果是否为条件函数定义的结果）\n@retry(stop=stop_after_attempt(3), retry=retry_if_result(symbol), reraise=True)\ndef test_retry():\n    print(\"等待重试.....\")\n    return None\n\nif __name__ == '__main__':\n    test_retry5()\n````","slug":"综合/python 请求重试机制tenacity","published":1,"date":"2023-02-26T15:28:35.061Z","updated":"2023-02-27T11:34:33.135Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsycl001m0gcn3eodzzta","content":"<h1 id=\"python-请求重试机制tenacity\"><a href=\"#python-请求重试机制tenacity\" class=\"headerlink\" title=\"python 请求重试机制tenacity\"></a>python 请求重试机制tenacity</h1><p>优秀的参考<br> <a href=\"https://www.cnblogs.com/wuzhibinsuib/p/13443622.html\" target=\"_blank\" rel=\"noopener\">ref</a><br><code>from tenacity import *</code></p>\n<h1 id=\"正常看到错误就重试\"><a href=\"#正常看到错误就重试\" class=\"headerlink\" title=\"正常看到错误就重试\"></a>正常看到错误就重试</h1><pre><code>@retry\ndef test_retry1():\n    print(&quot;等待重试.....&quot;)\n    raise Exception  # 通过raise直接返回一个错误</code></pre><h1 id=\"设置最大的重试次数\"><a href=\"#设置最大的重试次数\" class=\"headerlink\" title=\"设置最大的重试次数\"></a>设置最大的重试次数</h1><pre><code>@retry(stop=stop_after_attempt(5))\ndef test_retry2():\n    print(&quot;等待重试.....&quot;)\n    raise Exception</code></pre><h1 id=\"设置最大重试时间，-这里的意思是5秒内如果还错误就继续执行\"><a href=\"#设置最大重试时间，-这里的意思是5秒内如果还错误就继续执行\" class=\"headerlink\" title=\"设置最大重试时间， 这里的意思是5秒内如果还错误就继续执行\"></a>设置最大重试时间， 这里的意思是5秒内如果还错误就继续执行</h1><pre><code>@retry(stop=stop_after_delay(5))\ndef test_retry3():\n    print(&quot;等待重试.....&quot;)\n    return &quot;hello&quot; + 1</code></pre><h1 id=\"指定特定的错误类型\"><a href=\"#指定特定的错误类型\" class=\"headerlink\" title=\"指定特定的错误类型\"></a>指定特定的错误类型</h1><pre><code>@retry(retry=retry_if_exception_type(TypeError))\ndef test_retry4():\n    print(&quot;等待重试.....&quot;)\n    raise TypeError # 捕获类型错误，当出现类型错误时重试</code></pre><h1 id=\"同时设置多个参数\"><a href=\"#同时设置多个参数\" class=\"headerlink\" title=\"同时设置多个参数\"></a>同时设置多个参数</h1><pre><code>from tenacity import retry, stop_after_delay, stop_after_attempt\n\n@retry(stop=(stop_after_delay(5) | stop_after_attempt(7)))\ndef test_retry():\n    print(&quot;等待重试....&quot;)\n    raise Exception\n\ntest_retry()\n</code></pre><h1 id=\"自定义\"><a href=\"#自定义\" class=\"headerlink\" title=\"自定义\"></a>自定义</h1><pre><code>\n\n# 首先定义了一个函数symbol，它的作用是判断传入的值是否为None；它返回一个布尔值，如果结果value=None，则返回true，否则返回False\ndef symbol(value):\n    return value is None\n\n\n# 装饰器中retry=retry_if_result(symbol)，表示把test_retry函数的结果传入symbol，判断test_retry的结果是否为None，\n# 如果=None，就进行重试(retry),如果不等于None，就结束并返回函数值（所以达成重试的条件是test_retry的结果是否为条件函数定义的结果）\n@retry(stop=stop_after_attempt(3), retry=retry_if_result(symbol), reraise=True)\ndef test_retry():\n    print(&quot;等待重试.....&quot;)\n    return None\n\nif __name__ == &#39;__main__&#39;:\n    test_retry5()</code></pre>","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"python-请求重试机制tenacity\"><a href=\"#python-请求重试机制tenacity\" class=\"headerlink\" title=\"python 请求重试机制tenacity\"></a>python 请求重试机制tenacity</h1><p>优秀的参考<br> <a href=\"https://www.cnblogs.com/wuzhibinsuib/p/13443622.html\" target=\"_blank\" rel=\"noopener\">ref</a><br><code>from tenacity import *</code></p>\n<h1 id=\"正常看到错误就重试\"><a href=\"#正常看到错误就重试\" class=\"headerlink\" title=\"正常看到错误就重试\"></a>正常看到错误就重试</h1><pre><code>@retry\ndef test_retry1():\n    print(&quot;等待重试.....&quot;)\n    raise Exception  # 通过raise直接返回一个错误</code></pre><h1 id=\"设置最大的重试次数\"><a href=\"#设置最大的重试次数\" class=\"headerlink\" title=\"设置最大的重试次数\"></a>设置最大的重试次数</h1><pre><code>@retry(stop=stop_after_attempt(5))\ndef test_retry2():\n    print(&quot;等待重试.....&quot;)\n    raise Exception</code></pre><h1 id=\"设置最大重试时间，-这里的意思是5秒内如果还错误就继续执行\"><a href=\"#设置最大重试时间，-这里的意思是5秒内如果还错误就继续执行\" class=\"headerlink\" title=\"设置最大重试时间， 这里的意思是5秒内如果还错误就继续执行\"></a>设置最大重试时间， 这里的意思是5秒内如果还错误就继续执行</h1><pre><code>@retry(stop=stop_after_delay(5))\ndef test_retry3():\n    print(&quot;等待重试.....&quot;)\n    return &quot;hello&quot; + 1</code></pre><h1 id=\"指定特定的错误类型\"><a href=\"#指定特定的错误类型\" class=\"headerlink\" title=\"指定特定的错误类型\"></a>指定特定的错误类型</h1><pre><code>@retry(retry=retry_if_exception_type(TypeError))\ndef test_retry4():\n    print(&quot;等待重试.....&quot;)\n    raise TypeError # 捕获类型错误，当出现类型错误时重试</code></pre><h1 id=\"同时设置多个参数\"><a href=\"#同时设置多个参数\" class=\"headerlink\" title=\"同时设置多个参数\"></a>同时设置多个参数</h1><pre><code>from tenacity import retry, stop_after_delay, stop_after_attempt\n\n@retry(stop=(stop_after_delay(5) | stop_after_attempt(7)))\ndef test_retry():\n    print(&quot;等待重试....&quot;)\n    raise Exception\n\ntest_retry()\n</code></pre><h1 id=\"自定义\"><a href=\"#自定义\" class=\"headerlink\" title=\"自定义\"></a>自定义</h1><pre><code>\n\n# 首先定义了一个函数symbol，它的作用是判断传入的值是否为None；它返回一个布尔值，如果结果value=None，则返回true，否则返回False\ndef symbol(value):\n    return value is None\n\n\n# 装饰器中retry=retry_if_result(symbol)，表示把test_retry函数的结果传入symbol，判断test_retry的结果是否为None，\n# 如果=None，就进行重试(retry),如果不等于None，就结束并返回函数值（所以达成重试的条件是test_retry的结果是否为条件函数定义的结果）\n@retry(stop=stop_after_attempt(3), retry=retry_if_result(symbol), reraise=True)\ndef test_retry():\n    print(&quot;等待重试.....&quot;)\n    return None\n\nif __name__ == &#39;__main__&#39;:\n    test_retry5()</code></pre>"},{"_content":"\n\n\n# opengl学习\n\n## 安装\n\n\n\n安装的时候注意系统版本（pip默认下载32位的）\n\n去官网下载64位的安装包[链接](https://www.lfd.uci.edu/~gohlke/pythonlibs/#pyopengl)\n\n\n## 基本入门\n\n### OpenGL 库及函数简介\nOpenGL函数的命名格式如下：\n\n```\n<库前缀><根命令><可选的参数个数><可选的参数类型>\n\n```\n\n**常见的库前缀**有 gl、glu、glut、aux、wgl、glx、agl 等。库前缀表示该函数属于 OpenGL 哪一个开发库。\n\n**从函数名后面中还可以看出需要多少个参数以及参数的类型。I 代表 int 型，f 代表 float 型，d 代表 double 型，u 代表无符号整型。例如 glColor3f() 表示了该函数属于gl库，参数是三个浮点数。**\n\nOpenGL 函数库相关的 API 有核心库(gl)、实用库(glu)、实用工具库(glut)、辅助库(aux)、窗口库(glx、agl、wgl)和扩展函数库等。gl是核心，glu是对gl的部分封装。glut是为跨平台的OpenGL程序的工具包，比aux功能强大。glx、agl、wgl 是针对不同窗口系统的函数。扩展函数库是硬件厂商为实现硬件更新利用OpenGL的扩展机制开发的函数。本文仅对常用的四个库做简单介绍。\n\n### OpenGL 核心库 GL\n\n核心库包含有115个函数，函数名的前缀为gl。这部分函数用于常规的、核心的图形处理。此函数由gl.dll来负责解释执行。由于许多函数可以接收不同数以下几类。据类型的参数，因此派生出来的函数原形多达300多个。核心库中的函数主要可以分为以下几类函数：\n\n#### 绘制基本几何图元的函数：\n`glBegain()、glEnd()、glNormal*()、glVertex*()`\n\n#### 矩阵操作、几何变换和投影变换的函数：\n如矩阵入栈函数**glPushMatrix**()，矩阵出栈函数**glPopMatrix**()，装载矩阵函数**glLoadMatrix**()，矩阵相乘函数**glMultMatrix**()，当前矩阵函数**glMatrixMode**()和矩阵标准化函数**glLoadIdentity**()，几何变换函数**glTranslate***()、**glRotate***()和**glScale***()，投影变换函数**glOrtho**()、**glFrustum**()和视口变换函数**glViewport**()\n\n#### 颜色、光照和材质的函数：\n如设置颜色模式函数glColor*()、glIndex*()，设置光照效果的函数glLight*() 、glLightModel*()和设置材质效果函数glMaterial()\n\n#### 显示列表函数：\n主要有创建、结束、生成、删除和调用显示列表的函数glNewList()、glEndList()、glGenLists()、glCallList()和glDeleteLists()\n\n#### 纹理映射函数：\n主要有一维纹理函数glTexImage1D()、二维纹理函数glTexImage2D()、设置纹理参数、纹理环境和纹理坐标的函数glTexParameter*()、glTexEnv*()和glTetCoord*()\n\n#### 特殊效果函数：\n融合函数glBlendFunc()、反走样函数glHint()和雾化效果glFog*()\n\n#### 光栅化、象素操作函数：\n如象素位置glRasterPos*()、线型宽度glLineWidth()、多边形绘制模式glPolygonMode()，读取象素glReadPixel()、复制象素glCopyPixel()\n\n#### 选择与反馈函数：\n主要有渲染模式glRenderMode()、选择缓冲区glSelectBuffer()和反馈缓冲区glFeedbackBuffer()\n\n#### 曲线与曲面的绘制函数：\n生成曲线或曲面的函数glMap*()、glMapGrid*()，求值器的函数glEvalCoord*() glEvalMesh*()\n\n#### 状态设置与查询函数：\nglGet*()、glEnable()、glGetError()\n\n### OpenGL 实用库 GLU\n\n包含有43个函数，函数名的前缀为glu。OpenGL提供了强大的但是为数不多的绘图命令，所有较复杂的绘图都必须从点、线、面开始。Glu 为了减轻繁重的编程工作，封装了OpenGL函数，Glu函数通过调用核心库的函数，为开发者提供相对简单的用法，实现一些较为复杂的操作。此函数由glu.dll来负责解释执行。OpenGL中的核心库和实用库可以在所有的OpenGL平台上运行。主要包括了以下几种：\n\n#### 辅助纹理贴图函数：\ngluScaleImage() 、gluBuild1Dmipmaps()、gluBuild2Dmipmaps()\n\n#### 坐标转换和投影变换函数：\n定义投影方式函数gluPerspective()、gluOrtho2D() 、gluLookAt()，拾取投影视景体函数gluPickMatrix()，投影矩阵计算gluProject()和gluUnProject()\n\n#### 多边形镶嵌工具：\ngluNewTess()、gluDeleteTess()、gluTessCallback()、gluBeginPolygon()、gluTessVertex()、gluNextContour()、gluEndPolygon()\n\n#### 二次曲面绘制工具：\n主要有绘制球面、锥面、柱面、圆环面gluNewQuadric()、gluSphere()、gluCylinder()、gluDisk()、gluPartialDisk()、gluDeleteQuadric()\n\n\n\n### OpenGL 工具库 GLUT\n\n包含大约30多个函数，函数名前缀为glut。glut是不依赖于窗口平台的OpenGL工具包，由Mark KLilgrad在SGI编写（现在在Nvidia），目的是隐藏不同窗口平台API的复杂度。函数以glut开头，它们作为aux库功能更强的替代品，提供更为复杂的绘制功能，此函数由glut.dll来负责解释执行。由于glut中的窗口管理函数是不依赖于运行环境的，因此OpenGL中的工具库可以在X-Window, Windows NT, OS/2等系统下运行，特别适合于开发不需要复杂界面的OpenGL示例程序。对于有经验的程序员来说，一般先用glut理顺3D图形代码，然后再集成为完整的应用程序。这部分函数主要包括：\n\n#### 窗口操作函数：\n窗口初始化、窗口大小、窗口位置函数等 glutInit()、glutInitDisplayMode()、glutInitWindowSize()、glutInitWindowPosition()\n\n#### 回调函数：\n响应刷新消息、键盘消息、鼠标消息、定时器函数 GlutDisplayFunc()、glutPostRedisplay()、glutReshapeFunc()、glutTimerFunc()、glutKeyboardFunc()、glutMouseFunc()\n\n#### 创建复杂的三维物体：\n这些和aux库的函数功能相同\n\n#### 菜单函数：\n创建添加菜单的函数 GlutCreateMenu()、glutSetMenu()、glutAddMenuEntry()、glutAddSubMenu() 和 glutAttachMenu()\n\n#### 程序运行函数：\nglutMainLoop()\n\n\n\n\n\n## 入门之线段的绘制\n\n**先上代码**\n\n```\n# -*- coding: utf-8 -*-\nfrom OpenGL.GL import *\nfrom OpenGL.GLU import *\nfrom OpenGL.GLUT import *\nimport numpy as np\n\n\ndef init():\n    glClearColor(1.0, 1.0, 1.0, 0.0)  # 设置画布背景色。注意：这里必须是4个参数\n    # glClear(GL_COLOR_BUFFER_BIT)  # 将上面的颜色赋值给窗口, 只要有这个先后顺序就行\n\n    glMatrixMode(GL_PROJECTION)  #设置投影模式\n    gluOrtho2D(0,200,0,200)  # 设置画布x，y的范围\n    glDisable(GL_BLEND)  # 关闭颜色混合\n\n    glEnable(GL_LINE_STIPPLE)  #启用线型，可以绘制虚线之类的了\n\n\n\n# 绘制图像函数\ndef drawFunc():\n    global x\n    global y\n\n    # 清除屏幕\n    glClear(GL_COLOR_BUFFER_BIT)\n\n    glLineWidth(10.0)  # 设置线的宽度\n\n    glBegin(GL_LINE_STRIP)  # 绘制连续线段\n\n    glColor4f(1.0, 0.0, 0.0, 1.0)        # 设置当前颜色为红色不透明\n\n\n    for i in range(len(x)):\n        glVertex2f(x[i]*100,y[i])\n\n    glEnd()\n\n\n    # 刷新显示图像，保证前面的OpenGL命令立即执行，而不是让它们在缓冲区中等待。\n    glFlush()\n\n\n# 主函数\nif __name__ == \"__main__\":\n    # 使用glut库初始化OpenGL\n    glutInit()\n    # 显示模式 GLUT_SINGLE无缓冲直接显示|GLUT_RGBA采用RGB(A非alpha)\n    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGBA)\n    # 设置窗口位置及大小\n    glutInitWindowPosition(0, 0)  # 位置是指在屏幕的位置\n    glutInitWindowSize(400, 400)\n    # 创建窗口\n    glutCreateWindow(\"myTest1\")\n    global x\n    global y\n    x = np.linspace(0,2* np.pi,num=1000)\n    y = np.sin(x)* 200\n\n\n    init()\n\n\n    # 调用display()函数绘制图像\n    glutDisplayFunc(drawFunc)\n\n\n    # 进入glut主循环\n    glutMainLoop()\n\n```\n\n\n\n\n\n### 函数讲解-----void glLineStipple(GLint factor,GLshort pattern)\n\n这是用来设置线型的。\n\n**从这个模式的低位开始，**一个像素一个像素的进行处理。如果模式中对应的位是1，就绘制这个像素，否则就不绘制。模式可以使用factor参数（表示重复因子）进行扩展，它与1和0的连续子序列相乘。因此，如果模式中出现了3个1，并且factor是2，那么它们就扩展为6个连续的1。必须以GL_LINE_STIPPLE为参数调用glEnable()才能启用直线点画功能。为了禁用直线点画功能，可以向glDisable()函数传递同一个参数。\n\n例如：\n\n**glLineStipple(1, 0x3F07);**\n\nglEnable(GL_LINE_STIPPLE);  //启用线型\n\n此时模式为Ox3F07（二进制形式为0011111100000111）**低位开始，从右往左**，它所画出来的直线是这样的：先连续绘制3个像素，然后连续5个像素留空，再连续绘制6个像素，最后两个像素留空（注意，首先是从低位开始的）。如果factor是2，那么这个模式便被扩展为：先连续绘制6个像素，然后连续10个像素留空，再连续绘制12个像素，最后4个像素留空。\n\n如果没有启用点画线功能，OpenGL会自动把pattern当做为OxFFFF，把factor当成1。\n\n```\n# -*- coding: utf-8 -*-\nfrom OpenGL.GL import *\nfrom OpenGL.GLU import *\nfrom OpenGL.GLUT import *\nimport numpy as np\n\n\ndef init():\n    glClearColor(1.0, 1.0, 1.0, 0.0)  # 设置画布背景色。注意：这里必须是4个参数\n    # glClear(GL_COLOR_BUFFER_BIT)  # 将上面的颜色赋值给窗口, 只要有这个先后顺序就行\n\n    glMatrixMode(GL_PROJECTION)  #设置投影模式\n    gluOrtho2D(0,200,0,200)  # 设置画布x，y的范围\n    glDisable(GL_BLEND)  # 关闭颜色混合\n\n    glEnable(GL_LINE_STIPPLE)  #启用线型，可以绘制虚线之类的了\n\n\n\n# 绘制图像函数\ndef drawFunc():\n    global x\n    global y\n\n    # 清除屏幕\n    glClear(GL_COLOR_BUFFER_BIT)\n\n    glLineWidth(3.0)  # 设置线的宽度\n\n    glLineStipple(1, 0xFFFF);  # 设置线型,直线\n\n\n    glBegin(GL_LINE_STRIP)  # 绘制连续线段\n\n    glColor4f(1.0, 0.0, 0.0, 1.0)        # 设置当前颜色为红色不透明\n\n    for i in range(len(x)):\n        glVertex2f(x[i]*100,y[i])\n\n    glEnd()\n\n\n\n    glLineStipple(1, 0x00FF);  # 设置线型,虚线\n\n\n    glBegin(GL_LINE_STRIP)  # 绘制连续线段\n\n    glColor4f(0.0, 1.0, 0.0, 1.0)        # 设置当前颜色为红色不透明\n\n    for i in range(len(x)):\n        glVertex2f(x[i]*100,y[i] -20)\n\n    glEnd()\n\n    # 刷新显示图像，保证前面的OpenGL命令立即执行，而不是让它们在缓冲区中等待。\n    glFlush()\n\n\n# 主函数\nif __name__ == \"__main__\":\n    # 使用glut库初始化OpenGL\n    glutInit()\n    # 显示模式 GLUT_SINGLE无缓冲直接显示|GLUT_RGBA采用RGB(A非alpha)\n    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGBA)\n    # 设置窗口位置及大小\n    glutInitWindowPosition(0, 0)  # 位置是指在屏幕的位置\n    glutInitWindowSize(400, 400)\n    # 创建窗口\n    glutCreateWindow(\"myTest1\")\n    global x\n    global y\n    x = np.linspace(0,2* np.pi,num=1000)\n    y = np.sin(x)* 200\n\n\n    init()\n\n\n    # 调用display()函数绘制图像\n    glutDisplayFunc(drawFunc)\n\n\n    # 进入glut主循环\n    glutMainLoop()\n\n```\n\n\n\n\n\n### 启用线性插值----glShadeModel(GL_SMOOTH) \n\n```\n# -*- coding: utf-8 -*-\nfrom OpenGL.GL import *\nfrom OpenGL.GLU import *\nfrom OpenGL.GLUT import *\nimport numpy as np\n\n\ndef init():\n    glClearColor(1.0, 1.0, 1.0, 0.0)  # 设置画布背景色。注意：这里必须是4个参数\n    # glClear(GL_COLOR_BUFFER_BIT)  # 将上面的颜色赋值给窗口, 只要有这个先后顺序就行\n\n    glMatrixMode(GL_PROJECTION)  #设置投影模式\n    gluOrtho2D(0,200,0,200)  # 设置画布x，y的范围\n    glDisable(GL_BLEND)  # 关闭颜色混合\n\n    glEnable(GL_LINE_STIPPLE)  #启用线型，可以绘制虚线之类的了\n\n\n\n# 绘制图像函数\ndef drawFunc():\n    global x\n    global y\n\n    # 清除屏幕\n    glClear(GL_COLOR_BUFFER_BIT)\n\n    glLineWidth(3.0)  # 设置线的宽度\n\n    glLineStipple(1, 0xFFFF);  # 设置线型,直线\n\n    glShadeModel(GL_SMOOTH)  # 开启对颜色的线性插值\n\n\n\n    glBegin(GL_LINE_STRIP)  # 绘制连续线段\n\n    for i in range(len(x)):\n        glColor4f(0.0,  i /len(x), i /len(x), 1.0)  # 设置当前颜色,渐变\n\n        glVertex2f(x[i]*100,y[i])\n\n    glEnd()\n\n\n\n\n\n    # 刷新显示图像，保证前面的OpenGL命令立即执行，而不是让它们在缓冲区中等待。\n    glFlush()\n\n\n# 主函数\nif __name__ == \"__main__\":\n    # 使用glut库初始化OpenGL\n    glutInit()\n    # 显示模式 GLUT_SINGLE无缓冲直接显示|GLUT_RGBA采用RGB(A非alpha)\n    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGBA)\n    # 设置窗口位置及大小\n    glutInitWindowPosition(0, 0)  # 位置是指在屏幕的位置\n    glutInitWindowSize(400, 400)\n    # 创建窗口\n    glutCreateWindow(\"myTest1\")\n    global x\n    global y\n    x = np.linspace(0,0.5* np.pi,num=1000)\n    y = np.sin(x)* 200\n\n    init()\n\n    # 调用display()函数绘制图像\n    glutDisplayFunc(drawFunc)\n\n\n    # 进入glut主循环\n    glutMainLoop()\n\n```\n\n\n\n\n\n## 几何变换\n\n**几何变换本质是仿射变换**，二维与三位基本原理一样，这里不多赘述\n\n\n\n### 函数glMatrixMode（）\n\n**这个函数其实就是对接下来要做什么进行一下声明**，也就是在要做下一步之前告诉计算机我要对“什么”进行操作了，这个“什么”在glMatrixMode的“()”里的选项(参数)有**，GL_PROJECTION，GL_MODELVIEW和GL_TEXTURE；**\n\n**详细说明**\n\n- **GL_PROJECTION**： 这个是投影的意思，就是要对投影相关进行操作，也就是把物体投影到一个平面上，就像我们照相一样，把3维物体投到2维的平面上。这样，接下来的语句可以是跟透视相关的函数，比如glFrustum()或gluPerspective()；\n- **GL_MODELVIEW**：对模型视景的操作，接下来的语句描绘一个以模型为基础的适应，这样来设置参数，接下来用到的就是像gluLookAt()这样的函数；\n- **GL_TEXTURE：**对纹理相关进行操作\n\n\n\n\n\n### 函数glLoadIdentity()\n\n**恢复初始坐标系的手段**：该命令是一个无参的无值函数，其功能是用一个4×4的单位矩阵来替换当前矩阵，实际上就是对当前矩阵进行初始化。也就是说，无论以前进行了多少次矩阵变换，在该命令执行后，**当前矩阵均恢复成一个单位矩阵，即相当于没有进行任何矩阵变换状态**\n\n### 三维中的视角投影\n\n![image-20210518184712038](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7974510d81a8f068b3b3d3e0ac238580/2250a2194fd4eca0a860e796f7366f82.png)\n\n以上是书里面的形容整个工作流程的段内容。\n\n\n\n**分为**\n\n#### 平行投影\n\n![image-20210518184935113](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7974510d81a8f068b3b3d3e0ac238580/508b98e6ad40a60dacb2bb2854e5f749.png)\n\n\n\n#### 透视投影\n\n![image-20210518185003943](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7974510d81a8f068b3b3d3e0ac238580/35526336ec9d6370cf1619c7d7a10360.png)\n\n### 函数glOrtho（），平行投影\n\n类似二维的**gluOrtho2D（）**\n\n**创建一个正交平行的视景体**。 一般用于物体不会因为离屏幕的远近而产生大小的变换的情况\n\n例：\n\n```\n    glOrtho(-1,1,-1,1,-1,1)  # 设置视景体\n```\n\n**视景体**:其实就是能够显示观察的范围。\n\n![image-20210518144514464](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7974510d81a8f068b3b3d3e0ac238580/9ef786641e8327032a3d7a981a778626.png)\n\n\n\n\n\n### 透视投影glFrustum（）\n\n![image-20210518185229062](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7974510d81a8f068b3b3d3e0ac238580/7bbc25d1492e3b81ee11ef5b968874e8.png)\n\n\n\n\n\n![image-20210518144522692](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7974510d81a8f068b3b3d3e0ac238580/3ce99d17c2fd0addad843f0d33bc1760.png)\n\n\n\n```\n    # 使用前的基本设置\n    glMatrixMode(GL_MODELVIEW)  #设置投影模式\n    gluLookAt(0,0,0,  #相机在世界坐标的位置\n              0,0,1,  #相机镜头对准的物体在世界坐标的位置！！！！！！，这里是物体的位置\n              1,0,0  #相机向上的方向在世界坐标中的方向\n              )\n\n\n    glMatrixMode(GL_PROJECTION)  #设置投影模式\n    # 设置投影变换视景体参数\n    glFrustum(-1,1,-1,1, 0.3,2)\n```\n\n绘制图形\n\n```\n    glColor4f(1,0,0,1)\n    drawCircle(0,0,100,0.5,z=0.5)\n\n\n    glColor4f(0,0,1,1)\n    drawCircle(0,0,100, 1, z=0.9)\n```\n\n这两个圆半径相差一倍，但是使用透视投影，第一个能遮住第二个半\n\n![image-20210518191339617](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7974510d81a8f068b3b3d3e0ac238580/99bc0e5b277845423ed4bc0276813fcd.png)\n\n**果然**\n\n\n\n\n\n\n\n\n\n### 平移\n\n```\n    glTranslatef(0.5, 0.0, 0)  # 沿着x轴平移0.5\n```\n\n\n\n### 旋转\n\n```\n    glPushMatrix()  # 观察矩阵入栈\n    glRotate(90,0,0,1)  # 围绕y轴旋转90度\n    drawTriangle(0)\n\n    glPopMatrix()  # 观察矩阵出栈，相当于回复初始矩阵了\n```\n\n\n\n### 缩放\n\n```\n    glPushMatrix()  # 观察矩阵入栈\n    glScale(0.5,0.5,0.5)  # 缩放到一半\n    drawTriangle(0)\n\n    glPopMatrix()  # 观察矩阵出栈，相当于回复初始矩阵了\n```\n\n\n\n### 观察矩阵入栈与出栈\n\n物体的显示是有经过观察矩阵变换的\n\n当你做了一些移动或旋转等变换后，使用**glPushMatrix**(); **观察矩阵入栈**\nOpenGL 会把这个变换后的位置和角度保存起来。\n然后你再随便做第二次移动或旋转变换，再用**glPopMatrix**();**观察矩阵出栈**\nOpenGL 就把刚刚保存的那个位置和角度恢复。\n\n\n\n### 关于视图模式下几何变换的矩阵计算顺序（非常重要的一个概念）\n\n**是类似栈一样执行的**\n\n```\n     # 从点(x0,y0,0)绕方向（0，0，1）旋转theta度\n    glTranslatef(x0,y0,0)                   M1\n    glRotate(theta ,0,0,1)  # 围绕y轴旋转90度 M2\n    glTranslatef(-1*x0,-1*y0,0)  \t\t\tM3\n```\n\n对于接下来要绘制的图形而言，实际上，应该是\n\n$$x^{,} = M1 \\cdot M2 \\cdot M3 \\cdot x$$\n\n这个在很多时候都非常重要\n\n\n\n\n\n## 深度测试\n\n**深度缓冲(Depth Buffer)**,以防止被其他面遮挡的面渲染到前面。使用函数\n\n```\n    glEnable(GL_DEPTH_TEST)  # 深度测试\n```\n\n\n\n**实验**\n\n我们同时绘制两个z轴不同的图形\n\n```\n    drawTriangle(0)\n\n    drawCircle(0,0,100, 0.9)\n\n```\n\n\n\n没开之前\n\n![image-20210518150145147](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7974510d81a8f068b3b3d3e0ac238580/b4716349e59a32047b1eafc54132f229.png)\n\n不难看出，三角形被后来绘制的圆形给挡住了。\n\n**开启深度测试**\n\n![image-20210518150228027](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7974510d81a8f068b3b3d3e0ac238580/3e22591f8acb6b6e8832e33cb467cea5.png)\n\n**没毛病**\n\n\n\n","source":"_posts/综合/opengl学习.md","raw":"\n\n\n# opengl学习\n\n## 安装\n\n\n\n安装的时候注意系统版本（pip默认下载32位的）\n\n去官网下载64位的安装包[链接](https://www.lfd.uci.edu/~gohlke/pythonlibs/#pyopengl)\n\n\n## 基本入门\n\n### OpenGL 库及函数简介\nOpenGL函数的命名格式如下：\n\n```\n<库前缀><根命令><可选的参数个数><可选的参数类型>\n\n```\n\n**常见的库前缀**有 gl、glu、glut、aux、wgl、glx、agl 等。库前缀表示该函数属于 OpenGL 哪一个开发库。\n\n**从函数名后面中还可以看出需要多少个参数以及参数的类型。I 代表 int 型，f 代表 float 型，d 代表 double 型，u 代表无符号整型。例如 glColor3f() 表示了该函数属于gl库，参数是三个浮点数。**\n\nOpenGL 函数库相关的 API 有核心库(gl)、实用库(glu)、实用工具库(glut)、辅助库(aux)、窗口库(glx、agl、wgl)和扩展函数库等。gl是核心，glu是对gl的部分封装。glut是为跨平台的OpenGL程序的工具包，比aux功能强大。glx、agl、wgl 是针对不同窗口系统的函数。扩展函数库是硬件厂商为实现硬件更新利用OpenGL的扩展机制开发的函数。本文仅对常用的四个库做简单介绍。\n\n### OpenGL 核心库 GL\n\n核心库包含有115个函数，函数名的前缀为gl。这部分函数用于常规的、核心的图形处理。此函数由gl.dll来负责解释执行。由于许多函数可以接收不同数以下几类。据类型的参数，因此派生出来的函数原形多达300多个。核心库中的函数主要可以分为以下几类函数：\n\n#### 绘制基本几何图元的函数：\n`glBegain()、glEnd()、glNormal*()、glVertex*()`\n\n#### 矩阵操作、几何变换和投影变换的函数：\n如矩阵入栈函数**glPushMatrix**()，矩阵出栈函数**glPopMatrix**()，装载矩阵函数**glLoadMatrix**()，矩阵相乘函数**glMultMatrix**()，当前矩阵函数**glMatrixMode**()和矩阵标准化函数**glLoadIdentity**()，几何变换函数**glTranslate***()、**glRotate***()和**glScale***()，投影变换函数**glOrtho**()、**glFrustum**()和视口变换函数**glViewport**()\n\n#### 颜色、光照和材质的函数：\n如设置颜色模式函数glColor*()、glIndex*()，设置光照效果的函数glLight*() 、glLightModel*()和设置材质效果函数glMaterial()\n\n#### 显示列表函数：\n主要有创建、结束、生成、删除和调用显示列表的函数glNewList()、glEndList()、glGenLists()、glCallList()和glDeleteLists()\n\n#### 纹理映射函数：\n主要有一维纹理函数glTexImage1D()、二维纹理函数glTexImage2D()、设置纹理参数、纹理环境和纹理坐标的函数glTexParameter*()、glTexEnv*()和glTetCoord*()\n\n#### 特殊效果函数：\n融合函数glBlendFunc()、反走样函数glHint()和雾化效果glFog*()\n\n#### 光栅化、象素操作函数：\n如象素位置glRasterPos*()、线型宽度glLineWidth()、多边形绘制模式glPolygonMode()，读取象素glReadPixel()、复制象素glCopyPixel()\n\n#### 选择与反馈函数：\n主要有渲染模式glRenderMode()、选择缓冲区glSelectBuffer()和反馈缓冲区glFeedbackBuffer()\n\n#### 曲线与曲面的绘制函数：\n生成曲线或曲面的函数glMap*()、glMapGrid*()，求值器的函数glEvalCoord*() glEvalMesh*()\n\n#### 状态设置与查询函数：\nglGet*()、glEnable()、glGetError()\n\n### OpenGL 实用库 GLU\n\n包含有43个函数，函数名的前缀为glu。OpenGL提供了强大的但是为数不多的绘图命令，所有较复杂的绘图都必须从点、线、面开始。Glu 为了减轻繁重的编程工作，封装了OpenGL函数，Glu函数通过调用核心库的函数，为开发者提供相对简单的用法，实现一些较为复杂的操作。此函数由glu.dll来负责解释执行。OpenGL中的核心库和实用库可以在所有的OpenGL平台上运行。主要包括了以下几种：\n\n#### 辅助纹理贴图函数：\ngluScaleImage() 、gluBuild1Dmipmaps()、gluBuild2Dmipmaps()\n\n#### 坐标转换和投影变换函数：\n定义投影方式函数gluPerspective()、gluOrtho2D() 、gluLookAt()，拾取投影视景体函数gluPickMatrix()，投影矩阵计算gluProject()和gluUnProject()\n\n#### 多边形镶嵌工具：\ngluNewTess()、gluDeleteTess()、gluTessCallback()、gluBeginPolygon()、gluTessVertex()、gluNextContour()、gluEndPolygon()\n\n#### 二次曲面绘制工具：\n主要有绘制球面、锥面、柱面、圆环面gluNewQuadric()、gluSphere()、gluCylinder()、gluDisk()、gluPartialDisk()、gluDeleteQuadric()\n\n\n\n### OpenGL 工具库 GLUT\n\n包含大约30多个函数，函数名前缀为glut。glut是不依赖于窗口平台的OpenGL工具包，由Mark KLilgrad在SGI编写（现在在Nvidia），目的是隐藏不同窗口平台API的复杂度。函数以glut开头，它们作为aux库功能更强的替代品，提供更为复杂的绘制功能，此函数由glut.dll来负责解释执行。由于glut中的窗口管理函数是不依赖于运行环境的，因此OpenGL中的工具库可以在X-Window, Windows NT, OS/2等系统下运行，特别适合于开发不需要复杂界面的OpenGL示例程序。对于有经验的程序员来说，一般先用glut理顺3D图形代码，然后再集成为完整的应用程序。这部分函数主要包括：\n\n#### 窗口操作函数：\n窗口初始化、窗口大小、窗口位置函数等 glutInit()、glutInitDisplayMode()、glutInitWindowSize()、glutInitWindowPosition()\n\n#### 回调函数：\n响应刷新消息、键盘消息、鼠标消息、定时器函数 GlutDisplayFunc()、glutPostRedisplay()、glutReshapeFunc()、glutTimerFunc()、glutKeyboardFunc()、glutMouseFunc()\n\n#### 创建复杂的三维物体：\n这些和aux库的函数功能相同\n\n#### 菜单函数：\n创建添加菜单的函数 GlutCreateMenu()、glutSetMenu()、glutAddMenuEntry()、glutAddSubMenu() 和 glutAttachMenu()\n\n#### 程序运行函数：\nglutMainLoop()\n\n\n\n\n\n## 入门之线段的绘制\n\n**先上代码**\n\n```\n# -*- coding: utf-8 -*-\nfrom OpenGL.GL import *\nfrom OpenGL.GLU import *\nfrom OpenGL.GLUT import *\nimport numpy as np\n\n\ndef init():\n    glClearColor(1.0, 1.0, 1.0, 0.0)  # 设置画布背景色。注意：这里必须是4个参数\n    # glClear(GL_COLOR_BUFFER_BIT)  # 将上面的颜色赋值给窗口, 只要有这个先后顺序就行\n\n    glMatrixMode(GL_PROJECTION)  #设置投影模式\n    gluOrtho2D(0,200,0,200)  # 设置画布x，y的范围\n    glDisable(GL_BLEND)  # 关闭颜色混合\n\n    glEnable(GL_LINE_STIPPLE)  #启用线型，可以绘制虚线之类的了\n\n\n\n# 绘制图像函数\ndef drawFunc():\n    global x\n    global y\n\n    # 清除屏幕\n    glClear(GL_COLOR_BUFFER_BIT)\n\n    glLineWidth(10.0)  # 设置线的宽度\n\n    glBegin(GL_LINE_STRIP)  # 绘制连续线段\n\n    glColor4f(1.0, 0.0, 0.0, 1.0)        # 设置当前颜色为红色不透明\n\n\n    for i in range(len(x)):\n        glVertex2f(x[i]*100,y[i])\n\n    glEnd()\n\n\n    # 刷新显示图像，保证前面的OpenGL命令立即执行，而不是让它们在缓冲区中等待。\n    glFlush()\n\n\n# 主函数\nif __name__ == \"__main__\":\n    # 使用glut库初始化OpenGL\n    glutInit()\n    # 显示模式 GLUT_SINGLE无缓冲直接显示|GLUT_RGBA采用RGB(A非alpha)\n    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGBA)\n    # 设置窗口位置及大小\n    glutInitWindowPosition(0, 0)  # 位置是指在屏幕的位置\n    glutInitWindowSize(400, 400)\n    # 创建窗口\n    glutCreateWindow(\"myTest1\")\n    global x\n    global y\n    x = np.linspace(0,2* np.pi,num=1000)\n    y = np.sin(x)* 200\n\n\n    init()\n\n\n    # 调用display()函数绘制图像\n    glutDisplayFunc(drawFunc)\n\n\n    # 进入glut主循环\n    glutMainLoop()\n\n```\n\n\n\n\n\n### 函数讲解-----void glLineStipple(GLint factor,GLshort pattern)\n\n这是用来设置线型的。\n\n**从这个模式的低位开始，**一个像素一个像素的进行处理。如果模式中对应的位是1，就绘制这个像素，否则就不绘制。模式可以使用factor参数（表示重复因子）进行扩展，它与1和0的连续子序列相乘。因此，如果模式中出现了3个1，并且factor是2，那么它们就扩展为6个连续的1。必须以GL_LINE_STIPPLE为参数调用glEnable()才能启用直线点画功能。为了禁用直线点画功能，可以向glDisable()函数传递同一个参数。\n\n例如：\n\n**glLineStipple(1, 0x3F07);**\n\nglEnable(GL_LINE_STIPPLE);  //启用线型\n\n此时模式为Ox3F07（二进制形式为0011111100000111）**低位开始，从右往左**，它所画出来的直线是这样的：先连续绘制3个像素，然后连续5个像素留空，再连续绘制6个像素，最后两个像素留空（注意，首先是从低位开始的）。如果factor是2，那么这个模式便被扩展为：先连续绘制6个像素，然后连续10个像素留空，再连续绘制12个像素，最后4个像素留空。\n\n如果没有启用点画线功能，OpenGL会自动把pattern当做为OxFFFF，把factor当成1。\n\n```\n# -*- coding: utf-8 -*-\nfrom OpenGL.GL import *\nfrom OpenGL.GLU import *\nfrom OpenGL.GLUT import *\nimport numpy as np\n\n\ndef init():\n    glClearColor(1.0, 1.0, 1.0, 0.0)  # 设置画布背景色。注意：这里必须是4个参数\n    # glClear(GL_COLOR_BUFFER_BIT)  # 将上面的颜色赋值给窗口, 只要有这个先后顺序就行\n\n    glMatrixMode(GL_PROJECTION)  #设置投影模式\n    gluOrtho2D(0,200,0,200)  # 设置画布x，y的范围\n    glDisable(GL_BLEND)  # 关闭颜色混合\n\n    glEnable(GL_LINE_STIPPLE)  #启用线型，可以绘制虚线之类的了\n\n\n\n# 绘制图像函数\ndef drawFunc():\n    global x\n    global y\n\n    # 清除屏幕\n    glClear(GL_COLOR_BUFFER_BIT)\n\n    glLineWidth(3.0)  # 设置线的宽度\n\n    glLineStipple(1, 0xFFFF);  # 设置线型,直线\n\n\n    glBegin(GL_LINE_STRIP)  # 绘制连续线段\n\n    glColor4f(1.0, 0.0, 0.0, 1.0)        # 设置当前颜色为红色不透明\n\n    for i in range(len(x)):\n        glVertex2f(x[i]*100,y[i])\n\n    glEnd()\n\n\n\n    glLineStipple(1, 0x00FF);  # 设置线型,虚线\n\n\n    glBegin(GL_LINE_STRIP)  # 绘制连续线段\n\n    glColor4f(0.0, 1.0, 0.0, 1.0)        # 设置当前颜色为红色不透明\n\n    for i in range(len(x)):\n        glVertex2f(x[i]*100,y[i] -20)\n\n    glEnd()\n\n    # 刷新显示图像，保证前面的OpenGL命令立即执行，而不是让它们在缓冲区中等待。\n    glFlush()\n\n\n# 主函数\nif __name__ == \"__main__\":\n    # 使用glut库初始化OpenGL\n    glutInit()\n    # 显示模式 GLUT_SINGLE无缓冲直接显示|GLUT_RGBA采用RGB(A非alpha)\n    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGBA)\n    # 设置窗口位置及大小\n    glutInitWindowPosition(0, 0)  # 位置是指在屏幕的位置\n    glutInitWindowSize(400, 400)\n    # 创建窗口\n    glutCreateWindow(\"myTest1\")\n    global x\n    global y\n    x = np.linspace(0,2* np.pi,num=1000)\n    y = np.sin(x)* 200\n\n\n    init()\n\n\n    # 调用display()函数绘制图像\n    glutDisplayFunc(drawFunc)\n\n\n    # 进入glut主循环\n    glutMainLoop()\n\n```\n\n\n\n\n\n### 启用线性插值----glShadeModel(GL_SMOOTH) \n\n```\n# -*- coding: utf-8 -*-\nfrom OpenGL.GL import *\nfrom OpenGL.GLU import *\nfrom OpenGL.GLUT import *\nimport numpy as np\n\n\ndef init():\n    glClearColor(1.0, 1.0, 1.0, 0.0)  # 设置画布背景色。注意：这里必须是4个参数\n    # glClear(GL_COLOR_BUFFER_BIT)  # 将上面的颜色赋值给窗口, 只要有这个先后顺序就行\n\n    glMatrixMode(GL_PROJECTION)  #设置投影模式\n    gluOrtho2D(0,200,0,200)  # 设置画布x，y的范围\n    glDisable(GL_BLEND)  # 关闭颜色混合\n\n    glEnable(GL_LINE_STIPPLE)  #启用线型，可以绘制虚线之类的了\n\n\n\n# 绘制图像函数\ndef drawFunc():\n    global x\n    global y\n\n    # 清除屏幕\n    glClear(GL_COLOR_BUFFER_BIT)\n\n    glLineWidth(3.0)  # 设置线的宽度\n\n    glLineStipple(1, 0xFFFF);  # 设置线型,直线\n\n    glShadeModel(GL_SMOOTH)  # 开启对颜色的线性插值\n\n\n\n    glBegin(GL_LINE_STRIP)  # 绘制连续线段\n\n    for i in range(len(x)):\n        glColor4f(0.0,  i /len(x), i /len(x), 1.0)  # 设置当前颜色,渐变\n\n        glVertex2f(x[i]*100,y[i])\n\n    glEnd()\n\n\n\n\n\n    # 刷新显示图像，保证前面的OpenGL命令立即执行，而不是让它们在缓冲区中等待。\n    glFlush()\n\n\n# 主函数\nif __name__ == \"__main__\":\n    # 使用glut库初始化OpenGL\n    glutInit()\n    # 显示模式 GLUT_SINGLE无缓冲直接显示|GLUT_RGBA采用RGB(A非alpha)\n    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGBA)\n    # 设置窗口位置及大小\n    glutInitWindowPosition(0, 0)  # 位置是指在屏幕的位置\n    glutInitWindowSize(400, 400)\n    # 创建窗口\n    glutCreateWindow(\"myTest1\")\n    global x\n    global y\n    x = np.linspace(0,0.5* np.pi,num=1000)\n    y = np.sin(x)* 200\n\n    init()\n\n    # 调用display()函数绘制图像\n    glutDisplayFunc(drawFunc)\n\n\n    # 进入glut主循环\n    glutMainLoop()\n\n```\n\n\n\n\n\n## 几何变换\n\n**几何变换本质是仿射变换**，二维与三位基本原理一样，这里不多赘述\n\n\n\n### 函数glMatrixMode（）\n\n**这个函数其实就是对接下来要做什么进行一下声明**，也就是在要做下一步之前告诉计算机我要对“什么”进行操作了，这个“什么”在glMatrixMode的“()”里的选项(参数)有**，GL_PROJECTION，GL_MODELVIEW和GL_TEXTURE；**\n\n**详细说明**\n\n- **GL_PROJECTION**： 这个是投影的意思，就是要对投影相关进行操作，也就是把物体投影到一个平面上，就像我们照相一样，把3维物体投到2维的平面上。这样，接下来的语句可以是跟透视相关的函数，比如glFrustum()或gluPerspective()；\n- **GL_MODELVIEW**：对模型视景的操作，接下来的语句描绘一个以模型为基础的适应，这样来设置参数，接下来用到的就是像gluLookAt()这样的函数；\n- **GL_TEXTURE：**对纹理相关进行操作\n\n\n\n\n\n### 函数glLoadIdentity()\n\n**恢复初始坐标系的手段**：该命令是一个无参的无值函数，其功能是用一个4×4的单位矩阵来替换当前矩阵，实际上就是对当前矩阵进行初始化。也就是说，无论以前进行了多少次矩阵变换，在该命令执行后，**当前矩阵均恢复成一个单位矩阵，即相当于没有进行任何矩阵变换状态**\n\n### 三维中的视角投影\n\n![image-20210518184712038](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7974510d81a8f068b3b3d3e0ac238580/2250a2194fd4eca0a860e796f7366f82.png)\n\n以上是书里面的形容整个工作流程的段内容。\n\n\n\n**分为**\n\n#### 平行投影\n\n![image-20210518184935113](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7974510d81a8f068b3b3d3e0ac238580/508b98e6ad40a60dacb2bb2854e5f749.png)\n\n\n\n#### 透视投影\n\n![image-20210518185003943](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7974510d81a8f068b3b3d3e0ac238580/35526336ec9d6370cf1619c7d7a10360.png)\n\n### 函数glOrtho（），平行投影\n\n类似二维的**gluOrtho2D（）**\n\n**创建一个正交平行的视景体**。 一般用于物体不会因为离屏幕的远近而产生大小的变换的情况\n\n例：\n\n```\n    glOrtho(-1,1,-1,1,-1,1)  # 设置视景体\n```\n\n**视景体**:其实就是能够显示观察的范围。\n\n![image-20210518144514464](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7974510d81a8f068b3b3d3e0ac238580/9ef786641e8327032a3d7a981a778626.png)\n\n\n\n\n\n### 透视投影glFrustum（）\n\n![image-20210518185229062](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7974510d81a8f068b3b3d3e0ac238580/7bbc25d1492e3b81ee11ef5b968874e8.png)\n\n\n\n\n\n![image-20210518144522692](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7974510d81a8f068b3b3d3e0ac238580/3ce99d17c2fd0addad843f0d33bc1760.png)\n\n\n\n```\n    # 使用前的基本设置\n    glMatrixMode(GL_MODELVIEW)  #设置投影模式\n    gluLookAt(0,0,0,  #相机在世界坐标的位置\n              0,0,1,  #相机镜头对准的物体在世界坐标的位置！！！！！！，这里是物体的位置\n              1,0,0  #相机向上的方向在世界坐标中的方向\n              )\n\n\n    glMatrixMode(GL_PROJECTION)  #设置投影模式\n    # 设置投影变换视景体参数\n    glFrustum(-1,1,-1,1, 0.3,2)\n```\n\n绘制图形\n\n```\n    glColor4f(1,0,0,1)\n    drawCircle(0,0,100,0.5,z=0.5)\n\n\n    glColor4f(0,0,1,1)\n    drawCircle(0,0,100, 1, z=0.9)\n```\n\n这两个圆半径相差一倍，但是使用透视投影，第一个能遮住第二个半\n\n![image-20210518191339617](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7974510d81a8f068b3b3d3e0ac238580/99bc0e5b277845423ed4bc0276813fcd.png)\n\n**果然**\n\n\n\n\n\n\n\n\n\n### 平移\n\n```\n    glTranslatef(0.5, 0.0, 0)  # 沿着x轴平移0.5\n```\n\n\n\n### 旋转\n\n```\n    glPushMatrix()  # 观察矩阵入栈\n    glRotate(90,0,0,1)  # 围绕y轴旋转90度\n    drawTriangle(0)\n\n    glPopMatrix()  # 观察矩阵出栈，相当于回复初始矩阵了\n```\n\n\n\n### 缩放\n\n```\n    glPushMatrix()  # 观察矩阵入栈\n    glScale(0.5,0.5,0.5)  # 缩放到一半\n    drawTriangle(0)\n\n    glPopMatrix()  # 观察矩阵出栈，相当于回复初始矩阵了\n```\n\n\n\n### 观察矩阵入栈与出栈\n\n物体的显示是有经过观察矩阵变换的\n\n当你做了一些移动或旋转等变换后，使用**glPushMatrix**(); **观察矩阵入栈**\nOpenGL 会把这个变换后的位置和角度保存起来。\n然后你再随便做第二次移动或旋转变换，再用**glPopMatrix**();**观察矩阵出栈**\nOpenGL 就把刚刚保存的那个位置和角度恢复。\n\n\n\n### 关于视图模式下几何变换的矩阵计算顺序（非常重要的一个概念）\n\n**是类似栈一样执行的**\n\n```\n     # 从点(x0,y0,0)绕方向（0，0，1）旋转theta度\n    glTranslatef(x0,y0,0)                   M1\n    glRotate(theta ,0,0,1)  # 围绕y轴旋转90度 M2\n    glTranslatef(-1*x0,-1*y0,0)  \t\t\tM3\n```\n\n对于接下来要绘制的图形而言，实际上，应该是\n\n$$x^{,} = M1 \\cdot M2 \\cdot M3 \\cdot x$$\n\n这个在很多时候都非常重要\n\n\n\n\n\n## 深度测试\n\n**深度缓冲(Depth Buffer)**,以防止被其他面遮挡的面渲染到前面。使用函数\n\n```\n    glEnable(GL_DEPTH_TEST)  # 深度测试\n```\n\n\n\n**实验**\n\n我们同时绘制两个z轴不同的图形\n\n```\n    drawTriangle(0)\n\n    drawCircle(0,0,100, 0.9)\n\n```\n\n\n\n没开之前\n\n![image-20210518150145147](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7974510d81a8f068b3b3d3e0ac238580/b4716349e59a32047b1eafc54132f229.png)\n\n不难看出，三角形被后来绘制的圆形给挡住了。\n\n**开启深度测试**\n\n![image-20210518150228027](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7974510d81a8f068b3b3d3e0ac238580/3e22591f8acb6b6e8832e33cb467cea5.png)\n\n**没毛病**\n\n\n\n","slug":"综合/opengl学习","published":1,"date":"2023-02-26T15:28:35.060Z","updated":"2023-02-27T11:34:33.140Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsycm001n0gcnc5yj7a1b","content":"<h1 id=\"opengl学习\"><a href=\"#opengl学习\" class=\"headerlink\" title=\"opengl学习\"></a>opengl学习</h1><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>安装的时候注意系统版本（pip默认下载32位的）</p>\n<p>去官网下载64位的安装包<a href=\"https://www.lfd.uci.edu/~gohlke/pythonlibs/#pyopengl\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<h2 id=\"基本入门\"><a href=\"#基本入门\" class=\"headerlink\" title=\"基本入门\"></a>基本入门</h2><h3 id=\"OpenGL-库及函数简介\"><a href=\"#OpenGL-库及函数简介\" class=\"headerlink\" title=\"OpenGL 库及函数简介\"></a>OpenGL 库及函数简介</h3><p>OpenGL函数的命名格式如下：</p>\n<pre><code>&lt;库前缀&gt;&lt;根命令&gt;&lt;可选的参数个数&gt;&lt;可选的参数类型&gt;\n</code></pre><p><strong>常见的库前缀</strong>有 gl、glu、glut、aux、wgl、glx、agl 等。库前缀表示该函数属于 OpenGL 哪一个开发库。</p>\n<p><strong>从函数名后面中还可以看出需要多少个参数以及参数的类型。I 代表 int 型，f 代表 float 型，d 代表 double 型，u 代表无符号整型。例如 glColor3f() 表示了该函数属于gl库，参数是三个浮点数。</strong></p>\n<p>OpenGL 函数库相关的 API 有核心库(gl)、实用库(glu)、实用工具库(glut)、辅助库(aux)、窗口库(glx、agl、wgl)和扩展函数库等。gl是核心，glu是对gl的部分封装。glut是为跨平台的OpenGL程序的工具包，比aux功能强大。glx、agl、wgl 是针对不同窗口系统的函数。扩展函数库是硬件厂商为实现硬件更新利用OpenGL的扩展机制开发的函数。本文仅对常用的四个库做简单介绍。</p>\n<h3 id=\"OpenGL-核心库-GL\"><a href=\"#OpenGL-核心库-GL\" class=\"headerlink\" title=\"OpenGL 核心库 GL\"></a>OpenGL 核心库 GL</h3><p>核心库包含有115个函数，函数名的前缀为gl。这部分函数用于常规的、核心的图形处理。此函数由gl.dll来负责解释执行。由于许多函数可以接收不同数以下几类。据类型的参数，因此派生出来的函数原形多达300多个。核心库中的函数主要可以分为以下几类函数：</p>\n<h4 id=\"绘制基本几何图元的函数：\"><a href=\"#绘制基本几何图元的函数：\" class=\"headerlink\" title=\"绘制基本几何图元的函数：\"></a>绘制基本几何图元的函数：</h4><p><code>glBegain()、glEnd()、glNormal*()、glVertex*()</code></p>\n<h4 id=\"矩阵操作、几何变换和投影变换的函数：\"><a href=\"#矩阵操作、几何变换和投影变换的函数：\" class=\"headerlink\" title=\"矩阵操作、几何变换和投影变换的函数：\"></a>矩阵操作、几何变换和投影变换的函数：</h4><p>如矩阵入栈函数<strong>glPushMatrix</strong>()，矩阵出栈函数<strong>glPopMatrix</strong>()，装载矩阵函数<strong>glLoadMatrix</strong>()，矩阵相乘函数<strong>glMultMatrix</strong>()，当前矩阵函数<strong>glMatrixMode</strong>()和矩阵标准化函数<strong>glLoadIdentity</strong>()，几何变换函数<strong>glTranslate*</strong>()、<strong>glRotate*</strong>()和<strong>glScale*</strong>()，投影变换函数<strong>glOrtho</strong>()、<strong>glFrustum</strong>()和视口变换函数<strong>glViewport</strong>()</p>\n<h4 id=\"颜色、光照和材质的函数：\"><a href=\"#颜色、光照和材质的函数：\" class=\"headerlink\" title=\"颜色、光照和材质的函数：\"></a>颜色、光照和材质的函数：</h4><p>如设置颜色模式函数glColor<em>()、glIndex</em>()，设置光照效果的函数glLight<em>() 、glLightModel</em>()和设置材质效果函数glMaterial()</p>\n<h4 id=\"显示列表函数：\"><a href=\"#显示列表函数：\" class=\"headerlink\" title=\"显示列表函数：\"></a>显示列表函数：</h4><p>主要有创建、结束、生成、删除和调用显示列表的函数glNewList()、glEndList()、glGenLists()、glCallList()和glDeleteLists()</p>\n<h4 id=\"纹理映射函数：\"><a href=\"#纹理映射函数：\" class=\"headerlink\" title=\"纹理映射函数：\"></a>纹理映射函数：</h4><p>主要有一维纹理函数glTexImage1D()、二维纹理函数glTexImage2D()、设置纹理参数、纹理环境和纹理坐标的函数glTexParameter<em>()、glTexEnv</em>()和glTetCoord*()</p>\n<h4 id=\"特殊效果函数：\"><a href=\"#特殊效果函数：\" class=\"headerlink\" title=\"特殊效果函数：\"></a>特殊效果函数：</h4><p>融合函数glBlendFunc()、反走样函数glHint()和雾化效果glFog*()</p>\n<h4 id=\"光栅化、象素操作函数：\"><a href=\"#光栅化、象素操作函数：\" class=\"headerlink\" title=\"光栅化、象素操作函数：\"></a>光栅化、象素操作函数：</h4><p>如象素位置glRasterPos*()、线型宽度glLineWidth()、多边形绘制模式glPolygonMode()，读取象素glReadPixel()、复制象素glCopyPixel()</p>\n<h4 id=\"选择与反馈函数：\"><a href=\"#选择与反馈函数：\" class=\"headerlink\" title=\"选择与反馈函数：\"></a>选择与反馈函数：</h4><p>主要有渲染模式glRenderMode()、选择缓冲区glSelectBuffer()和反馈缓冲区glFeedbackBuffer()</p>\n<h4 id=\"曲线与曲面的绘制函数：\"><a href=\"#曲线与曲面的绘制函数：\" class=\"headerlink\" title=\"曲线与曲面的绘制函数：\"></a>曲线与曲面的绘制函数：</h4><p>生成曲线或曲面的函数glMap<em>()、glMapGrid</em>()，求值器的函数glEvalCoord<em>() glEvalMesh</em>()</p>\n<h4 id=\"状态设置与查询函数：\"><a href=\"#状态设置与查询函数：\" class=\"headerlink\" title=\"状态设置与查询函数：\"></a>状态设置与查询函数：</h4><p>glGet*()、glEnable()、glGetError()</p>\n<h3 id=\"OpenGL-实用库-GLU\"><a href=\"#OpenGL-实用库-GLU\" class=\"headerlink\" title=\"OpenGL 实用库 GLU\"></a>OpenGL 实用库 GLU</h3><p>包含有43个函数，函数名的前缀为glu。OpenGL提供了强大的但是为数不多的绘图命令，所有较复杂的绘图都必须从点、线、面开始。Glu 为了减轻繁重的编程工作，封装了OpenGL函数，Glu函数通过调用核心库的函数，为开发者提供相对简单的用法，实现一些较为复杂的操作。此函数由glu.dll来负责解释执行。OpenGL中的核心库和实用库可以在所有的OpenGL平台上运行。主要包括了以下几种：</p>\n<h4 id=\"辅助纹理贴图函数：\"><a href=\"#辅助纹理贴图函数：\" class=\"headerlink\" title=\"辅助纹理贴图函数：\"></a>辅助纹理贴图函数：</h4><p>gluScaleImage() 、gluBuild1Dmipmaps()、gluBuild2Dmipmaps()</p>\n<h4 id=\"坐标转换和投影变换函数：\"><a href=\"#坐标转换和投影变换函数：\" class=\"headerlink\" title=\"坐标转换和投影变换函数：\"></a>坐标转换和投影变换函数：</h4><p>定义投影方式函数gluPerspective()、gluOrtho2D() 、gluLookAt()，拾取投影视景体函数gluPickMatrix()，投影矩阵计算gluProject()和gluUnProject()</p>\n<h4 id=\"多边形镶嵌工具：\"><a href=\"#多边形镶嵌工具：\" class=\"headerlink\" title=\"多边形镶嵌工具：\"></a>多边形镶嵌工具：</h4><p>gluNewTess()、gluDeleteTess()、gluTessCallback()、gluBeginPolygon()、gluTessVertex()、gluNextContour()、gluEndPolygon()</p>\n<h4 id=\"二次曲面绘制工具：\"><a href=\"#二次曲面绘制工具：\" class=\"headerlink\" title=\"二次曲面绘制工具：\"></a>二次曲面绘制工具：</h4><p>主要有绘制球面、锥面、柱面、圆环面gluNewQuadric()、gluSphere()、gluCylinder()、gluDisk()、gluPartialDisk()、gluDeleteQuadric()</p>\n<h3 id=\"OpenGL-工具库-GLUT\"><a href=\"#OpenGL-工具库-GLUT\" class=\"headerlink\" title=\"OpenGL 工具库 GLUT\"></a>OpenGL 工具库 GLUT</h3><p>包含大约30多个函数，函数名前缀为glut。glut是不依赖于窗口平台的OpenGL工具包，由Mark KLilgrad在SGI编写（现在在Nvidia），目的是隐藏不同窗口平台API的复杂度。函数以glut开头，它们作为aux库功能更强的替代品，提供更为复杂的绘制功能，此函数由glut.dll来负责解释执行。由于glut中的窗口管理函数是不依赖于运行环境的，因此OpenGL中的工具库可以在X-Window, Windows NT, OS/2等系统下运行，特别适合于开发不需要复杂界面的OpenGL示例程序。对于有经验的程序员来说，一般先用glut理顺3D图形代码，然后再集成为完整的应用程序。这部分函数主要包括：</p>\n<h4 id=\"窗口操作函数：\"><a href=\"#窗口操作函数：\" class=\"headerlink\" title=\"窗口操作函数：\"></a>窗口操作函数：</h4><p>窗口初始化、窗口大小、窗口位置函数等 glutInit()、glutInitDisplayMode()、glutInitWindowSize()、glutInitWindowPosition()</p>\n<h4 id=\"回调函数：\"><a href=\"#回调函数：\" class=\"headerlink\" title=\"回调函数：\"></a>回调函数：</h4><p>响应刷新消息、键盘消息、鼠标消息、定时器函数 GlutDisplayFunc()、glutPostRedisplay()、glutReshapeFunc()、glutTimerFunc()、glutKeyboardFunc()、glutMouseFunc()</p>\n<h4 id=\"创建复杂的三维物体：\"><a href=\"#创建复杂的三维物体：\" class=\"headerlink\" title=\"创建复杂的三维物体：\"></a>创建复杂的三维物体：</h4><p>这些和aux库的函数功能相同</p>\n<h4 id=\"菜单函数：\"><a href=\"#菜单函数：\" class=\"headerlink\" title=\"菜单函数：\"></a>菜单函数：</h4><p>创建添加菜单的函数 GlutCreateMenu()、glutSetMenu()、glutAddMenuEntry()、glutAddSubMenu() 和 glutAttachMenu()</p>\n<h4 id=\"程序运行函数：\"><a href=\"#程序运行函数：\" class=\"headerlink\" title=\"程序运行函数：\"></a>程序运行函数：</h4><p>glutMainLoop()</p>\n<h2 id=\"入门之线段的绘制\"><a href=\"#入门之线段的绘制\" class=\"headerlink\" title=\"入门之线段的绘制\"></a>入门之线段的绘制</h2><p><strong>先上代码</strong></p>\n<pre><code># -*- coding: utf-8 -*-\nfrom OpenGL.GL import *\nfrom OpenGL.GLU import *\nfrom OpenGL.GLUT import *\nimport numpy as np\n\n\ndef init():\n    glClearColor(1.0, 1.0, 1.0, 0.0)  # 设置画布背景色。注意：这里必须是4个参数\n    # glClear(GL_COLOR_BUFFER_BIT)  # 将上面的颜色赋值给窗口, 只要有这个先后顺序就行\n\n    glMatrixMode(GL_PROJECTION)  #设置投影模式\n    gluOrtho2D(0,200,0,200)  # 设置画布x，y的范围\n    glDisable(GL_BLEND)  # 关闭颜色混合\n\n    glEnable(GL_LINE_STIPPLE)  #启用线型，可以绘制虚线之类的了\n\n\n\n# 绘制图像函数\ndef drawFunc():\n    global x\n    global y\n\n    # 清除屏幕\n    glClear(GL_COLOR_BUFFER_BIT)\n\n    glLineWidth(10.0)  # 设置线的宽度\n\n    glBegin(GL_LINE_STRIP)  # 绘制连续线段\n\n    glColor4f(1.0, 0.0, 0.0, 1.0)        # 设置当前颜色为红色不透明\n\n\n    for i in range(len(x)):\n        glVertex2f(x[i]*100,y[i])\n\n    glEnd()\n\n\n    # 刷新显示图像，保证前面的OpenGL命令立即执行，而不是让它们在缓冲区中等待。\n    glFlush()\n\n\n# 主函数\nif __name__ == &quot;__main__&quot;:\n    # 使用glut库初始化OpenGL\n    glutInit()\n    # 显示模式 GLUT_SINGLE无缓冲直接显示|GLUT_RGBA采用RGB(A非alpha)\n    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGBA)\n    # 设置窗口位置及大小\n    glutInitWindowPosition(0, 0)  # 位置是指在屏幕的位置\n    glutInitWindowSize(400, 400)\n    # 创建窗口\n    glutCreateWindow(&quot;myTest1&quot;)\n    global x\n    global y\n    x = np.linspace(0,2* np.pi,num=1000)\n    y = np.sin(x)* 200\n\n\n    init()\n\n\n    # 调用display()函数绘制图像\n    glutDisplayFunc(drawFunc)\n\n\n    # 进入glut主循环\n    glutMainLoop()\n</code></pre><h3 id=\"函数讲解—–void-glLineStipple-GLint-factor-GLshort-pattern\"><a href=\"#函数讲解—–void-glLineStipple-GLint-factor-GLshort-pattern\" class=\"headerlink\" title=\"函数讲解—–void glLineStipple(GLint factor,GLshort pattern)\"></a>函数讲解—–void glLineStipple(GLint factor,GLshort pattern)</h3><p>这是用来设置线型的。</p>\n<p><strong>从这个模式的低位开始，</strong>一个像素一个像素的进行处理。如果模式中对应的位是1，就绘制这个像素，否则就不绘制。模式可以使用factor参数（表示重复因子）进行扩展，它与1和0的连续子序列相乘。因此，如果模式中出现了3个1，并且factor是2，那么它们就扩展为6个连续的1。必须以GL_LINE_STIPPLE为参数调用glEnable()才能启用直线点画功能。为了禁用直线点画功能，可以向glDisable()函数传递同一个参数。</p>\n<p>例如：</p>\n<p><strong>glLineStipple(1, 0x3F07);</strong></p>\n<p>glEnable(GL_LINE_STIPPLE);  //启用线型</p>\n<p>此时模式为Ox3F07（二进制形式为0011111100000111）<strong>低位开始，从右往左</strong>，它所画出来的直线是这样的：先连续绘制3个像素，然后连续5个像素留空，再连续绘制6个像素，最后两个像素留空（注意，首先是从低位开始的）。如果factor是2，那么这个模式便被扩展为：先连续绘制6个像素，然后连续10个像素留空，再连续绘制12个像素，最后4个像素留空。</p>\n<p>如果没有启用点画线功能，OpenGL会自动把pattern当做为OxFFFF，把factor当成1。</p>\n<pre><code># -*- coding: utf-8 -*-\nfrom OpenGL.GL import *\nfrom OpenGL.GLU import *\nfrom OpenGL.GLUT import *\nimport numpy as np\n\n\ndef init():\n    glClearColor(1.0, 1.0, 1.0, 0.0)  # 设置画布背景色。注意：这里必须是4个参数\n    # glClear(GL_COLOR_BUFFER_BIT)  # 将上面的颜色赋值给窗口, 只要有这个先后顺序就行\n\n    glMatrixMode(GL_PROJECTION)  #设置投影模式\n    gluOrtho2D(0,200,0,200)  # 设置画布x，y的范围\n    glDisable(GL_BLEND)  # 关闭颜色混合\n\n    glEnable(GL_LINE_STIPPLE)  #启用线型，可以绘制虚线之类的了\n\n\n\n# 绘制图像函数\ndef drawFunc():\n    global x\n    global y\n\n    # 清除屏幕\n    glClear(GL_COLOR_BUFFER_BIT)\n\n    glLineWidth(3.0)  # 设置线的宽度\n\n    glLineStipple(1, 0xFFFF);  # 设置线型,直线\n\n\n    glBegin(GL_LINE_STRIP)  # 绘制连续线段\n\n    glColor4f(1.0, 0.0, 0.0, 1.0)        # 设置当前颜色为红色不透明\n\n    for i in range(len(x)):\n        glVertex2f(x[i]*100,y[i])\n\n    glEnd()\n\n\n\n    glLineStipple(1, 0x00FF);  # 设置线型,虚线\n\n\n    glBegin(GL_LINE_STRIP)  # 绘制连续线段\n\n    glColor4f(0.0, 1.0, 0.0, 1.0)        # 设置当前颜色为红色不透明\n\n    for i in range(len(x)):\n        glVertex2f(x[i]*100,y[i] -20)\n\n    glEnd()\n\n    # 刷新显示图像，保证前面的OpenGL命令立即执行，而不是让它们在缓冲区中等待。\n    glFlush()\n\n\n# 主函数\nif __name__ == &quot;__main__&quot;:\n    # 使用glut库初始化OpenGL\n    glutInit()\n    # 显示模式 GLUT_SINGLE无缓冲直接显示|GLUT_RGBA采用RGB(A非alpha)\n    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGBA)\n    # 设置窗口位置及大小\n    glutInitWindowPosition(0, 0)  # 位置是指在屏幕的位置\n    glutInitWindowSize(400, 400)\n    # 创建窗口\n    glutCreateWindow(&quot;myTest1&quot;)\n    global x\n    global y\n    x = np.linspace(0,2* np.pi,num=1000)\n    y = np.sin(x)* 200\n\n\n    init()\n\n\n    # 调用display()函数绘制图像\n    glutDisplayFunc(drawFunc)\n\n\n    # 进入glut主循环\n    glutMainLoop()\n</code></pre><h3 id=\"启用线性插值—-glShadeModel-GL-SMOOTH\"><a href=\"#启用线性插值—-glShadeModel-GL-SMOOTH\" class=\"headerlink\" title=\"启用线性插值—-glShadeModel(GL_SMOOTH)\"></a>启用线性插值—-glShadeModel(GL_SMOOTH)</h3><pre><code># -*- coding: utf-8 -*-\nfrom OpenGL.GL import *\nfrom OpenGL.GLU import *\nfrom OpenGL.GLUT import *\nimport numpy as np\n\n\ndef init():\n    glClearColor(1.0, 1.0, 1.0, 0.0)  # 设置画布背景色。注意：这里必须是4个参数\n    # glClear(GL_COLOR_BUFFER_BIT)  # 将上面的颜色赋值给窗口, 只要有这个先后顺序就行\n\n    glMatrixMode(GL_PROJECTION)  #设置投影模式\n    gluOrtho2D(0,200,0,200)  # 设置画布x，y的范围\n    glDisable(GL_BLEND)  # 关闭颜色混合\n\n    glEnable(GL_LINE_STIPPLE)  #启用线型，可以绘制虚线之类的了\n\n\n\n# 绘制图像函数\ndef drawFunc():\n    global x\n    global y\n\n    # 清除屏幕\n    glClear(GL_COLOR_BUFFER_BIT)\n\n    glLineWidth(3.0)  # 设置线的宽度\n\n    glLineStipple(1, 0xFFFF);  # 设置线型,直线\n\n    glShadeModel(GL_SMOOTH)  # 开启对颜色的线性插值\n\n\n\n    glBegin(GL_LINE_STRIP)  # 绘制连续线段\n\n    for i in range(len(x)):\n        glColor4f(0.0,  i /len(x), i /len(x), 1.0)  # 设置当前颜色,渐变\n\n        glVertex2f(x[i]*100,y[i])\n\n    glEnd()\n\n\n\n\n\n    # 刷新显示图像，保证前面的OpenGL命令立即执行，而不是让它们在缓冲区中等待。\n    glFlush()\n\n\n# 主函数\nif __name__ == &quot;__main__&quot;:\n    # 使用glut库初始化OpenGL\n    glutInit()\n    # 显示模式 GLUT_SINGLE无缓冲直接显示|GLUT_RGBA采用RGB(A非alpha)\n    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGBA)\n    # 设置窗口位置及大小\n    glutInitWindowPosition(0, 0)  # 位置是指在屏幕的位置\n    glutInitWindowSize(400, 400)\n    # 创建窗口\n    glutCreateWindow(&quot;myTest1&quot;)\n    global x\n    global y\n    x = np.linspace(0,0.5* np.pi,num=1000)\n    y = np.sin(x)* 200\n\n    init()\n\n    # 调用display()函数绘制图像\n    glutDisplayFunc(drawFunc)\n\n\n    # 进入glut主循环\n    glutMainLoop()\n</code></pre><h2 id=\"几何变换\"><a href=\"#几何变换\" class=\"headerlink\" title=\"几何变换\"></a>几何变换</h2><p><strong>几何变换本质是仿射变换</strong>，二维与三位基本原理一样，这里不多赘述</p>\n<h3 id=\"函数glMatrixMode（）\"><a href=\"#函数glMatrixMode（）\" class=\"headerlink\" title=\"函数glMatrixMode（）\"></a>函数glMatrixMode（）</h3><p><strong>这个函数其实就是对接下来要做什么进行一下声明</strong>，也就是在要做下一步之前告诉计算机我要对“什么”进行操作了，这个“什么”在glMatrixMode的“()”里的选项(参数)有<strong>，GL_PROJECTION，GL_MODELVIEW和GL_TEXTURE；</strong></p>\n<p><strong>详细说明</strong></p>\n<ul>\n<li><strong>GL_PROJECTION</strong>： 这个是投影的意思，就是要对投影相关进行操作，也就是把物体投影到一个平面上，就像我们照相一样，把3维物体投到2维的平面上。这样，接下来的语句可以是跟透视相关的函数，比如glFrustum()或gluPerspective()；</li>\n<li><strong>GL_MODELVIEW</strong>：对模型视景的操作，接下来的语句描绘一个以模型为基础的适应，这样来设置参数，接下来用到的就是像gluLookAt()这样的函数；</li>\n<li><strong>GL_TEXTURE：</strong>对纹理相关进行操作</li>\n</ul>\n<h3 id=\"函数glLoadIdentity\"><a href=\"#函数glLoadIdentity\" class=\"headerlink\" title=\"函数glLoadIdentity()\"></a>函数glLoadIdentity()</h3><p><strong>恢复初始坐标系的手段</strong>：该命令是一个无参的无值函数，其功能是用一个4×4的单位矩阵来替换当前矩阵，实际上就是对当前矩阵进行初始化。也就是说，无论以前进行了多少次矩阵变换，在该命令执行后，<strong>当前矩阵均恢复成一个单位矩阵，即相当于没有进行任何矩阵变换状态</strong></p>\n<h3 id=\"三维中的视角投影\"><a href=\"#三维中的视角投影\" class=\"headerlink\" title=\"三维中的视角投影\"></a>三维中的视角投影</h3><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7974510d81a8f068b3b3d3e0ac238580/2250a2194fd4eca0a860e796f7366f82.png\" alt=\"image-20210518184712038\"></p>\n<p>以上是书里面的形容整个工作流程的段内容。</p>\n<p><strong>分为</strong></p>\n<h4 id=\"平行投影\"><a href=\"#平行投影\" class=\"headerlink\" title=\"平行投影\"></a>平行投影</h4><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7974510d81a8f068b3b3d3e0ac238580/508b98e6ad40a60dacb2bb2854e5f749.png\" alt=\"image-20210518184935113\"></p>\n<h4 id=\"透视投影\"><a href=\"#透视投影\" class=\"headerlink\" title=\"透视投影\"></a>透视投影</h4><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7974510d81a8f068b3b3d3e0ac238580/35526336ec9d6370cf1619c7d7a10360.png\" alt=\"image-20210518185003943\"></p>\n<h3 id=\"函数glOrtho（），平行投影\"><a href=\"#函数glOrtho（），平行投影\" class=\"headerlink\" title=\"函数glOrtho（），平行投影\"></a>函数glOrtho（），平行投影</h3><p>类似二维的<strong>gluOrtho2D（）</strong></p>\n<p><strong>创建一个正交平行的视景体</strong>。 一般用于物体不会因为离屏幕的远近而产生大小的变换的情况</p>\n<p>例：</p>\n<pre><code>    glOrtho(-1,1,-1,1,-1,1)  # 设置视景体</code></pre><p><strong>视景体</strong>:其实就是能够显示观察的范围。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7974510d81a8f068b3b3d3e0ac238580/9ef786641e8327032a3d7a981a778626.png\" alt=\"image-20210518144514464\"></p>\n<h3 id=\"透视投影glFrustum（）\"><a href=\"#透视投影glFrustum（）\" class=\"headerlink\" title=\"透视投影glFrustum（）\"></a>透视投影glFrustum（）</h3><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7974510d81a8f068b3b3d3e0ac238580/7bbc25d1492e3b81ee11ef5b968874e8.png\" alt=\"image-20210518185229062\"></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7974510d81a8f068b3b3d3e0ac238580/3ce99d17c2fd0addad843f0d33bc1760.png\" alt=\"image-20210518144522692\"></p>\n<pre><code>    # 使用前的基本设置\n    glMatrixMode(GL_MODELVIEW)  #设置投影模式\n    gluLookAt(0,0,0,  #相机在世界坐标的位置\n              0,0,1,  #相机镜头对准的物体在世界坐标的位置！！！！！！，这里是物体的位置\n              1,0,0  #相机向上的方向在世界坐标中的方向\n              )\n\n\n    glMatrixMode(GL_PROJECTION)  #设置投影模式\n    # 设置投影变换视景体参数\n    glFrustum(-1,1,-1,1, 0.3,2)</code></pre><p>绘制图形</p>\n<pre><code>    glColor4f(1,0,0,1)\n    drawCircle(0,0,100,0.5,z=0.5)\n\n\n    glColor4f(0,0,1,1)\n    drawCircle(0,0,100, 1, z=0.9)</code></pre><p>这两个圆半径相差一倍，但是使用透视投影，第一个能遮住第二个半</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7974510d81a8f068b3b3d3e0ac238580/99bc0e5b277845423ed4bc0276813fcd.png\" alt=\"image-20210518191339617\"></p>\n<p><strong>果然</strong></p>\n<h3 id=\"平移\"><a href=\"#平移\" class=\"headerlink\" title=\"平移\"></a>平移</h3><pre><code>    glTranslatef(0.5, 0.0, 0)  # 沿着x轴平移0.5</code></pre><h3 id=\"旋转\"><a href=\"#旋转\" class=\"headerlink\" title=\"旋转\"></a>旋转</h3><pre><code>    glPushMatrix()  # 观察矩阵入栈\n    glRotate(90,0,0,1)  # 围绕y轴旋转90度\n    drawTriangle(0)\n\n    glPopMatrix()  # 观察矩阵出栈，相当于回复初始矩阵了</code></pre><h3 id=\"缩放\"><a href=\"#缩放\" class=\"headerlink\" title=\"缩放\"></a>缩放</h3><pre><code>    glPushMatrix()  # 观察矩阵入栈\n    glScale(0.5,0.5,0.5)  # 缩放到一半\n    drawTriangle(0)\n\n    glPopMatrix()  # 观察矩阵出栈，相当于回复初始矩阵了</code></pre><h3 id=\"观察矩阵入栈与出栈\"><a href=\"#观察矩阵入栈与出栈\" class=\"headerlink\" title=\"观察矩阵入栈与出栈\"></a>观察矩阵入栈与出栈</h3><p>物体的显示是有经过观察矩阵变换的</p>\n<p>当你做了一些移动或旋转等变换后，使用<strong>glPushMatrix</strong>(); <strong>观察矩阵入栈</strong><br>OpenGL 会把这个变换后的位置和角度保存起来。<br>然后你再随便做第二次移动或旋转变换，再用<strong>glPopMatrix</strong>();<strong>观察矩阵出栈</strong><br>OpenGL 就把刚刚保存的那个位置和角度恢复。</p>\n<h3 id=\"关于视图模式下几何变换的矩阵计算顺序（非常重要的一个概念）\"><a href=\"#关于视图模式下几何变换的矩阵计算顺序（非常重要的一个概念）\" class=\"headerlink\" title=\"关于视图模式下几何变换的矩阵计算顺序（非常重要的一个概念）\"></a>关于视图模式下几何变换的矩阵计算顺序（非常重要的一个概念）</h3><p><strong>是类似栈一样执行的</strong></p>\n<pre><code>     # 从点(x0,y0,0)绕方向（0，0，1）旋转theta度\n    glTranslatef(x0,y0,0)                   M1\n    glRotate(theta ,0,0,1)  # 围绕y轴旋转90度 M2\n    glTranslatef(-1*x0,-1*y0,0)              M3</code></pre><p>对于接下来要绘制的图形而言，实际上，应该是</p>\n<p>$$x^{,} = M1 \\cdot M2 \\cdot M3 \\cdot x$$</p>\n<p>这个在很多时候都非常重要</p>\n<h2 id=\"深度测试\"><a href=\"#深度测试\" class=\"headerlink\" title=\"深度测试\"></a>深度测试</h2><p><strong>深度缓冲(Depth Buffer)</strong>,以防止被其他面遮挡的面渲染到前面。使用函数</p>\n<pre><code>    glEnable(GL_DEPTH_TEST)  # 深度测试</code></pre><p><strong>实验</strong></p>\n<p>我们同时绘制两个z轴不同的图形</p>\n<pre><code>    drawTriangle(0)\n\n    drawCircle(0,0,100, 0.9)\n</code></pre><p>没开之前</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7974510d81a8f068b3b3d3e0ac238580/b4716349e59a32047b1eafc54132f229.png\" alt=\"image-20210518150145147\"></p>\n<p>不难看出，三角形被后来绘制的圆形给挡住了。</p>\n<p><strong>开启深度测试</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7974510d81a8f068b3b3d3e0ac238580/3e22591f8acb6b6e8832e33cb467cea5.png\" alt=\"image-20210518150228027\"></p>\n<p><strong>没毛病</strong></p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"opengl学习\"><a href=\"#opengl学习\" class=\"headerlink\" title=\"opengl学习\"></a>opengl学习</h1><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>安装的时候注意系统版本（pip默认下载32位的）</p>\n<p>去官网下载64位的安装包<a href=\"https://www.lfd.uci.edu/~gohlke/pythonlibs/#pyopengl\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<h2 id=\"基本入门\"><a href=\"#基本入门\" class=\"headerlink\" title=\"基本入门\"></a>基本入门</h2><h3 id=\"OpenGL-库及函数简介\"><a href=\"#OpenGL-库及函数简介\" class=\"headerlink\" title=\"OpenGL 库及函数简介\"></a>OpenGL 库及函数简介</h3><p>OpenGL函数的命名格式如下：</p>\n<pre><code>&lt;库前缀&gt;&lt;根命令&gt;&lt;可选的参数个数&gt;&lt;可选的参数类型&gt;\n</code></pre><p><strong>常见的库前缀</strong>有 gl、glu、glut、aux、wgl、glx、agl 等。库前缀表示该函数属于 OpenGL 哪一个开发库。</p>\n<p><strong>从函数名后面中还可以看出需要多少个参数以及参数的类型。I 代表 int 型，f 代表 float 型，d 代表 double 型，u 代表无符号整型。例如 glColor3f() 表示了该函数属于gl库，参数是三个浮点数。</strong></p>\n<p>OpenGL 函数库相关的 API 有核心库(gl)、实用库(glu)、实用工具库(glut)、辅助库(aux)、窗口库(glx、agl、wgl)和扩展函数库等。gl是核心，glu是对gl的部分封装。glut是为跨平台的OpenGL程序的工具包，比aux功能强大。glx、agl、wgl 是针对不同窗口系统的函数。扩展函数库是硬件厂商为实现硬件更新利用OpenGL的扩展机制开发的函数。本文仅对常用的四个库做简单介绍。</p>\n<h3 id=\"OpenGL-核心库-GL\"><a href=\"#OpenGL-核心库-GL\" class=\"headerlink\" title=\"OpenGL 核心库 GL\"></a>OpenGL 核心库 GL</h3><p>核心库包含有115个函数，函数名的前缀为gl。这部分函数用于常规的、核心的图形处理。此函数由gl.dll来负责解释执行。由于许多函数可以接收不同数以下几类。据类型的参数，因此派生出来的函数原形多达300多个。核心库中的函数主要可以分为以下几类函数：</p>\n<h4 id=\"绘制基本几何图元的函数：\"><a href=\"#绘制基本几何图元的函数：\" class=\"headerlink\" title=\"绘制基本几何图元的函数：\"></a>绘制基本几何图元的函数：</h4><p><code>glBegain()、glEnd()、glNormal*()、glVertex*()</code></p>\n<h4 id=\"矩阵操作、几何变换和投影变换的函数：\"><a href=\"#矩阵操作、几何变换和投影变换的函数：\" class=\"headerlink\" title=\"矩阵操作、几何变换和投影变换的函数：\"></a>矩阵操作、几何变换和投影变换的函数：</h4><p>如矩阵入栈函数<strong>glPushMatrix</strong>()，矩阵出栈函数<strong>glPopMatrix</strong>()，装载矩阵函数<strong>glLoadMatrix</strong>()，矩阵相乘函数<strong>glMultMatrix</strong>()，当前矩阵函数<strong>glMatrixMode</strong>()和矩阵标准化函数<strong>glLoadIdentity</strong>()，几何变换函数<strong>glTranslate*</strong>()、<strong>glRotate*</strong>()和<strong>glScale*</strong>()，投影变换函数<strong>glOrtho</strong>()、<strong>glFrustum</strong>()和视口变换函数<strong>glViewport</strong>()</p>\n<h4 id=\"颜色、光照和材质的函数：\"><a href=\"#颜色、光照和材质的函数：\" class=\"headerlink\" title=\"颜色、光照和材质的函数：\"></a>颜色、光照和材质的函数：</h4><p>如设置颜色模式函数glColor<em>()、glIndex</em>()，设置光照效果的函数glLight<em>() 、glLightModel</em>()和设置材质效果函数glMaterial()</p>\n<h4 id=\"显示列表函数：\"><a href=\"#显示列表函数：\" class=\"headerlink\" title=\"显示列表函数：\"></a>显示列表函数：</h4><p>主要有创建、结束、生成、删除和调用显示列表的函数glNewList()、glEndList()、glGenLists()、glCallList()和glDeleteLists()</p>\n<h4 id=\"纹理映射函数：\"><a href=\"#纹理映射函数：\" class=\"headerlink\" title=\"纹理映射函数：\"></a>纹理映射函数：</h4><p>主要有一维纹理函数glTexImage1D()、二维纹理函数glTexImage2D()、设置纹理参数、纹理环境和纹理坐标的函数glTexParameter<em>()、glTexEnv</em>()和glTetCoord*()</p>\n<h4 id=\"特殊效果函数：\"><a href=\"#特殊效果函数：\" class=\"headerlink\" title=\"特殊效果函数：\"></a>特殊效果函数：</h4><p>融合函数glBlendFunc()、反走样函数glHint()和雾化效果glFog*()</p>\n<h4 id=\"光栅化、象素操作函数：\"><a href=\"#光栅化、象素操作函数：\" class=\"headerlink\" title=\"光栅化、象素操作函数：\"></a>光栅化、象素操作函数：</h4><p>如象素位置glRasterPos*()、线型宽度glLineWidth()、多边形绘制模式glPolygonMode()，读取象素glReadPixel()、复制象素glCopyPixel()</p>\n<h4 id=\"选择与反馈函数：\"><a href=\"#选择与反馈函数：\" class=\"headerlink\" title=\"选择与反馈函数：\"></a>选择与反馈函数：</h4><p>主要有渲染模式glRenderMode()、选择缓冲区glSelectBuffer()和反馈缓冲区glFeedbackBuffer()</p>\n<h4 id=\"曲线与曲面的绘制函数：\"><a href=\"#曲线与曲面的绘制函数：\" class=\"headerlink\" title=\"曲线与曲面的绘制函数：\"></a>曲线与曲面的绘制函数：</h4><p>生成曲线或曲面的函数glMap<em>()、glMapGrid</em>()，求值器的函数glEvalCoord<em>() glEvalMesh</em>()</p>\n<h4 id=\"状态设置与查询函数：\"><a href=\"#状态设置与查询函数：\" class=\"headerlink\" title=\"状态设置与查询函数：\"></a>状态设置与查询函数：</h4><p>glGet*()、glEnable()、glGetError()</p>\n<h3 id=\"OpenGL-实用库-GLU\"><a href=\"#OpenGL-实用库-GLU\" class=\"headerlink\" title=\"OpenGL 实用库 GLU\"></a>OpenGL 实用库 GLU</h3><p>包含有43个函数，函数名的前缀为glu。OpenGL提供了强大的但是为数不多的绘图命令，所有较复杂的绘图都必须从点、线、面开始。Glu 为了减轻繁重的编程工作，封装了OpenGL函数，Glu函数通过调用核心库的函数，为开发者提供相对简单的用法，实现一些较为复杂的操作。此函数由glu.dll来负责解释执行。OpenGL中的核心库和实用库可以在所有的OpenGL平台上运行。主要包括了以下几种：</p>\n<h4 id=\"辅助纹理贴图函数：\"><a href=\"#辅助纹理贴图函数：\" class=\"headerlink\" title=\"辅助纹理贴图函数：\"></a>辅助纹理贴图函数：</h4><p>gluScaleImage() 、gluBuild1Dmipmaps()、gluBuild2Dmipmaps()</p>\n<h4 id=\"坐标转换和投影变换函数：\"><a href=\"#坐标转换和投影变换函数：\" class=\"headerlink\" title=\"坐标转换和投影变换函数：\"></a>坐标转换和投影变换函数：</h4><p>定义投影方式函数gluPerspective()、gluOrtho2D() 、gluLookAt()，拾取投影视景体函数gluPickMatrix()，投影矩阵计算gluProject()和gluUnProject()</p>\n<h4 id=\"多边形镶嵌工具：\"><a href=\"#多边形镶嵌工具：\" class=\"headerlink\" title=\"多边形镶嵌工具：\"></a>多边形镶嵌工具：</h4><p>gluNewTess()、gluDeleteTess()、gluTessCallback()、gluBeginPolygon()、gluTessVertex()、gluNextContour()、gluEndPolygon()</p>\n<h4 id=\"二次曲面绘制工具：\"><a href=\"#二次曲面绘制工具：\" class=\"headerlink\" title=\"二次曲面绘制工具：\"></a>二次曲面绘制工具：</h4><p>主要有绘制球面、锥面、柱面、圆环面gluNewQuadric()、gluSphere()、gluCylinder()、gluDisk()、gluPartialDisk()、gluDeleteQuadric()</p>\n<h3 id=\"OpenGL-工具库-GLUT\"><a href=\"#OpenGL-工具库-GLUT\" class=\"headerlink\" title=\"OpenGL 工具库 GLUT\"></a>OpenGL 工具库 GLUT</h3><p>包含大约30多个函数，函数名前缀为glut。glut是不依赖于窗口平台的OpenGL工具包，由Mark KLilgrad在SGI编写（现在在Nvidia），目的是隐藏不同窗口平台API的复杂度。函数以glut开头，它们作为aux库功能更强的替代品，提供更为复杂的绘制功能，此函数由glut.dll来负责解释执行。由于glut中的窗口管理函数是不依赖于运行环境的，因此OpenGL中的工具库可以在X-Window, Windows NT, OS/2等系统下运行，特别适合于开发不需要复杂界面的OpenGL示例程序。对于有经验的程序员来说，一般先用glut理顺3D图形代码，然后再集成为完整的应用程序。这部分函数主要包括：</p>\n<h4 id=\"窗口操作函数：\"><a href=\"#窗口操作函数：\" class=\"headerlink\" title=\"窗口操作函数：\"></a>窗口操作函数：</h4><p>窗口初始化、窗口大小、窗口位置函数等 glutInit()、glutInitDisplayMode()、glutInitWindowSize()、glutInitWindowPosition()</p>\n<h4 id=\"回调函数：\"><a href=\"#回调函数：\" class=\"headerlink\" title=\"回调函数：\"></a>回调函数：</h4><p>响应刷新消息、键盘消息、鼠标消息、定时器函数 GlutDisplayFunc()、glutPostRedisplay()、glutReshapeFunc()、glutTimerFunc()、glutKeyboardFunc()、glutMouseFunc()</p>\n<h4 id=\"创建复杂的三维物体：\"><a href=\"#创建复杂的三维物体：\" class=\"headerlink\" title=\"创建复杂的三维物体：\"></a>创建复杂的三维物体：</h4><p>这些和aux库的函数功能相同</p>\n<h4 id=\"菜单函数：\"><a href=\"#菜单函数：\" class=\"headerlink\" title=\"菜单函数：\"></a>菜单函数：</h4><p>创建添加菜单的函数 GlutCreateMenu()、glutSetMenu()、glutAddMenuEntry()、glutAddSubMenu() 和 glutAttachMenu()</p>\n<h4 id=\"程序运行函数：\"><a href=\"#程序运行函数：\" class=\"headerlink\" title=\"程序运行函数：\"></a>程序运行函数：</h4><p>glutMainLoop()</p>\n<h2 id=\"入门之线段的绘制\"><a href=\"#入门之线段的绘制\" class=\"headerlink\" title=\"入门之线段的绘制\"></a>入门之线段的绘制</h2><p><strong>先上代码</strong></p>\n<pre><code># -*- coding: utf-8 -*-\nfrom OpenGL.GL import *\nfrom OpenGL.GLU import *\nfrom OpenGL.GLUT import *\nimport numpy as np\n\n\ndef init():\n    glClearColor(1.0, 1.0, 1.0, 0.0)  # 设置画布背景色。注意：这里必须是4个参数\n    # glClear(GL_COLOR_BUFFER_BIT)  # 将上面的颜色赋值给窗口, 只要有这个先后顺序就行\n\n    glMatrixMode(GL_PROJECTION)  #设置投影模式\n    gluOrtho2D(0,200,0,200)  # 设置画布x，y的范围\n    glDisable(GL_BLEND)  # 关闭颜色混合\n\n    glEnable(GL_LINE_STIPPLE)  #启用线型，可以绘制虚线之类的了\n\n\n\n# 绘制图像函数\ndef drawFunc():\n    global x\n    global y\n\n    # 清除屏幕\n    glClear(GL_COLOR_BUFFER_BIT)\n\n    glLineWidth(10.0)  # 设置线的宽度\n\n    glBegin(GL_LINE_STRIP)  # 绘制连续线段\n\n    glColor4f(1.0, 0.0, 0.0, 1.0)        # 设置当前颜色为红色不透明\n\n\n    for i in range(len(x)):\n        glVertex2f(x[i]*100,y[i])\n\n    glEnd()\n\n\n    # 刷新显示图像，保证前面的OpenGL命令立即执行，而不是让它们在缓冲区中等待。\n    glFlush()\n\n\n# 主函数\nif __name__ == &quot;__main__&quot;:\n    # 使用glut库初始化OpenGL\n    glutInit()\n    # 显示模式 GLUT_SINGLE无缓冲直接显示|GLUT_RGBA采用RGB(A非alpha)\n    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGBA)\n    # 设置窗口位置及大小\n    glutInitWindowPosition(0, 0)  # 位置是指在屏幕的位置\n    glutInitWindowSize(400, 400)\n    # 创建窗口\n    glutCreateWindow(&quot;myTest1&quot;)\n    global x\n    global y\n    x = np.linspace(0,2* np.pi,num=1000)\n    y = np.sin(x)* 200\n\n\n    init()\n\n\n    # 调用display()函数绘制图像\n    glutDisplayFunc(drawFunc)\n\n\n    # 进入glut主循环\n    glutMainLoop()\n</code></pre><h3 id=\"函数讲解—–void-glLineStipple-GLint-factor-GLshort-pattern\"><a href=\"#函数讲解—–void-glLineStipple-GLint-factor-GLshort-pattern\" class=\"headerlink\" title=\"函数讲解—–void glLineStipple(GLint factor,GLshort pattern)\"></a>函数讲解—–void glLineStipple(GLint factor,GLshort pattern)</h3><p>这是用来设置线型的。</p>\n<p><strong>从这个模式的低位开始，</strong>一个像素一个像素的进行处理。如果模式中对应的位是1，就绘制这个像素，否则就不绘制。模式可以使用factor参数（表示重复因子）进行扩展，它与1和0的连续子序列相乘。因此，如果模式中出现了3个1，并且factor是2，那么它们就扩展为6个连续的1。必须以GL_LINE_STIPPLE为参数调用glEnable()才能启用直线点画功能。为了禁用直线点画功能，可以向glDisable()函数传递同一个参数。</p>\n<p>例如：</p>\n<p><strong>glLineStipple(1, 0x3F07);</strong></p>\n<p>glEnable(GL_LINE_STIPPLE);  //启用线型</p>\n<p>此时模式为Ox3F07（二进制形式为0011111100000111）<strong>低位开始，从右往左</strong>，它所画出来的直线是这样的：先连续绘制3个像素，然后连续5个像素留空，再连续绘制6个像素，最后两个像素留空（注意，首先是从低位开始的）。如果factor是2，那么这个模式便被扩展为：先连续绘制6个像素，然后连续10个像素留空，再连续绘制12个像素，最后4个像素留空。</p>\n<p>如果没有启用点画线功能，OpenGL会自动把pattern当做为OxFFFF，把factor当成1。</p>\n<pre><code># -*- coding: utf-8 -*-\nfrom OpenGL.GL import *\nfrom OpenGL.GLU import *\nfrom OpenGL.GLUT import *\nimport numpy as np\n\n\ndef init():\n    glClearColor(1.0, 1.0, 1.0, 0.0)  # 设置画布背景色。注意：这里必须是4个参数\n    # glClear(GL_COLOR_BUFFER_BIT)  # 将上面的颜色赋值给窗口, 只要有这个先后顺序就行\n\n    glMatrixMode(GL_PROJECTION)  #设置投影模式\n    gluOrtho2D(0,200,0,200)  # 设置画布x，y的范围\n    glDisable(GL_BLEND)  # 关闭颜色混合\n\n    glEnable(GL_LINE_STIPPLE)  #启用线型，可以绘制虚线之类的了\n\n\n\n# 绘制图像函数\ndef drawFunc():\n    global x\n    global y\n\n    # 清除屏幕\n    glClear(GL_COLOR_BUFFER_BIT)\n\n    glLineWidth(3.0)  # 设置线的宽度\n\n    glLineStipple(1, 0xFFFF);  # 设置线型,直线\n\n\n    glBegin(GL_LINE_STRIP)  # 绘制连续线段\n\n    glColor4f(1.0, 0.0, 0.0, 1.0)        # 设置当前颜色为红色不透明\n\n    for i in range(len(x)):\n        glVertex2f(x[i]*100,y[i])\n\n    glEnd()\n\n\n\n    glLineStipple(1, 0x00FF);  # 设置线型,虚线\n\n\n    glBegin(GL_LINE_STRIP)  # 绘制连续线段\n\n    glColor4f(0.0, 1.0, 0.0, 1.0)        # 设置当前颜色为红色不透明\n\n    for i in range(len(x)):\n        glVertex2f(x[i]*100,y[i] -20)\n\n    glEnd()\n\n    # 刷新显示图像，保证前面的OpenGL命令立即执行，而不是让它们在缓冲区中等待。\n    glFlush()\n\n\n# 主函数\nif __name__ == &quot;__main__&quot;:\n    # 使用glut库初始化OpenGL\n    glutInit()\n    # 显示模式 GLUT_SINGLE无缓冲直接显示|GLUT_RGBA采用RGB(A非alpha)\n    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGBA)\n    # 设置窗口位置及大小\n    glutInitWindowPosition(0, 0)  # 位置是指在屏幕的位置\n    glutInitWindowSize(400, 400)\n    # 创建窗口\n    glutCreateWindow(&quot;myTest1&quot;)\n    global x\n    global y\n    x = np.linspace(0,2* np.pi,num=1000)\n    y = np.sin(x)* 200\n\n\n    init()\n\n\n    # 调用display()函数绘制图像\n    glutDisplayFunc(drawFunc)\n\n\n    # 进入glut主循环\n    glutMainLoop()\n</code></pre><h3 id=\"启用线性插值—-glShadeModel-GL-SMOOTH\"><a href=\"#启用线性插值—-glShadeModel-GL-SMOOTH\" class=\"headerlink\" title=\"启用线性插值—-glShadeModel(GL_SMOOTH)\"></a>启用线性插值—-glShadeModel(GL_SMOOTH)</h3><pre><code># -*- coding: utf-8 -*-\nfrom OpenGL.GL import *\nfrom OpenGL.GLU import *\nfrom OpenGL.GLUT import *\nimport numpy as np\n\n\ndef init():\n    glClearColor(1.0, 1.0, 1.0, 0.0)  # 设置画布背景色。注意：这里必须是4个参数\n    # glClear(GL_COLOR_BUFFER_BIT)  # 将上面的颜色赋值给窗口, 只要有这个先后顺序就行\n\n    glMatrixMode(GL_PROJECTION)  #设置投影模式\n    gluOrtho2D(0,200,0,200)  # 设置画布x，y的范围\n    glDisable(GL_BLEND)  # 关闭颜色混合\n\n    glEnable(GL_LINE_STIPPLE)  #启用线型，可以绘制虚线之类的了\n\n\n\n# 绘制图像函数\ndef drawFunc():\n    global x\n    global y\n\n    # 清除屏幕\n    glClear(GL_COLOR_BUFFER_BIT)\n\n    glLineWidth(3.0)  # 设置线的宽度\n\n    glLineStipple(1, 0xFFFF);  # 设置线型,直线\n\n    glShadeModel(GL_SMOOTH)  # 开启对颜色的线性插值\n\n\n\n    glBegin(GL_LINE_STRIP)  # 绘制连续线段\n\n    for i in range(len(x)):\n        glColor4f(0.0,  i /len(x), i /len(x), 1.0)  # 设置当前颜色,渐变\n\n        glVertex2f(x[i]*100,y[i])\n\n    glEnd()\n\n\n\n\n\n    # 刷新显示图像，保证前面的OpenGL命令立即执行，而不是让它们在缓冲区中等待。\n    glFlush()\n\n\n# 主函数\nif __name__ == &quot;__main__&quot;:\n    # 使用glut库初始化OpenGL\n    glutInit()\n    # 显示模式 GLUT_SINGLE无缓冲直接显示|GLUT_RGBA采用RGB(A非alpha)\n    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGBA)\n    # 设置窗口位置及大小\n    glutInitWindowPosition(0, 0)  # 位置是指在屏幕的位置\n    glutInitWindowSize(400, 400)\n    # 创建窗口\n    glutCreateWindow(&quot;myTest1&quot;)\n    global x\n    global y\n    x = np.linspace(0,0.5* np.pi,num=1000)\n    y = np.sin(x)* 200\n\n    init()\n\n    # 调用display()函数绘制图像\n    glutDisplayFunc(drawFunc)\n\n\n    # 进入glut主循环\n    glutMainLoop()\n</code></pre><h2 id=\"几何变换\"><a href=\"#几何变换\" class=\"headerlink\" title=\"几何变换\"></a>几何变换</h2><p><strong>几何变换本质是仿射变换</strong>，二维与三位基本原理一样，这里不多赘述</p>\n<h3 id=\"函数glMatrixMode（）\"><a href=\"#函数glMatrixMode（）\" class=\"headerlink\" title=\"函数glMatrixMode（）\"></a>函数glMatrixMode（）</h3><p><strong>这个函数其实就是对接下来要做什么进行一下声明</strong>，也就是在要做下一步之前告诉计算机我要对“什么”进行操作了，这个“什么”在glMatrixMode的“()”里的选项(参数)有<strong>，GL_PROJECTION，GL_MODELVIEW和GL_TEXTURE；</strong></p>\n<p><strong>详细说明</strong></p>\n<ul>\n<li><strong>GL_PROJECTION</strong>： 这个是投影的意思，就是要对投影相关进行操作，也就是把物体投影到一个平面上，就像我们照相一样，把3维物体投到2维的平面上。这样，接下来的语句可以是跟透视相关的函数，比如glFrustum()或gluPerspective()；</li>\n<li><strong>GL_MODELVIEW</strong>：对模型视景的操作，接下来的语句描绘一个以模型为基础的适应，这样来设置参数，接下来用到的就是像gluLookAt()这样的函数；</li>\n<li><strong>GL_TEXTURE：</strong>对纹理相关进行操作</li>\n</ul>\n<h3 id=\"函数glLoadIdentity\"><a href=\"#函数glLoadIdentity\" class=\"headerlink\" title=\"函数glLoadIdentity()\"></a>函数glLoadIdentity()</h3><p><strong>恢复初始坐标系的手段</strong>：该命令是一个无参的无值函数，其功能是用一个4×4的单位矩阵来替换当前矩阵，实际上就是对当前矩阵进行初始化。也就是说，无论以前进行了多少次矩阵变换，在该命令执行后，<strong>当前矩阵均恢复成一个单位矩阵，即相当于没有进行任何矩阵变换状态</strong></p>\n<h3 id=\"三维中的视角投影\"><a href=\"#三维中的视角投影\" class=\"headerlink\" title=\"三维中的视角投影\"></a>三维中的视角投影</h3><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7974510d81a8f068b3b3d3e0ac238580/2250a2194fd4eca0a860e796f7366f82.png\" alt=\"image-20210518184712038\"></p>\n<p>以上是书里面的形容整个工作流程的段内容。</p>\n<p><strong>分为</strong></p>\n<h4 id=\"平行投影\"><a href=\"#平行投影\" class=\"headerlink\" title=\"平行投影\"></a>平行投影</h4><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7974510d81a8f068b3b3d3e0ac238580/508b98e6ad40a60dacb2bb2854e5f749.png\" alt=\"image-20210518184935113\"></p>\n<h4 id=\"透视投影\"><a href=\"#透视投影\" class=\"headerlink\" title=\"透视投影\"></a>透视投影</h4><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7974510d81a8f068b3b3d3e0ac238580/35526336ec9d6370cf1619c7d7a10360.png\" alt=\"image-20210518185003943\"></p>\n<h3 id=\"函数glOrtho（），平行投影\"><a href=\"#函数glOrtho（），平行投影\" class=\"headerlink\" title=\"函数glOrtho（），平行投影\"></a>函数glOrtho（），平行投影</h3><p>类似二维的<strong>gluOrtho2D（）</strong></p>\n<p><strong>创建一个正交平行的视景体</strong>。 一般用于物体不会因为离屏幕的远近而产生大小的变换的情况</p>\n<p>例：</p>\n<pre><code>    glOrtho(-1,1,-1,1,-1,1)  # 设置视景体</code></pre><p><strong>视景体</strong>:其实就是能够显示观察的范围。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7974510d81a8f068b3b3d3e0ac238580/9ef786641e8327032a3d7a981a778626.png\" alt=\"image-20210518144514464\"></p>\n<h3 id=\"透视投影glFrustum（）\"><a href=\"#透视投影glFrustum（）\" class=\"headerlink\" title=\"透视投影glFrustum（）\"></a>透视投影glFrustum（）</h3><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7974510d81a8f068b3b3d3e0ac238580/7bbc25d1492e3b81ee11ef5b968874e8.png\" alt=\"image-20210518185229062\"></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7974510d81a8f068b3b3d3e0ac238580/3ce99d17c2fd0addad843f0d33bc1760.png\" alt=\"image-20210518144522692\"></p>\n<pre><code>    # 使用前的基本设置\n    glMatrixMode(GL_MODELVIEW)  #设置投影模式\n    gluLookAt(0,0,0,  #相机在世界坐标的位置\n              0,0,1,  #相机镜头对准的物体在世界坐标的位置！！！！！！，这里是物体的位置\n              1,0,0  #相机向上的方向在世界坐标中的方向\n              )\n\n\n    glMatrixMode(GL_PROJECTION)  #设置投影模式\n    # 设置投影变换视景体参数\n    glFrustum(-1,1,-1,1, 0.3,2)</code></pre><p>绘制图形</p>\n<pre><code>    glColor4f(1,0,0,1)\n    drawCircle(0,0,100,0.5,z=0.5)\n\n\n    glColor4f(0,0,1,1)\n    drawCircle(0,0,100, 1, z=0.9)</code></pre><p>这两个圆半径相差一倍，但是使用透视投影，第一个能遮住第二个半</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7974510d81a8f068b3b3d3e0ac238580/99bc0e5b277845423ed4bc0276813fcd.png\" alt=\"image-20210518191339617\"></p>\n<p><strong>果然</strong></p>\n<h3 id=\"平移\"><a href=\"#平移\" class=\"headerlink\" title=\"平移\"></a>平移</h3><pre><code>    glTranslatef(0.5, 0.0, 0)  # 沿着x轴平移0.5</code></pre><h3 id=\"旋转\"><a href=\"#旋转\" class=\"headerlink\" title=\"旋转\"></a>旋转</h3><pre><code>    glPushMatrix()  # 观察矩阵入栈\n    glRotate(90,0,0,1)  # 围绕y轴旋转90度\n    drawTriangle(0)\n\n    glPopMatrix()  # 观察矩阵出栈，相当于回复初始矩阵了</code></pre><h3 id=\"缩放\"><a href=\"#缩放\" class=\"headerlink\" title=\"缩放\"></a>缩放</h3><pre><code>    glPushMatrix()  # 观察矩阵入栈\n    glScale(0.5,0.5,0.5)  # 缩放到一半\n    drawTriangle(0)\n\n    glPopMatrix()  # 观察矩阵出栈，相当于回复初始矩阵了</code></pre><h3 id=\"观察矩阵入栈与出栈\"><a href=\"#观察矩阵入栈与出栈\" class=\"headerlink\" title=\"观察矩阵入栈与出栈\"></a>观察矩阵入栈与出栈</h3><p>物体的显示是有经过观察矩阵变换的</p>\n<p>当你做了一些移动或旋转等变换后，使用<strong>glPushMatrix</strong>(); <strong>观察矩阵入栈</strong><br>OpenGL 会把这个变换后的位置和角度保存起来。<br>然后你再随便做第二次移动或旋转变换，再用<strong>glPopMatrix</strong>();<strong>观察矩阵出栈</strong><br>OpenGL 就把刚刚保存的那个位置和角度恢复。</p>\n<h3 id=\"关于视图模式下几何变换的矩阵计算顺序（非常重要的一个概念）\"><a href=\"#关于视图模式下几何变换的矩阵计算顺序（非常重要的一个概念）\" class=\"headerlink\" title=\"关于视图模式下几何变换的矩阵计算顺序（非常重要的一个概念）\"></a>关于视图模式下几何变换的矩阵计算顺序（非常重要的一个概念）</h3><p><strong>是类似栈一样执行的</strong></p>\n<pre><code>     # 从点(x0,y0,0)绕方向（0，0，1）旋转theta度\n    glTranslatef(x0,y0,0)                   M1\n    glRotate(theta ,0,0,1)  # 围绕y轴旋转90度 M2\n    glTranslatef(-1*x0,-1*y0,0)              M3</code></pre><p>对于接下来要绘制的图形而言，实际上，应该是</p>\n<p>$$x^{,} = M1 \\cdot M2 \\cdot M3 \\cdot x$$</p>\n<p>这个在很多时候都非常重要</p>\n<h2 id=\"深度测试\"><a href=\"#深度测试\" class=\"headerlink\" title=\"深度测试\"></a>深度测试</h2><p><strong>深度缓冲(Depth Buffer)</strong>,以防止被其他面遮挡的面渲染到前面。使用函数</p>\n<pre><code>    glEnable(GL_DEPTH_TEST)  # 深度测试</code></pre><p><strong>实验</strong></p>\n<p>我们同时绘制两个z轴不同的图形</p>\n<pre><code>    drawTriangle(0)\n\n    drawCircle(0,0,100, 0.9)\n</code></pre><p>没开之前</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7974510d81a8f068b3b3d3e0ac238580/b4716349e59a32047b1eafc54132f229.png\" alt=\"image-20210518150145147\"></p>\n<p>不难看出，三角形被后来绘制的圆形给挡住了。</p>\n<p><strong>开启深度测试</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7974510d81a8f068b3b3d3e0ac238580/3e22591f8acb6b6e8832e33cb467cea5.png\" alt=\"image-20210518150228027\"></p>\n<p><strong>没毛病</strong></p>\n"},{"_content":"# 场景\n\n有一台配置有N卡的win，有一个可能不在同一个局域网的PC机B。\n\n想要让主机B能够流畅的控制桌面使用win。\n\n使用moonlight\n\n\n\n# 具体\n\n**我走的服务器代理，所以延迟会比较高**，50ms\n\n### win上配置Nvidia Geforce Experience的Shield\n\n你需要安装Nvidia Geforce Experience，在它的设置中找到并启用Shield串流服务。这个需要比较彻底的科学上网才能开，建议\n\n- 使用openwrt\n- 使用clash的![image-20221218215126294](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/73e9ab486fd11539c76112ad3b7a06ee/aa75dc1d4821f4ef9038d94241064049.png)\n\n\n\n开启\n\n![image-20221218215224220](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/73e9ab486fd11539c76112ad3b7a06ee/93ddecc08da551187d5414a8cfb5171c.png)\n\n\n\n一个用来重启`NvContainerLocalSystem`的bat脚本\n\n```\n@echo off\necho 关闭服务\nnet stop \"NvContainerLocalSystem\"\ntimeout 2\necho 开启服务\nnet start \"NvContainerLocalSystem\"\n```\n\n\n\n\n\n### 在win上配置frp客户端代理到服务器公网\n\n如果要代理到公网，就用这个\n\n配置文件为`frpc.ini`，修改其内容如下：\n\n```\n[common]\nserver_addr = <Your server IP>\nserver_port = <Your selected port>\ntoken = <Your password>\n\n[nvidia-stream-tcp-1]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 47984\nremote_port = 47984\n\n[nvidia-stream-tcp-2]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 47989\nremote_port = 47989\n\n[nvidia-stream-tcp-3]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 48010\nremote_port = 48010\n\n[nvidia-stream-udp-1]\ntype = udp\nlocal_ip = 127.0.0.1\nlocal_port = 5353\nremote_port = 5353\n\n[nvidia-stream-udp-2]\ntype = udp\nlocal_ip = 127.0.0.1\nlocal_port = 47998\nremote_port = 47998\n\n[nvidia-stream-udp-3]\ntype = udp\nlocal_ip = 127.0.0.1\nlocal_port = 47999\nremote_port = 47999\n\n[nvidia-stream-udp-4]\ntype = udp\nlocal_ip = 127.0.0.1\nlocal_port = 48000\nremote_port = 48000\n\n[nvidia-stream-udp-5]\ntype = udp\nlocal_ip = 127.0.0.1\nlocal_port = 48002\nremote_port = 48002\n\n[nvidia-stream-udp-6]\ntype = udp\nlocal_ip = 127.0.0.1\nlocal_port = 48010\nremote_port = 48010\n```\n\n\n\n\n\n### 如何使用moonlight连接\n\n\n\n输入ip就可以了\n\n![image-20221218215436510](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/73e9ab486fd11539c76112ad3b7a06ee/1c585179af1e0b42cd02697fb2b5f03e.png)\n\n\n\nMoonlight串流的画面质量很高，当作远程桌面来用完全没问题。不过，它默认只让你启动游戏，那怎么办呢？你可以启动一个不会立即进去的游戏，比如CS:GO，然后把它晾着去干别的事情。其实，还有一种更优雅的解法：在Geforce Experience里把`C:\\Windows\\System32\\mstsc.exe`添加到游戏列表里，在Moonlight里点mstsc就能直接进桌面了。其实`mstsc.exe`是Windows 远程桌面的exe，Moonlight并没有真的去执行它，Moonlight实际上相当于收到了一个信号，那就是你想直接进桌面。至于为什么设计得这么奇怪，那你得问Nvidia。\n\n\n\n\n\n\n\n# 关于win的防火墙问题\n\nhttps://tutujanjan.com/?p=2146","source":"_posts/综合/moonlight云电脑.md","raw":"# 场景\n\n有一台配置有N卡的win，有一个可能不在同一个局域网的PC机B。\n\n想要让主机B能够流畅的控制桌面使用win。\n\n使用moonlight\n\n\n\n# 具体\n\n**我走的服务器代理，所以延迟会比较高**，50ms\n\n### win上配置Nvidia Geforce Experience的Shield\n\n你需要安装Nvidia Geforce Experience，在它的设置中找到并启用Shield串流服务。这个需要比较彻底的科学上网才能开，建议\n\n- 使用openwrt\n- 使用clash的![image-20221218215126294](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/73e9ab486fd11539c76112ad3b7a06ee/aa75dc1d4821f4ef9038d94241064049.png)\n\n\n\n开启\n\n![image-20221218215224220](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/73e9ab486fd11539c76112ad3b7a06ee/93ddecc08da551187d5414a8cfb5171c.png)\n\n\n\n一个用来重启`NvContainerLocalSystem`的bat脚本\n\n```\n@echo off\necho 关闭服务\nnet stop \"NvContainerLocalSystem\"\ntimeout 2\necho 开启服务\nnet start \"NvContainerLocalSystem\"\n```\n\n\n\n\n\n### 在win上配置frp客户端代理到服务器公网\n\n如果要代理到公网，就用这个\n\n配置文件为`frpc.ini`，修改其内容如下：\n\n```\n[common]\nserver_addr = <Your server IP>\nserver_port = <Your selected port>\ntoken = <Your password>\n\n[nvidia-stream-tcp-1]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 47984\nremote_port = 47984\n\n[nvidia-stream-tcp-2]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 47989\nremote_port = 47989\n\n[nvidia-stream-tcp-3]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 48010\nremote_port = 48010\n\n[nvidia-stream-udp-1]\ntype = udp\nlocal_ip = 127.0.0.1\nlocal_port = 5353\nremote_port = 5353\n\n[nvidia-stream-udp-2]\ntype = udp\nlocal_ip = 127.0.0.1\nlocal_port = 47998\nremote_port = 47998\n\n[nvidia-stream-udp-3]\ntype = udp\nlocal_ip = 127.0.0.1\nlocal_port = 47999\nremote_port = 47999\n\n[nvidia-stream-udp-4]\ntype = udp\nlocal_ip = 127.0.0.1\nlocal_port = 48000\nremote_port = 48000\n\n[nvidia-stream-udp-5]\ntype = udp\nlocal_ip = 127.0.0.1\nlocal_port = 48002\nremote_port = 48002\n\n[nvidia-stream-udp-6]\ntype = udp\nlocal_ip = 127.0.0.1\nlocal_port = 48010\nremote_port = 48010\n```\n\n\n\n\n\n### 如何使用moonlight连接\n\n\n\n输入ip就可以了\n\n![image-20221218215436510](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/73e9ab486fd11539c76112ad3b7a06ee/1c585179af1e0b42cd02697fb2b5f03e.png)\n\n\n\nMoonlight串流的画面质量很高，当作远程桌面来用完全没问题。不过，它默认只让你启动游戏，那怎么办呢？你可以启动一个不会立即进去的游戏，比如CS:GO，然后把它晾着去干别的事情。其实，还有一种更优雅的解法：在Geforce Experience里把`C:\\Windows\\System32\\mstsc.exe`添加到游戏列表里，在Moonlight里点mstsc就能直接进桌面了。其实`mstsc.exe`是Windows 远程桌面的exe，Moonlight并没有真的去执行它，Moonlight实际上相当于收到了一个信号，那就是你想直接进桌面。至于为什么设计得这么奇怪，那你得问Nvidia。\n\n\n\n\n\n\n\n# 关于win的防火墙问题\n\nhttps://tutujanjan.com/?p=2146","slug":"综合/moonlight云电脑","published":1,"date":"2023-02-26T15:28:35.060Z","updated":"2023-02-27T11:34:33.138Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsycm001o0gcnltkez5mb","content":"<h1 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h1><p>有一台配置有N卡的win，有一个可能不在同一个局域网的PC机B。</p>\n<p>想要让主机B能够流畅的控制桌面使用win。</p>\n<p>使用moonlight</p>\n<h1 id=\"具体\"><a href=\"#具体\" class=\"headerlink\" title=\"具体\"></a>具体</h1><p><strong>我走的服务器代理，所以延迟会比较高</strong>，50ms</p>\n<h3 id=\"win上配置Nvidia-Geforce-Experience的Shield\"><a href=\"#win上配置Nvidia-Geforce-Experience的Shield\" class=\"headerlink\" title=\"win上配置Nvidia Geforce Experience的Shield\"></a>win上配置Nvidia Geforce Experience的Shield</h3><p>你需要安装Nvidia Geforce Experience，在它的设置中找到并启用Shield串流服务。这个需要比较彻底的科学上网才能开，建议</p>\n<ul>\n<li>使用openwrt</li>\n<li>使用clash的<img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/73e9ab486fd11539c76112ad3b7a06ee/aa75dc1d4821f4ef9038d94241064049.png\" alt=\"image-20221218215126294\"></li>\n</ul>\n<p>开启</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/73e9ab486fd11539c76112ad3b7a06ee/93ddecc08da551187d5414a8cfb5171c.png\" alt=\"image-20221218215224220\"></p>\n<p>一个用来重启<code>NvContainerLocalSystem</code>的bat脚本</p>\n<pre><code>@echo off\necho 关闭服务\nnet stop &quot;NvContainerLocalSystem&quot;\ntimeout 2\necho 开启服务\nnet start &quot;NvContainerLocalSystem&quot;</code></pre><h3 id=\"在win上配置frp客户端代理到服务器公网\"><a href=\"#在win上配置frp客户端代理到服务器公网\" class=\"headerlink\" title=\"在win上配置frp客户端代理到服务器公网\"></a>在win上配置frp客户端代理到服务器公网</h3><p>如果要代理到公网，就用这个</p>\n<p>配置文件为<code>frpc.ini</code>，修改其内容如下：</p>\n<pre><code>[common]\nserver_addr = &lt;Your server IP&gt;\nserver_port = &lt;Your selected port&gt;\ntoken = &lt;Your password&gt;\n\n[nvidia-stream-tcp-1]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 47984\nremote_port = 47984\n\n[nvidia-stream-tcp-2]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 47989\nremote_port = 47989\n\n[nvidia-stream-tcp-3]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 48010\nremote_port = 48010\n\n[nvidia-stream-udp-1]\ntype = udp\nlocal_ip = 127.0.0.1\nlocal_port = 5353\nremote_port = 5353\n\n[nvidia-stream-udp-2]\ntype = udp\nlocal_ip = 127.0.0.1\nlocal_port = 47998\nremote_port = 47998\n\n[nvidia-stream-udp-3]\ntype = udp\nlocal_ip = 127.0.0.1\nlocal_port = 47999\nremote_port = 47999\n\n[nvidia-stream-udp-4]\ntype = udp\nlocal_ip = 127.0.0.1\nlocal_port = 48000\nremote_port = 48000\n\n[nvidia-stream-udp-5]\ntype = udp\nlocal_ip = 127.0.0.1\nlocal_port = 48002\nremote_port = 48002\n\n[nvidia-stream-udp-6]\ntype = udp\nlocal_ip = 127.0.0.1\nlocal_port = 48010\nremote_port = 48010</code></pre><h3 id=\"如何使用moonlight连接\"><a href=\"#如何使用moonlight连接\" class=\"headerlink\" title=\"如何使用moonlight连接\"></a>如何使用moonlight连接</h3><p>输入ip就可以了</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/73e9ab486fd11539c76112ad3b7a06ee/1c585179af1e0b42cd02697fb2b5f03e.png\" alt=\"image-20221218215436510\"></p>\n<p>Moonlight串流的画面质量很高，当作远程桌面来用完全没问题。不过，它默认只让你启动游戏，那怎么办呢？你可以启动一个不会立即进去的游戏，比如CS:GO，然后把它晾着去干别的事情。其实，还有一种更优雅的解法：在Geforce Experience里把<code>C:\\Windows\\System32\\mstsc.exe</code>添加到游戏列表里，在Moonlight里点mstsc就能直接进桌面了。其实<code>mstsc.exe</code>是Windows 远程桌面的exe，Moonlight并没有真的去执行它，Moonlight实际上相当于收到了一个信号，那就是你想直接进桌面。至于为什么设计得这么奇怪，那你得问Nvidia。</p>\n<h1 id=\"关于win的防火墙问题\"><a href=\"#关于win的防火墙问题\" class=\"headerlink\" title=\"关于win的防火墙问题\"></a>关于win的防火墙问题</h1><p><a href=\"https://tutujanjan.com/?p=2146\" target=\"_blank\" rel=\"noopener\">https://tutujanjan.com/?p=2146</a></p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h1><p>有一台配置有N卡的win，有一个可能不在同一个局域网的PC机B。</p>\n<p>想要让主机B能够流畅的控制桌面使用win。</p>\n<p>使用moonlight</p>\n<h1 id=\"具体\"><a href=\"#具体\" class=\"headerlink\" title=\"具体\"></a>具体</h1><p><strong>我走的服务器代理，所以延迟会比较高</strong>，50ms</p>\n<h3 id=\"win上配置Nvidia-Geforce-Experience的Shield\"><a href=\"#win上配置Nvidia-Geforce-Experience的Shield\" class=\"headerlink\" title=\"win上配置Nvidia Geforce Experience的Shield\"></a>win上配置Nvidia Geforce Experience的Shield</h3><p>你需要安装Nvidia Geforce Experience，在它的设置中找到并启用Shield串流服务。这个需要比较彻底的科学上网才能开，建议</p>\n<ul>\n<li>使用openwrt</li>\n<li>使用clash的<img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/73e9ab486fd11539c76112ad3b7a06ee/aa75dc1d4821f4ef9038d94241064049.png\" alt=\"image-20221218215126294\"></li>\n</ul>\n<p>开启</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/73e9ab486fd11539c76112ad3b7a06ee/93ddecc08da551187d5414a8cfb5171c.png\" alt=\"image-20221218215224220\"></p>\n<p>一个用来重启<code>NvContainerLocalSystem</code>的bat脚本</p>\n<pre><code>@echo off\necho 关闭服务\nnet stop &quot;NvContainerLocalSystem&quot;\ntimeout 2\necho 开启服务\nnet start &quot;NvContainerLocalSystem&quot;</code></pre><h3 id=\"在win上配置frp客户端代理到服务器公网\"><a href=\"#在win上配置frp客户端代理到服务器公网\" class=\"headerlink\" title=\"在win上配置frp客户端代理到服务器公网\"></a>在win上配置frp客户端代理到服务器公网</h3><p>如果要代理到公网，就用这个</p>\n<p>配置文件为<code>frpc.ini</code>，修改其内容如下：</p>\n<pre><code>[common]\nserver_addr = &lt;Your server IP&gt;\nserver_port = &lt;Your selected port&gt;\ntoken = &lt;Your password&gt;\n\n[nvidia-stream-tcp-1]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 47984\nremote_port = 47984\n\n[nvidia-stream-tcp-2]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 47989\nremote_port = 47989\n\n[nvidia-stream-tcp-3]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 48010\nremote_port = 48010\n\n[nvidia-stream-udp-1]\ntype = udp\nlocal_ip = 127.0.0.1\nlocal_port = 5353\nremote_port = 5353\n\n[nvidia-stream-udp-2]\ntype = udp\nlocal_ip = 127.0.0.1\nlocal_port = 47998\nremote_port = 47998\n\n[nvidia-stream-udp-3]\ntype = udp\nlocal_ip = 127.0.0.1\nlocal_port = 47999\nremote_port = 47999\n\n[nvidia-stream-udp-4]\ntype = udp\nlocal_ip = 127.0.0.1\nlocal_port = 48000\nremote_port = 48000\n\n[nvidia-stream-udp-5]\ntype = udp\nlocal_ip = 127.0.0.1\nlocal_port = 48002\nremote_port = 48002\n\n[nvidia-stream-udp-6]\ntype = udp\nlocal_ip = 127.0.0.1\nlocal_port = 48010\nremote_port = 48010</code></pre><h3 id=\"如何使用moonlight连接\"><a href=\"#如何使用moonlight连接\" class=\"headerlink\" title=\"如何使用moonlight连接\"></a>如何使用moonlight连接</h3><p>输入ip就可以了</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/73e9ab486fd11539c76112ad3b7a06ee/1c585179af1e0b42cd02697fb2b5f03e.png\" alt=\"image-20221218215436510\"></p>\n<p>Moonlight串流的画面质量很高，当作远程桌面来用完全没问题。不过，它默认只让你启动游戏，那怎么办呢？你可以启动一个不会立即进去的游戏，比如CS:GO，然后把它晾着去干别的事情。其实，还有一种更优雅的解法：在Geforce Experience里把<code>C:\\Windows\\System32\\mstsc.exe</code>添加到游戏列表里，在Moonlight里点mstsc就能直接进桌面了。其实<code>mstsc.exe</code>是Windows 远程桌面的exe，Moonlight并没有真的去执行它，Moonlight实际上相当于收到了一个信号，那就是你想直接进桌面。至于为什么设计得这么奇怪，那你得问Nvidia。</p>\n<h1 id=\"关于win的防火墙问题\"><a href=\"#关于win的防火墙问题\" class=\"headerlink\" title=\"关于win的防火墙问题\"></a>关于win的防火墙问题</h1><p><a href=\"https://tutujanjan.com/?p=2146\" target=\"_blank\" rel=\"noopener\">https://tutujanjan.com/?p=2146</a></p>\n"},{"_content":"# 协程，进程，线程概念\n\n- 进程：资源占用的基本单位。\n- 线程：执行任务的单位，一个进程可以有多个线程。\n\n**以上两者，如果要实现并发，那么利用的是多核cpu的并行能力。**但是协程不一样，协程实际上还是单线程\n\n- 协程：**程序员通过高超的代码能力，在代码执行流程中人为的实现多任务并发，是单个线程内的任务调度技巧。**\n\n\n\n# python的协程------yield，next，send\n\n```\ndef simple_coroutine():\n    print('-> 启动协程')\n    y = 10\n    \n    # 遇到yield就暂停返回，直到next再返回过来，\n\"\"\"\n    var = yield xxxx的赋值形式。它同时具备两个功能，一是暂停并返回函数，二是接收外部send()方法发送过来的值，重新激活函数，并将这个值赋值给var变量！\n\"\"\"\n    x = yield y\n    print('-> 协程接收到了x的值:', x)\n\nmy_coro = simple_coroutine()\nret = next(my_coro)\nprint(ret)\nmy_coro.send(10)\n```\n\n\n\n# python协程------async，await\n\n```\nimport asyncio\nimport datetime\n\nasync def display_date(num, loop):      # 注意这一行的写法\n    end_time = loop.time() + 10.0\n    while True:\n        print(\"Loop: {} Time: {}\".format(num, datetime.datetime.now()))\n        if (loop.time() + 1.0) >= end_time:\n            break\n        await asyncio.sleep(2)  # 阻塞直到协程sleep(2)返回结果\n\nloop = asyncio.get_event_loop()  # 获取一个event_loop\ntasks = [display_date(1, loop), display_date(2, loop)]\nloop.run_until_complete(asyncio.gather(*tasks))  # \"阻塞\"直到所有的tasks完成\nloop.close()\n\n```\n\n\n- 创建事件循环\n- 指定循环模式并运行\n- 关闭循环\n\n\n\n# 一个spider的样例\n```\nimport asyncio\nimport aiohttp\nimport time\n\nstart = time.time()\n\nasync def get(url):\n    session = aiohttp.ClientSession()\n    response = await session.get(url)\n    await response.text()\n    await session.close()\n    return response\n\nasync def request():\n    url = 'https://httpbin.org/delay/5'\n    print('Waiting for', url)\n    response = await get(url)\n    print('Get response from', url, 'response', response)\n\ntasks = [asyncio.ensure_future(request()) for _ in range(10)]\nloop = asyncio.get_event_loop()\nloop.run_until_complete(asyncio.wait(tasks))\n\nend = time.time()\nprint('Cost time:', end - start)\n```\n","source":"_posts/综合/python协程，进程与线程.md","raw":"# 协程，进程，线程概念\n\n- 进程：资源占用的基本单位。\n- 线程：执行任务的单位，一个进程可以有多个线程。\n\n**以上两者，如果要实现并发，那么利用的是多核cpu的并行能力。**但是协程不一样，协程实际上还是单线程\n\n- 协程：**程序员通过高超的代码能力，在代码执行流程中人为的实现多任务并发，是单个线程内的任务调度技巧。**\n\n\n\n# python的协程------yield，next，send\n\n```\ndef simple_coroutine():\n    print('-> 启动协程')\n    y = 10\n    \n    # 遇到yield就暂停返回，直到next再返回过来，\n\"\"\"\n    var = yield xxxx的赋值形式。它同时具备两个功能，一是暂停并返回函数，二是接收外部send()方法发送过来的值，重新激活函数，并将这个值赋值给var变量！\n\"\"\"\n    x = yield y\n    print('-> 协程接收到了x的值:', x)\n\nmy_coro = simple_coroutine()\nret = next(my_coro)\nprint(ret)\nmy_coro.send(10)\n```\n\n\n\n# python协程------async，await\n\n```\nimport asyncio\nimport datetime\n\nasync def display_date(num, loop):      # 注意这一行的写法\n    end_time = loop.time() + 10.0\n    while True:\n        print(\"Loop: {} Time: {}\".format(num, datetime.datetime.now()))\n        if (loop.time() + 1.0) >= end_time:\n            break\n        await asyncio.sleep(2)  # 阻塞直到协程sleep(2)返回结果\n\nloop = asyncio.get_event_loop()  # 获取一个event_loop\ntasks = [display_date(1, loop), display_date(2, loop)]\nloop.run_until_complete(asyncio.gather(*tasks))  # \"阻塞\"直到所有的tasks完成\nloop.close()\n\n```\n\n\n- 创建事件循环\n- 指定循环模式并运行\n- 关闭循环\n\n\n\n# 一个spider的样例\n```\nimport asyncio\nimport aiohttp\nimport time\n\nstart = time.time()\n\nasync def get(url):\n    session = aiohttp.ClientSession()\n    response = await session.get(url)\n    await response.text()\n    await session.close()\n    return response\n\nasync def request():\n    url = 'https://httpbin.org/delay/5'\n    print('Waiting for', url)\n    response = await get(url)\n    print('Get response from', url, 'response', response)\n\ntasks = [asyncio.ensure_future(request()) for _ in range(10)]\nloop = asyncio.get_event_loop()\nloop.run_until_complete(asyncio.wait(tasks))\n\nend = time.time()\nprint('Cost time:', end - start)\n```\n","slug":"综合/python协程，进程与线程","published":1,"date":"2023-02-26T15:28:35.062Z","updated":"2023-02-27T11:34:33.142Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsycq001p0gcn8ok910qg","content":"<h1 id=\"协程，进程，线程概念\"><a href=\"#协程，进程，线程概念\" class=\"headerlink\" title=\"协程，进程，线程概念\"></a>协程，进程，线程概念</h1><ul>\n<li>进程：资源占用的基本单位。</li>\n<li>线程：执行任务的单位，一个进程可以有多个线程。</li>\n</ul>\n<p><strong>以上两者，如果要实现并发，那么利用的是多核cpu的并行能力。</strong>但是协程不一样，协程实际上还是单线程</p>\n<ul>\n<li>协程：<strong>程序员通过高超的代码能力，在代码执行流程中人为的实现多任务并发，是单个线程内的任务调度技巧。</strong></li>\n</ul>\n<h1 id=\"python的协程——yield，next，send\"><a href=\"#python的协程——yield，next，send\" class=\"headerlink\" title=\"python的协程——yield，next，send\"></a>python的协程——yield，next，send</h1><pre><code>def simple_coroutine():\n    print(&#39;-&gt; 启动协程&#39;)\n    y = 10\n\n    # 遇到yield就暂停返回，直到next再返回过来，\n&quot;&quot;&quot;\n    var = yield xxxx的赋值形式。它同时具备两个功能，一是暂停并返回函数，二是接收外部send()方法发送过来的值，重新激活函数，并将这个值赋值给var变量！\n&quot;&quot;&quot;\n    x = yield y\n    print(&#39;-&gt; 协程接收到了x的值:&#39;, x)\n\nmy_coro = simple_coroutine()\nret = next(my_coro)\nprint(ret)\nmy_coro.send(10)</code></pre><h1 id=\"python协程——async，await\"><a href=\"#python协程——async，await\" class=\"headerlink\" title=\"python协程——async，await\"></a>python协程——async，await</h1><pre><code>import asyncio\nimport datetime\n\nasync def display_date(num, loop):      # 注意这一行的写法\n    end_time = loop.time() + 10.0\n    while True:\n        print(&quot;Loop: {} Time: {}&quot;.format(num, datetime.datetime.now()))\n        if (loop.time() + 1.0) &gt;= end_time:\n            break\n        await asyncio.sleep(2)  # 阻塞直到协程sleep(2)返回结果\n\nloop = asyncio.get_event_loop()  # 获取一个event_loop\ntasks = [display_date(1, loop), display_date(2, loop)]\nloop.run_until_complete(asyncio.gather(*tasks))  # &quot;阻塞&quot;直到所有的tasks完成\nloop.close()\n</code></pre><ul>\n<li>创建事件循环</li>\n<li>指定循环模式并运行</li>\n<li>关闭循环</li>\n</ul>\n<h1 id=\"一个spider的样例\"><a href=\"#一个spider的样例\" class=\"headerlink\" title=\"一个spider的样例\"></a>一个spider的样例</h1><pre><code>import asyncio\nimport aiohttp\nimport time\n\nstart = time.time()\n\nasync def get(url):\n    session = aiohttp.ClientSession()\n    response = await session.get(url)\n    await response.text()\n    await session.close()\n    return response\n\nasync def request():\n    url = &#39;https://httpbin.org/delay/5&#39;\n    print(&#39;Waiting for&#39;, url)\n    response = await get(url)\n    print(&#39;Get response from&#39;, url, &#39;response&#39;, response)\n\ntasks = [asyncio.ensure_future(request()) for _ in range(10)]\nloop = asyncio.get_event_loop()\nloop.run_until_complete(asyncio.wait(tasks))\n\nend = time.time()\nprint(&#39;Cost time:&#39;, end - start)</code></pre>","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"协程，进程，线程概念\"><a href=\"#协程，进程，线程概念\" class=\"headerlink\" title=\"协程，进程，线程概念\"></a>协程，进程，线程概念</h1><ul>\n<li>进程：资源占用的基本单位。</li>\n<li>线程：执行任务的单位，一个进程可以有多个线程。</li>\n</ul>\n<p><strong>以上两者，如果要实现并发，那么利用的是多核cpu的并行能力。</strong>但是协程不一样，协程实际上还是单线程</p>\n<ul>\n<li>协程：<strong>程序员通过高超的代码能力，在代码执行流程中人为的实现多任务并发，是单个线程内的任务调度技巧。</strong></li>\n</ul>\n<h1 id=\"python的协程——yield，next，send\"><a href=\"#python的协程——yield，next，send\" class=\"headerlink\" title=\"python的协程——yield，next，send\"></a>python的协程——yield，next，send</h1><pre><code>def simple_coroutine():\n    print(&#39;-&gt; 启动协程&#39;)\n    y = 10\n\n    # 遇到yield就暂停返回，直到next再返回过来，\n&quot;&quot;&quot;\n    var = yield xxxx的赋值形式。它同时具备两个功能，一是暂停并返回函数，二是接收外部send()方法发送过来的值，重新激活函数，并将这个值赋值给var变量！\n&quot;&quot;&quot;\n    x = yield y\n    print(&#39;-&gt; 协程接收到了x的值:&#39;, x)\n\nmy_coro = simple_coroutine()\nret = next(my_coro)\nprint(ret)\nmy_coro.send(10)</code></pre><h1 id=\"python协程——async，await\"><a href=\"#python协程——async，await\" class=\"headerlink\" title=\"python协程——async，await\"></a>python协程——async，await</h1><pre><code>import asyncio\nimport datetime\n\nasync def display_date(num, loop):      # 注意这一行的写法\n    end_time = loop.time() + 10.0\n    while True:\n        print(&quot;Loop: {} Time: {}&quot;.format(num, datetime.datetime.now()))\n        if (loop.time() + 1.0) &gt;= end_time:\n            break\n        await asyncio.sleep(2)  # 阻塞直到协程sleep(2)返回结果\n\nloop = asyncio.get_event_loop()  # 获取一个event_loop\ntasks = [display_date(1, loop), display_date(2, loop)]\nloop.run_until_complete(asyncio.gather(*tasks))  # &quot;阻塞&quot;直到所有的tasks完成\nloop.close()\n</code></pre><ul>\n<li>创建事件循环</li>\n<li>指定循环模式并运行</li>\n<li>关闭循环</li>\n</ul>\n<h1 id=\"一个spider的样例\"><a href=\"#一个spider的样例\" class=\"headerlink\" title=\"一个spider的样例\"></a>一个spider的样例</h1><pre><code>import asyncio\nimport aiohttp\nimport time\n\nstart = time.time()\n\nasync def get(url):\n    session = aiohttp.ClientSession()\n    response = await session.get(url)\n    await response.text()\n    await session.close()\n    return response\n\nasync def request():\n    url = &#39;https://httpbin.org/delay/5&#39;\n    print(&#39;Waiting for&#39;, url)\n    response = await get(url)\n    print(&#39;Get response from&#39;, url, &#39;response&#39;, response)\n\ntasks = [asyncio.ensure_future(request()) for _ in range(10)]\nloop = asyncio.get_event_loop()\nloop.run_until_complete(asyncio.wait(tasks))\n\nend = time.time()\nprint(&#39;Cost time:&#39;, end - start)</code></pre>"},{"_content":"# ps学习\n\n\n\n## 基础三件套\n\n- 吸色：吸取颜色，作为画笔的使用\n- 画笔：用来绘制，需要调节大小，硬度，以及画笔的形状综合使用\n- 橡皮擦：和画笔类似，不过是用来消除颜色的\n- 选择工具，一个是普通几何形状的框选，另一个就是自己用钢笔绘制出来轮廓选择\n- 油漆桶，类似画笔，不过可以一次性全部填充谋颜色。\n\n\n\n## 技巧\n\n适当调节画笔橡皮擦的硬度。用硬度低的大橡皮擦擦除边缘部分，整体比较保真。\n\n\n\n\n\n## 消背景技巧------调整颜色范围\n\n![image-20221009110452976](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84d663a0b038982740b9687a7d3fec01/23a81d4c402608f3d82f91314fe27bb7.png)\n\n使用混合选项。\n\n![image-20221009110523619](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84d663a0b038982740b9687a7d3fec01/127381b4f2cd920a0328a8bbc620736c.png)\n\n\n\n\n\n## 关于调整对比度等色相\n\n可以做到加深颜色，调节对比度等等。\n\n![image-20221009110612289](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84d663a0b038982740b9687a7d3fec01/3f53ce38859f888269d9f7792158e766.png)\n\n\n\n\n\n\n\n## 蒙版\n\n\n\n### 图层蒙版---黑透白不透\n\n![image-20221009103857768](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84d663a0b038982740b9687a7d3fec01/e4c20d5da0e1091c10e8d8267b946842.png)\n\n蒙版的底色是白色，在蒙版上用黑色话，那么就会让前景变得透明。反之白色不透明\n\n介于黑白之间的灰色是半透明。\n\n### 剪贴蒙版---上面图，下面形\n\n可以用来加深颜色啥的\n\n![image-20221009104558570](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84d663a0b038982740b9687a7d3fec01/eed3c82b9da9c8cb72ed35f95ead8483.png)\n\n\n\n上面的的整个剪贴蒙版会根据下面的图形像素块分布，自动选择是否存在。有就存在，没有就不存在。\n\n\n\n\n\n","source":"_posts/综合/ps学习.md","raw":"# ps学习\n\n\n\n## 基础三件套\n\n- 吸色：吸取颜色，作为画笔的使用\n- 画笔：用来绘制，需要调节大小，硬度，以及画笔的形状综合使用\n- 橡皮擦：和画笔类似，不过是用来消除颜色的\n- 选择工具，一个是普通几何形状的框选，另一个就是自己用钢笔绘制出来轮廓选择\n- 油漆桶，类似画笔，不过可以一次性全部填充谋颜色。\n\n\n\n## 技巧\n\n适当调节画笔橡皮擦的硬度。用硬度低的大橡皮擦擦除边缘部分，整体比较保真。\n\n\n\n\n\n## 消背景技巧------调整颜色范围\n\n![image-20221009110452976](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84d663a0b038982740b9687a7d3fec01/23a81d4c402608f3d82f91314fe27bb7.png)\n\n使用混合选项。\n\n![image-20221009110523619](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84d663a0b038982740b9687a7d3fec01/127381b4f2cd920a0328a8bbc620736c.png)\n\n\n\n\n\n## 关于调整对比度等色相\n\n可以做到加深颜色，调节对比度等等。\n\n![image-20221009110612289](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84d663a0b038982740b9687a7d3fec01/3f53ce38859f888269d9f7792158e766.png)\n\n\n\n\n\n\n\n## 蒙版\n\n\n\n### 图层蒙版---黑透白不透\n\n![image-20221009103857768](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84d663a0b038982740b9687a7d3fec01/e4c20d5da0e1091c10e8d8267b946842.png)\n\n蒙版的底色是白色，在蒙版上用黑色话，那么就会让前景变得透明。反之白色不透明\n\n介于黑白之间的灰色是半透明。\n\n### 剪贴蒙版---上面图，下面形\n\n可以用来加深颜色啥的\n\n![image-20221009104558570](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84d663a0b038982740b9687a7d3fec01/eed3c82b9da9c8cb72ed35f95ead8483.png)\n\n\n\n上面的的整个剪贴蒙版会根据下面的图形像素块分布，自动选择是否存在。有就存在，没有就不存在。\n\n\n\n\n\n","slug":"综合/ps学习","published":1,"date":"2023-02-26T15:28:35.061Z","updated":"2023-02-27T11:34:33.138Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsycq001q0gcn0g6bnufr","content":"<h1 id=\"ps学习\"><a href=\"#ps学习\" class=\"headerlink\" title=\"ps学习\"></a>ps学习</h1><h2 id=\"基础三件套\"><a href=\"#基础三件套\" class=\"headerlink\" title=\"基础三件套\"></a>基础三件套</h2><ul>\n<li>吸色：吸取颜色，作为画笔的使用</li>\n<li>画笔：用来绘制，需要调节大小，硬度，以及画笔的形状综合使用</li>\n<li>橡皮擦：和画笔类似，不过是用来消除颜色的</li>\n<li>选择工具，一个是普通几何形状的框选，另一个就是自己用钢笔绘制出来轮廓选择</li>\n<li>油漆桶，类似画笔，不过可以一次性全部填充谋颜色。</li>\n</ul>\n<h2 id=\"技巧\"><a href=\"#技巧\" class=\"headerlink\" title=\"技巧\"></a>技巧</h2><p>适当调节画笔橡皮擦的硬度。用硬度低的大橡皮擦擦除边缘部分，整体比较保真。</p>\n<h2 id=\"消背景技巧——调整颜色范围\"><a href=\"#消背景技巧——调整颜色范围\" class=\"headerlink\" title=\"消背景技巧——调整颜色范围\"></a>消背景技巧——调整颜色范围</h2><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84d663a0b038982740b9687a7d3fec01/23a81d4c402608f3d82f91314fe27bb7.png\" alt=\"image-20221009110452976\"></p>\n<p>使用混合选项。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84d663a0b038982740b9687a7d3fec01/127381b4f2cd920a0328a8bbc620736c.png\" alt=\"image-20221009110523619\"></p>\n<h2 id=\"关于调整对比度等色相\"><a href=\"#关于调整对比度等色相\" class=\"headerlink\" title=\"关于调整对比度等色相\"></a>关于调整对比度等色相</h2><p>可以做到加深颜色，调节对比度等等。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84d663a0b038982740b9687a7d3fec01/3f53ce38859f888269d9f7792158e766.png\" alt=\"image-20221009110612289\"></p>\n<h2 id=\"蒙版\"><a href=\"#蒙版\" class=\"headerlink\" title=\"蒙版\"></a>蒙版</h2><h3 id=\"图层蒙版—黑透白不透\"><a href=\"#图层蒙版—黑透白不透\" class=\"headerlink\" title=\"图层蒙版—黑透白不透\"></a>图层蒙版—黑透白不透</h3><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84d663a0b038982740b9687a7d3fec01/e4c20d5da0e1091c10e8d8267b946842.png\" alt=\"image-20221009103857768\"></p>\n<p>蒙版的底色是白色，在蒙版上用黑色话，那么就会让前景变得透明。反之白色不透明</p>\n<p>介于黑白之间的灰色是半透明。</p>\n<h3 id=\"剪贴蒙版—上面图，下面形\"><a href=\"#剪贴蒙版—上面图，下面形\" class=\"headerlink\" title=\"剪贴蒙版—上面图，下面形\"></a>剪贴蒙版—上面图，下面形</h3><p>可以用来加深颜色啥的</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84d663a0b038982740b9687a7d3fec01/eed3c82b9da9c8cb72ed35f95ead8483.png\" alt=\"image-20221009104558570\"></p>\n<p>上面的的整个剪贴蒙版会根据下面的图形像素块分布，自动选择是否存在。有就存在，没有就不存在。</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"ps学习\"><a href=\"#ps学习\" class=\"headerlink\" title=\"ps学习\"></a>ps学习</h1><h2 id=\"基础三件套\"><a href=\"#基础三件套\" class=\"headerlink\" title=\"基础三件套\"></a>基础三件套</h2><ul>\n<li>吸色：吸取颜色，作为画笔的使用</li>\n<li>画笔：用来绘制，需要调节大小，硬度，以及画笔的形状综合使用</li>\n<li>橡皮擦：和画笔类似，不过是用来消除颜色的</li>\n<li>选择工具，一个是普通几何形状的框选，另一个就是自己用钢笔绘制出来轮廓选择</li>\n<li>油漆桶，类似画笔，不过可以一次性全部填充谋颜色。</li>\n</ul>\n<h2 id=\"技巧\"><a href=\"#技巧\" class=\"headerlink\" title=\"技巧\"></a>技巧</h2><p>适当调节画笔橡皮擦的硬度。用硬度低的大橡皮擦擦除边缘部分，整体比较保真。</p>\n<h2 id=\"消背景技巧——调整颜色范围\"><a href=\"#消背景技巧——调整颜色范围\" class=\"headerlink\" title=\"消背景技巧——调整颜色范围\"></a>消背景技巧——调整颜色范围</h2><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84d663a0b038982740b9687a7d3fec01/23a81d4c402608f3d82f91314fe27bb7.png\" alt=\"image-20221009110452976\"></p>\n<p>使用混合选项。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84d663a0b038982740b9687a7d3fec01/127381b4f2cd920a0328a8bbc620736c.png\" alt=\"image-20221009110523619\"></p>\n<h2 id=\"关于调整对比度等色相\"><a href=\"#关于调整对比度等色相\" class=\"headerlink\" title=\"关于调整对比度等色相\"></a>关于调整对比度等色相</h2><p>可以做到加深颜色，调节对比度等等。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84d663a0b038982740b9687a7d3fec01/3f53ce38859f888269d9f7792158e766.png\" alt=\"image-20221009110612289\"></p>\n<h2 id=\"蒙版\"><a href=\"#蒙版\" class=\"headerlink\" title=\"蒙版\"></a>蒙版</h2><h3 id=\"图层蒙版—黑透白不透\"><a href=\"#图层蒙版—黑透白不透\" class=\"headerlink\" title=\"图层蒙版—黑透白不透\"></a>图层蒙版—黑透白不透</h3><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84d663a0b038982740b9687a7d3fec01/e4c20d5da0e1091c10e8d8267b946842.png\" alt=\"image-20221009103857768\"></p>\n<p>蒙版的底色是白色，在蒙版上用黑色话，那么就会让前景变得透明。反之白色不透明</p>\n<p>介于黑白之间的灰色是半透明。</p>\n<h3 id=\"剪贴蒙版—上面图，下面形\"><a href=\"#剪贴蒙版—上面图，下面形\" class=\"headerlink\" title=\"剪贴蒙版—上面图，下面形\"></a>剪贴蒙版—上面图，下面形</h3><p>可以用来加深颜色啥的</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84d663a0b038982740b9687a7d3fec01/eed3c82b9da9c8cb72ed35f95ead8483.png\" alt=\"image-20221009104558570\"></p>\n<p>上面的的整个剪贴蒙版会根据下面的图形像素块分布，自动选择是否存在。有就存在，没有就不存在。</p>\n"},{"_content":"# 基于nonebot的qq机器人搭建\n\n\n\n## 安装go-cqhttp\n\n这个是一个用来拟真qq客户端的库，能够自动登录一个qq账号，并开放相关接口。\n\n**安装**\n\n- 去官网下载可执行文件\n- 用docker。\n\n**这里我们需要开放两个接口**\n\n- 反向websock接口，用来与nonebot框架搭建/cmd msg 的基于event的机器人命令\n- http接口，用来开放一些公开的api接口`http://127.0.0.1:5700/send_private_msg?user_id=[接收者qq号]&message=[发送的信息]`\n\n```\n# go-cqhttp 默认配置文件\n\naccount: # 账号相关\n  uin: ******* # QQ账号\n  password: '*******' # 密码为空时使用扫码登录\n  encrypt: false  # 是否开启密码加密\n  status: 0      # 在线状态 请参考 https://docs.go-cqhttp.org/guide/config.html#在线状态\n  relogin: # 重连设置\n    delay: 3   # 首次重连延迟, 单位秒\n    interval: 3   # 重连间隔\n    max-times: 0  # 最大重连次数, 0为无限制\n\n  # 是否使用服务器下发的新地址进行重连\n  # 注意, 此设置可能导致在海外服务器上连接情况更差\n  use-sso-address: true\n  # 是否允许发送临时会话消息\n  allow-temp-session: false\n\nheartbeat:\n  # 心跳频率, 单位秒\n  # -1 为关闭心跳\n  interval: 5\n\nmessage:\n  # 上报数据类型\n  # 可选: string,array\n  post-format: string\n  # 是否忽略无效的CQ码, 如果为假将原样发送\n  ignore-invalid-cqcode: false\n  # 是否强制分片发送消息\n  # 分片发送将会带来更快的速度\n  # 但是兼容性会有些问题\n  force-fragment: false\n  # 是否将url分片发送\n  fix-url: false\n  # 下载图片等请求网络代理\n  proxy-rewrite: ''\n  # 是否上报自身消息\n  report-self-message: false\n  # 移除服务端的Reply附带的At\n  remove-reply-at: false\n  # 为Reply附加更多信息\n  extra-reply-data: false\n  # 跳过 Mime 扫描, 忽略错误数据\n  skip-mime-scan: false\n\noutput:\n  # 日志等级 trace,debug,info,warn,error\n  log-level: warn\n  # 日志时效 单位天. 超过这个时间之前的日志将会被自动删除. 设置为 0 表示永久保留.\n  log-aging: 15\n  # 是否在每次启动时强制创建全新的文件储存日志. 为 false 的情况下将会在上次启动时创建的日志文件续写\n  log-force-new: true\n  # 是否启用日志颜色\n  log-colorful: true\n  # 是否启用 DEBUG\n  debug: false # 开启调试模式\n\n# 默认中间件锚点\ndefault-middlewares: &default\n  # 访问密钥, 强烈推荐在公网的服务器设置\n  access-token: ''\n  # 事件过滤器文件目录\n  filter: ''\n  # API限速设置\n  # 该设置为全局生效\n  # 原 cqhttp 虽然启用了 rate_limit 后缀, 但是基本没插件适配\n  # 目前该限速设置为令牌桶算法, 请参考:\n  # https://baike.baidu.com/item/%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95/6597000?fr=aladdin\n  rate-limit:\n    enabled: false # 是否启用限速\n    frequency: 1  # 令牌回复频率, 单位秒\n    bucket: 1     # 令牌桶大小\n\ndatabase: # 数据库相关设置\n  leveldb:\n    # 是否启用内置leveldb数据库\n    # 启用将会增加10-20MB的内存占用和一定的磁盘空间\n    # 关闭将无法使用 撤回 回复 get_msg 等上下文相关功能\n    enable: true\n\n  # 媒体文件缓存， 删除此项则使用缓存文件(旧版行为)\n  cache:\n    image: data/image.db\n    video: data/video.db\n\n# 连接服务列表\nservers:\n  # 添加方式，同一连接方式可添加多个，具体配置说明请查看文档\n  #- http: # http 通信\n  #- ws:   # 正向 Websocket\n  #- ws-reverse: # 反向 Websocket\n  #- pprof: #性能分析服务器\n  # 反向WS设置\n\n  - ws-reverse:\n      universal: ws://0.0.0.0:8082/ws/\n      # 反向WS API 地址\n\n      # 重连间隔 单位毫秒\n      reconnect-interval: 3000\n      middlewares:\n        <<: *default # 引用默认中间件\n        \n  - http: # HTTP 通信设置\n      address: 0.0.0.0:5700 # HTTP监听地址\n      timeout: 5      # 反向 HTTP 超时时间, 单位秒，<5 时将被忽略\n      long-polling:   # 长轮询拓展\n        enabled: false       # 是否开启\n        max-queue-size: 2000 # 消息队列大小，0 表示不限制队列大小，谨慎使用\n```\n\n\n\n\n\n## nonebot 框架\n\n**python用pip安装好库**\n\n然后可以搭建相关命令了，详细写法放到项目中自行观看","source":"_posts/综合/qq机器人搭建.md","raw":"# 基于nonebot的qq机器人搭建\n\n\n\n## 安装go-cqhttp\n\n这个是一个用来拟真qq客户端的库，能够自动登录一个qq账号，并开放相关接口。\n\n**安装**\n\n- 去官网下载可执行文件\n- 用docker。\n\n**这里我们需要开放两个接口**\n\n- 反向websock接口，用来与nonebot框架搭建/cmd msg 的基于event的机器人命令\n- http接口，用来开放一些公开的api接口`http://127.0.0.1:5700/send_private_msg?user_id=[接收者qq号]&message=[发送的信息]`\n\n```\n# go-cqhttp 默认配置文件\n\naccount: # 账号相关\n  uin: ******* # QQ账号\n  password: '*******' # 密码为空时使用扫码登录\n  encrypt: false  # 是否开启密码加密\n  status: 0      # 在线状态 请参考 https://docs.go-cqhttp.org/guide/config.html#在线状态\n  relogin: # 重连设置\n    delay: 3   # 首次重连延迟, 单位秒\n    interval: 3   # 重连间隔\n    max-times: 0  # 最大重连次数, 0为无限制\n\n  # 是否使用服务器下发的新地址进行重连\n  # 注意, 此设置可能导致在海外服务器上连接情况更差\n  use-sso-address: true\n  # 是否允许发送临时会话消息\n  allow-temp-session: false\n\nheartbeat:\n  # 心跳频率, 单位秒\n  # -1 为关闭心跳\n  interval: 5\n\nmessage:\n  # 上报数据类型\n  # 可选: string,array\n  post-format: string\n  # 是否忽略无效的CQ码, 如果为假将原样发送\n  ignore-invalid-cqcode: false\n  # 是否强制分片发送消息\n  # 分片发送将会带来更快的速度\n  # 但是兼容性会有些问题\n  force-fragment: false\n  # 是否将url分片发送\n  fix-url: false\n  # 下载图片等请求网络代理\n  proxy-rewrite: ''\n  # 是否上报自身消息\n  report-self-message: false\n  # 移除服务端的Reply附带的At\n  remove-reply-at: false\n  # 为Reply附加更多信息\n  extra-reply-data: false\n  # 跳过 Mime 扫描, 忽略错误数据\n  skip-mime-scan: false\n\noutput:\n  # 日志等级 trace,debug,info,warn,error\n  log-level: warn\n  # 日志时效 单位天. 超过这个时间之前的日志将会被自动删除. 设置为 0 表示永久保留.\n  log-aging: 15\n  # 是否在每次启动时强制创建全新的文件储存日志. 为 false 的情况下将会在上次启动时创建的日志文件续写\n  log-force-new: true\n  # 是否启用日志颜色\n  log-colorful: true\n  # 是否启用 DEBUG\n  debug: false # 开启调试模式\n\n# 默认中间件锚点\ndefault-middlewares: &default\n  # 访问密钥, 强烈推荐在公网的服务器设置\n  access-token: ''\n  # 事件过滤器文件目录\n  filter: ''\n  # API限速设置\n  # 该设置为全局生效\n  # 原 cqhttp 虽然启用了 rate_limit 后缀, 但是基本没插件适配\n  # 目前该限速设置为令牌桶算法, 请参考:\n  # https://baike.baidu.com/item/%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95/6597000?fr=aladdin\n  rate-limit:\n    enabled: false # 是否启用限速\n    frequency: 1  # 令牌回复频率, 单位秒\n    bucket: 1     # 令牌桶大小\n\ndatabase: # 数据库相关设置\n  leveldb:\n    # 是否启用内置leveldb数据库\n    # 启用将会增加10-20MB的内存占用和一定的磁盘空间\n    # 关闭将无法使用 撤回 回复 get_msg 等上下文相关功能\n    enable: true\n\n  # 媒体文件缓存， 删除此项则使用缓存文件(旧版行为)\n  cache:\n    image: data/image.db\n    video: data/video.db\n\n# 连接服务列表\nservers:\n  # 添加方式，同一连接方式可添加多个，具体配置说明请查看文档\n  #- http: # http 通信\n  #- ws:   # 正向 Websocket\n  #- ws-reverse: # 反向 Websocket\n  #- pprof: #性能分析服务器\n  # 反向WS设置\n\n  - ws-reverse:\n      universal: ws://0.0.0.0:8082/ws/\n      # 反向WS API 地址\n\n      # 重连间隔 单位毫秒\n      reconnect-interval: 3000\n      middlewares:\n        <<: *default # 引用默认中间件\n        \n  - http: # HTTP 通信设置\n      address: 0.0.0.0:5700 # HTTP监听地址\n      timeout: 5      # 反向 HTTP 超时时间, 单位秒，<5 时将被忽略\n      long-polling:   # 长轮询拓展\n        enabled: false       # 是否开启\n        max-queue-size: 2000 # 消息队列大小，0 表示不限制队列大小，谨慎使用\n```\n\n\n\n\n\n## nonebot 框架\n\n**python用pip安装好库**\n\n然后可以搭建相关命令了，详细写法放到项目中自行观看","slug":"综合/qq机器人搭建","published":1,"date":"2023-02-26T15:28:35.063Z","updated":"2023-02-27T11:34:33.136Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsycr001r0gcnx9rhql9b","content":"<h1 id=\"基于nonebot的qq机器人搭建\"><a href=\"#基于nonebot的qq机器人搭建\" class=\"headerlink\" title=\"基于nonebot的qq机器人搭建\"></a>基于nonebot的qq机器人搭建</h1><h2 id=\"安装go-cqhttp\"><a href=\"#安装go-cqhttp\" class=\"headerlink\" title=\"安装go-cqhttp\"></a>安装go-cqhttp</h2><p>这个是一个用来拟真qq客户端的库，能够自动登录一个qq账号，并开放相关接口。</p>\n<p><strong>安装</strong></p>\n<ul>\n<li>去官网下载可执行文件</li>\n<li>用docker。</li>\n</ul>\n<p><strong>这里我们需要开放两个接口</strong></p>\n<ul>\n<li>反向websock接口，用来与nonebot框架搭建/cmd msg 的基于event的机器人命令</li>\n<li>http接口，用来开放一些公开的api接口<code>http://127.0.0.1:5700/send_private_msg?user_id=[接收者qq号]&amp;message=[发送的信息]</code></li>\n</ul>\n<pre><code># go-cqhttp 默认配置文件\n\naccount: # 账号相关\n  uin: ******* # QQ账号\n  password: &#39;*******&#39; # 密码为空时使用扫码登录\n  encrypt: false  # 是否开启密码加密\n  status: 0      # 在线状态 请参考 https://docs.go-cqhttp.org/guide/config.html#在线状态\n  relogin: # 重连设置\n    delay: 3   # 首次重连延迟, 单位秒\n    interval: 3   # 重连间隔\n    max-times: 0  # 最大重连次数, 0为无限制\n\n  # 是否使用服务器下发的新地址进行重连\n  # 注意, 此设置可能导致在海外服务器上连接情况更差\n  use-sso-address: true\n  # 是否允许发送临时会话消息\n  allow-temp-session: false\n\nheartbeat:\n  # 心跳频率, 单位秒\n  # -1 为关闭心跳\n  interval: 5\n\nmessage:\n  # 上报数据类型\n  # 可选: string,array\n  post-format: string\n  # 是否忽略无效的CQ码, 如果为假将原样发送\n  ignore-invalid-cqcode: false\n  # 是否强制分片发送消息\n  # 分片发送将会带来更快的速度\n  # 但是兼容性会有些问题\n  force-fragment: false\n  # 是否将url分片发送\n  fix-url: false\n  # 下载图片等请求网络代理\n  proxy-rewrite: &#39;&#39;\n  # 是否上报自身消息\n  report-self-message: false\n  # 移除服务端的Reply附带的At\n  remove-reply-at: false\n  # 为Reply附加更多信息\n  extra-reply-data: false\n  # 跳过 Mime 扫描, 忽略错误数据\n  skip-mime-scan: false\n\noutput:\n  # 日志等级 trace,debug,info,warn,error\n  log-level: warn\n  # 日志时效 单位天. 超过这个时间之前的日志将会被自动删除. 设置为 0 表示永久保留.\n  log-aging: 15\n  # 是否在每次启动时强制创建全新的文件储存日志. 为 false 的情况下将会在上次启动时创建的日志文件续写\n  log-force-new: true\n  # 是否启用日志颜色\n  log-colorful: true\n  # 是否启用 DEBUG\n  debug: false # 开启调试模式\n\n# 默认中间件锚点\ndefault-middlewares: &amp;default\n  # 访问密钥, 强烈推荐在公网的服务器设置\n  access-token: &#39;&#39;\n  # 事件过滤器文件目录\n  filter: &#39;&#39;\n  # API限速设置\n  # 该设置为全局生效\n  # 原 cqhttp 虽然启用了 rate_limit 后缀, 但是基本没插件适配\n  # 目前该限速设置为令牌桶算法, 请参考:\n  # https://baike.baidu.com/item/%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95/6597000?fr=aladdin\n  rate-limit:\n    enabled: false # 是否启用限速\n    frequency: 1  # 令牌回复频率, 单位秒\n    bucket: 1     # 令牌桶大小\n\ndatabase: # 数据库相关设置\n  leveldb:\n    # 是否启用内置leveldb数据库\n    # 启用将会增加10-20MB的内存占用和一定的磁盘空间\n    # 关闭将无法使用 撤回 回复 get_msg 等上下文相关功能\n    enable: true\n\n  # 媒体文件缓存， 删除此项则使用缓存文件(旧版行为)\n  cache:\n    image: data/image.db\n    video: data/video.db\n\n# 连接服务列表\nservers:\n  # 添加方式，同一连接方式可添加多个，具体配置说明请查看文档\n  #- http: # http 通信\n  #- ws:   # 正向 Websocket\n  #- ws-reverse: # 反向 Websocket\n  #- pprof: #性能分析服务器\n  # 反向WS设置\n\n  - ws-reverse:\n      universal: ws://0.0.0.0:8082/ws/\n      # 反向WS API 地址\n\n      # 重连间隔 单位毫秒\n      reconnect-interval: 3000\n      middlewares:\n        &lt;&lt;: *default # 引用默认中间件\n\n  - http: # HTTP 通信设置\n      address: 0.0.0.0:5700 # HTTP监听地址\n      timeout: 5      # 反向 HTTP 超时时间, 单位秒，&lt;5 时将被忽略\n      long-polling:   # 长轮询拓展\n        enabled: false       # 是否开启\n        max-queue-size: 2000 # 消息队列大小，0 表示不限制队列大小，谨慎使用</code></pre><h2 id=\"nonebot-框架\"><a href=\"#nonebot-框架\" class=\"headerlink\" title=\"nonebot 框架\"></a>nonebot 框架</h2><p><strong>python用pip安装好库</strong></p>\n<p>然后可以搭建相关命令了，详细写法放到项目中自行观看</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"基于nonebot的qq机器人搭建\"><a href=\"#基于nonebot的qq机器人搭建\" class=\"headerlink\" title=\"基于nonebot的qq机器人搭建\"></a>基于nonebot的qq机器人搭建</h1><h2 id=\"安装go-cqhttp\"><a href=\"#安装go-cqhttp\" class=\"headerlink\" title=\"安装go-cqhttp\"></a>安装go-cqhttp</h2><p>这个是一个用来拟真qq客户端的库，能够自动登录一个qq账号，并开放相关接口。</p>\n<p><strong>安装</strong></p>\n<ul>\n<li>去官网下载可执行文件</li>\n<li>用docker。</li>\n</ul>\n<p><strong>这里我们需要开放两个接口</strong></p>\n<ul>\n<li>反向websock接口，用来与nonebot框架搭建/cmd msg 的基于event的机器人命令</li>\n<li>http接口，用来开放一些公开的api接口<code>http://127.0.0.1:5700/send_private_msg?user_id=[接收者qq号]&amp;message=[发送的信息]</code></li>\n</ul>\n<pre><code># go-cqhttp 默认配置文件\n\naccount: # 账号相关\n  uin: ******* # QQ账号\n  password: &#39;*******&#39; # 密码为空时使用扫码登录\n  encrypt: false  # 是否开启密码加密\n  status: 0      # 在线状态 请参考 https://docs.go-cqhttp.org/guide/config.html#在线状态\n  relogin: # 重连设置\n    delay: 3   # 首次重连延迟, 单位秒\n    interval: 3   # 重连间隔\n    max-times: 0  # 最大重连次数, 0为无限制\n\n  # 是否使用服务器下发的新地址进行重连\n  # 注意, 此设置可能导致在海外服务器上连接情况更差\n  use-sso-address: true\n  # 是否允许发送临时会话消息\n  allow-temp-session: false\n\nheartbeat:\n  # 心跳频率, 单位秒\n  # -1 为关闭心跳\n  interval: 5\n\nmessage:\n  # 上报数据类型\n  # 可选: string,array\n  post-format: string\n  # 是否忽略无效的CQ码, 如果为假将原样发送\n  ignore-invalid-cqcode: false\n  # 是否强制分片发送消息\n  # 分片发送将会带来更快的速度\n  # 但是兼容性会有些问题\n  force-fragment: false\n  # 是否将url分片发送\n  fix-url: false\n  # 下载图片等请求网络代理\n  proxy-rewrite: &#39;&#39;\n  # 是否上报自身消息\n  report-self-message: false\n  # 移除服务端的Reply附带的At\n  remove-reply-at: false\n  # 为Reply附加更多信息\n  extra-reply-data: false\n  # 跳过 Mime 扫描, 忽略错误数据\n  skip-mime-scan: false\n\noutput:\n  # 日志等级 trace,debug,info,warn,error\n  log-level: warn\n  # 日志时效 单位天. 超过这个时间之前的日志将会被自动删除. 设置为 0 表示永久保留.\n  log-aging: 15\n  # 是否在每次启动时强制创建全新的文件储存日志. 为 false 的情况下将会在上次启动时创建的日志文件续写\n  log-force-new: true\n  # 是否启用日志颜色\n  log-colorful: true\n  # 是否启用 DEBUG\n  debug: false # 开启调试模式\n\n# 默认中间件锚点\ndefault-middlewares: &amp;default\n  # 访问密钥, 强烈推荐在公网的服务器设置\n  access-token: &#39;&#39;\n  # 事件过滤器文件目录\n  filter: &#39;&#39;\n  # API限速设置\n  # 该设置为全局生效\n  # 原 cqhttp 虽然启用了 rate_limit 后缀, 但是基本没插件适配\n  # 目前该限速设置为令牌桶算法, 请参考:\n  # https://baike.baidu.com/item/%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95/6597000?fr=aladdin\n  rate-limit:\n    enabled: false # 是否启用限速\n    frequency: 1  # 令牌回复频率, 单位秒\n    bucket: 1     # 令牌桶大小\n\ndatabase: # 数据库相关设置\n  leveldb:\n    # 是否启用内置leveldb数据库\n    # 启用将会增加10-20MB的内存占用和一定的磁盘空间\n    # 关闭将无法使用 撤回 回复 get_msg 等上下文相关功能\n    enable: true\n\n  # 媒体文件缓存， 删除此项则使用缓存文件(旧版行为)\n  cache:\n    image: data/image.db\n    video: data/video.db\n\n# 连接服务列表\nservers:\n  # 添加方式，同一连接方式可添加多个，具体配置说明请查看文档\n  #- http: # http 通信\n  #- ws:   # 正向 Websocket\n  #- ws-reverse: # 反向 Websocket\n  #- pprof: #性能分析服务器\n  # 反向WS设置\n\n  - ws-reverse:\n      universal: ws://0.0.0.0:8082/ws/\n      # 反向WS API 地址\n\n      # 重连间隔 单位毫秒\n      reconnect-interval: 3000\n      middlewares:\n        &lt;&lt;: *default # 引用默认中间件\n\n  - http: # HTTP 通信设置\n      address: 0.0.0.0:5700 # HTTP监听地址\n      timeout: 5      # 反向 HTTP 超时时间, 单位秒，&lt;5 时将被忽略\n      long-polling:   # 长轮询拓展\n        enabled: false       # 是否开启\n        max-queue-size: 2000 # 消息队列大小，0 表示不限制队列大小，谨慎使用</code></pre><h2 id=\"nonebot-框架\"><a href=\"#nonebot-框架\" class=\"headerlink\" title=\"nonebot 框架\"></a>nonebot 框架</h2><p><strong>python用pip安装好库</strong></p>\n<p>然后可以搭建相关命令了，详细写法放到项目中自行观看</p>\n"},{"_content":"# python 错误处理\n\n## try and except捕获异常\n可以通过用多个except捕获多个异常\n```\ntry:\n    print 2/'0'\nexcept ZeroDivisionError:\n    print '除数不能为0'\nexcept Exception:\n    print '其他类型异常'\nexcept Exception as e: # 捕获到错误本体\n    print(e)\n```\n\n## final句子,最终必执行\nfinally子句和try子句联合使用但是和except语句不同，finally不管try子句内部是否有异常发生，都会执行finally子句内的代码。所有一般情况下，finally自己常常用于关闭文件或者在Socket中。\n\n```\ntry:\n    print 2/'0'\nexcept (ZeroDivisionError,Exception):\n    print '发生了一个异常'\nfinally:\n    print '不管是否发生异常都执行'\n```\n\n## raise抛出一个异常\n\n```\ndef ThorwErr():\n    raise Exception(\"抛出一个异常\") \n# Exception: 抛出一个异常 \nThorwErr()\n```","source":"_posts/综合/python错误异常处理.md","raw":"# python 错误处理\n\n## try and except捕获异常\n可以通过用多个except捕获多个异常\n```\ntry:\n    print 2/'0'\nexcept ZeroDivisionError:\n    print '除数不能为0'\nexcept Exception:\n    print '其他类型异常'\nexcept Exception as e: # 捕获到错误本体\n    print(e)\n```\n\n## final句子,最终必执行\nfinally子句和try子句联合使用但是和except语句不同，finally不管try子句内部是否有异常发生，都会执行finally子句内的代码。所有一般情况下，finally自己常常用于关闭文件或者在Socket中。\n\n```\ntry:\n    print 2/'0'\nexcept (ZeroDivisionError,Exception):\n    print '发生了一个异常'\nfinally:\n    print '不管是否发生异常都执行'\n```\n\n## raise抛出一个异常\n\n```\ndef ThorwErr():\n    raise Exception(\"抛出一个异常\") \n# Exception: 抛出一个异常 \nThorwErr()\n```","slug":"综合/python错误异常处理","published":1,"date":"2023-02-26T15:28:35.062Z","updated":"2023-02-27T11:34:33.142Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsycv001s0gcn1k91tada","content":"<h1 id=\"python-错误处理\"><a href=\"#python-错误处理\" class=\"headerlink\" title=\"python 错误处理\"></a>python 错误处理</h1><h2 id=\"try-and-except捕获异常\"><a href=\"#try-and-except捕获异常\" class=\"headerlink\" title=\"try and except捕获异常\"></a>try and except捕获异常</h2><p>可以通过用多个except捕获多个异常</p>\n<pre><code>try:\n    print 2/&#39;0&#39;\nexcept ZeroDivisionError:\n    print &#39;除数不能为0&#39;\nexcept Exception:\n    print &#39;其他类型异常&#39;\nexcept Exception as e: # 捕获到错误本体\n    print(e)</code></pre><h2 id=\"final句子-最终必执行\"><a href=\"#final句子-最终必执行\" class=\"headerlink\" title=\"final句子,最终必执行\"></a>final句子,最终必执行</h2><p>finally子句和try子句联合使用但是和except语句不同，finally不管try子句内部是否有异常发生，都会执行finally子句内的代码。所有一般情况下，finally自己常常用于关闭文件或者在Socket中。</p>\n<pre><code>try:\n    print 2/&#39;0&#39;\nexcept (ZeroDivisionError,Exception):\n    print &#39;发生了一个异常&#39;\nfinally:\n    print &#39;不管是否发生异常都执行&#39;</code></pre><h2 id=\"raise抛出一个异常\"><a href=\"#raise抛出一个异常\" class=\"headerlink\" title=\"raise抛出一个异常\"></a>raise抛出一个异常</h2><pre><code>def ThorwErr():\n    raise Exception(&quot;抛出一个异常&quot;) \n# Exception: 抛出一个异常 \nThorwErr()</code></pre>","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"python-错误处理\"><a href=\"#python-错误处理\" class=\"headerlink\" title=\"python 错误处理\"></a>python 错误处理</h1><h2 id=\"try-and-except捕获异常\"><a href=\"#try-and-except捕获异常\" class=\"headerlink\" title=\"try and except捕获异常\"></a>try and except捕获异常</h2><p>可以通过用多个except捕获多个异常</p>\n<pre><code>try:\n    print 2/&#39;0&#39;\nexcept ZeroDivisionError:\n    print &#39;除数不能为0&#39;\nexcept Exception:\n    print &#39;其他类型异常&#39;\nexcept Exception as e: # 捕获到错误本体\n    print(e)</code></pre><h2 id=\"final句子-最终必执行\"><a href=\"#final句子-最终必执行\" class=\"headerlink\" title=\"final句子,最终必执行\"></a>final句子,最终必执行</h2><p>finally子句和try子句联合使用但是和except语句不同，finally不管try子句内部是否有异常发生，都会执行finally子句内的代码。所有一般情况下，finally自己常常用于关闭文件或者在Socket中。</p>\n<pre><code>try:\n    print 2/&#39;0&#39;\nexcept (ZeroDivisionError,Exception):\n    print &#39;发生了一个异常&#39;\nfinally:\n    print &#39;不管是否发生异常都执行&#39;</code></pre><h2 id=\"raise抛出一个异常\"><a href=\"#raise抛出一个异常\" class=\"headerlink\" title=\"raise抛出一个异常\"></a>raise抛出一个异常</h2><pre><code>def ThorwErr():\n    raise Exception(&quot;抛出一个异常&quot;) \n# Exception: 抛出一个异常 \nThorwErr()</code></pre>"},{"_content":"\n\n# root后如何愉快玩耍\n\n\n\n# root是什么\n\n正如linux有root用户，root用户代表了最高的权限。安卓也有root用户，一般在安卓中简称root权限。只有在获取了root权限后才能开发更多玩法。\n\n\n\n## magisk面具\n\nmagisk可以用来做root权限的管理工具，但是却不仅仅是一个root的权限管理工具这么简单。还可以用来安装各种模块工具。是一个很强大的框架\n\n\n\n## LSPosed框架\n\n与 Xposed 相同，**LPSosed 可以在不真实修改任何应用和系统组件的情况下达到修改的目的，从而实现强大的功能。**\n\n例如：去广告，b站解锁区域。\n\n\n\n## 注意仓库源问题\n\n这些框架基本都是在github开源的，因此很多时候源也都在github上。国内很容易导致仓库连接不上。\n\n\n\n## 一些组件推荐\n\n<div align=\"center\">\n[哔哩哔哩漫游娘](https://www.weibo.com/p/230418139a6f1100102vlj6)\n\n\n\n网易云vip破解\n\n\n\n去广告\n\n\n\n\n\n\n\n","source":"_posts/综合/安卓root探索记录.md","raw":"\n\n# root后如何愉快玩耍\n\n\n\n# root是什么\n\n正如linux有root用户，root用户代表了最高的权限。安卓也有root用户，一般在安卓中简称root权限。只有在获取了root权限后才能开发更多玩法。\n\n\n\n## magisk面具\n\nmagisk可以用来做root权限的管理工具，但是却不仅仅是一个root的权限管理工具这么简单。还可以用来安装各种模块工具。是一个很强大的框架\n\n\n\n## LSPosed框架\n\n与 Xposed 相同，**LPSosed 可以在不真实修改任何应用和系统组件的情况下达到修改的目的，从而实现强大的功能。**\n\n例如：去广告，b站解锁区域。\n\n\n\n## 注意仓库源问题\n\n这些框架基本都是在github开源的，因此很多时候源也都在github上。国内很容易导致仓库连接不上。\n\n\n\n## 一些组件推荐\n\n<div align=\"center\">\n[哔哩哔哩漫游娘](https://www.weibo.com/p/230418139a6f1100102vlj6)\n\n\n\n网易云vip破解\n\n\n\n去广告\n\n\n\n\n\n\n\n","slug":"综合/安卓root探索记录","published":1,"date":"2023-02-26T15:28:35.065Z","updated":"2023-02-27T11:34:33.140Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsycw001t0gcngsyljx1t","content":"<h1 id=\"root后如何愉快玩耍\"><a href=\"#root后如何愉快玩耍\" class=\"headerlink\" title=\"root后如何愉快玩耍\"></a>root后如何愉快玩耍</h1><h1 id=\"root是什么\"><a href=\"#root是什么\" class=\"headerlink\" title=\"root是什么\"></a>root是什么</h1><p>正如linux有root用户，root用户代表了最高的权限。安卓也有root用户，一般在安卓中简称root权限。只有在获取了root权限后才能开发更多玩法。</p>\n<h2 id=\"magisk面具\"><a href=\"#magisk面具\" class=\"headerlink\" title=\"magisk面具\"></a>magisk面具</h2><p>magisk可以用来做root权限的管理工具，但是却不仅仅是一个root的权限管理工具这么简单。还可以用来安装各种模块工具。是一个很强大的框架</p>\n<h2 id=\"LSPosed框架\"><a href=\"#LSPosed框架\" class=\"headerlink\" title=\"LSPosed框架\"></a>LSPosed框架</h2><p>与 Xposed 相同，<strong>LPSosed 可以在不真实修改任何应用和系统组件的情况下达到修改的目的，从而实现强大的功能。</strong></p>\n<p>例如：去广告，b站解锁区域。</p>\n<h2 id=\"注意仓库源问题\"><a href=\"#注意仓库源问题\" class=\"headerlink\" title=\"注意仓库源问题\"></a>注意仓库源问题</h2><p>这些框架基本都是在github开源的，因此很多时候源也都在github上。国内很容易导致仓库连接不上。</p>\n<h2 id=\"一些组件推荐\"><a href=\"#一些组件推荐\" class=\"headerlink\" title=\"一些组件推荐\"></a>一些组件推荐</h2><div align=\"center\">\n[哔哩哔哩漫游娘](https://www.weibo.com/p/230418139a6f1100102vlj6)\n\n\n\n<p>网易云vip破解</p>\n<p>去广告</p>\n</div>","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"root后如何愉快玩耍\"><a href=\"#root后如何愉快玩耍\" class=\"headerlink\" title=\"root后如何愉快玩耍\"></a>root后如何愉快玩耍</h1><h1 id=\"root是什么\"><a href=\"#root是什么\" class=\"headerlink\" title=\"root是什么\"></a>root是什么</h1><p>正如linux有root用户，root用户代表了最高的权限。安卓也有root用户，一般在安卓中简称root权限。只有在获取了root权限后才能开发更多玩法。</p>\n<h2 id=\"magisk面具\"><a href=\"#magisk面具\" class=\"headerlink\" title=\"magisk面具\"></a>magisk面具</h2><p>magisk可以用来做root权限的管理工具，但是却不仅仅是一个root的权限管理工具这么简单。还可以用来安装各种模块工具。是一个很强大的框架</p>\n<h2 id=\"LSPosed框架\"><a href=\"#LSPosed框架\" class=\"headerlink\" title=\"LSPosed框架\"></a>LSPosed框架</h2><p>与 Xposed 相同，<strong>LPSosed 可以在不真实修改任何应用和系统组件的情况下达到修改的目的，从而实现强大的功能。</strong></p>\n<p>例如：去广告，b站解锁区域。</p>\n<h2 id=\"注意仓库源问题\"><a href=\"#注意仓库源问题\" class=\"headerlink\" title=\"注意仓库源问题\"></a>注意仓库源问题</h2><p>这些框架基本都是在github开源的，因此很多时候源也都在github上。国内很容易导致仓库连接不上。</p>\n<h2 id=\"一些组件推荐\"><a href=\"#一些组件推荐\" class=\"headerlink\" title=\"一些组件推荐\"></a>一些组件推荐</h2><div align=\"center\">\n[哔哩哔哩漫游娘](https://www.weibo.com/p/230418139a6f1100102vlj6)\n\n\n\n<p>网易云vip破解</p>\n<p>去广告</p>\n</div>"},{"_content":"# 关于R6300与小米AX3600刷openwrt教程\n## R6300教程\n**需要用到的资源如下[百度云](https://pan.baidu.com/s/1pmyT5WHlxAezD48TDZvtPw) 提取码：s87z**\n\n![image-20220427141644265](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/ea0039925ec70e144d4792e92c25f6e0.png)\n\n刷机文件：\n\n- R6300V2_back-to-ofw.trx 由梅林刷到原厂的固件\n\n- factory-to-dd-wrt.chk 原厂刷到dd-wrt的跳板固件\n\n- Openwrt-19.07.2。 需要刷入的openwrt固件\n\n- netgear-r6300v2-webflash.bin dd-wrt 当前最新固件（20210211）\n\n\n\n### 刷回原厂固定版本的系统\n\n如果是其他诸如梅林等系统，首先将系统还原为原厂固件系统。\n\n以下是梅林\n\n![1-0bc2d58fee7642019cb30bd7a602e575](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/93edce52263cc3eb349d7568a8c08f05.png)\n\n在梅林**系统管理里面的固件升级**直接使用文件进行刷机：\n**使用固件**![2-1a198385c20a4bec9c37017afa96d234](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/0cb37d5e8eb201e4bbc883a958f315e8.png)\n\n然后进入升级界面\n\n![image-20220427142108994](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/712af7d351e1b50c5fd02b5108c4390d.png)\n\n然后有完成的提示\n\n![4-3a4e3346f13b420fa44f3960022623d9](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/a78c6b3b81399d525fc26aa0fd38f227.png)\n\n\n\n### 原厂刷入dd-wrt\n\n原厂Netgear的默认地址：192.168.1.1 用户名：admin 密码：password\n\n![8-6c0d8a99b5b84078b5aab5dd6e86c2eb](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/ec0b52849f93bd4129bc102c0fd873d9.png)\n\n\n\n**然后原版刷入dd-wrt跳板固件**\n\n这里选择用dd-wrt作为跳板固件，选择factory-to-dd-wrt.chk 刷机成后可以选择继续刷到最新版的dd-wrt或者openwrt。\n\n需要注意的是，如果是**美版6300v2需要选择dd-wrt.K3_R6300V2CH.chk**，美版特殊！文件包内有文件。\n\n![9-24c5e4f975524dd4a3a8dde2289c3001](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/1bfa1601623222f7e86625158bcf9e0a.png)\n\n在上传文件升级会有版本提示，否则就需要从新确认固件是否有问题。\n\n![10-06403273426f4554bc3971db95745025](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/36a9e3eff61b678e889623abcd7f23d3.png)\n\n\n\n刷机成功后，就能进入dd-wrt系统了。ip没变，还是192.168.1.1。登陆进去后，选择刷入openwrt系统\n\n![13-262c666e5c7b49ac8698c936f08e6161](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/91867a8f9b0fc2561447eda0d30b1a78.png)\n\n\n\n选择刷入固件：\n\n我们这里选择刷入openwrt系统\n\n![image-20220427142620127](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/613b9e8eff1b03b8f06f0c2b3d881326.png)\n\n![14-c936b7bf28ab4ccc89a700b20aec4d23](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/bfc2f9933d21d0d8a83546b2745eba4c.png)\n\n### 启动openwrt\n\n这里有点小bug。**在dd-wrt刷入openwrt后，要重启路由器**。否则虽然有网关出现，但是管理界面会链接不上。\n\n\n\n\n\n\n\n## AX3600刷入openwrt\n\n整体上来说，和6300类似。\n\n用到的文件[网盘](https://www.geet.cc/?dir=d/%E5%B0%8F%E7%B1%B3AX3600)\n\n![image-20220427144226797](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/0e1df7673937e9ead59b6d3f7f820c84.png)\n\n### 先刷入特定版本的老原厂固件\n\n![image-20220427143040471](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/43eeaee99fded71701cd18345571a8dc.png)\n\n**这个版本有漏洞可以破解，可以刷入ssh**\n\n![image-20220427143128048](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/787c270109e6b27ce54a690fdd2f07f4.png)\n\n### 然后进入ssh\n\n先拿到token，stok后面这串就是我们的token。\n\n![image-20220427143245513](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/9a70c38bc2502b34488ac0f99f0bd1dd.png)\n\n#### 获取 SSH：\n\n```\nhttp://192.168.31.1/cgi-bin/luci/;stok=（将token放入这里）/api/misystem/set_config_iotdev?bssid=Xiaomi&user_id=longdike&ssid=-h%3B%20nvram%20set%20ssh_en%3D1%3B%20nvram%20commit%3B%20sed%20-i%20's%2Fchannel%3D.*%2Fchannel%3D%5C%22debug%5C%22%2Fg'%20%2Fetc%2Finit.d%2Fdropbear%3B%20%2Fetc%2Finit.d%2Fdropbear%20start%3B\n```\n\n*补全**stok=**后面的数据，*\n\n![image-20220427143427007](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/b0c8b3f267226337926b194714ba3ccd.png)\n\n*然后复制到浏览器打开*，显示`{\"code\":0}`就说明成功了。\n\n![image-20220427143453925](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/9d2de0f04ed48745291a5d918536c0ae.png)\n\n#### 修改默认 SSH 密码为 admin\n\n具体办法同上，也是选择拿到token复制到如下链接并访问。\n\n```\nhttp://192.168.31.1/cgi-bin/luci/;stok=/api/misystem/set_config_iotdev?bssid=Xiaomi&user_id=longdike&ssid=-h%3B%20echo%20-e%20'admin%5Cnadmin'%20%7C%20passwd%20root%3B\n```\n\n*补全**stok=**后面的数据，然后复制到浏览器打开*,显示`{\"code\":0}`就说明成功了。\n\n#### 进入ssh\n这里用putty连上路由器\n\n![image-20220427143659857](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/dc6b43f987c3bebe113a5a6acd2600d1.png)\n\n**密码是admin。**\n\n\n\n然后将如下升级固件用scp传入路由器的/tmp目录下\n\n![image-20220427143830787](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/2a0b5977a0841025cfcfef964f1dbccd.png)\n\n\n\n#### ssh执行以下命令\n\n```\nnvram set flag_last_success=0\nnvram set flag_boot_rootfs=0\nnvram set flag_boot_success=1\nnvram set flag_try_sys1_failed=0\nnvram set flag_try_sys2_failed=0\nnvram set boot_wait=on\nnvram set uart_en=1\nnvram set telnet_en=1\nnvram set ssh_en=1\nnvram commit\n```\n\n然后逐一执行以下命令(注意替换包的名字)\n\n```\nubiformat /dev/mtd12 -y -f /tmp/请替换固件包名.ubi\nnvram set flag_last_success=0\nnvram set flag_boot_rootfs=0\nnvram commit\nreboot\n```\n\n\n\n\n\n重启后进入openwrt\n\n**openwrt默认用户名和密码为（root，password）**\n\n![image-20220427144053505](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/d251269b566a21aba463f41c3b20fa32.png)\n\n\n\n\n\n\n\n## 参考\n\n- [1] [Netgear R6300v2 刷机dd-wrt openwrt\n](https://www.zabbx.cn/archives/netgearr6300v2%E5%88%B7%E6%9C%BAdd-wrtopenwrt)\n- [2] [R6300 V2 路由器刷 OpenWrt 翻车记\n](https://zhuanlan.zhihu.com/p/93230822)\n\n- [3] [小米AX3600不扩容刷机OpenWrt教程](www.ceer.cc/122)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 电子楼网络表\n\n电子楼的ip网关是：202.197.33.254\n\n子网掩码是：255.255.255.0\n\n\n\n\n| 交换机端口号 | 房间号 |使用人  |IP地址  |\n|  ----  | ----  |----  |----  |\n| 1 | 501 |陈志刚 |211 |\n| 2 | 502 |刘佳琦 |212 |\n| 3 | 503 |胡志刚 |213 |\n| 4 | 504 |刘莉平 |214 |\n| 5 | 505 |胡志刚 |62 |\n| 6 | 506 |胡志刚 |216 |\n| 7 | 507 |陈志刚 |217 |\n| 8 | 508 |陈志刚 |218 |\n| 9 | 509 |郁松 |219 |\n| 10 | 510 |赵明 |220 |\n| 11 | 511 |曾峰 |221 |\n| 12 | 512 | | |\n| 13 | 513 |曾峰 |223 |\n| 14 | 514 |邓磊 |224 |\n| 15 | 515 |刘佳琦 |225 |\n| 16 | 516 |费洪晓 |226 |\n| 17 | 517 |杨柳 |227 |\n| 18 | 518 |邝砾 |228 |\n| 19 | 519 |谭长庚 |229 |\n| 20 | 520 |任胜兵 |70 |\n| 21 | 521 |会议室 |224 |\n| 22 |  |        |        |\n| 23 |  | 赵明   | 231    |\n| 24 |  | 陈学工 | 232    |\n| 25 |  | 廖志芳 | 233    |","source":"_posts/综合/实验室网络.md","raw":"# 关于R6300与小米AX3600刷openwrt教程\n## R6300教程\n**需要用到的资源如下[百度云](https://pan.baidu.com/s/1pmyT5WHlxAezD48TDZvtPw) 提取码：s87z**\n\n![image-20220427141644265](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/ea0039925ec70e144d4792e92c25f6e0.png)\n\n刷机文件：\n\n- R6300V2_back-to-ofw.trx 由梅林刷到原厂的固件\n\n- factory-to-dd-wrt.chk 原厂刷到dd-wrt的跳板固件\n\n- Openwrt-19.07.2。 需要刷入的openwrt固件\n\n- netgear-r6300v2-webflash.bin dd-wrt 当前最新固件（20210211）\n\n\n\n### 刷回原厂固定版本的系统\n\n如果是其他诸如梅林等系统，首先将系统还原为原厂固件系统。\n\n以下是梅林\n\n![1-0bc2d58fee7642019cb30bd7a602e575](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/93edce52263cc3eb349d7568a8c08f05.png)\n\n在梅林**系统管理里面的固件升级**直接使用文件进行刷机：\n**使用固件**![2-1a198385c20a4bec9c37017afa96d234](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/0cb37d5e8eb201e4bbc883a958f315e8.png)\n\n然后进入升级界面\n\n![image-20220427142108994](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/712af7d351e1b50c5fd02b5108c4390d.png)\n\n然后有完成的提示\n\n![4-3a4e3346f13b420fa44f3960022623d9](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/a78c6b3b81399d525fc26aa0fd38f227.png)\n\n\n\n### 原厂刷入dd-wrt\n\n原厂Netgear的默认地址：192.168.1.1 用户名：admin 密码：password\n\n![8-6c0d8a99b5b84078b5aab5dd6e86c2eb](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/ec0b52849f93bd4129bc102c0fd873d9.png)\n\n\n\n**然后原版刷入dd-wrt跳板固件**\n\n这里选择用dd-wrt作为跳板固件，选择factory-to-dd-wrt.chk 刷机成后可以选择继续刷到最新版的dd-wrt或者openwrt。\n\n需要注意的是，如果是**美版6300v2需要选择dd-wrt.K3_R6300V2CH.chk**，美版特殊！文件包内有文件。\n\n![9-24c5e4f975524dd4a3a8dde2289c3001](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/1bfa1601623222f7e86625158bcf9e0a.png)\n\n在上传文件升级会有版本提示，否则就需要从新确认固件是否有问题。\n\n![10-06403273426f4554bc3971db95745025](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/36a9e3eff61b678e889623abcd7f23d3.png)\n\n\n\n刷机成功后，就能进入dd-wrt系统了。ip没变，还是192.168.1.1。登陆进去后，选择刷入openwrt系统\n\n![13-262c666e5c7b49ac8698c936f08e6161](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/91867a8f9b0fc2561447eda0d30b1a78.png)\n\n\n\n选择刷入固件：\n\n我们这里选择刷入openwrt系统\n\n![image-20220427142620127](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/613b9e8eff1b03b8f06f0c2b3d881326.png)\n\n![14-c936b7bf28ab4ccc89a700b20aec4d23](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/bfc2f9933d21d0d8a83546b2745eba4c.png)\n\n### 启动openwrt\n\n这里有点小bug。**在dd-wrt刷入openwrt后，要重启路由器**。否则虽然有网关出现，但是管理界面会链接不上。\n\n\n\n\n\n\n\n## AX3600刷入openwrt\n\n整体上来说，和6300类似。\n\n用到的文件[网盘](https://www.geet.cc/?dir=d/%E5%B0%8F%E7%B1%B3AX3600)\n\n![image-20220427144226797](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/0e1df7673937e9ead59b6d3f7f820c84.png)\n\n### 先刷入特定版本的老原厂固件\n\n![image-20220427143040471](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/43eeaee99fded71701cd18345571a8dc.png)\n\n**这个版本有漏洞可以破解，可以刷入ssh**\n\n![image-20220427143128048](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/787c270109e6b27ce54a690fdd2f07f4.png)\n\n### 然后进入ssh\n\n先拿到token，stok后面这串就是我们的token。\n\n![image-20220427143245513](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/9a70c38bc2502b34488ac0f99f0bd1dd.png)\n\n#### 获取 SSH：\n\n```\nhttp://192.168.31.1/cgi-bin/luci/;stok=（将token放入这里）/api/misystem/set_config_iotdev?bssid=Xiaomi&user_id=longdike&ssid=-h%3B%20nvram%20set%20ssh_en%3D1%3B%20nvram%20commit%3B%20sed%20-i%20's%2Fchannel%3D.*%2Fchannel%3D%5C%22debug%5C%22%2Fg'%20%2Fetc%2Finit.d%2Fdropbear%3B%20%2Fetc%2Finit.d%2Fdropbear%20start%3B\n```\n\n*补全**stok=**后面的数据，*\n\n![image-20220427143427007](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/b0c8b3f267226337926b194714ba3ccd.png)\n\n*然后复制到浏览器打开*，显示`{\"code\":0}`就说明成功了。\n\n![image-20220427143453925](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/9d2de0f04ed48745291a5d918536c0ae.png)\n\n#### 修改默认 SSH 密码为 admin\n\n具体办法同上，也是选择拿到token复制到如下链接并访问。\n\n```\nhttp://192.168.31.1/cgi-bin/luci/;stok=/api/misystem/set_config_iotdev?bssid=Xiaomi&user_id=longdike&ssid=-h%3B%20echo%20-e%20'admin%5Cnadmin'%20%7C%20passwd%20root%3B\n```\n\n*补全**stok=**后面的数据，然后复制到浏览器打开*,显示`{\"code\":0}`就说明成功了。\n\n#### 进入ssh\n这里用putty连上路由器\n\n![image-20220427143659857](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/dc6b43f987c3bebe113a5a6acd2600d1.png)\n\n**密码是admin。**\n\n\n\n然后将如下升级固件用scp传入路由器的/tmp目录下\n\n![image-20220427143830787](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/2a0b5977a0841025cfcfef964f1dbccd.png)\n\n\n\n#### ssh执行以下命令\n\n```\nnvram set flag_last_success=0\nnvram set flag_boot_rootfs=0\nnvram set flag_boot_success=1\nnvram set flag_try_sys1_failed=0\nnvram set flag_try_sys2_failed=0\nnvram set boot_wait=on\nnvram set uart_en=1\nnvram set telnet_en=1\nnvram set ssh_en=1\nnvram commit\n```\n\n然后逐一执行以下命令(注意替换包的名字)\n\n```\nubiformat /dev/mtd12 -y -f /tmp/请替换固件包名.ubi\nnvram set flag_last_success=0\nnvram set flag_boot_rootfs=0\nnvram commit\nreboot\n```\n\n\n\n\n\n重启后进入openwrt\n\n**openwrt默认用户名和密码为（root，password）**\n\n![image-20220427144053505](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/d251269b566a21aba463f41c3b20fa32.png)\n\n\n\n\n\n\n\n## 参考\n\n- [1] [Netgear R6300v2 刷机dd-wrt openwrt\n](https://www.zabbx.cn/archives/netgearr6300v2%E5%88%B7%E6%9C%BAdd-wrtopenwrt)\n- [2] [R6300 V2 路由器刷 OpenWrt 翻车记\n](https://zhuanlan.zhihu.com/p/93230822)\n\n- [3] [小米AX3600不扩容刷机OpenWrt教程](www.ceer.cc/122)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 电子楼网络表\n\n电子楼的ip网关是：202.197.33.254\n\n子网掩码是：255.255.255.0\n\n\n\n\n| 交换机端口号 | 房间号 |使用人  |IP地址  |\n|  ----  | ----  |----  |----  |\n| 1 | 501 |陈志刚 |211 |\n| 2 | 502 |刘佳琦 |212 |\n| 3 | 503 |胡志刚 |213 |\n| 4 | 504 |刘莉平 |214 |\n| 5 | 505 |胡志刚 |62 |\n| 6 | 506 |胡志刚 |216 |\n| 7 | 507 |陈志刚 |217 |\n| 8 | 508 |陈志刚 |218 |\n| 9 | 509 |郁松 |219 |\n| 10 | 510 |赵明 |220 |\n| 11 | 511 |曾峰 |221 |\n| 12 | 512 | | |\n| 13 | 513 |曾峰 |223 |\n| 14 | 514 |邓磊 |224 |\n| 15 | 515 |刘佳琦 |225 |\n| 16 | 516 |费洪晓 |226 |\n| 17 | 517 |杨柳 |227 |\n| 18 | 518 |邝砾 |228 |\n| 19 | 519 |谭长庚 |229 |\n| 20 | 520 |任胜兵 |70 |\n| 21 | 521 |会议室 |224 |\n| 22 |  |        |        |\n| 23 |  | 赵明   | 231    |\n| 24 |  | 陈学工 | 232    |\n| 25 |  | 廖志芳 | 233    |","slug":"综合/实验室网络","published":1,"date":"2023-02-27T11:33:23.580Z","updated":"2023-02-27T11:34:33.139Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsycw001u0gcn0npf2qd7","content":"<h1 id=\"关于R6300与小米AX3600刷openwrt教程\"><a href=\"#关于R6300与小米AX3600刷openwrt教程\" class=\"headerlink\" title=\"关于R6300与小米AX3600刷openwrt教程\"></a>关于R6300与小米AX3600刷openwrt教程</h1><h2 id=\"R6300教程\"><a href=\"#R6300教程\" class=\"headerlink\" title=\"R6300教程\"></a>R6300教程</h2><p><strong>需要用到的资源如下<a href=\"https://pan.baidu.com/s/1pmyT5WHlxAezD48TDZvtPw\" target=\"_blank\" rel=\"noopener\">百度云</a> 提取码：s87z</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/ea0039925ec70e144d4792e92c25f6e0.png\" alt=\"image-20220427141644265\"></p>\n<p>刷机文件：</p>\n<ul>\n<li><p>R6300V2_back-to-ofw.trx 由梅林刷到原厂的固件</p>\n</li>\n<li><p>factory-to-dd-wrt.chk 原厂刷到dd-wrt的跳板固件</p>\n</li>\n<li><p>Openwrt-19.07.2。 需要刷入的openwrt固件</p>\n</li>\n<li><p>netgear-r6300v2-webflash.bin dd-wrt 当前最新固件（20210211）</p>\n</li>\n</ul>\n<h3 id=\"刷回原厂固定版本的系统\"><a href=\"#刷回原厂固定版本的系统\" class=\"headerlink\" title=\"刷回原厂固定版本的系统\"></a>刷回原厂固定版本的系统</h3><p>如果是其他诸如梅林等系统，首先将系统还原为原厂固件系统。</p>\n<p>以下是梅林</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/93edce52263cc3eb349d7568a8c08f05.png\" alt=\"1-0bc2d58fee7642019cb30bd7a602e575\"></p>\n<p>在梅林<strong>系统管理里面的固件升级</strong>直接使用文件进行刷机：<br><strong>使用固件</strong><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/0cb37d5e8eb201e4bbc883a958f315e8.png\" alt=\"2-1a198385c20a4bec9c37017afa96d234\"></p>\n<p>然后进入升级界面</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/712af7d351e1b50c5fd02b5108c4390d.png\" alt=\"image-20220427142108994\"></p>\n<p>然后有完成的提示</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/a78c6b3b81399d525fc26aa0fd38f227.png\" alt=\"4-3a4e3346f13b420fa44f3960022623d9\"></p>\n<h3 id=\"原厂刷入dd-wrt\"><a href=\"#原厂刷入dd-wrt\" class=\"headerlink\" title=\"原厂刷入dd-wrt\"></a>原厂刷入dd-wrt</h3><p>原厂Netgear的默认地址：192.168.1.1 用户名：admin 密码：password</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/ec0b52849f93bd4129bc102c0fd873d9.png\" alt=\"8-6c0d8a99b5b84078b5aab5dd6e86c2eb\"></p>\n<p><strong>然后原版刷入dd-wrt跳板固件</strong></p>\n<p>这里选择用dd-wrt作为跳板固件，选择factory-to-dd-wrt.chk 刷机成后可以选择继续刷到最新版的dd-wrt或者openwrt。</p>\n<p>需要注意的是，如果是<strong>美版6300v2需要选择dd-wrt.K3_R6300V2CH.chk</strong>，美版特殊！文件包内有文件。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/1bfa1601623222f7e86625158bcf9e0a.png\" alt=\"9-24c5e4f975524dd4a3a8dde2289c3001\"></p>\n<p>在上传文件升级会有版本提示，否则就需要从新确认固件是否有问题。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/36a9e3eff61b678e889623abcd7f23d3.png\" alt=\"10-06403273426f4554bc3971db95745025\"></p>\n<p>刷机成功后，就能进入dd-wrt系统了。ip没变，还是192.168.1.1。登陆进去后，选择刷入openwrt系统</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/91867a8f9b0fc2561447eda0d30b1a78.png\" alt=\"13-262c666e5c7b49ac8698c936f08e6161\"></p>\n<p>选择刷入固件：</p>\n<p>我们这里选择刷入openwrt系统</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/613b9e8eff1b03b8f06f0c2b3d881326.png\" alt=\"image-20220427142620127\"></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/bfc2f9933d21d0d8a83546b2745eba4c.png\" alt=\"14-c936b7bf28ab4ccc89a700b20aec4d23\"></p>\n<h3 id=\"启动openwrt\"><a href=\"#启动openwrt\" class=\"headerlink\" title=\"启动openwrt\"></a>启动openwrt</h3><p>这里有点小bug。<strong>在dd-wrt刷入openwrt后，要重启路由器</strong>。否则虽然有网关出现，但是管理界面会链接不上。</p>\n<h2 id=\"AX3600刷入openwrt\"><a href=\"#AX3600刷入openwrt\" class=\"headerlink\" title=\"AX3600刷入openwrt\"></a>AX3600刷入openwrt</h2><p>整体上来说，和6300类似。</p>\n<p>用到的文件<a href=\"https://www.geet.cc/?dir=d/%E5%B0%8F%E7%B1%B3AX3600\" target=\"_blank\" rel=\"noopener\">网盘</a></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/0e1df7673937e9ead59b6d3f7f820c84.png\" alt=\"image-20220427144226797\"></p>\n<h3 id=\"先刷入特定版本的老原厂固件\"><a href=\"#先刷入特定版本的老原厂固件\" class=\"headerlink\" title=\"先刷入特定版本的老原厂固件\"></a>先刷入特定版本的老原厂固件</h3><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/43eeaee99fded71701cd18345571a8dc.png\" alt=\"image-20220427143040471\"></p>\n<p><strong>这个版本有漏洞可以破解，可以刷入ssh</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/787c270109e6b27ce54a690fdd2f07f4.png\" alt=\"image-20220427143128048\"></p>\n<h3 id=\"然后进入ssh\"><a href=\"#然后进入ssh\" class=\"headerlink\" title=\"然后进入ssh\"></a>然后进入ssh</h3><p>先拿到token，stok后面这串就是我们的token。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/9a70c38bc2502b34488ac0f99f0bd1dd.png\" alt=\"image-20220427143245513\"></p>\n<h4 id=\"获取-SSH：\"><a href=\"#获取-SSH：\" class=\"headerlink\" title=\"获取 SSH：\"></a>获取 SSH：</h4><pre><code>http://192.168.31.1/cgi-bin/luci/;stok=（将token放入这里）/api/misystem/set_config_iotdev?bssid=Xiaomi&amp;user_id=longdike&amp;ssid=-h%3B%20nvram%20set%20ssh_en%3D1%3B%20nvram%20commit%3B%20sed%20-i%20&#39;s%2Fchannel%3D.*%2Fchannel%3D%5C%22debug%5C%22%2Fg&#39;%20%2Fetc%2Finit.d%2Fdropbear%3B%20%2Fetc%2Finit.d%2Fdropbear%20start%3B</code></pre><p><em>补全<strong>stok=</strong>后面的数据，</em></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/b0c8b3f267226337926b194714ba3ccd.png\" alt=\"image-20220427143427007\"></p>\n<p><em>然后复制到浏览器打开</em>，显示<code>{&quot;code&quot;:0}</code>就说明成功了。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/9d2de0f04ed48745291a5d918536c0ae.png\" alt=\"image-20220427143453925\"></p>\n<h4 id=\"修改默认-SSH-密码为-admin\"><a href=\"#修改默认-SSH-密码为-admin\" class=\"headerlink\" title=\"修改默认 SSH 密码为 admin\"></a>修改默认 SSH 密码为 admin</h4><p>具体办法同上，也是选择拿到token复制到如下链接并访问。</p>\n<pre><code>http://192.168.31.1/cgi-bin/luci/;stok=/api/misystem/set_config_iotdev?bssid=Xiaomi&amp;user_id=longdike&amp;ssid=-h%3B%20echo%20-e%20&#39;admin%5Cnadmin&#39;%20%7C%20passwd%20root%3B</code></pre><p><em>补全<strong>stok=</strong>后面的数据，然后复制到浏览器打开</em>,显示<code>{&quot;code&quot;:0}</code>就说明成功了。</p>\n<h4 id=\"进入ssh\"><a href=\"#进入ssh\" class=\"headerlink\" title=\"进入ssh\"></a>进入ssh</h4><p>这里用putty连上路由器</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/dc6b43f987c3bebe113a5a6acd2600d1.png\" alt=\"image-20220427143659857\"></p>\n<p><strong>密码是admin。</strong></p>\n<p>然后将如下升级固件用scp传入路由器的/tmp目录下</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/2a0b5977a0841025cfcfef964f1dbccd.png\" alt=\"image-20220427143830787\"></p>\n<h4 id=\"ssh执行以下命令\"><a href=\"#ssh执行以下命令\" class=\"headerlink\" title=\"ssh执行以下命令\"></a>ssh执行以下命令</h4><pre><code>nvram set flag_last_success=0\nnvram set flag_boot_rootfs=0\nnvram set flag_boot_success=1\nnvram set flag_try_sys1_failed=0\nnvram set flag_try_sys2_failed=0\nnvram set boot_wait=on\nnvram set uart_en=1\nnvram set telnet_en=1\nnvram set ssh_en=1\nnvram commit</code></pre><p>然后逐一执行以下命令(注意替换包的名字)</p>\n<pre><code>ubiformat /dev/mtd12 -y -f /tmp/请替换固件包名.ubi\nnvram set flag_last_success=0\nnvram set flag_boot_rootfs=0\nnvram commit\nreboot</code></pre><p>重启后进入openwrt</p>\n<p><strong>openwrt默认用户名和密码为（root，password）</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/d251269b566a21aba463f41c3b20fa32.png\" alt=\"image-20220427144053505\"></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><p>[1] <a href=\"https://www.zabbx.cn/archives/netgearr6300v2%E5%88%B7%E6%9C%BAdd-wrtopenwrt\" target=\"_blank\" rel=\"noopener\">Netgear R6300v2 刷机dd-wrt openwrt\n</a></p>\n</li>\n<li><p>[2] <a href=\"https://zhuanlan.zhihu.com/p/93230822\" target=\"_blank\" rel=\"noopener\">R6300 V2 路由器刷 OpenWrt 翻车记\n</a></p>\n</li>\n<li><p>[3] <a href=\"www.ceer.cc/122\">小米AX3600不扩容刷机OpenWrt教程</a></p>\n</li>\n</ul>\n<h2 id=\"电子楼网络表\"><a href=\"#电子楼网络表\" class=\"headerlink\" title=\"电子楼网络表\"></a>电子楼网络表</h2><p>电子楼的ip网关是：202.197.33.254</p>\n<p>子网掩码是：255.255.255.0</p>\n<table>\n<thead>\n<tr>\n<th>交换机端口号</th>\n<th>房间号</th>\n<th>使用人</th>\n<th>IP地址</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>501</td>\n<td>陈志刚</td>\n<td>211</td>\n</tr>\n<tr>\n<td>2</td>\n<td>502</td>\n<td>刘佳琦</td>\n<td>212</td>\n</tr>\n<tr>\n<td>3</td>\n<td>503</td>\n<td>胡志刚</td>\n<td>213</td>\n</tr>\n<tr>\n<td>4</td>\n<td>504</td>\n<td>刘莉平</td>\n<td>214</td>\n</tr>\n<tr>\n<td>5</td>\n<td>505</td>\n<td>胡志刚</td>\n<td>62</td>\n</tr>\n<tr>\n<td>6</td>\n<td>506</td>\n<td>胡志刚</td>\n<td>216</td>\n</tr>\n<tr>\n<td>7</td>\n<td>507</td>\n<td>陈志刚</td>\n<td>217</td>\n</tr>\n<tr>\n<td>8</td>\n<td>508</td>\n<td>陈志刚</td>\n<td>218</td>\n</tr>\n<tr>\n<td>9</td>\n<td>509</td>\n<td>郁松</td>\n<td>219</td>\n</tr>\n<tr>\n<td>10</td>\n<td>510</td>\n<td>赵明</td>\n<td>220</td>\n</tr>\n<tr>\n<td>11</td>\n<td>511</td>\n<td>曾峰</td>\n<td>221</td>\n</tr>\n<tr>\n<td>12</td>\n<td>512</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>13</td>\n<td>513</td>\n<td>曾峰</td>\n<td>223</td>\n</tr>\n<tr>\n<td>14</td>\n<td>514</td>\n<td>邓磊</td>\n<td>224</td>\n</tr>\n<tr>\n<td>15</td>\n<td>515</td>\n<td>刘佳琦</td>\n<td>225</td>\n</tr>\n<tr>\n<td>16</td>\n<td>516</td>\n<td>费洪晓</td>\n<td>226</td>\n</tr>\n<tr>\n<td>17</td>\n<td>517</td>\n<td>杨柳</td>\n<td>227</td>\n</tr>\n<tr>\n<td>18</td>\n<td>518</td>\n<td>邝砾</td>\n<td>228</td>\n</tr>\n<tr>\n<td>19</td>\n<td>519</td>\n<td>谭长庚</td>\n<td>229</td>\n</tr>\n<tr>\n<td>20</td>\n<td>520</td>\n<td>任胜兵</td>\n<td>70</td>\n</tr>\n<tr>\n<td>21</td>\n<td>521</td>\n<td>会议室</td>\n<td>224</td>\n</tr>\n<tr>\n<td>22</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>23</td>\n<td></td>\n<td>赵明</td>\n<td>231</td>\n</tr>\n<tr>\n<td>24</td>\n<td></td>\n<td>陈学工</td>\n<td>232</td>\n</tr>\n<tr>\n<td>25</td>\n<td></td>\n<td>廖志芳</td>\n<td>233</td>\n</tr>\n</tbody></table>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"关于R6300与小米AX3600刷openwrt教程\"><a href=\"#关于R6300与小米AX3600刷openwrt教程\" class=\"headerlink\" title=\"关于R6300与小米AX3600刷openwrt教程\"></a>关于R6300与小米AX3600刷openwrt教程</h1><h2 id=\"R6300教程\"><a href=\"#R6300教程\" class=\"headerlink\" title=\"R6300教程\"></a>R6300教程</h2><p><strong>需要用到的资源如下<a href=\"https://pan.baidu.com/s/1pmyT5WHlxAezD48TDZvtPw\" target=\"_blank\" rel=\"noopener\">百度云</a> 提取码：s87z</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/ea0039925ec70e144d4792e92c25f6e0.png\" alt=\"image-20220427141644265\"></p>\n<p>刷机文件：</p>\n<ul>\n<li><p>R6300V2_back-to-ofw.trx 由梅林刷到原厂的固件</p>\n</li>\n<li><p>factory-to-dd-wrt.chk 原厂刷到dd-wrt的跳板固件</p>\n</li>\n<li><p>Openwrt-19.07.2。 需要刷入的openwrt固件</p>\n</li>\n<li><p>netgear-r6300v2-webflash.bin dd-wrt 当前最新固件（20210211）</p>\n</li>\n</ul>\n<h3 id=\"刷回原厂固定版本的系统\"><a href=\"#刷回原厂固定版本的系统\" class=\"headerlink\" title=\"刷回原厂固定版本的系统\"></a>刷回原厂固定版本的系统</h3><p>如果是其他诸如梅林等系统，首先将系统还原为原厂固件系统。</p>\n<p>以下是梅林</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/93edce52263cc3eb349d7568a8c08f05.png\" alt=\"1-0bc2d58fee7642019cb30bd7a602e575\"></p>\n<p>在梅林<strong>系统管理里面的固件升级</strong>直接使用文件进行刷机：<br><strong>使用固件</strong><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/0cb37d5e8eb201e4bbc883a958f315e8.png\" alt=\"2-1a198385c20a4bec9c37017afa96d234\"></p>\n<p>然后进入升级界面</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/712af7d351e1b50c5fd02b5108c4390d.png\" alt=\"image-20220427142108994\"></p>\n<p>然后有完成的提示</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/a78c6b3b81399d525fc26aa0fd38f227.png\" alt=\"4-3a4e3346f13b420fa44f3960022623d9\"></p>\n<h3 id=\"原厂刷入dd-wrt\"><a href=\"#原厂刷入dd-wrt\" class=\"headerlink\" title=\"原厂刷入dd-wrt\"></a>原厂刷入dd-wrt</h3><p>原厂Netgear的默认地址：192.168.1.1 用户名：admin 密码：password</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/ec0b52849f93bd4129bc102c0fd873d9.png\" alt=\"8-6c0d8a99b5b84078b5aab5dd6e86c2eb\"></p>\n<p><strong>然后原版刷入dd-wrt跳板固件</strong></p>\n<p>这里选择用dd-wrt作为跳板固件，选择factory-to-dd-wrt.chk 刷机成后可以选择继续刷到最新版的dd-wrt或者openwrt。</p>\n<p>需要注意的是，如果是<strong>美版6300v2需要选择dd-wrt.K3_R6300V2CH.chk</strong>，美版特殊！文件包内有文件。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/1bfa1601623222f7e86625158bcf9e0a.png\" alt=\"9-24c5e4f975524dd4a3a8dde2289c3001\"></p>\n<p>在上传文件升级会有版本提示，否则就需要从新确认固件是否有问题。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/36a9e3eff61b678e889623abcd7f23d3.png\" alt=\"10-06403273426f4554bc3971db95745025\"></p>\n<p>刷机成功后，就能进入dd-wrt系统了。ip没变，还是192.168.1.1。登陆进去后，选择刷入openwrt系统</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/91867a8f9b0fc2561447eda0d30b1a78.png\" alt=\"13-262c666e5c7b49ac8698c936f08e6161\"></p>\n<p>选择刷入固件：</p>\n<p>我们这里选择刷入openwrt系统</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/613b9e8eff1b03b8f06f0c2b3d881326.png\" alt=\"image-20220427142620127\"></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/bfc2f9933d21d0d8a83546b2745eba4c.png\" alt=\"14-c936b7bf28ab4ccc89a700b20aec4d23\"></p>\n<h3 id=\"启动openwrt\"><a href=\"#启动openwrt\" class=\"headerlink\" title=\"启动openwrt\"></a>启动openwrt</h3><p>这里有点小bug。<strong>在dd-wrt刷入openwrt后，要重启路由器</strong>。否则虽然有网关出现，但是管理界面会链接不上。</p>\n<h2 id=\"AX3600刷入openwrt\"><a href=\"#AX3600刷入openwrt\" class=\"headerlink\" title=\"AX3600刷入openwrt\"></a>AX3600刷入openwrt</h2><p>整体上来说，和6300类似。</p>\n<p>用到的文件<a href=\"https://www.geet.cc/?dir=d/%E5%B0%8F%E7%B1%B3AX3600\" target=\"_blank\" rel=\"noopener\">网盘</a></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/0e1df7673937e9ead59b6d3f7f820c84.png\" alt=\"image-20220427144226797\"></p>\n<h3 id=\"先刷入特定版本的老原厂固件\"><a href=\"#先刷入特定版本的老原厂固件\" class=\"headerlink\" title=\"先刷入特定版本的老原厂固件\"></a>先刷入特定版本的老原厂固件</h3><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/43eeaee99fded71701cd18345571a8dc.png\" alt=\"image-20220427143040471\"></p>\n<p><strong>这个版本有漏洞可以破解，可以刷入ssh</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/787c270109e6b27ce54a690fdd2f07f4.png\" alt=\"image-20220427143128048\"></p>\n<h3 id=\"然后进入ssh\"><a href=\"#然后进入ssh\" class=\"headerlink\" title=\"然后进入ssh\"></a>然后进入ssh</h3><p>先拿到token，stok后面这串就是我们的token。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/9a70c38bc2502b34488ac0f99f0bd1dd.png\" alt=\"image-20220427143245513\"></p>\n<h4 id=\"获取-SSH：\"><a href=\"#获取-SSH：\" class=\"headerlink\" title=\"获取 SSH：\"></a>获取 SSH：</h4><pre><code>http://192.168.31.1/cgi-bin/luci/;stok=（将token放入这里）/api/misystem/set_config_iotdev?bssid=Xiaomi&amp;user_id=longdike&amp;ssid=-h%3B%20nvram%20set%20ssh_en%3D1%3B%20nvram%20commit%3B%20sed%20-i%20&#39;s%2Fchannel%3D.*%2Fchannel%3D%5C%22debug%5C%22%2Fg&#39;%20%2Fetc%2Finit.d%2Fdropbear%3B%20%2Fetc%2Finit.d%2Fdropbear%20start%3B</code></pre><p><em>补全<strong>stok=</strong>后面的数据，</em></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/b0c8b3f267226337926b194714ba3ccd.png\" alt=\"image-20220427143427007\"></p>\n<p><em>然后复制到浏览器打开</em>，显示<code>{&quot;code&quot;:0}</code>就说明成功了。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/9d2de0f04ed48745291a5d918536c0ae.png\" alt=\"image-20220427143453925\"></p>\n<h4 id=\"修改默认-SSH-密码为-admin\"><a href=\"#修改默认-SSH-密码为-admin\" class=\"headerlink\" title=\"修改默认 SSH 密码为 admin\"></a>修改默认 SSH 密码为 admin</h4><p>具体办法同上，也是选择拿到token复制到如下链接并访问。</p>\n<pre><code>http://192.168.31.1/cgi-bin/luci/;stok=/api/misystem/set_config_iotdev?bssid=Xiaomi&amp;user_id=longdike&amp;ssid=-h%3B%20echo%20-e%20&#39;admin%5Cnadmin&#39;%20%7C%20passwd%20root%3B</code></pre><p><em>补全<strong>stok=</strong>后面的数据，然后复制到浏览器打开</em>,显示<code>{&quot;code&quot;:0}</code>就说明成功了。</p>\n<h4 id=\"进入ssh\"><a href=\"#进入ssh\" class=\"headerlink\" title=\"进入ssh\"></a>进入ssh</h4><p>这里用putty连上路由器</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/dc6b43f987c3bebe113a5a6acd2600d1.png\" alt=\"image-20220427143659857\"></p>\n<p><strong>密码是admin。</strong></p>\n<p>然后将如下升级固件用scp传入路由器的/tmp目录下</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/2a0b5977a0841025cfcfef964f1dbccd.png\" alt=\"image-20220427143830787\"></p>\n<h4 id=\"ssh执行以下命令\"><a href=\"#ssh执行以下命令\" class=\"headerlink\" title=\"ssh执行以下命令\"></a>ssh执行以下命令</h4><pre><code>nvram set flag_last_success=0\nnvram set flag_boot_rootfs=0\nnvram set flag_boot_success=1\nnvram set flag_try_sys1_failed=0\nnvram set flag_try_sys2_failed=0\nnvram set boot_wait=on\nnvram set uart_en=1\nnvram set telnet_en=1\nnvram set ssh_en=1\nnvram commit</code></pre><p>然后逐一执行以下命令(注意替换包的名字)</p>\n<pre><code>ubiformat /dev/mtd12 -y -f /tmp/请替换固件包名.ubi\nnvram set flag_last_success=0\nnvram set flag_boot_rootfs=0\nnvram commit\nreboot</code></pre><p>重启后进入openwrt</p>\n<p><strong>openwrt默认用户名和密码为（root，password）</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/eac86cb5b405690647db62f9da52eb90/d251269b566a21aba463f41c3b20fa32.png\" alt=\"image-20220427144053505\"></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><p>[1] <a href=\"https://www.zabbx.cn/archives/netgearr6300v2%E5%88%B7%E6%9C%BAdd-wrtopenwrt\" target=\"_blank\" rel=\"noopener\">Netgear R6300v2 刷机dd-wrt openwrt\n</a></p>\n</li>\n<li><p>[2] <a href=\"https://zhuanlan.zhihu.com/p/93230822\" target=\"_blank\" rel=\"noopener\">R6300 V2 路由器刷 OpenWrt 翻车记\n</a></p>\n</li>\n<li><p>[3] <a href=\"www.ceer.cc/122\">小米AX3600不扩容刷机OpenWrt教程</a></p>\n</li>\n</ul>\n<h2 id=\"电子楼网络表\"><a href=\"#电子楼网络表\" class=\"headerlink\" title=\"电子楼网络表\"></a>电子楼网络表</h2><p>电子楼的ip网关是：202.197.33.254</p>\n<p>子网掩码是：255.255.255.0</p>\n<table>\n<thead>\n<tr>\n<th>交换机端口号</th>\n<th>房间号</th>\n<th>使用人</th>\n<th>IP地址</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>501</td>\n<td>陈志刚</td>\n<td>211</td>\n</tr>\n<tr>\n<td>2</td>\n<td>502</td>\n<td>刘佳琦</td>\n<td>212</td>\n</tr>\n<tr>\n<td>3</td>\n<td>503</td>\n<td>胡志刚</td>\n<td>213</td>\n</tr>\n<tr>\n<td>4</td>\n<td>504</td>\n<td>刘莉平</td>\n<td>214</td>\n</tr>\n<tr>\n<td>5</td>\n<td>505</td>\n<td>胡志刚</td>\n<td>62</td>\n</tr>\n<tr>\n<td>6</td>\n<td>506</td>\n<td>胡志刚</td>\n<td>216</td>\n</tr>\n<tr>\n<td>7</td>\n<td>507</td>\n<td>陈志刚</td>\n<td>217</td>\n</tr>\n<tr>\n<td>8</td>\n<td>508</td>\n<td>陈志刚</td>\n<td>218</td>\n</tr>\n<tr>\n<td>9</td>\n<td>509</td>\n<td>郁松</td>\n<td>219</td>\n</tr>\n<tr>\n<td>10</td>\n<td>510</td>\n<td>赵明</td>\n<td>220</td>\n</tr>\n<tr>\n<td>11</td>\n<td>511</td>\n<td>曾峰</td>\n<td>221</td>\n</tr>\n<tr>\n<td>12</td>\n<td>512</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>13</td>\n<td>513</td>\n<td>曾峰</td>\n<td>223</td>\n</tr>\n<tr>\n<td>14</td>\n<td>514</td>\n<td>邓磊</td>\n<td>224</td>\n</tr>\n<tr>\n<td>15</td>\n<td>515</td>\n<td>刘佳琦</td>\n<td>225</td>\n</tr>\n<tr>\n<td>16</td>\n<td>516</td>\n<td>费洪晓</td>\n<td>226</td>\n</tr>\n<tr>\n<td>17</td>\n<td>517</td>\n<td>杨柳</td>\n<td>227</td>\n</tr>\n<tr>\n<td>18</td>\n<td>518</td>\n<td>邝砾</td>\n<td>228</td>\n</tr>\n<tr>\n<td>19</td>\n<td>519</td>\n<td>谭长庚</td>\n<td>229</td>\n</tr>\n<tr>\n<td>20</td>\n<td>520</td>\n<td>任胜兵</td>\n<td>70</td>\n</tr>\n<tr>\n<td>21</td>\n<td>521</td>\n<td>会议室</td>\n<td>224</td>\n</tr>\n<tr>\n<td>22</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>23</td>\n<td></td>\n<td>赵明</td>\n<td>231</td>\n</tr>\n<tr>\n<td>24</td>\n<td></td>\n<td>陈学工</td>\n<td>232</td>\n</tr>\n<tr>\n<td>25</td>\n<td></td>\n<td>廖志芳</td>\n<td>233</td>\n</tr>\n</tbody></table>\n"},{"_content":"# 傅里叶级数\n## 公式原型\n![在这里插入图片描述](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/6059b08d8855b8450233e45c78893109/9971d39839d8afd301b1e30957d1284f.png)\n![在这里插入图片描述](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/6059b08d8855b8450233e45c78893109/fd68bb7bffd1c019c338f3a16f02b2f3.png)\n![在这里插入图片描述](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/6059b08d8855b8450233e45c78893109/31a233c086ba8c7c68651f37da1a40b2.png)\n![在这里插入图片描述](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/6059b08d8855b8450233e45c78893109/e63675d4dba817f387a77354cf4d6b4b.png)\n\n## 代码\n\n```sql\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport math\n\n# x, y 的参数方程，用来计算在某个时间进度下，x和y的坐标\ndef fx(t):\n    x = 2 * np.cos(t) - np.cos(2*t)\n    return x\ndef fy(t):\n    y = 2* np.sin(t) - np.sin(2*t)\n    return y\n\n\ndef ft(t):\n    x = fx(t)\n    y = fy(t)\n    return x + 1j * y\n\n\nt= np.linspace(0, 2 * math.pi, 100)\n\nx = fx(t)\n\ny = fy(t)\n\n# 查看原始数据\nplt.title('the origin data')\nplt.plot(x, y, c = 'blue')\n# plt.show()\n\n\n# 微分计算的步长\ndx = 0.001\n\n# 计算定积分, dx是微分程度， left， right是上下界\ndef calF(f, dx, left, right):\n    Sum = 0\n\n\n    # 选值进行计算的点\n    xNum = np.linspace(left, right, int((right-left) /dx)  )\n\n    for i in xNum:\n        now = f(i) * dx\n        Sum += now\n    return Sum\n\n\ntmpf = lambda x: x**2\n\nans = calF(tmpf, dx, 0, 1)\nprint(ans)\n\n\nT = 2 * math.pi\nwo = 2 * math.pi / T\n\n# 这里用得是欧拉公式化简后的 e 的指数形式\nc = []\n\n\n# 这里的范围就相当于是圈数\nfor i in range(-30, 30):\n    print(i)\n    tmpf = lambda x: ft(x)* np.exp(-1j * i * wo * x)  # 隐函数表达式\n\n    nowc = calF(tmpf, dx, 0, T) / T  # 定积分计算， 因为具有着正交的性质\n    c.append([i, nowc])\n\n\nprint(c)\n\n\n# 计算傅里叶级数的函数\ndef FinallFunc(t):\n    Sum = 0\n    for n, nowc in c:\n        tmp = nowc * np.exp(1j * n * wo * t)\n        Sum += tmp\n\n    return Sum\n\n\n\n# 进行测试， 看是否计算出来了傅里叶级数\ntx = []\nty = []\nfor i in t:\n    num = FinallFunc(i)\n    tx0 = num.real\n    ty0 = num.imag\n\n    tx.append(tx0)\n    ty.append(ty0)\nplt.title('the Fourier data')\nplt.scatter(tx, ty, c= 'black')\nplt.show()\n\n\n```\n结果，拟合效果很好\n![在这里插入图片描述](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/6059b08d8855b8450233e45c78893109/7106658772c3884cbe019980ffef90a7.png)\n## 数据变成离散的点,将这些点变成一个近似函数\n\n那么需要对数据先分段拟合成一个个小段的函数，可以直接用直线。\n\n这里参考某位大佬的做法[大佬](https://pw.yuelili.com/study/cg/proof-1000-circle-miku.html)，使用贝塞尔曲线进行拟合，不过要注意函数。\n\n我这里就不用贝塞尔了，直接用直线替代。\n\n每一段，分必计算c（-n） 到  cn。然后相加起来，注意每一断时间。\n\n写好加载数据变成函数的代码后。\n\n然后与前面的拟合代码结合。\n\n结果： 当接近500个圈的时候就效果很不错了。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/6059b08d8855b8450233e45c78893109/4db543f7188b6ce627f1215d95bedfb1.png)\n底层工程在[github](https://github.com/2892211452/leeCode/tree/master/%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E/%E5%82%85%E9%87%8C%E5%8F%B6)\n\n\n","source":"_posts/综合/傅里叶级数 画初音 附底层代码.md","raw":"# 傅里叶级数\n## 公式原型\n![在这里插入图片描述](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/6059b08d8855b8450233e45c78893109/9971d39839d8afd301b1e30957d1284f.png)\n![在这里插入图片描述](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/6059b08d8855b8450233e45c78893109/fd68bb7bffd1c019c338f3a16f02b2f3.png)\n![在这里插入图片描述](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/6059b08d8855b8450233e45c78893109/31a233c086ba8c7c68651f37da1a40b2.png)\n![在这里插入图片描述](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/6059b08d8855b8450233e45c78893109/e63675d4dba817f387a77354cf4d6b4b.png)\n\n## 代码\n\n```sql\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport math\n\n# x, y 的参数方程，用来计算在某个时间进度下，x和y的坐标\ndef fx(t):\n    x = 2 * np.cos(t) - np.cos(2*t)\n    return x\ndef fy(t):\n    y = 2* np.sin(t) - np.sin(2*t)\n    return y\n\n\ndef ft(t):\n    x = fx(t)\n    y = fy(t)\n    return x + 1j * y\n\n\nt= np.linspace(0, 2 * math.pi, 100)\n\nx = fx(t)\n\ny = fy(t)\n\n# 查看原始数据\nplt.title('the origin data')\nplt.plot(x, y, c = 'blue')\n# plt.show()\n\n\n# 微分计算的步长\ndx = 0.001\n\n# 计算定积分, dx是微分程度， left， right是上下界\ndef calF(f, dx, left, right):\n    Sum = 0\n\n\n    # 选值进行计算的点\n    xNum = np.linspace(left, right, int((right-left) /dx)  )\n\n    for i in xNum:\n        now = f(i) * dx\n        Sum += now\n    return Sum\n\n\ntmpf = lambda x: x**2\n\nans = calF(tmpf, dx, 0, 1)\nprint(ans)\n\n\nT = 2 * math.pi\nwo = 2 * math.pi / T\n\n# 这里用得是欧拉公式化简后的 e 的指数形式\nc = []\n\n\n# 这里的范围就相当于是圈数\nfor i in range(-30, 30):\n    print(i)\n    tmpf = lambda x: ft(x)* np.exp(-1j * i * wo * x)  # 隐函数表达式\n\n    nowc = calF(tmpf, dx, 0, T) / T  # 定积分计算， 因为具有着正交的性质\n    c.append([i, nowc])\n\n\nprint(c)\n\n\n# 计算傅里叶级数的函数\ndef FinallFunc(t):\n    Sum = 0\n    for n, nowc in c:\n        tmp = nowc * np.exp(1j * n * wo * t)\n        Sum += tmp\n\n    return Sum\n\n\n\n# 进行测试， 看是否计算出来了傅里叶级数\ntx = []\nty = []\nfor i in t:\n    num = FinallFunc(i)\n    tx0 = num.real\n    ty0 = num.imag\n\n    tx.append(tx0)\n    ty.append(ty0)\nplt.title('the Fourier data')\nplt.scatter(tx, ty, c= 'black')\nplt.show()\n\n\n```\n结果，拟合效果很好\n![在这里插入图片描述](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/6059b08d8855b8450233e45c78893109/7106658772c3884cbe019980ffef90a7.png)\n## 数据变成离散的点,将这些点变成一个近似函数\n\n那么需要对数据先分段拟合成一个个小段的函数，可以直接用直线。\n\n这里参考某位大佬的做法[大佬](https://pw.yuelili.com/study/cg/proof-1000-circle-miku.html)，使用贝塞尔曲线进行拟合，不过要注意函数。\n\n我这里就不用贝塞尔了，直接用直线替代。\n\n每一段，分必计算c（-n） 到  cn。然后相加起来，注意每一断时间。\n\n写好加载数据变成函数的代码后。\n\n然后与前面的拟合代码结合。\n\n结果： 当接近500个圈的时候就效果很不错了。\n\n![在这里插入图片描述](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/6059b08d8855b8450233e45c78893109/4db543f7188b6ce627f1215d95bedfb1.png)\n底层工程在[github](https://github.com/2892211452/leeCode/tree/master/%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E/%E5%82%85%E9%87%8C%E5%8F%B6)\n\n\n","slug":"综合/傅里叶级数 画初音 附底层代码","published":1,"date":"2023-02-27T11:33:23.577Z","updated":"2023-02-27T11:34:33.137Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsycw001v0gcnbiwrohsd","content":"<h1 id=\"傅里叶级数\"><a href=\"#傅里叶级数\" class=\"headerlink\" title=\"傅里叶级数\"></a>傅里叶级数</h1><h2 id=\"公式原型\"><a href=\"#公式原型\" class=\"headerlink\" title=\"公式原型\"></a>公式原型</h2><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/6059b08d8855b8450233e45c78893109/9971d39839d8afd301b1e30957d1284f.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/6059b08d8855b8450233e45c78893109/fd68bb7bffd1c019c338f3a16f02b2f3.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/6059b08d8855b8450233e45c78893109/31a233c086ba8c7c68651f37da1a40b2.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/6059b08d8855b8450233e45c78893109/e63675d4dba817f387a77354cf4d6b4b.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre class=\"line-numbers language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">import</span> numpy <span class=\"token keyword\">as</span> np\n<span class=\"token keyword\">import</span> matplotlib<span class=\"token punctuation\">.</span>pyplot <span class=\"token keyword\">as</span> plt\n<span class=\"token keyword\">import</span> math\n\n<span class=\"token comment\" spellcheck=\"true\"># x, y 的参数方程，用来计算在某个时间进度下，x和y的坐标</span>\n<span class=\"token number\">def</span> fx<span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span>:\n    x <span class=\"token operator\">=</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> np<span class=\"token punctuation\">.</span>cos<span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> np<span class=\"token punctuation\">.</span>cos<span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token operator\">*</span>t<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> x\n<span class=\"token number\">def</span> fy<span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span>:\n    y <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token operator\">*</span> np<span class=\"token punctuation\">.</span>sin<span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> np<span class=\"token punctuation\">.</span>sin<span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token operator\">*</span>t<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> y\n\n\n<span class=\"token number\">def</span> ft<span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span>:\n    x <span class=\"token operator\">=</span> fx<span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span>\n    y <span class=\"token operator\">=</span> fy<span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> x <span class=\"token operator\">+</span> 1j <span class=\"token operator\">*</span> y\n\n\nt<span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>linspace<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> math<span class=\"token punctuation\">.</span>pi<span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span>\n\nx <span class=\"token operator\">=</span> fx<span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span>\n\ny <span class=\"token operator\">=</span> fy<span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 查看原始数据</span>\nplt<span class=\"token punctuation\">.</span>title<span class=\"token punctuation\">(</span><span class=\"token string\">'the origin data'</span><span class=\"token punctuation\">)</span>\nplt<span class=\"token punctuation\">.</span>plot<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">,</span> <span class=\"token number\">c</span> <span class=\"token operator\">=</span> <span class=\"token string\">'blue'</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\"># plt.show()</span>\n\n\n<span class=\"token comment\" spellcheck=\"true\"># 微分计算的步长</span>\ndx <span class=\"token operator\">=</span> <span class=\"token number\">0.001</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 计算定积分, dx是微分程度， left， right是上下界</span>\n<span class=\"token number\">def</span> calF<span class=\"token punctuation\">(</span><span class=\"token number\">f</span><span class=\"token punctuation\">,</span> dx<span class=\"token punctuation\">,</span> <span class=\"token keyword\">left</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">right</span><span class=\"token punctuation\">)</span>:\n    Sum <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n\n\n    <span class=\"token comment\" spellcheck=\"true\"># 选值进行计算的点</span>\n    xNum <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>linspace<span class=\"token punctuation\">(</span><span class=\"token keyword\">left</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">right</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">right</span><span class=\"token operator\">-</span><span class=\"token keyword\">left</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span>dx<span class=\"token punctuation\">)</span>  <span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">for</span> i <span class=\"token operator\">in</span> xNum:\n        now <span class=\"token operator\">=</span> <span class=\"token number\">f</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> dx\n        Sum <span class=\"token operator\">+</span><span class=\"token operator\">=</span> now\n    <span class=\"token keyword\">return</span> Sum\n\n\ntmpf <span class=\"token operator\">=</span> lambda x: x<span class=\"token operator\">*</span><span class=\"token operator\">*</span><span class=\"token number\">2</span>\n\nans <span class=\"token operator\">=</span> calF<span class=\"token punctuation\">(</span>tmpf<span class=\"token punctuation\">,</span> dx<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>ans<span class=\"token punctuation\">)</span>\n\n\nT <span class=\"token operator\">=</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> math<span class=\"token punctuation\">.</span>pi\nwo <span class=\"token operator\">=</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> math<span class=\"token punctuation\">.</span>pi <span class=\"token operator\">/</span> T\n\n<span class=\"token comment\" spellcheck=\"true\"># 这里用得是欧拉公式化简后的 e 的指数形式</span>\n<span class=\"token number\">c</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n\n<span class=\"token comment\" spellcheck=\"true\"># 这里的范围就相当于是圈数</span>\n<span class=\"token keyword\">for</span> i <span class=\"token operator\">in</span> range<span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">30</span><span class=\"token punctuation\">,</span> <span class=\"token number\">30</span><span class=\"token punctuation\">)</span>:\n    <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    tmpf <span class=\"token operator\">=</span> lambda x: ft<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token operator\">*</span> np<span class=\"token punctuation\">.</span>exp<span class=\"token punctuation\">(</span><span class=\"token operator\">-</span>1j <span class=\"token operator\">*</span> i <span class=\"token operator\">*</span> wo <span class=\"token operator\">*</span> x<span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\"># 隐函数表达式</span>\n\n    nowc <span class=\"token operator\">=</span> calF<span class=\"token punctuation\">(</span>tmpf<span class=\"token punctuation\">,</span> dx<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> T<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> T  <span class=\"token comment\" spellcheck=\"true\"># 定积分计算， 因为具有着正交的性质</span>\n    <span class=\"token number\">c</span><span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">,</span> nowc<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token number\">c</span><span class=\"token punctuation\">)</span>\n\n\n<span class=\"token comment\" spellcheck=\"true\"># 计算傅里叶级数的函数</span>\n<span class=\"token number\">def</span> FinallFunc<span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span>:\n    Sum <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n    <span class=\"token keyword\">for</span> n<span class=\"token punctuation\">,</span> nowc <span class=\"token operator\">in</span> <span class=\"token number\">c</span>:\n        tmp <span class=\"token operator\">=</span> nowc <span class=\"token operator\">*</span> np<span class=\"token punctuation\">.</span>exp<span class=\"token punctuation\">(</span>1j <span class=\"token operator\">*</span> n <span class=\"token operator\">*</span> wo <span class=\"token operator\">*</span> t<span class=\"token punctuation\">)</span>\n        Sum <span class=\"token operator\">+</span><span class=\"token operator\">=</span> tmp\n\n    <span class=\"token keyword\">return</span> Sum\n\n\n\n<span class=\"token comment\" spellcheck=\"true\"># 进行测试， 看是否计算出来了傅里叶级数</span>\ntx <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\nty <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">for</span> i <span class=\"token operator\">in</span> t:\n    num <span class=\"token operator\">=</span> FinallFunc<span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    tx0 <span class=\"token operator\">=</span> num<span class=\"token punctuation\">.</span><span class=\"token keyword\">real</span>\n    ty0 <span class=\"token operator\">=</span> num<span class=\"token punctuation\">.</span>imag\n\n    tx<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>tx0<span class=\"token punctuation\">)</span>\n    ty<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>ty0<span class=\"token punctuation\">)</span>\nplt<span class=\"token punctuation\">.</span>title<span class=\"token punctuation\">(</span><span class=\"token string\">'the Fourier data'</span><span class=\"token punctuation\">)</span>\nplt<span class=\"token punctuation\">.</span>scatter<span class=\"token punctuation\">(</span>tx<span class=\"token punctuation\">,</span> ty<span class=\"token punctuation\">,</span> <span class=\"token number\">c</span><span class=\"token operator\">=</span> <span class=\"token string\">'black'</span><span class=\"token punctuation\">)</span>\nplt<span class=\"token punctuation\">.</span><span class=\"token keyword\">show</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>结果，拟合效果很好<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/6059b08d8855b8450233e45c78893109/7106658772c3884cbe019980ffef90a7.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"数据变成离散的点-将这些点变成一个近似函数\"><a href=\"#数据变成离散的点-将这些点变成一个近似函数\" class=\"headerlink\" title=\"数据变成离散的点,将这些点变成一个近似函数\"></a>数据变成离散的点,将这些点变成一个近似函数</h2><p>那么需要对数据先分段拟合成一个个小段的函数，可以直接用直线。</p>\n<p>这里参考某位大佬的做法<a href=\"https://pw.yuelili.com/study/cg/proof-1000-circle-miku.html\" target=\"_blank\" rel=\"noopener\">大佬</a>，使用贝塞尔曲线进行拟合，不过要注意函数。</p>\n<p>我这里就不用贝塞尔了，直接用直线替代。</p>\n<p>每一段，分必计算c（-n） 到  cn。然后相加起来，注意每一断时间。</p>\n<p>写好加载数据变成函数的代码后。</p>\n<p>然后与前面的拟合代码结合。</p>\n<p>结果： 当接近500个圈的时候就效果很不错了。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/6059b08d8855b8450233e45c78893109/4db543f7188b6ce627f1215d95bedfb1.png\" alt=\"在这里插入图片描述\"><br>底层工程在<a href=\"https://github.com/2892211452/leeCode/tree/master/%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E/%E5%82%85%E9%87%8C%E5%8F%B6\" target=\"_blank\" rel=\"noopener\">github</a></p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"傅里叶级数\"><a href=\"#傅里叶级数\" class=\"headerlink\" title=\"傅里叶级数\"></a>傅里叶级数</h1><h2 id=\"公式原型\"><a href=\"#公式原型\" class=\"headerlink\" title=\"公式原型\"></a>公式原型</h2><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/6059b08d8855b8450233e45c78893109/9971d39839d8afd301b1e30957d1284f.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/6059b08d8855b8450233e45c78893109/fd68bb7bffd1c019c338f3a16f02b2f3.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/6059b08d8855b8450233e45c78893109/31a233c086ba8c7c68651f37da1a40b2.png\" alt=\"在这里插入图片描述\"><br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/6059b08d8855b8450233e45c78893109/e63675d4dba817f387a77354cf4d6b4b.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><pre><code class=\"sql\">import numpy as np\nimport matplotlib.pyplot as plt\nimport math\n\n# x, y 的参数方程，用来计算在某个时间进度下，x和y的坐标\ndef fx(t):\n    x = 2 * np.cos(t) - np.cos(2*t)\n    return x\ndef fy(t):\n    y = 2* np.sin(t) - np.sin(2*t)\n    return y\n\n\ndef ft(t):\n    x = fx(t)\n    y = fy(t)\n    return x + 1j * y\n\n\nt= np.linspace(0, 2 * math.pi, 100)\n\nx = fx(t)\n\ny = fy(t)\n\n# 查看原始数据\nplt.title(&#39;the origin data&#39;)\nplt.plot(x, y, c = &#39;blue&#39;)\n# plt.show()\n\n\n# 微分计算的步长\ndx = 0.001\n\n# 计算定积分, dx是微分程度， left， right是上下界\ndef calF(f, dx, left, right):\n    Sum = 0\n\n\n    # 选值进行计算的点\n    xNum = np.linspace(left, right, int((right-left) /dx)  )\n\n    for i in xNum:\n        now = f(i) * dx\n        Sum += now\n    return Sum\n\n\ntmpf = lambda x: x**2\n\nans = calF(tmpf, dx, 0, 1)\nprint(ans)\n\n\nT = 2 * math.pi\nwo = 2 * math.pi / T\n\n# 这里用得是欧拉公式化简后的 e 的指数形式\nc = []\n\n\n# 这里的范围就相当于是圈数\nfor i in range(-30, 30):\n    print(i)\n    tmpf = lambda x: ft(x)* np.exp(-1j * i * wo * x)  # 隐函数表达式\n\n    nowc = calF(tmpf, dx, 0, T) / T  # 定积分计算， 因为具有着正交的性质\n    c.append([i, nowc])\n\n\nprint(c)\n\n\n# 计算傅里叶级数的函数\ndef FinallFunc(t):\n    Sum = 0\n    for n, nowc in c:\n        tmp = nowc * np.exp(1j * n * wo * t)\n        Sum += tmp\n\n    return Sum\n\n\n\n# 进行测试， 看是否计算出来了傅里叶级数\ntx = []\nty = []\nfor i in t:\n    num = FinallFunc(i)\n    tx0 = num.real\n    ty0 = num.imag\n\n    tx.append(tx0)\n    ty.append(ty0)\nplt.title(&#39;the Fourier data&#39;)\nplt.scatter(tx, ty, c= &#39;black&#39;)\nplt.show()\n\n</code></pre>\n<p>结果，拟合效果很好<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/6059b08d8855b8450233e45c78893109/7106658772c3884cbe019980ffef90a7.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"数据变成离散的点-将这些点变成一个近似函数\"><a href=\"#数据变成离散的点-将这些点变成一个近似函数\" class=\"headerlink\" title=\"数据变成离散的点,将这些点变成一个近似函数\"></a>数据变成离散的点,将这些点变成一个近似函数</h2><p>那么需要对数据先分段拟合成一个个小段的函数，可以直接用直线。</p>\n<p>这里参考某位大佬的做法<a href=\"https://pw.yuelili.com/study/cg/proof-1000-circle-miku.html\" target=\"_blank\" rel=\"noopener\">大佬</a>，使用贝塞尔曲线进行拟合，不过要注意函数。</p>\n<p>我这里就不用贝塞尔了，直接用直线替代。</p>\n<p>每一段，分必计算c（-n） 到  cn。然后相加起来，注意每一断时间。</p>\n<p>写好加载数据变成函数的代码后。</p>\n<p>然后与前面的拟合代码结合。</p>\n<p>结果： 当接近500个圈的时候就效果很不错了。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/6059b08d8855b8450233e45c78893109/4db543f7188b6ce627f1215d95bedfb1.png\" alt=\"在这里插入图片描述\"><br>底层工程在<a href=\"https://github.com/2892211452/leeCode/tree/master/%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E/%E5%82%85%E9%87%8C%E5%8F%B6\" target=\"_blank\" rel=\"noopener\">github</a></p>\n"},{"_content":"# 老版本的selenium更新后有些方法用不了\n\n对于python来说，在4.2的selenium后就不能使用以下办法。\n\n```\nfind_element_by_id\nfind_element_by_name\nfind_element_by_xpath\nfind_element_by_link_text\nfind_element_by_partial_link_text\nfind_element_by_tag_name\nfind_element_by_class_name\nfind_element_by_css_selector\n```\n\n**但是有做好一个封装，**\n\n\n\n# 新用法\n\n```\nfrom selenium.webdriver.common.by import By\n\ndriver.find_element(By.XPATH, '//button[text()=\"Some text\"]')\ndriver.find_elements(By.XPATH, '//button')\n```\n\n下面是 By 类的一些可用属性:\n\n```\nID = \"id\"\nXPATH = \"xpath\"\nLINK_TEXT = \"link text\"\nPARTIAL_LINK_TEXT = \"partial link text\"\nNAME = \"name\"\nTAG_NAME = \"tag name\"\nCLASS_NAME = \"class name\"\nCSS_SELECTOR = \"css selector\"\n```\n\n整体使用逻辑没有变，记录一下。","source":"_posts/综合/selenium新版本后如何定位元素.md","raw":"# 老版本的selenium更新后有些方法用不了\n\n对于python来说，在4.2的selenium后就不能使用以下办法。\n\n```\nfind_element_by_id\nfind_element_by_name\nfind_element_by_xpath\nfind_element_by_link_text\nfind_element_by_partial_link_text\nfind_element_by_tag_name\nfind_element_by_class_name\nfind_element_by_css_selector\n```\n\n**但是有做好一个封装，**\n\n\n\n# 新用法\n\n```\nfrom selenium.webdriver.common.by import By\n\ndriver.find_element(By.XPATH, '//button[text()=\"Some text\"]')\ndriver.find_elements(By.XPATH, '//button')\n```\n\n下面是 By 类的一些可用属性:\n\n```\nID = \"id\"\nXPATH = \"xpath\"\nLINK_TEXT = \"link text\"\nPARTIAL_LINK_TEXT = \"partial link text\"\nNAME = \"name\"\nTAG_NAME = \"tag name\"\nCLASS_NAME = \"class name\"\nCSS_SELECTOR = \"css selector\"\n```\n\n整体使用逻辑没有变，记录一下。","slug":"综合/selenium新版本后如何定位元素","published":1,"date":"2023-02-26T15:28:35.063Z","updated":"2023-02-27T11:34:33.141Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsycy001w0gcni2fs67cz","content":"<h1 id=\"老版本的selenium更新后有些方法用不了\"><a href=\"#老版本的selenium更新后有些方法用不了\" class=\"headerlink\" title=\"老版本的selenium更新后有些方法用不了\"></a>老版本的selenium更新后有些方法用不了</h1><p>对于python来说，在4.2的selenium后就不能使用以下办法。</p>\n<pre><code>find_element_by_id\nfind_element_by_name\nfind_element_by_xpath\nfind_element_by_link_text\nfind_element_by_partial_link_text\nfind_element_by_tag_name\nfind_element_by_class_name\nfind_element_by_css_selector</code></pre><p><strong>但是有做好一个封装，</strong></p>\n<h1 id=\"新用法\"><a href=\"#新用法\" class=\"headerlink\" title=\"新用法\"></a>新用法</h1><pre><code>from selenium.webdriver.common.by import By\n\ndriver.find_element(By.XPATH, &#39;//button[text()=&quot;Some text&quot;]&#39;)\ndriver.find_elements(By.XPATH, &#39;//button&#39;)</code></pre><p>下面是 By 类的一些可用属性:</p>\n<pre><code>ID = &quot;id&quot;\nXPATH = &quot;xpath&quot;\nLINK_TEXT = &quot;link text&quot;\nPARTIAL_LINK_TEXT = &quot;partial link text&quot;\nNAME = &quot;name&quot;\nTAG_NAME = &quot;tag name&quot;\nCLASS_NAME = &quot;class name&quot;\nCSS_SELECTOR = &quot;css selector&quot;</code></pre><p>整体使用逻辑没有变，记录一下。</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"老版本的selenium更新后有些方法用不了\"><a href=\"#老版本的selenium更新后有些方法用不了\" class=\"headerlink\" title=\"老版本的selenium更新后有些方法用不了\"></a>老版本的selenium更新后有些方法用不了</h1><p>对于python来说，在4.2的selenium后就不能使用以下办法。</p>\n<pre><code>find_element_by_id\nfind_element_by_name\nfind_element_by_xpath\nfind_element_by_link_text\nfind_element_by_partial_link_text\nfind_element_by_tag_name\nfind_element_by_class_name\nfind_element_by_css_selector</code></pre><p><strong>但是有做好一个封装，</strong></p>\n<h1 id=\"新用法\"><a href=\"#新用法\" class=\"headerlink\" title=\"新用法\"></a>新用法</h1><pre><code>from selenium.webdriver.common.by import By\n\ndriver.find_element(By.XPATH, &#39;//button[text()=&quot;Some text&quot;]&#39;)\ndriver.find_elements(By.XPATH, &#39;//button&#39;)</code></pre><p>下面是 By 类的一些可用属性:</p>\n<pre><code>ID = &quot;id&quot;\nXPATH = &quot;xpath&quot;\nLINK_TEXT = &quot;link text&quot;\nPARTIAL_LINK_TEXT = &quot;partial link text&quot;\nNAME = &quot;name&quot;\nTAG_NAME = &quot;tag name&quot;\nCLASS_NAME = &quot;class name&quot;\nCSS_SELECTOR = &quot;css selector&quot;</code></pre><p>整体使用逻辑没有变，记录一下。</p>\n"},{"_content":"# 为什么需要vscode\n\n以python为例，相较于其他的编辑器（如Pycharm），vscode占用跟小的内存。打开更加迅速。vscode本身就是一个编辑器，但是由于继承了很多第三方插件。所以能够高效的进行代码开发。此外，vscode基本能够教高效的进行所有种类的代码开发。\n\n缺点：代码自动补全效率不够高，比不过Pycharm等intelJ系列。\n\n\n\n# 插件\n\n我个人常用插件如下。\n\n![image-20230130164706188](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/5e3a7dea6422dfb6e1a0f6a1406b2905/50024b62346fc315ccb602737e3645ab.png)\n\n\n\n## remote ssh插件\n\n配置如下，我这里使用的是秘钥登录，可以避免每次输入密码。\n\n![image-20230130164811532](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/5e3a7dea6422dfb6e1a0f6a1406b2905/9f950dc01a8dc355638199782ace7aa8.png)\n\n相较于ssh链接的优点，有缓存机制，能够高效的进行文件编写。\n\n\n\n\n\n## python环境\n\n如何让每个不同文件夹不同的环境。\n\n搜索栏，输入**select interpret**\n\n![image-20230130165153810](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/5e3a7dea6422dfb6e1a0f6a1406b2905/54d99fc5fb493a0921ce5644145f4eb4.png)\n\n选择需要的解释器\n\n![image-20230130165247326](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/5e3a7dea6422dfb6e1a0f6a1406b2905/844992e2632ff98c2953a0e9ce8a856d.png)\n\n\n\n","source":"_posts/综合/vscode使用入门与配置.md","raw":"# 为什么需要vscode\n\n以python为例，相较于其他的编辑器（如Pycharm），vscode占用跟小的内存。打开更加迅速。vscode本身就是一个编辑器，但是由于继承了很多第三方插件。所以能够高效的进行代码开发。此外，vscode基本能够教高效的进行所有种类的代码开发。\n\n缺点：代码自动补全效率不够高，比不过Pycharm等intelJ系列。\n\n\n\n# 插件\n\n我个人常用插件如下。\n\n![image-20230130164706188](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/5e3a7dea6422dfb6e1a0f6a1406b2905/50024b62346fc315ccb602737e3645ab.png)\n\n\n\n## remote ssh插件\n\n配置如下，我这里使用的是秘钥登录，可以避免每次输入密码。\n\n![image-20230130164811532](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/5e3a7dea6422dfb6e1a0f6a1406b2905/9f950dc01a8dc355638199782ace7aa8.png)\n\n相较于ssh链接的优点，有缓存机制，能够高效的进行文件编写。\n\n\n\n\n\n## python环境\n\n如何让每个不同文件夹不同的环境。\n\n搜索栏，输入**select interpret**\n\n![image-20230130165153810](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/5e3a7dea6422dfb6e1a0f6a1406b2905/54d99fc5fb493a0921ce5644145f4eb4.png)\n\n选择需要的解释器\n\n![image-20230130165247326](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/5e3a7dea6422dfb6e1a0f6a1406b2905/844992e2632ff98c2953a0e9ce8a856d.png)\n\n\n\n","slug":"综合/vscode使用入门与配置","published":1,"date":"2023-02-26T15:28:35.064Z","updated":"2023-02-27T11:34:33.136Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsyd0001x0gcno3k4bo96","content":"<h1 id=\"为什么需要vscode\"><a href=\"#为什么需要vscode\" class=\"headerlink\" title=\"为什么需要vscode\"></a>为什么需要vscode</h1><p>以python为例，相较于其他的编辑器（如Pycharm），vscode占用跟小的内存。打开更加迅速。vscode本身就是一个编辑器，但是由于继承了很多第三方插件。所以能够高效的进行代码开发。此外，vscode基本能够教高效的进行所有种类的代码开发。</p>\n<p>缺点：代码自动补全效率不够高，比不过Pycharm等intelJ系列。</p>\n<h1 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h1><p>我个人常用插件如下。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/5e3a7dea6422dfb6e1a0f6a1406b2905/50024b62346fc315ccb602737e3645ab.png\" alt=\"image-20230130164706188\"></p>\n<h2 id=\"remote-ssh插件\"><a href=\"#remote-ssh插件\" class=\"headerlink\" title=\"remote ssh插件\"></a>remote ssh插件</h2><p>配置如下，我这里使用的是秘钥登录，可以避免每次输入密码。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/5e3a7dea6422dfb6e1a0f6a1406b2905/9f950dc01a8dc355638199782ace7aa8.png\" alt=\"image-20230130164811532\"></p>\n<p>相较于ssh链接的优点，有缓存机制，能够高效的进行文件编写。</p>\n<h2 id=\"python环境\"><a href=\"#python环境\" class=\"headerlink\" title=\"python环境\"></a>python环境</h2><p>如何让每个不同文件夹不同的环境。</p>\n<p>搜索栏，输入<strong>select interpret</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/5e3a7dea6422dfb6e1a0f6a1406b2905/54d99fc5fb493a0921ce5644145f4eb4.png\" alt=\"image-20230130165153810\"></p>\n<p>选择需要的解释器</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/5e3a7dea6422dfb6e1a0f6a1406b2905/844992e2632ff98c2953a0e9ce8a856d.png\" alt=\"image-20230130165247326\"></p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"为什么需要vscode\"><a href=\"#为什么需要vscode\" class=\"headerlink\" title=\"为什么需要vscode\"></a>为什么需要vscode</h1><p>以python为例，相较于其他的编辑器（如Pycharm），vscode占用跟小的内存。打开更加迅速。vscode本身就是一个编辑器，但是由于继承了很多第三方插件。所以能够高效的进行代码开发。此外，vscode基本能够教高效的进行所有种类的代码开发。</p>\n<p>缺点：代码自动补全效率不够高，比不过Pycharm等intelJ系列。</p>\n<h1 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h1><p>我个人常用插件如下。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/5e3a7dea6422dfb6e1a0f6a1406b2905/50024b62346fc315ccb602737e3645ab.png\" alt=\"image-20230130164706188\"></p>\n<h2 id=\"remote-ssh插件\"><a href=\"#remote-ssh插件\" class=\"headerlink\" title=\"remote ssh插件\"></a>remote ssh插件</h2><p>配置如下，我这里使用的是秘钥登录，可以避免每次输入密码。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/5e3a7dea6422dfb6e1a0f6a1406b2905/9f950dc01a8dc355638199782ace7aa8.png\" alt=\"image-20230130164811532\"></p>\n<p>相较于ssh链接的优点，有缓存机制，能够高效的进行文件编写。</p>\n<h2 id=\"python环境\"><a href=\"#python环境\" class=\"headerlink\" title=\"python环境\"></a>python环境</h2><p>如何让每个不同文件夹不同的环境。</p>\n<p>搜索栏，输入<strong>select interpret</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/5e3a7dea6422dfb6e1a0f6a1406b2905/54d99fc5fb493a0921ce5644145f4eb4.png\" alt=\"image-20230130165153810\"></p>\n<p>选择需要的解释器</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/5e3a7dea6422dfb6e1a0f6a1406b2905/844992e2632ff98c2953a0e9ce8a856d.png\" alt=\"image-20230130165247326\"></p>\n"},{"_content":"# 欧拉公式推导及其python代码\n\n## 公式\n ![在这里插入图片描述](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/852f37b337f8a8d3dc1d4b345a5df96c/23159a3cf7a5c15d37dd2d2e18407318.png)\n\n我们把n的取值从0到1用程序模拟看看，x取从【0，2PI】。\n\n## 代码结果\n当n是51\n![在这里插入图片描述](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/852f37b337f8a8d3dc1d4b345a5df96c/d81dd6f39e893f018c38f52ed32111dc.png)\n当n是751\n![在这里插入图片描述](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/852f37b337f8a8d3dc1d4b345a5df96c/11f771ee5e20c2ce20e6d50f2df20088.png)\n当n是4801\n![在这里插入图片描述](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/852f37b337f8a8d3dc1d4b345a5df96c/41f25ec5ede28def5d25787b48399eaa.png)\n不难看出，n越大，就越趋近于圆。\n\n当n趋近于无穷大的时候。在复平面上，是趋近于极坐标的。\n可以用泰勒展开验证。\n直接证明可以参考[博客](https://zhuanlan.zhihu.com/p/48392958)","source":"_posts/综合/欧拉公式.md","raw":"# 欧拉公式推导及其python代码\n\n## 公式\n ![在这里插入图片描述](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/852f37b337f8a8d3dc1d4b345a5df96c/23159a3cf7a5c15d37dd2d2e18407318.png)\n\n我们把n的取值从0到1用程序模拟看看，x取从【0，2PI】。\n\n## 代码结果\n当n是51\n![在这里插入图片描述](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/852f37b337f8a8d3dc1d4b345a5df96c/d81dd6f39e893f018c38f52ed32111dc.png)\n当n是751\n![在这里插入图片描述](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/852f37b337f8a8d3dc1d4b345a5df96c/11f771ee5e20c2ce20e6d50f2df20088.png)\n当n是4801\n![在这里插入图片描述](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/852f37b337f8a8d3dc1d4b345a5df96c/41f25ec5ede28def5d25787b48399eaa.png)\n不难看出，n越大，就越趋近于圆。\n\n当n趋近于无穷大的时候。在复平面上，是趋近于极坐标的。\n可以用泰勒展开验证。\n直接证明可以参考[博客](https://zhuanlan.zhihu.com/p/48392958)","slug":"综合/欧拉公式","published":1,"date":"2023-02-27T11:33:23.580Z","updated":"2023-02-27T11:34:33.139Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsyd1001y0gcnmxq1v99a","content":"<h1 id=\"欧拉公式推导及其python代码\"><a href=\"#欧拉公式推导及其python代码\" class=\"headerlink\" title=\"欧拉公式推导及其python代码\"></a>欧拉公式推导及其python代码</h1><h2 id=\"公式\"><a href=\"#公式\" class=\"headerlink\" title=\"公式\"></a>公式</h2><p> <img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/852f37b337f8a8d3dc1d4b345a5df96c/23159a3cf7a5c15d37dd2d2e18407318.png\" alt=\"在这里插入图片描述\"></p>\n<p>我们把n的取值从0到1用程序模拟看看，x取从【0，2PI】。</p>\n<h2 id=\"代码结果\"><a href=\"#代码结果\" class=\"headerlink\" title=\"代码结果\"></a>代码结果</h2><p>当n是51<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/852f37b337f8a8d3dc1d4b345a5df96c/d81dd6f39e893f018c38f52ed32111dc.png\" alt=\"在这里插入图片描述\"><br>当n是751<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/852f37b337f8a8d3dc1d4b345a5df96c/11f771ee5e20c2ce20e6d50f2df20088.png\" alt=\"在这里插入图片描述\"><br>当n是4801<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/852f37b337f8a8d3dc1d4b345a5df96c/41f25ec5ede28def5d25787b48399eaa.png\" alt=\"在这里插入图片描述\"><br>不难看出，n越大，就越趋近于圆。</p>\n<p>当n趋近于无穷大的时候。在复平面上，是趋近于极坐标的。<br>可以用泰勒展开验证。<br>直接证明可以参考<a href=\"https://zhuanlan.zhihu.com/p/48392958\" target=\"_blank\" rel=\"noopener\">博客</a></p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"欧拉公式推导及其python代码\"><a href=\"#欧拉公式推导及其python代码\" class=\"headerlink\" title=\"欧拉公式推导及其python代码\"></a>欧拉公式推导及其python代码</h1><h2 id=\"公式\"><a href=\"#公式\" class=\"headerlink\" title=\"公式\"></a>公式</h2><p> <img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/852f37b337f8a8d3dc1d4b345a5df96c/23159a3cf7a5c15d37dd2d2e18407318.png\" alt=\"在这里插入图片描述\"></p>\n<p>我们把n的取值从0到1用程序模拟看看，x取从【0，2PI】。</p>\n<h2 id=\"代码结果\"><a href=\"#代码结果\" class=\"headerlink\" title=\"代码结果\"></a>代码结果</h2><p>当n是51<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/852f37b337f8a8d3dc1d4b345a5df96c/d81dd6f39e893f018c38f52ed32111dc.png\" alt=\"在这里插入图片描述\"><br>当n是751<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/852f37b337f8a8d3dc1d4b345a5df96c/11f771ee5e20c2ce20e6d50f2df20088.png\" alt=\"在这里插入图片描述\"><br>当n是4801<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/852f37b337f8a8d3dc1d4b345a5df96c/41f25ec5ede28def5d25787b48399eaa.png\" alt=\"在这里插入图片描述\"><br>不难看出，n越大，就越趋近于圆。</p>\n<p>当n趋近于无穷大的时候。在复平面上，是趋近于极坐标的。<br>可以用泰勒展开验证。<br>直接证明可以参考<a href=\"https://zhuanlan.zhihu.com/p/48392958\" target=\"_blank\" rel=\"noopener\">博客</a></p>\n"},{"_content":"# Python 数据库池子\n\n## 引言\n假设网站一天有很大的访问量，数据库服务器就需要为每次连接创建一次数据库连接，极大的浪费数据库的资源，并且极易造成数据库服务器内存溢出、拓机。\n数据库连接是一种关键的有限的昂贵的资源,这一点在多用户的网页应用程序中体现的尤为突出.对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性,影响到程序的性能指标.数据库连接池正式针对这个问题提出来的.数据库连接池负责分配,管理和释放数据库连接,它允许应用程序重复使用一个现有的数据库连接,而不是重新建立一个。\n\n### 相关关键属性\n1, 最小连接数:是连接池**一直保持的数据库连接**,所以如果应用程序对数据库连接的使用量不大,将会有大量的数据库连接资源被浪费.\n2, 最大连接数:是连接池**能申请的最大连接数**,如果数据库连接请求超过次数,后面的数据库连接请求将被加入到等待队列中,这会影响以后的数据库操作\n3, 如果最小连接数与最大连接数相差很大:那么最先连接请求将会获利,之后超过最小连接数量的连接请求等价于建立一个新的数据库连接.不过,这些大于最小连接数的数据库连接在使用完不会马上被释放,他将被放到连接池中等待重复使用或是空间超时后被释放.\n\n### 相关要求\n- DB连接池必须要确保某一时间内一个 conn 只能分配给一个线程。不同 conn 的事务是相互独立的。 \n- 连接池的分配与释放\n- 配置与维护\n  如何确保连接池中的最小连接数呢？有**动态和静态**两种策略。动态即每隔一定时间就对连接池进行检测，如果发现连接数量小于最小连接数，则补充相应数量的新连接,以保证连接池的正常运转。静态是发现空闲连接不够时再去检查。\n\n\n\n## redis 数据池与断开重连\n官方有\n\n\n## rabbitmq连接池\n这个可能得自己写\n\n\n## 参考\n[https://www.cnblogs.com/-wenli/p/13578837.html](https://www.cnblogs.com/-wenli/p/13578837.html)","source":"_posts/综合/数据库池子Python.md","raw":"# Python 数据库池子\n\n## 引言\n假设网站一天有很大的访问量，数据库服务器就需要为每次连接创建一次数据库连接，极大的浪费数据库的资源，并且极易造成数据库服务器内存溢出、拓机。\n数据库连接是一种关键的有限的昂贵的资源,这一点在多用户的网页应用程序中体现的尤为突出.对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性,影响到程序的性能指标.数据库连接池正式针对这个问题提出来的.数据库连接池负责分配,管理和释放数据库连接,它允许应用程序重复使用一个现有的数据库连接,而不是重新建立一个。\n\n### 相关关键属性\n1, 最小连接数:是连接池**一直保持的数据库连接**,所以如果应用程序对数据库连接的使用量不大,将会有大量的数据库连接资源被浪费.\n2, 最大连接数:是连接池**能申请的最大连接数**,如果数据库连接请求超过次数,后面的数据库连接请求将被加入到等待队列中,这会影响以后的数据库操作\n3, 如果最小连接数与最大连接数相差很大:那么最先连接请求将会获利,之后超过最小连接数量的连接请求等价于建立一个新的数据库连接.不过,这些大于最小连接数的数据库连接在使用完不会马上被释放,他将被放到连接池中等待重复使用或是空间超时后被释放.\n\n### 相关要求\n- DB连接池必须要确保某一时间内一个 conn 只能分配给一个线程。不同 conn 的事务是相互独立的。 \n- 连接池的分配与释放\n- 配置与维护\n  如何确保连接池中的最小连接数呢？有**动态和静态**两种策略。动态即每隔一定时间就对连接池进行检测，如果发现连接数量小于最小连接数，则补充相应数量的新连接,以保证连接池的正常运转。静态是发现空闲连接不够时再去检查。\n\n\n\n## redis 数据池与断开重连\n官方有\n\n\n## rabbitmq连接池\n这个可能得自己写\n\n\n## 参考\n[https://www.cnblogs.com/-wenli/p/13578837.html](https://www.cnblogs.com/-wenli/p/13578837.html)","slug":"综合/数据库池子Python","published":1,"date":"2023-02-27T11:33:23.580Z","updated":"2023-02-27T11:34:33.139Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsyd1001z0gcnzwatkabi","content":"<h1 id=\"Python-数据库池子\"><a href=\"#Python-数据库池子\" class=\"headerlink\" title=\"Python 数据库池子\"></a>Python 数据库池子</h1><h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>假设网站一天有很大的访问量，数据库服务器就需要为每次连接创建一次数据库连接，极大的浪费数据库的资源，并且极易造成数据库服务器内存溢出、拓机。<br>数据库连接是一种关键的有限的昂贵的资源,这一点在多用户的网页应用程序中体现的尤为突出.对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性,影响到程序的性能指标.数据库连接池正式针对这个问题提出来的.数据库连接池负责分配,管理和释放数据库连接,它允许应用程序重复使用一个现有的数据库连接,而不是重新建立一个。</p>\n<h3 id=\"相关关键属性\"><a href=\"#相关关键属性\" class=\"headerlink\" title=\"相关关键属性\"></a>相关关键属性</h3><p>1, 最小连接数:是连接池<strong>一直保持的数据库连接</strong>,所以如果应用程序对数据库连接的使用量不大,将会有大量的数据库连接资源被浪费.<br>2, 最大连接数:是连接池<strong>能申请的最大连接数</strong>,如果数据库连接请求超过次数,后面的数据库连接请求将被加入到等待队列中,这会影响以后的数据库操作<br>3, 如果最小连接数与最大连接数相差很大:那么最先连接请求将会获利,之后超过最小连接数量的连接请求等价于建立一个新的数据库连接.不过,这些大于最小连接数的数据库连接在使用完不会马上被释放,他将被放到连接池中等待重复使用或是空间超时后被释放.</p>\n<h3 id=\"相关要求\"><a href=\"#相关要求\" class=\"headerlink\" title=\"相关要求\"></a>相关要求</h3><ul>\n<li>DB连接池必须要确保某一时间内一个 conn 只能分配给一个线程。不同 conn 的事务是相互独立的。 </li>\n<li>连接池的分配与释放</li>\n<li>配置与维护<br>如何确保连接池中的最小连接数呢？有<strong>动态和静态</strong>两种策略。动态即每隔一定时间就对连接池进行检测，如果发现连接数量小于最小连接数，则补充相应数量的新连接,以保证连接池的正常运转。静态是发现空闲连接不够时再去检查。</li>\n</ul>\n<h2 id=\"redis-数据池与断开重连\"><a href=\"#redis-数据池与断开重连\" class=\"headerlink\" title=\"redis 数据池与断开重连\"></a>redis 数据池与断开重连</h2><p>官方有</p>\n<h2 id=\"rabbitmq连接池\"><a href=\"#rabbitmq连接池\" class=\"headerlink\" title=\"rabbitmq连接池\"></a>rabbitmq连接池</h2><p>这个可能得自己写</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.cnblogs.com/-wenli/p/13578837.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/-wenli/p/13578837.html</a></p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"Python-数据库池子\"><a href=\"#Python-数据库池子\" class=\"headerlink\" title=\"Python 数据库池子\"></a>Python 数据库池子</h1><h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>假设网站一天有很大的访问量，数据库服务器就需要为每次连接创建一次数据库连接，极大的浪费数据库的资源，并且极易造成数据库服务器内存溢出、拓机。<br>数据库连接是一种关键的有限的昂贵的资源,这一点在多用户的网页应用程序中体现的尤为突出.对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性,影响到程序的性能指标.数据库连接池正式针对这个问题提出来的.数据库连接池负责分配,管理和释放数据库连接,它允许应用程序重复使用一个现有的数据库连接,而不是重新建立一个。</p>\n<h3 id=\"相关关键属性\"><a href=\"#相关关键属性\" class=\"headerlink\" title=\"相关关键属性\"></a>相关关键属性</h3><p>1, 最小连接数:是连接池<strong>一直保持的数据库连接</strong>,所以如果应用程序对数据库连接的使用量不大,将会有大量的数据库连接资源被浪费.<br>2, 最大连接数:是连接池<strong>能申请的最大连接数</strong>,如果数据库连接请求超过次数,后面的数据库连接请求将被加入到等待队列中,这会影响以后的数据库操作<br>3, 如果最小连接数与最大连接数相差很大:那么最先连接请求将会获利,之后超过最小连接数量的连接请求等价于建立一个新的数据库连接.不过,这些大于最小连接数的数据库连接在使用完不会马上被释放,他将被放到连接池中等待重复使用或是空间超时后被释放.</p>\n<h3 id=\"相关要求\"><a href=\"#相关要求\" class=\"headerlink\" title=\"相关要求\"></a>相关要求</h3><ul>\n<li>DB连接池必须要确保某一时间内一个 conn 只能分配给一个线程。不同 conn 的事务是相互独立的。 </li>\n<li>连接池的分配与释放</li>\n<li>配置与维护<br>如何确保连接池中的最小连接数呢？有<strong>动态和静态</strong>两种策略。动态即每隔一定时间就对连接池进行检测，如果发现连接数量小于最小连接数，则补充相应数量的新连接,以保证连接池的正常运转。静态是发现空闲连接不够时再去检查。</li>\n</ul>\n<h2 id=\"redis-数据池与断开重连\"><a href=\"#redis-数据池与断开重连\" class=\"headerlink\" title=\"redis 数据池与断开重连\"></a>redis 数据池与断开重连</h2><p>官方有</p>\n<h2 id=\"rabbitmq连接池\"><a href=\"#rabbitmq连接池\" class=\"headerlink\" title=\"rabbitmq连接池\"></a>rabbitmq连接池</h2><p>这个可能得自己写</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.cnblogs.com/-wenli/p/13578837.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/-wenli/p/13578837.html</a></p>\n"},{"title":"爬虫","date":"2020-01-15T01:38:17.000Z","draft":false,"_content":"\n# 爬虫\n\n##### 定义\n```\n网络爬虫（又称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。\n```\n**个人理解就是，从互联网上获取数据，进行自动化，规范化，也就是说，取代人去做繁重的数据采集。再者使用selenium等，可以模拟浏览器，写交互性的自动化脚本，本质都是解放人力**\n## 本质\n```文本\n本质上，爬虫就是获取网页，然后解析网页，最后得到开发者想要的数据。\n这么说是不够正确的，或者说，只是爬虫常用的一部分，是对爬虫的一种浅显的理解，实际上，我感觉爬虫就像是模拟浏览器，但是却通过个人的分析，选择需要加载的去加载，获取想要获取的。\n```\n\n## 关键点\n主要就是两个部分，一个就是定位数据（定位节点），另外一个就是从节点获取数据，或者模拟操作。关于对节点的定位，一种就是普通的通过特殊属性值等来筛选，另外一种就是通过父子节点，兄弟等关系进行推到，因为前端设计的时侯一般是分为几个部分去做的，而且渲染也是在特定的地方进行渲染，所以父子节点的关系，能够良好的对列表进行分析。\n\n## 工具\n我个人是常用**python**写爬虫的类型，因为它有很多强大的库，而且性能也很不错。例如使用requests库，非常简单，方便，且强大。然后想要批量，高效率的进行爬虫，可以使用**Scrapy**\n去进行项目式的开发，个人感觉是没有明确的界限，当你需要什么就用什么，不要局限于框架。\n其次，**java**上的开发就没有那么方便，可能是因为我对java爬虫知之甚少吧。（常用jousp以及正则去进行html解析）\n\n## 关于pythonn爬虫\n通过**requests**等库去获取网页，然后解析网页。\n```解析的常用方法通过两类\n1,是通过id，class，以及其他属性去进行锁定标签。然后提取数据。\n2,是通过正则表达式去进行字符串匹配\n个人感觉第一种简单，方便。但是第二种同样不可获缺，是必须要进行学习的东西，否则爬虫在某些情况可能回降低写程序的思路。\n```\n**Scrapy**爬虫框架\n```\n这个框架的最大优势就是非常的高效率，适用于对于一个网站的各个阶级的页面的爬虫。这些页面之间通常能够形成链式的关系。或者同层的关系\nScrapy多线程并发，效率极高。\n```\n\n## 关于反爬虫\n对于部分网站是可以直接解析进行爬虫的，但是并不是全部，有些网站针对这种情况进行了防范\n- 常见的防范办法是判断**header**请求头,**IP**,以及一些根据反映速度等等鬼才点子进行反爬虫。\n```\n所以要写一个好爬虫，就需要伪造，学会伪装自己，写好请求头，IP，以及控制反应速度等等。具体代码，可以自行百度\n```\n\n## 关于Selenium\n这可以说是一个终极武器，\n简单的来说，就是真正的去打开一个模拟器，然后加载网页，获取网页数据，\n\n```\n有好处也有坏处\n好处是可以获取到更加全面的资源，跳过繁重的api接口分析。直接获取加载的数据。\n坏处是不加以选择的加载数据，效率极低。\n```\n综上，虽然有缺点，但是还是挺有用的，至少能够进行方便的浏览器点击，输入等模拟操作，在进行操作自动化的时侯用处很大。\n\n\n\n\n\n**实现方法是次要的，重要的是思维方式，上层决定下层的运作**\n\n## Seleniumd 的使用技巧\n这里强推chrome加上selenium，效率杠杠的\n\n首先解释一下，python是一门**解释性语言**\n```\n解释性语言定义：\n\n程序不需要编译，在运行程序的时候才翻译，每个语句都是执行的时候才翻译。这样解释性语言每执行一次就需要逐行翻译一次，效率比较低。\n\n现代解释性语言通常把源程序编译成中间代码，然后用解释器把中间代码一条条翻译成目标机器代码，一条条执行。\n```\n\n因为selenium的创建时十分耗时的，所以这并不方便于我们开发调试，比如点击某个按键等等。\n综上，我们使用console进行开发测试：\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/223e76bc8cf036a7acf3291dcc98752e/b5c4b80561a0ffb5a9f5dc0b539a5c11.png)\n这样，可以比如先定位到某个元素，然后边解释，边执行，和**juypter**很像\n\n同时，结合chrome去进行元素的定位\n**比如通过css_selector**\n```\ncontent = browser.find_element_by_css_selector('#app > div > div.home-page.f-clear > div.home-container > div > div.center-panel > div.card-list > div.feed-card > div.content > div:nth-child(2) > div.main-content > div.card-content > div.post-content > div > div.text.p-rel.description > div')\n\n```\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/223e76bc8cf036a7acf3291dcc98752e/1b5659791b4fb92ac31680e9dc9a3bd7.png)\n**或者xpath（也就是dom树**\n```\nbrowser.find_element_by_xpath()\n```\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/223e76bc8cf036a7acf3291dcc98752e/f48e4af38e3c0a7b4e16f965266adfe7.png)\n\n\n\n\n## 爬虫的工具使用，chrome\n最好用的工具之一，就像开发前端一样，可以通过这个查看获取了哪些资源，明白页面节点间的关系。狠方便。\n\n`使用搜索功能搜索数据`\n有写网站的数据不是直接静态的写载html中的，现在很多都是动态的用ajax等技术从后端获取，然后利用js渲染好节点数据。 所以怎样知道自己想要的数据在哪个端口呢。\n\n- 在html中查看数据节点的命名方式。（通常会保持一致）\n- 利用搜索工具搜索出想要信息，排查。\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/223e76bc8cf036a7acf3291dcc98752e/cbedae4df4dcc92b8165f58fb1ea0046.png)\n\n\n## 关于数据定位\n对于某些网站，他们的数据往往没有那么直观就能再html或者某个json接口中就直接找到，可能他们的数据格式不一样。经过了一定处理，比如四舍五入，或者统计计算（比如我碰到的东方财富网站）。这时候我们就需要对网站进行分析了。要了解其内部js是如何运算数据的，以及最后得出结果。\n这里讲一个简单的，对dom树进行监控。这里检测dom树节点什么时候发生变化。\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/223e76bc8cf036a7acf3291dcc98752e/b55ffae2b070b559822bd87e1b421a23.png)\n通过这样再元素那对节点进行监控，当节点改变时，就会debug：暂停\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/223e76bc8cf036a7acf3291dcc98752e/49614456be82c270ccfc1305f171e8ad.png)\n这样就定位到了js如何变化\n\n还有直接对js进行断点的，但是没有这个好用。\n\n## 分布式，多线程等技术\n\n  使用这些批量的爬虫技术，主要是为了提高效率，因为时间很重要，要在规定时间内将数据又快又好的爬取出来。\n- 我主要使用python里面的多线程，协程进行爬取，具体做法\n[协程博客](https://hackmd.io/28Kc3q_nR9as7UTbF0Y7Kw)\n- 注意爬取的速度， 太快反而会导致错误\n- 使用伪装\n\n常用框架：**scrapy**\n\n\n## 反爬虫\n这也很重要，对于爬虫是不可或缺的。\n\n\n\n## 分级层爬取，\n尽量将数据存储到本地，哪怕其中部分不是我最终需要的数据，只要是中间过程的一步，在不影响整体速度的前提下，尽量将中间数据也存储到本地。\n\n本地数据的读取速度是很快的，重要的是，减少目标服务器的压力。\n\n## 确保数据整体的正确性\n很多时候，我们并不能一次性就把握住某个接口的全部特性，那么我们需要尽量的多做测试，在拥有足够多的数据样本的情况下，去进行判断。\n\n明白样本和整体的意义。","source":"_posts/综合/爬虫.md","raw":"---\ntitle: \"爬虫\"\ndate: 2020-01-15T17:38:17+08:00\ndraft: false\n---\n\n# 爬虫\n\n##### 定义\n```\n网络爬虫（又称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。\n```\n**个人理解就是，从互联网上获取数据，进行自动化，规范化，也就是说，取代人去做繁重的数据采集。再者使用selenium等，可以模拟浏览器，写交互性的自动化脚本，本质都是解放人力**\n## 本质\n```文本\n本质上，爬虫就是获取网页，然后解析网页，最后得到开发者想要的数据。\n这么说是不够正确的，或者说，只是爬虫常用的一部分，是对爬虫的一种浅显的理解，实际上，我感觉爬虫就像是模拟浏览器，但是却通过个人的分析，选择需要加载的去加载，获取想要获取的。\n```\n\n## 关键点\n主要就是两个部分，一个就是定位数据（定位节点），另外一个就是从节点获取数据，或者模拟操作。关于对节点的定位，一种就是普通的通过特殊属性值等来筛选，另外一种就是通过父子节点，兄弟等关系进行推到，因为前端设计的时侯一般是分为几个部分去做的，而且渲染也是在特定的地方进行渲染，所以父子节点的关系，能够良好的对列表进行分析。\n\n## 工具\n我个人是常用**python**写爬虫的类型，因为它有很多强大的库，而且性能也很不错。例如使用requests库，非常简单，方便，且强大。然后想要批量，高效率的进行爬虫，可以使用**Scrapy**\n去进行项目式的开发，个人感觉是没有明确的界限，当你需要什么就用什么，不要局限于框架。\n其次，**java**上的开发就没有那么方便，可能是因为我对java爬虫知之甚少吧。（常用jousp以及正则去进行html解析）\n\n## 关于pythonn爬虫\n通过**requests**等库去获取网页，然后解析网页。\n```解析的常用方法通过两类\n1,是通过id，class，以及其他属性去进行锁定标签。然后提取数据。\n2,是通过正则表达式去进行字符串匹配\n个人感觉第一种简单，方便。但是第二种同样不可获缺，是必须要进行学习的东西，否则爬虫在某些情况可能回降低写程序的思路。\n```\n**Scrapy**爬虫框架\n```\n这个框架的最大优势就是非常的高效率，适用于对于一个网站的各个阶级的页面的爬虫。这些页面之间通常能够形成链式的关系。或者同层的关系\nScrapy多线程并发，效率极高。\n```\n\n## 关于反爬虫\n对于部分网站是可以直接解析进行爬虫的，但是并不是全部，有些网站针对这种情况进行了防范\n- 常见的防范办法是判断**header**请求头,**IP**,以及一些根据反映速度等等鬼才点子进行反爬虫。\n```\n所以要写一个好爬虫，就需要伪造，学会伪装自己，写好请求头，IP，以及控制反应速度等等。具体代码，可以自行百度\n```\n\n## 关于Selenium\n这可以说是一个终极武器，\n简单的来说，就是真正的去打开一个模拟器，然后加载网页，获取网页数据，\n\n```\n有好处也有坏处\n好处是可以获取到更加全面的资源，跳过繁重的api接口分析。直接获取加载的数据。\n坏处是不加以选择的加载数据，效率极低。\n```\n综上，虽然有缺点，但是还是挺有用的，至少能够进行方便的浏览器点击，输入等模拟操作，在进行操作自动化的时侯用处很大。\n\n\n\n\n\n**实现方法是次要的，重要的是思维方式，上层决定下层的运作**\n\n## Seleniumd 的使用技巧\n这里强推chrome加上selenium，效率杠杠的\n\n首先解释一下，python是一门**解释性语言**\n```\n解释性语言定义：\n\n程序不需要编译，在运行程序的时候才翻译，每个语句都是执行的时候才翻译。这样解释性语言每执行一次就需要逐行翻译一次，效率比较低。\n\n现代解释性语言通常把源程序编译成中间代码，然后用解释器把中间代码一条条翻译成目标机器代码，一条条执行。\n```\n\n因为selenium的创建时十分耗时的，所以这并不方便于我们开发调试，比如点击某个按键等等。\n综上，我们使用console进行开发测试：\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/223e76bc8cf036a7acf3291dcc98752e/b5c4b80561a0ffb5a9f5dc0b539a5c11.png)\n这样，可以比如先定位到某个元素，然后边解释，边执行，和**juypter**很像\n\n同时，结合chrome去进行元素的定位\n**比如通过css_selector**\n```\ncontent = browser.find_element_by_css_selector('#app > div > div.home-page.f-clear > div.home-container > div > div.center-panel > div.card-list > div.feed-card > div.content > div:nth-child(2) > div.main-content > div.card-content > div.post-content > div > div.text.p-rel.description > div')\n\n```\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/223e76bc8cf036a7acf3291dcc98752e/1b5659791b4fb92ac31680e9dc9a3bd7.png)\n**或者xpath（也就是dom树**\n```\nbrowser.find_element_by_xpath()\n```\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/223e76bc8cf036a7acf3291dcc98752e/f48e4af38e3c0a7b4e16f965266adfe7.png)\n\n\n\n\n## 爬虫的工具使用，chrome\n最好用的工具之一，就像开发前端一样，可以通过这个查看获取了哪些资源，明白页面节点间的关系。狠方便。\n\n`使用搜索功能搜索数据`\n有写网站的数据不是直接静态的写载html中的，现在很多都是动态的用ajax等技术从后端获取，然后利用js渲染好节点数据。 所以怎样知道自己想要的数据在哪个端口呢。\n\n- 在html中查看数据节点的命名方式。（通常会保持一致）\n- 利用搜索工具搜索出想要信息，排查。\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/223e76bc8cf036a7acf3291dcc98752e/cbedae4df4dcc92b8165f58fb1ea0046.png)\n\n\n## 关于数据定位\n对于某些网站，他们的数据往往没有那么直观就能再html或者某个json接口中就直接找到，可能他们的数据格式不一样。经过了一定处理，比如四舍五入，或者统计计算（比如我碰到的东方财富网站）。这时候我们就需要对网站进行分析了。要了解其内部js是如何运算数据的，以及最后得出结果。\n这里讲一个简单的，对dom树进行监控。这里检测dom树节点什么时候发生变化。\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/223e76bc8cf036a7acf3291dcc98752e/b55ffae2b070b559822bd87e1b421a23.png)\n通过这样再元素那对节点进行监控，当节点改变时，就会debug：暂停\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/223e76bc8cf036a7acf3291dcc98752e/49614456be82c270ccfc1305f171e8ad.png)\n这样就定位到了js如何变化\n\n还有直接对js进行断点的，但是没有这个好用。\n\n## 分布式，多线程等技术\n\n  使用这些批量的爬虫技术，主要是为了提高效率，因为时间很重要，要在规定时间内将数据又快又好的爬取出来。\n- 我主要使用python里面的多线程，协程进行爬取，具体做法\n[协程博客](https://hackmd.io/28Kc3q_nR9as7UTbF0Y7Kw)\n- 注意爬取的速度， 太快反而会导致错误\n- 使用伪装\n\n常用框架：**scrapy**\n\n\n## 反爬虫\n这也很重要，对于爬虫是不可或缺的。\n\n\n\n## 分级层爬取，\n尽量将数据存储到本地，哪怕其中部分不是我最终需要的数据，只要是中间过程的一步，在不影响整体速度的前提下，尽量将中间数据也存储到本地。\n\n本地数据的读取速度是很快的，重要的是，减少目标服务器的压力。\n\n## 确保数据整体的正确性\n很多时候，我们并不能一次性就把握住某个接口的全部特性，那么我们需要尽量的多做测试，在拥有足够多的数据样本的情况下，去进行判断。\n\n明白样本和整体的意义。","slug":"综合/爬虫","published":1,"updated":"2023-02-27T11:34:33.141Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsyd200200gcntjqenmqr","content":"<h1 id=\"爬虫\"><a href=\"#爬虫\" class=\"headerlink\" title=\"爬虫\"></a>爬虫</h1><h5 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h5><pre><code>网络爬虫（又称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。</code></pre><p><strong>个人理解就是，从互联网上获取数据，进行自动化，规范化，也就是说，取代人去做繁重的数据采集。再者使用selenium等，可以模拟浏览器，写交互性的自动化脚本，本质都是解放人力</strong></p>\n<h2 id=\"本质\"><a href=\"#本质\" class=\"headerlink\" title=\"本质\"></a>本质</h2><pre class=\"line-numbers language-文本\"><code class=\"language-文本\">本质上，爬虫就是获取网页，然后解析网页，最后得到开发者想要的数据。\n这么说是不够正确的，或者说，只是爬虫常用的一部分，是对爬虫的一种浅显的理解，实际上，我感觉爬虫就像是模拟浏览器，但是却通过个人的分析，选择需要加载的去加载，获取想要获取的。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h2 id=\"关键点\"><a href=\"#关键点\" class=\"headerlink\" title=\"关键点\"></a>关键点</h2><p>主要就是两个部分，一个就是定位数据（定位节点），另外一个就是从节点获取数据，或者模拟操作。关于对节点的定位，一种就是普通的通过特殊属性值等来筛选，另外一种就是通过父子节点，兄弟等关系进行推到，因为前端设计的时侯一般是分为几个部分去做的，而且渲染也是在特定的地方进行渲染，所以父子节点的关系，能够良好的对列表进行分析。</p>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><p>我个人是常用<strong>python</strong>写爬虫的类型，因为它有很多强大的库，而且性能也很不错。例如使用requests库，非常简单，方便，且强大。然后想要批量，高效率的进行爬虫，可以使用<strong>Scrapy</strong><br>去进行项目式的开发，个人感觉是没有明确的界限，当你需要什么就用什么，不要局限于框架。<br>其次，<strong>java</strong>上的开发就没有那么方便，可能是因为我对java爬虫知之甚少吧。（常用jousp以及正则去进行html解析）</p>\n<h2 id=\"关于pythonn爬虫\"><a href=\"#关于pythonn爬虫\" class=\"headerlink\" title=\"关于pythonn爬虫\"></a>关于pythonn爬虫</h2><p>通过<strong>requests</strong>等库去获取网页，然后解析网页。</p>\n<pre class=\"line-numbers language-解析的常用方法通过两类\"><code class=\"language-解析的常用方法通过两类\">1,是通过id，class，以及其他属性去进行锁定标签。然后提取数据。\n2,是通过正则表达式去进行字符串匹配\n个人感觉第一种简单，方便。但是第二种同样不可获缺，是必须要进行学习的东西，否则爬虫在某些情况可能回降低写程序的思路。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p><strong>Scrapy</strong>爬虫框架</p>\n<pre><code>这个框架的最大优势就是非常的高效率，适用于对于一个网站的各个阶级的页面的爬虫。这些页面之间通常能够形成链式的关系。或者同层的关系\nScrapy多线程并发，效率极高。</code></pre><h2 id=\"关于反爬虫\"><a href=\"#关于反爬虫\" class=\"headerlink\" title=\"关于反爬虫\"></a>关于反爬虫</h2><p>对于部分网站是可以直接解析进行爬虫的，但是并不是全部，有些网站针对这种情况进行了防范</p>\n<ul>\n<li>常见的防范办法是判断<strong>header</strong>请求头,<strong>IP</strong>,以及一些根据反映速度等等鬼才点子进行反爬虫。<pre><code>所以要写一个好爬虫，就需要伪造，学会伪装自己，写好请求头，IP，以及控制反应速度等等。具体代码，可以自行百度</code></pre></li>\n</ul>\n<h2 id=\"关于Selenium\"><a href=\"#关于Selenium\" class=\"headerlink\" title=\"关于Selenium\"></a>关于Selenium</h2><p>这可以说是一个终极武器，<br>简单的来说，就是真正的去打开一个模拟器，然后加载网页，获取网页数据，</p>\n<pre><code>有好处也有坏处\n好处是可以获取到更加全面的资源，跳过繁重的api接口分析。直接获取加载的数据。\n坏处是不加以选择的加载数据，效率极低。</code></pre><p>综上，虽然有缺点，但是还是挺有用的，至少能够进行方便的浏览器点击，输入等模拟操作，在进行操作自动化的时侯用处很大。</p>\n<p><strong>实现方法是次要的，重要的是思维方式，上层决定下层的运作</strong></p>\n<h2 id=\"Seleniumd-的使用技巧\"><a href=\"#Seleniumd-的使用技巧\" class=\"headerlink\" title=\"Seleniumd 的使用技巧\"></a>Seleniumd 的使用技巧</h2><p>这里强推chrome加上selenium，效率杠杠的</p>\n<p>首先解释一下，python是一门<strong>解释性语言</strong></p>\n<pre><code>解释性语言定义：\n\n程序不需要编译，在运行程序的时候才翻译，每个语句都是执行的时候才翻译。这样解释性语言每执行一次就需要逐行翻译一次，效率比较低。\n\n现代解释性语言通常把源程序编译成中间代码，然后用解释器把中间代码一条条翻译成目标机器代码，一条条执行。</code></pre><p>因为selenium的创建时十分耗时的，所以这并不方便于我们开发调试，比如点击某个按键等等。<br>综上，我们使用console进行开发测试：<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/223e76bc8cf036a7acf3291dcc98752e/b5c4b80561a0ffb5a9f5dc0b539a5c11.png\" alt><br>这样，可以比如先定位到某个元素，然后边解释，边执行，和<strong>juypter</strong>很像</p>\n<p>同时，结合chrome去进行元素的定位<br><strong>比如通过css_selector</strong></p>\n<pre><code>content = browser.find_element_by_css_selector(&#39;#app &gt; div &gt; div.home-page.f-clear &gt; div.home-container &gt; div &gt; div.center-panel &gt; div.card-list &gt; div.feed-card &gt; div.content &gt; div:nth-child(2) &gt; div.main-content &gt; div.card-content &gt; div.post-content &gt; div &gt; div.text.p-rel.description &gt; div&#39;)\n</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/223e76bc8cf036a7acf3291dcc98752e/1b5659791b4fb92ac31680e9dc9a3bd7.png\" alt><br><strong>或者xpath（也就是dom树</strong></p>\n<pre><code>browser.find_element_by_xpath()</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/223e76bc8cf036a7acf3291dcc98752e/f48e4af38e3c0a7b4e16f965266adfe7.png\" alt></p>\n<h2 id=\"爬虫的工具使用，chrome\"><a href=\"#爬虫的工具使用，chrome\" class=\"headerlink\" title=\"爬虫的工具使用，chrome\"></a>爬虫的工具使用，chrome</h2><p>最好用的工具之一，就像开发前端一样，可以通过这个查看获取了哪些资源，明白页面节点间的关系。狠方便。</p>\n<p><code>使用搜索功能搜索数据</code><br>有写网站的数据不是直接静态的写载html中的，现在很多都是动态的用ajax等技术从后端获取，然后利用js渲染好节点数据。 所以怎样知道自己想要的数据在哪个端口呢。</p>\n<ul>\n<li>在html中查看数据节点的命名方式。（通常会保持一致）</li>\n<li>利用搜索工具搜索出想要信息，排查。<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/223e76bc8cf036a7acf3291dcc98752e/cbedae4df4dcc92b8165f58fb1ea0046.png\" alt></li>\n</ul>\n<h2 id=\"关于数据定位\"><a href=\"#关于数据定位\" class=\"headerlink\" title=\"关于数据定位\"></a>关于数据定位</h2><p>对于某些网站，他们的数据往往没有那么直观就能再html或者某个json接口中就直接找到，可能他们的数据格式不一样。经过了一定处理，比如四舍五入，或者统计计算（比如我碰到的东方财富网站）。这时候我们就需要对网站进行分析了。要了解其内部js是如何运算数据的，以及最后得出结果。<br>这里讲一个简单的，对dom树进行监控。这里检测dom树节点什么时候发生变化。<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/223e76bc8cf036a7acf3291dcc98752e/b55ffae2b070b559822bd87e1b421a23.png\" alt><br>通过这样再元素那对节点进行监控，当节点改变时，就会debug：暂停<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/223e76bc8cf036a7acf3291dcc98752e/49614456be82c270ccfc1305f171e8ad.png\" alt><br>这样就定位到了js如何变化</p>\n<p>还有直接对js进行断点的，但是没有这个好用。</p>\n<h2 id=\"分布式，多线程等技术\"><a href=\"#分布式，多线程等技术\" class=\"headerlink\" title=\"分布式，多线程等技术\"></a>分布式，多线程等技术</h2><p>  使用这些批量的爬虫技术，主要是为了提高效率，因为时间很重要，要在规定时间内将数据又快又好的爬取出来。</p>\n<ul>\n<li>我主要使用python里面的多线程，协程进行爬取，具体做法<br><a href=\"https://hackmd.io/28Kc3q_nR9as7UTbF0Y7Kw\" target=\"_blank\" rel=\"noopener\">协程博客</a></li>\n<li>注意爬取的速度， 太快反而会导致错误</li>\n<li>使用伪装</li>\n</ul>\n<p>常用框架：<strong>scrapy</strong></p>\n<h2 id=\"反爬虫\"><a href=\"#反爬虫\" class=\"headerlink\" title=\"反爬虫\"></a>反爬虫</h2><p>这也很重要，对于爬虫是不可或缺的。</p>\n<h2 id=\"分级层爬取，\"><a href=\"#分级层爬取，\" class=\"headerlink\" title=\"分级层爬取，\"></a>分级层爬取，</h2><p>尽量将数据存储到本地，哪怕其中部分不是我最终需要的数据，只要是中间过程的一步，在不影响整体速度的前提下，尽量将中间数据也存储到本地。</p>\n<p>本地数据的读取速度是很快的，重要的是，减少目标服务器的压力。</p>\n<h2 id=\"确保数据整体的正确性\"><a href=\"#确保数据整体的正确性\" class=\"headerlink\" title=\"确保数据整体的正确性\"></a>确保数据整体的正确性</h2><p>很多时候，我们并不能一次性就把握住某个接口的全部特性，那么我们需要尽量的多做测试，在拥有足够多的数据样本的情况下，去进行判断。</p>\n<p>明白样本和整体的意义。</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"爬虫\"><a href=\"#爬虫\" class=\"headerlink\" title=\"爬虫\"></a>爬虫</h1><h5 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h5><pre><code>网络爬虫（又称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。</code></pre><p><strong>个人理解就是，从互联网上获取数据，进行自动化，规范化，也就是说，取代人去做繁重的数据采集。再者使用selenium等，可以模拟浏览器，写交互性的自动化脚本，本质都是解放人力</strong></p>\n<h2 id=\"本质\"><a href=\"#本质\" class=\"headerlink\" title=\"本质\"></a>本质</h2><pre><code class=\"文本\">本质上，爬虫就是获取网页，然后解析网页，最后得到开发者想要的数据。\n这么说是不够正确的，或者说，只是爬虫常用的一部分，是对爬虫的一种浅显的理解，实际上，我感觉爬虫就像是模拟浏览器，但是却通过个人的分析，选择需要加载的去加载，获取想要获取的。</code></pre>\n<h2 id=\"关键点\"><a href=\"#关键点\" class=\"headerlink\" title=\"关键点\"></a>关键点</h2><p>主要就是两个部分，一个就是定位数据（定位节点），另外一个就是从节点获取数据，或者模拟操作。关于对节点的定位，一种就是普通的通过特殊属性值等来筛选，另外一种就是通过父子节点，兄弟等关系进行推到，因为前端设计的时侯一般是分为几个部分去做的，而且渲染也是在特定的地方进行渲染，所以父子节点的关系，能够良好的对列表进行分析。</p>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><p>我个人是常用<strong>python</strong>写爬虫的类型，因为它有很多强大的库，而且性能也很不错。例如使用requests库，非常简单，方便，且强大。然后想要批量，高效率的进行爬虫，可以使用<strong>Scrapy</strong><br>去进行项目式的开发，个人感觉是没有明确的界限，当你需要什么就用什么，不要局限于框架。<br>其次，<strong>java</strong>上的开发就没有那么方便，可能是因为我对java爬虫知之甚少吧。（常用jousp以及正则去进行html解析）</p>\n<h2 id=\"关于pythonn爬虫\"><a href=\"#关于pythonn爬虫\" class=\"headerlink\" title=\"关于pythonn爬虫\"></a>关于pythonn爬虫</h2><p>通过<strong>requests</strong>等库去获取网页，然后解析网页。</p>\n<pre><code class=\"解析的常用方法通过两类\">1,是通过id，class，以及其他属性去进行锁定标签。然后提取数据。\n2,是通过正则表达式去进行字符串匹配\n个人感觉第一种简单，方便。但是第二种同样不可获缺，是必须要进行学习的东西，否则爬虫在某些情况可能回降低写程序的思路。</code></pre>\n<p><strong>Scrapy</strong>爬虫框架</p>\n<pre><code>这个框架的最大优势就是非常的高效率，适用于对于一个网站的各个阶级的页面的爬虫。这些页面之间通常能够形成链式的关系。或者同层的关系\nScrapy多线程并发，效率极高。</code></pre><h2 id=\"关于反爬虫\"><a href=\"#关于反爬虫\" class=\"headerlink\" title=\"关于反爬虫\"></a>关于反爬虫</h2><p>对于部分网站是可以直接解析进行爬虫的，但是并不是全部，有些网站针对这种情况进行了防范</p>\n<ul>\n<li>常见的防范办法是判断<strong>header</strong>请求头,<strong>IP</strong>,以及一些根据反映速度等等鬼才点子进行反爬虫。<pre><code>所以要写一个好爬虫，就需要伪造，学会伪装自己，写好请求头，IP，以及控制反应速度等等。具体代码，可以自行百度</code></pre></li>\n</ul>\n<h2 id=\"关于Selenium\"><a href=\"#关于Selenium\" class=\"headerlink\" title=\"关于Selenium\"></a>关于Selenium</h2><p>这可以说是一个终极武器，<br>简单的来说，就是真正的去打开一个模拟器，然后加载网页，获取网页数据，</p>\n<pre><code>有好处也有坏处\n好处是可以获取到更加全面的资源，跳过繁重的api接口分析。直接获取加载的数据。\n坏处是不加以选择的加载数据，效率极低。</code></pre><p>综上，虽然有缺点，但是还是挺有用的，至少能够进行方便的浏览器点击，输入等模拟操作，在进行操作自动化的时侯用处很大。</p>\n<p><strong>实现方法是次要的，重要的是思维方式，上层决定下层的运作</strong></p>\n<h2 id=\"Seleniumd-的使用技巧\"><a href=\"#Seleniumd-的使用技巧\" class=\"headerlink\" title=\"Seleniumd 的使用技巧\"></a>Seleniumd 的使用技巧</h2><p>这里强推chrome加上selenium，效率杠杠的</p>\n<p>首先解释一下，python是一门<strong>解释性语言</strong></p>\n<pre><code>解释性语言定义：\n\n程序不需要编译，在运行程序的时候才翻译，每个语句都是执行的时候才翻译。这样解释性语言每执行一次就需要逐行翻译一次，效率比较低。\n\n现代解释性语言通常把源程序编译成中间代码，然后用解释器把中间代码一条条翻译成目标机器代码，一条条执行。</code></pre><p>因为selenium的创建时十分耗时的，所以这并不方便于我们开发调试，比如点击某个按键等等。<br>综上，我们使用console进行开发测试：<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/223e76bc8cf036a7acf3291dcc98752e/b5c4b80561a0ffb5a9f5dc0b539a5c11.png\" alt><br>这样，可以比如先定位到某个元素，然后边解释，边执行，和<strong>juypter</strong>很像</p>\n<p>同时，结合chrome去进行元素的定位<br><strong>比如通过css_selector</strong></p>\n<pre><code>content = browser.find_element_by_css_selector(&#39;#app &gt; div &gt; div.home-page.f-clear &gt; div.home-container &gt; div &gt; div.center-panel &gt; div.card-list &gt; div.feed-card &gt; div.content &gt; div:nth-child(2) &gt; div.main-content &gt; div.card-content &gt; div.post-content &gt; div &gt; div.text.p-rel.description &gt; div&#39;)\n</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/223e76bc8cf036a7acf3291dcc98752e/1b5659791b4fb92ac31680e9dc9a3bd7.png\" alt><br><strong>或者xpath（也就是dom树</strong></p>\n<pre><code>browser.find_element_by_xpath()</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/223e76bc8cf036a7acf3291dcc98752e/f48e4af38e3c0a7b4e16f965266adfe7.png\" alt></p>\n<h2 id=\"爬虫的工具使用，chrome\"><a href=\"#爬虫的工具使用，chrome\" class=\"headerlink\" title=\"爬虫的工具使用，chrome\"></a>爬虫的工具使用，chrome</h2><p>最好用的工具之一，就像开发前端一样，可以通过这个查看获取了哪些资源，明白页面节点间的关系。狠方便。</p>\n<p><code>使用搜索功能搜索数据</code><br>有写网站的数据不是直接静态的写载html中的，现在很多都是动态的用ajax等技术从后端获取，然后利用js渲染好节点数据。 所以怎样知道自己想要的数据在哪个端口呢。</p>\n<ul>\n<li>在html中查看数据节点的命名方式。（通常会保持一致）</li>\n<li>利用搜索工具搜索出想要信息，排查。<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/223e76bc8cf036a7acf3291dcc98752e/cbedae4df4dcc92b8165f58fb1ea0046.png\" alt></li>\n</ul>\n<h2 id=\"关于数据定位\"><a href=\"#关于数据定位\" class=\"headerlink\" title=\"关于数据定位\"></a>关于数据定位</h2><p>对于某些网站，他们的数据往往没有那么直观就能再html或者某个json接口中就直接找到，可能他们的数据格式不一样。经过了一定处理，比如四舍五入，或者统计计算（比如我碰到的东方财富网站）。这时候我们就需要对网站进行分析了。要了解其内部js是如何运算数据的，以及最后得出结果。<br>这里讲一个简单的，对dom树进行监控。这里检测dom树节点什么时候发生变化。<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/223e76bc8cf036a7acf3291dcc98752e/b55ffae2b070b559822bd87e1b421a23.png\" alt><br>通过这样再元素那对节点进行监控，当节点改变时，就会debug：暂停<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/223e76bc8cf036a7acf3291dcc98752e/49614456be82c270ccfc1305f171e8ad.png\" alt><br>这样就定位到了js如何变化</p>\n<p>还有直接对js进行断点的，但是没有这个好用。</p>\n<h2 id=\"分布式，多线程等技术\"><a href=\"#分布式，多线程等技术\" class=\"headerlink\" title=\"分布式，多线程等技术\"></a>分布式，多线程等技术</h2><p>  使用这些批量的爬虫技术，主要是为了提高效率，因为时间很重要，要在规定时间内将数据又快又好的爬取出来。</p>\n<ul>\n<li>我主要使用python里面的多线程，协程进行爬取，具体做法<br><a href=\"https://hackmd.io/28Kc3q_nR9as7UTbF0Y7Kw\" target=\"_blank\" rel=\"noopener\">协程博客</a></li>\n<li>注意爬取的速度， 太快反而会导致错误</li>\n<li>使用伪装</li>\n</ul>\n<p>常用框架：<strong>scrapy</strong></p>\n<h2 id=\"反爬虫\"><a href=\"#反爬虫\" class=\"headerlink\" title=\"反爬虫\"></a>反爬虫</h2><p>这也很重要，对于爬虫是不可或缺的。</p>\n<h2 id=\"分级层爬取，\"><a href=\"#分级层爬取，\" class=\"headerlink\" title=\"分级层爬取，\"></a>分级层爬取，</h2><p>尽量将数据存储到本地，哪怕其中部分不是我最终需要的数据，只要是中间过程的一步，在不影响整体速度的前提下，尽量将中间数据也存储到本地。</p>\n<p>本地数据的读取速度是很快的，重要的是，减少目标服务器的压力。</p>\n<h2 id=\"确保数据整体的正确性\"><a href=\"#确保数据整体的正确性\" class=\"headerlink\" title=\"确保数据整体的正确性\"></a>确保数据整体的正确性</h2><p>很多时候，我们并不能一次性就把握住某个接口的全部特性，那么我们需要尽量的多做测试，在拥有足够多的数据样本的情况下，去进行判断。</p>\n<p>明白样本和整体的意义。</p>\n"},{"_content":"# 数字图像处理\n\n本博客主要涉及算法方面。需要堆图形由一定了解\n\n\n\n## 预处理，加载，存储\n\n使用**pillow**进行加载\n\n```\nfrom PIL import Image\nim = Image.open('./../image/lena.png')\n```\n\n存储\n\n```\n# 把图像用png格式保存:\nim.save('thumbnail.png', 'png')\n```\n\n 转换成**numpy**形式\n\n```\nimg = np.array(im)      # image类 转 numpy\n```\n\n\n\n将**numpy**格式数组用图片显示\n\n```\nfrom matplotlib import pyplot as plt\nplt.imshow(img)\nplt.show()\n```\n\n![image-20210515125837128](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/333857553eedebc6deb8e041b4545289.png)\n\n分为不同得**通道**显示\n\n```\nb = img[:,:,0:1]\nplt.imshow(img, 'Blues')\n```\n\n\n\n![image-20210515125815860](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/927046a194025ee3737ec606f971dc0f.png)\n\n\n\n\n\n## 关于图像平滑处理\n\n### 首先对图像添加噪声\n\n我们这里添加白色小点得噪声\n\n![image-20210515130157855](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/15d8b11c13f91f944e46ebe71a19ab91.png)\n\n**白色得噪声是（255，255，255）**\n\n得到噪声图\n\n![image-20210515143316188](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/5b13d9bf970f9413668d1cecf0b27609.png)\n\n\n\n### 定义\n\n图像平滑是一种区域增强的算法，平滑算法有**邻域平均法、中指滤波、边界保持类滤波**等。在图像产生、传输和复制过程中，常常会因为多方面原因而**被噪声干扰或出现数据丢失，降低了图像的质量**（某一像素，如果它与周围像素点相比有明显的不同，则该点被噪声所感染）。这就需要**对图像进行一定的增强处理以减小这些缺陷带来的影响**。\n\n\n![img](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/35297be9cf4efdf048196eb5138323c7.png)\n\n### 邻域平均法和均值滤波\n\n其实就是一个**卷积运算**\n\n可以类比一下卷积神经网络\n\n$$g(x,y)= 1/M  \\sum_{(x,y)∈S} f(x,y)$$\n\n\n\n![image-20210515132244573](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/5343ce925ad238e9703e83ae8204d358.png)\n\n**如图**\n\n![image-20210515132401506](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/5758d6bca49a5c3c0f0085379ea926bc.png)\n\n\n\n\n\n- 我们这里先写一个单通道单核得卷积\n\n![image-20210515134556505](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/96e3429d00a616af6f0ecbd9dba263eb.png)\n\n- 初始化一个卷积核\n\n  ```\n  # filterKernel = np.array([\n  #     [1, 1, 1],\n  #     [1, 1, 1],\n  #     [1, 1, 1]\n  # ])\n  filterKernel = np.ones((6,6))\n  ```\n\n  \n\n- 查看结果\n\n![image-20210515134707303](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/4c10222326786736ab57b0127f064dd2.png)\n\n- **很明显有效果， 然后就是变单通道为多通道，单核为多核**\n\n  ![image-20210515143402138](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/c09bd424c04c84d241b42755255f61b9.png)\n\n**success**\n\n\n\n### 高斯平滑\n\n为了克服简单局部平均法的弊端(图像模糊)，目前已提出许多保持边缘、细节的局部平滑算法。它们的出发点都集中在如何选择邻域的大小、形状和方向、参数加平均及邻域各店的权重系数等。\n**图像高斯平滑也是邻域平均的思想对图像进行平滑的一种方法**，在图像高斯平滑中，对图像进行平均时，不同位置的像素被赋予了不同的权重。高斯平滑与简单平滑不同，它在对邻域内像素进行平均时，给予不同位置的像素不同的权值，下图的所示的 3 * 3 和 5 * 5 领域的高斯模板。\n\n**其实就是用二维高斯去生成一个卷积核**\n\n![image-20210517100746197](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/d9525903cbf9afe8b2274131a8b454dc.png)\n\n\n\n### 总结\n\n到这里，一些基本得卷积算法就已经剖析完毕，剩下得就只是对这些卷积核做一定处理。\n\n\n\n### **引申滤波的概念**\n\n滤波的目的主要两个：\n\n1.通过滤波来提取图像特征，简化图像所带的信息作为后续其它的图像处理\n\n2.为适应图像处理的需求，通过滤波消除图像数字化时所混入的噪声\n\n**其中第一点就是边缘检测中所使用的基本思想，即简化图像信息，使用边缘线代表图像所携带信息**\n\n**滤波可理解为滤波器(通常为3*3、5*5矩阵)在图像上进行从上到下，从左到右的遍历，计算滤波器与对应像素的值并根据滤波目的进行数值计算返回值到当前像素点**，实际就是卷积\n\n\n\n\n\n## 图像几何变换（缩放、图像旋转、图像翻转与图像平移）\n\n主要知识：**线性代数**\n\n### 提前概念\n\n对于一个图像，我们可以表达成一个**二维函数**\n\n$$f(x, y) = 色值 $$\n\n**而几何变换，并不改变色值，仅仅改变x，y得位置。**\n\n也就是说\n\n$$f(x^{`}, y^{`}) = f(x, y)$$\n\n**是一个映射**\n\n\n\n**（以下得图转载）**\n\n### 平移\n\n![image-20210515144701393](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/b2fce96fbb8c74f1c2cb9902dcaa9c68.png)\n\n\n\n### 缩放\n\n![image-20210515144734355](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/fd41ef949d9d0f9342da8e83640b3fc1.png)\n\n### 旋转\n\n![image-20210515144811005](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/d05eb9f612c3792dbbc3d6f9d7486cca.png)\n\n### 镜像变换\n\n![image-20210515145002510](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/95d09b33b89068365bf9bae6a0028389.png)\n\n\n\n\n\n### 插值算法\n\n关于以上变换有个要注意得问题。\n\n**变换后得坐标，定义域不一定和值域完全重合。**\n\n也就是说，变换后得点可能落不到整数上（一种情况。）\n\n**那么就需要插值算法了。** （简单起见，这里只讲线性插值算法）\n\n\n\n先讲一下整体得套路：\n\n\n\n![7B0D9C468E20156153764274EE6DAABA](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/c8cc26d6cfd020290b757289e0a21486.png)\n\n#### 邻近插值算法\n\n简单来说就是，直接对x和y进行取整。\n\n按照上述思路实现。\n\n![image-20210515185639914](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/ca4ba14ff7ecf0625b840a83c51535c4.png)\n\n不难看出，效果还行。\n\n试试旋转矩阵\n\n![image-20210515193419491](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/ada1ca6ce4fcc253cc936cd9ba1ebd38.png)\n\n\n\n#### 双线性插值\n\n**双线性插值是线性插值在二维时的推广,在两个方向上共做了三次线性插值。**定义了一个双曲抛物面与四个已知点拟合。\n\n具体操作为在X方向上进行两次线性插值计算，然后在Y方向上进行一次插值计算\n\n![image-20210515185941228](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/c943151c48efef8c4e8b14335bd00cf5.png)\n\n**具体得公式**\n\n![image-20210515190007957](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/67eddb619bd8277f01dc03339b6f8009.png)\n\n\n\n**（我这里踩了坑，原有的图像数据的大小是8位的，最大255）所以在上述运算中很容易就溢出了。**\n\n结果\n\n![image-20210515222501615](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/4da8e80612ea6115e92c6ebea9587fa5.png)\n\n**success**\n\n\n\n## 仿射变换与透视变换\n\n### 提前概念（二维为例子）\n\n- 什么是线性变换？\n\n$$\nx^{,}= A \\cdot x_{0}\n$$\n\n原点不变，且原有的平行关系和倍数关系都不变\n\n### 仿射变换\n\n在线性变换的基础上，**原点可以发生变换**。\n\n仿射变换是单纯对图片进行平移，缩放，倾斜和旋转，而这几个操作都不会改变图片线之间的平行关系。\n\n$$\nx^{,}= A \\cdot x_{0} + b\n$$\n\n如果用三维去线性表达，那么就是：\n$$\n\\begin{bmatrix}\nx^{,}\\\\ \ny^{,}\\\\ \n1\n\n\\end{bmatrix}\n= \n\n\\begin{bmatrix}\na11 &a12  &b1 \\\\ \na21 &  a22& b2\\\\ \n 0&0  & 1\n\\end{bmatrix}\n\n\\cdot\n\n\\begin{bmatrix}\nx\\\\ \ny\\\\ \n1\n\n\\end{bmatrix}\n$$\n\n### 什么是透视变换\n\n如果说仿射变换是在二维空间中的旋转，平移和缩放。**那么透视变换则是在三维空间中视角的变化。**\n\n**相对于仿射。透视变换能保持“直线性”，即原图像里面的直线，经透视变换后仍为直线**\n\n![image-20210515224105702](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/46eb52459edc83ef1dcfccaaa8e144d0.png)\n\n\n\n\n\n这里讲一下，如果说，仿射变化是三维空间中对某个平面的一些二维变化。\n\n那么透视变化就是对这个平面进行变换，并且利用视觉原理将图像进行一定处理（近大，远小）。\n\n![OpenCV-透视变换及对二维点求透视变换之后的坐标_leonardohaig的博客-CSDN博客](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/54e4529e9550f5cc8881ef96792434b9.png)\n\n\n\n**也就是说，先将图像旋转到$A^{,}B^{,}C^{,}$**\n\n**然后投影到平面$ABC$**\n\n**这里有一下假设，假设我们人是远点，从我们的眼睛去看，垂直与我们的目光的这个轴是$z$轴.**\n\n**在离我们一定距离的地方选一个画布$ABC$，其他所有画像都投影到这个画布上。**\n\n**那么假设平面$z$轴的距离是1.**\n\n**从$A^{,}B^{,}C^{,}$投影到画布$ABC$，计算公式为**\n\n$$\n\\begin{bmatrix}\nx\\\\ \ny\\\\ \n1\n\n\\end{bmatrix}\n=\n(1/z^{,}) \\cdot\n\\begin{bmatrix}\nx^{,}\\\\ \ny^{,}\\\\ \nz^{,}\n\n\\end{bmatrix}\n$$\n\n\n\n有了以上概念，**我们来最后计算一遍**\n\n![image-20210516140838713](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/3d1d091fab6e8ef34769c3833d999b0a.png)\n\n**先进行旋转变换。**\n\n**然后进行投影变换。**\n\n![image-20210516140914286](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/00e32af988032c970845ede0f2f9b581.png)\n\n\n\n然后就是繁琐的解方程过程，**这里是非齐次线性方程组求解**\n\n![image-20210516140938930](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/a92fd5ff6b904e4d6b308b447bf2e97c.png)\n\n\n\n让我们来看一下最后效果。\n\n![image-20210516141108490](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/6b75bb88d0f41f9710a2872e6e6c9f7e.png)\n\n\n\n右边是我们手动实现的。\n\n具体的思路是仿照**opencv**，不过代码是手动用**numpy**实现的，有助于理解。\n\n**核心代码**\n\n```\n#根据四个顶点设置图像透视变换矩阵\npos1 = np.float32([[114, 82], [287, 156], [8, 322], [216, 333]])  # 原来的坐标\npos2 = np.float32([[0, 0], [188, 0], [0, 262], [188, 262]])    # 变换后的坐标\n\n# 实际肉眼看上去的x，y和数组的存储是有区别的\ndef exchangeXY(pos):\n    for i in range(len(pos)):\n        pos[i] = [pos[i][1], pos[i][0]]\n\nexchangeXY(pos1)\nexchangeXY(pos2)\n\n# 计算透视变换矩阵\ndef getPerspectiveTransform(pos1, pos2):\n    length = len(pos1)\n    tmpMatrix = []\n    b = []\n    for i in range(length):\n        x0, y0 = pos1[i]\n        xn, yn = pos2[i]\n        tmpMatrix.append(\n            [x0, y0,1,0,0,0,-1 * x0 * xn, -1 * y0 * xn]\n        )\n        tmpMatrix.append(\n            [0,0,0,x0, y0,1,-1 * x0 * yn, -1 * y0 * yn]\n        )\n\n        b.append(xn)\n        b.append(yn)\n\n\n    tmpMatrix= np.array(tmpMatrix)\n    b = np.array(b)\n    ans =np.dot(np.linalg.inv(tmpMatrix), b)\n    finalMatrix = [\n        [ans[0], ans[1], ans[2]],\n        [ans[3], ans[4], ans[5]],\n        [ans[6], ans[7], 1]\n\n    ]\n    return np.array(finalMatrix)\n\nM = getPerspectiveTransform(pos1, pos2)\n```\n\n\n\n\n\n\n\n## 图像阈值化\n\n图像的二值化或阈值化（Binarization）旨在提取图像中的目标物体，将背景以及噪声区分开来。通常会设定一个阈值T，通过T将图像的像素划分为两类：大于T的像素群和小于T的像素群。\n\n![image-20210516195934138](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/86e4d4c06ed913297cf73df917113377.png)\n\n\n\n**二进制阈值化**\n\n![image-20210516200029306](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/e4bcc8740e408805c15aecc64e58da64.png)\n\n\n\n\n\n所谓其他阈值化，其实也就是不断在基础形式上都不同的类进行一定处理。\n\n## 灰度直方图\n\n### 前置概念\n\n**RGB图像：**\n\nRGB的值分别为0，0，0 表示的是黑色。\n\nRGB的值为255，255，255表示的是白色。\n\n**灰度图像：**\n\n灰度值为0表示黑色。\n\n灰度值为255表示白色。\n\n### 定义\n\n灰度直方图（histogram）是灰度级的函数，描述的是图像中每种灰度级像素的个数，反映图像中每种灰度出现的频率。横坐标是灰度级，纵坐标是灰度级出现的频率。\n\n![image-20210516200650255](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/14f8ae266ebabeb3c974b160502bf0d5.png)\n\n\n\n**用处：**\n\n在使用轮廓线确定物体边界时，通过直方图更好的选择边界阈值，进行阈值化处理；对物体与背景有较强对比的景物的分割特别有用；简单物体的面积和综合光密度IOD可以通过图像的直方图求得。\n\n\n\n### 直方图修正\n\n图像的直方图修正方法主要有直方图均衡化和直方图规定化直方图修正的目的是，**使修正后的图像的灰度间距拉开或者是图像灰度分布均匀，从而增大反差，使图像细节清晰，从而达到图像增强的目的**\n\n我们这里主要**直方图均衡化**。\n\n算法原理，把原有的概率乘以一个数（通常是色值的大小，取整）。这样就可以把一些较为相近的值给化到一起了。\n\n\n\n\n\n\n\n## 灰度值处理\n\n**rbg如何变为灰度值图像呢？**\n\n一种常见的方法是将RGB三个分量求和再取平均值，但更为准确的方法是设置不同的权重，将RGB分量按不同的比例进行灰度划分。比如人类的眼睛感官蓝色的敏感度最低，敏感最高的是绿色，因此将RGB按照0.299、0.587、0.144比例加权平均能得到较合理的灰度图像，\n\n![image-20210516201613044](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/d39f859b6c1f17c27dfe1eb8281277ca.png)\n\n\n\n## 图像灰度线性变换\n\n图像的灰度线性变换是通过建立灰度映射来调整原始图像的灰度，从而改善图像的质量，凸显图像的细节，**提高图像的对比度**\n\n$$\nf(D) = S \\cdot D + b\n$$\n\n**图像灰度非线性变换**\n\n- 例如什么一元二次函数\n- 对数变换\n- 伽玛变换又称为指数变换或幂次变换，是另一种常用的灰度非线性变换。就是指数函数\n\n## 图像锐化\n\n展图像锐化和边缘检测处理，加强原图像的高频部分。锐化突出图像的边缘细节，改善图像的对比度，使模糊的图像变得更清晰。\n\n图像锐化和边缘提取技术可以消除图像中的噪声，**提取图像信息中用来表征图像的一些变量**，为图像识别提供基础。\n\n通常使用**灰度差分法**对图像的边缘、轮廓进行处理，将其凸显。\n\n**如果把每一种算法都用卷积核来表示成矩阵的乘法，那么实际上就是一种卷积运算了**\n\n### Roberts算子（梯度法）\n\n**通过计算梯度从而凸显轮廓**\n\n对于图像 ![[公式]](https://www.zhihu.com/equation?tex=f%28x%2Cy%29) ,在点 ![[公式]](https://www.zhihu.com/equation?tex=%28x%2Cy%29) 处的梯度是一个矢量，定义为![[公式]](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/5d69f9d401c2fd45a0441959401fa85a.png)。\n\n梯度的幅度表示为 ![[公式]](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/e8fbf647c96fe6ec562eabb8ddadf43f.png)\n\n对于数字图像而言， ![[公式]](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/1dec5220f81575ccae6738b7d2466848.png) ，\n\n该式可以简化成 ![[公式]](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/59b6fc46f008b96c4914393b9731915e.png)\n\n\n\n**当梯度计算完之后，可以根据需要生成不同的梯度增强图像，**\n\n1）第一种， ![[公式]](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/bf834d39b57899bd1287107a509ea2cd.png) ，只显示灰度变化大的边缘轮廓，灰度变化平缓的呈黑色。\n\n2）第二种， ![[公式]](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/8d1049d104a4514f8715597d718d8069.png)\n\n可以显示出非常明显的边缘轮廓，又不会破坏原灰度变化平缓的背景。\n\n3）第三种， ![[公式]](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/f3b342875660dc887dcbd05121d8025d.png)\n\n。。。。还有很多类似的\n\n### **Sobel算子**\n\n采用梯度微分锐化图像，会让噪声、条纹得到增强，Sobel算子在一定程度上解决了这个问题， ![[公式]](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/8b9e97d5e86c30259dfe8709143352e3.png)\n\n从这个式子中，可以得到两个性质，\n\n- Sobel引入了平均的因素，因此对噪声有一定的平滑作用\n\n- Sobel算子的操作就是相隔两个行（列）的差分，所以边缘两侧元素的得到了增强，因此边缘显得粗而亮。\n\n- Sobel算子表示形式为：\n\n  ![[公式]](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/21ff5ffbd08ae34f86890889c335e850.png)\n\n###  **拉普拉斯算子（二阶微分）**\n\n拉普拉斯运算也是各向同性的线性运算。拉普拉斯算子为： ![[公式]](https://www.zhihu.com/equation?tex=+%5Cnabla+%5E2f%3D%5Cfrac%7B%5Cpartial+%5E2f%7D%7B%5Cpartial+x%5E2%7D%2B%5Cfrac%7B%5Cpartial+%5E2f%7D%7B%5Cpartial+y%5E2%7D++) ,锐化之后的图像 ![[公式]](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/05df0a4434c3b690175bd3491e580147.png)\n\n![[公式]](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/5a1c7b5cfeb56ef056d85fb12781544a.png) 为扩散效应的系数。\n\n![[公式]](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/c3d8d679c4bcc9fb05de4e54af9d5044.png)\n\n![[公式]](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/3c2471b3e33e37a96943870aa3f76c3d.png)\n\n由此式可知，数字图像在 ![[公式]](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/4930ba4025f56d086cf539962a9f0f08.png) 点的拉普拉斯算子，可以由该点的灰度值减去该点及其邻域四个点的平均灰度值求得。\n\n\n\n\n\n### Canny算子\n\n**1.使用高斯平滑（如公式所示）去除噪声。**\n\n![image-20210517111128781](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/5d6282b25a7dd374504724d07aec9471.png)\n\n**2.按照Sobel滤波器步骤计算梯度幅值和方向，寻找图像的强度梯度。先将卷积模板分别作用x和y方向，再计算梯度幅值和方向，其公式如下所示。梯度方向一般取0度、45度、90度和135度四个方向。**\n\n![image-20210517111159837](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/44a4ec5fe12053aad7f1576a45bc43b6.png)\n\n**3.通过非极大值抑制（Non-maximum Suppression）过滤掉非边缘像素，将模糊的边界变得清晰。该过程保留了每个像素点上梯度强度的极大值，过滤掉其他的值。**\n\n\n\n**4.利用滞后技术来跟踪边界。若某一像素位置和强边界相连的弱边界认为是边界，其他的弱边界则被删除。**\n\n\n\n\n\n## 边缘线检测\n\n边缘检测算法主要是基于图像强度的一阶和二阶导数，但**导数通常对噪声很敏感，**因此需要采用**滤波器来过滤噪声**，并**调用图像增强或阈值化算法进行处理**，**最后再进行边缘检测**。\n\n而所谓边缘检测，其实是用锐化算法算出边缘，然后通过一些细节处理捕捉边缘。\n","source":"_posts/综合/数字图像处理.md","raw":"# 数字图像处理\n\n本博客主要涉及算法方面。需要堆图形由一定了解\n\n\n\n## 预处理，加载，存储\n\n使用**pillow**进行加载\n\n```\nfrom PIL import Image\nim = Image.open('./../image/lena.png')\n```\n\n存储\n\n```\n# 把图像用png格式保存:\nim.save('thumbnail.png', 'png')\n```\n\n 转换成**numpy**形式\n\n```\nimg = np.array(im)      # image类 转 numpy\n```\n\n\n\n将**numpy**格式数组用图片显示\n\n```\nfrom matplotlib import pyplot as plt\nplt.imshow(img)\nplt.show()\n```\n\n![image-20210515125837128](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/333857553eedebc6deb8e041b4545289.png)\n\n分为不同得**通道**显示\n\n```\nb = img[:,:,0:1]\nplt.imshow(img, 'Blues')\n```\n\n\n\n![image-20210515125815860](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/927046a194025ee3737ec606f971dc0f.png)\n\n\n\n\n\n## 关于图像平滑处理\n\n### 首先对图像添加噪声\n\n我们这里添加白色小点得噪声\n\n![image-20210515130157855](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/15d8b11c13f91f944e46ebe71a19ab91.png)\n\n**白色得噪声是（255，255，255）**\n\n得到噪声图\n\n![image-20210515143316188](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/5b13d9bf970f9413668d1cecf0b27609.png)\n\n\n\n### 定义\n\n图像平滑是一种区域增强的算法，平滑算法有**邻域平均法、中指滤波、边界保持类滤波**等。在图像产生、传输和复制过程中，常常会因为多方面原因而**被噪声干扰或出现数据丢失，降低了图像的质量**（某一像素，如果它与周围像素点相比有明显的不同，则该点被噪声所感染）。这就需要**对图像进行一定的增强处理以减小这些缺陷带来的影响**。\n\n\n![img](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/35297be9cf4efdf048196eb5138323c7.png)\n\n### 邻域平均法和均值滤波\n\n其实就是一个**卷积运算**\n\n可以类比一下卷积神经网络\n\n$$g(x,y)= 1/M  \\sum_{(x,y)∈S} f(x,y)$$\n\n\n\n![image-20210515132244573](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/5343ce925ad238e9703e83ae8204d358.png)\n\n**如图**\n\n![image-20210515132401506](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/5758d6bca49a5c3c0f0085379ea926bc.png)\n\n\n\n\n\n- 我们这里先写一个单通道单核得卷积\n\n![image-20210515134556505](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/96e3429d00a616af6f0ecbd9dba263eb.png)\n\n- 初始化一个卷积核\n\n  ```\n  # filterKernel = np.array([\n  #     [1, 1, 1],\n  #     [1, 1, 1],\n  #     [1, 1, 1]\n  # ])\n  filterKernel = np.ones((6,6))\n  ```\n\n  \n\n- 查看结果\n\n![image-20210515134707303](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/4c10222326786736ab57b0127f064dd2.png)\n\n- **很明显有效果， 然后就是变单通道为多通道，单核为多核**\n\n  ![image-20210515143402138](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/c09bd424c04c84d241b42755255f61b9.png)\n\n**success**\n\n\n\n### 高斯平滑\n\n为了克服简单局部平均法的弊端(图像模糊)，目前已提出许多保持边缘、细节的局部平滑算法。它们的出发点都集中在如何选择邻域的大小、形状和方向、参数加平均及邻域各店的权重系数等。\n**图像高斯平滑也是邻域平均的思想对图像进行平滑的一种方法**，在图像高斯平滑中，对图像进行平均时，不同位置的像素被赋予了不同的权重。高斯平滑与简单平滑不同，它在对邻域内像素进行平均时，给予不同位置的像素不同的权值，下图的所示的 3 * 3 和 5 * 5 领域的高斯模板。\n\n**其实就是用二维高斯去生成一个卷积核**\n\n![image-20210517100746197](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/d9525903cbf9afe8b2274131a8b454dc.png)\n\n\n\n### 总结\n\n到这里，一些基本得卷积算法就已经剖析完毕，剩下得就只是对这些卷积核做一定处理。\n\n\n\n### **引申滤波的概念**\n\n滤波的目的主要两个：\n\n1.通过滤波来提取图像特征，简化图像所带的信息作为后续其它的图像处理\n\n2.为适应图像处理的需求，通过滤波消除图像数字化时所混入的噪声\n\n**其中第一点就是边缘检测中所使用的基本思想，即简化图像信息，使用边缘线代表图像所携带信息**\n\n**滤波可理解为滤波器(通常为3*3、5*5矩阵)在图像上进行从上到下，从左到右的遍历，计算滤波器与对应像素的值并根据滤波目的进行数值计算返回值到当前像素点**，实际就是卷积\n\n\n\n\n\n## 图像几何变换（缩放、图像旋转、图像翻转与图像平移）\n\n主要知识：**线性代数**\n\n### 提前概念\n\n对于一个图像，我们可以表达成一个**二维函数**\n\n$$f(x, y) = 色值 $$\n\n**而几何变换，并不改变色值，仅仅改变x，y得位置。**\n\n也就是说\n\n$$f(x^{`}, y^{`}) = f(x, y)$$\n\n**是一个映射**\n\n\n\n**（以下得图转载）**\n\n### 平移\n\n![image-20210515144701393](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/b2fce96fbb8c74f1c2cb9902dcaa9c68.png)\n\n\n\n### 缩放\n\n![image-20210515144734355](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/fd41ef949d9d0f9342da8e83640b3fc1.png)\n\n### 旋转\n\n![image-20210515144811005](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/d05eb9f612c3792dbbc3d6f9d7486cca.png)\n\n### 镜像变换\n\n![image-20210515145002510](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/95d09b33b89068365bf9bae6a0028389.png)\n\n\n\n\n\n### 插值算法\n\n关于以上变换有个要注意得问题。\n\n**变换后得坐标，定义域不一定和值域完全重合。**\n\n也就是说，变换后得点可能落不到整数上（一种情况。）\n\n**那么就需要插值算法了。** （简单起见，这里只讲线性插值算法）\n\n\n\n先讲一下整体得套路：\n\n\n\n![7B0D9C468E20156153764274EE6DAABA](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/c8cc26d6cfd020290b757289e0a21486.png)\n\n#### 邻近插值算法\n\n简单来说就是，直接对x和y进行取整。\n\n按照上述思路实现。\n\n![image-20210515185639914](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/ca4ba14ff7ecf0625b840a83c51535c4.png)\n\n不难看出，效果还行。\n\n试试旋转矩阵\n\n![image-20210515193419491](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/ada1ca6ce4fcc253cc936cd9ba1ebd38.png)\n\n\n\n#### 双线性插值\n\n**双线性插值是线性插值在二维时的推广,在两个方向上共做了三次线性插值。**定义了一个双曲抛物面与四个已知点拟合。\n\n具体操作为在X方向上进行两次线性插值计算，然后在Y方向上进行一次插值计算\n\n![image-20210515185941228](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/c943151c48efef8c4e8b14335bd00cf5.png)\n\n**具体得公式**\n\n![image-20210515190007957](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/67eddb619bd8277f01dc03339b6f8009.png)\n\n\n\n**（我这里踩了坑，原有的图像数据的大小是8位的，最大255）所以在上述运算中很容易就溢出了。**\n\n结果\n\n![image-20210515222501615](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/4da8e80612ea6115e92c6ebea9587fa5.png)\n\n**success**\n\n\n\n## 仿射变换与透视变换\n\n### 提前概念（二维为例子）\n\n- 什么是线性变换？\n\n$$\nx^{,}= A \\cdot x_{0}\n$$\n\n原点不变，且原有的平行关系和倍数关系都不变\n\n### 仿射变换\n\n在线性变换的基础上，**原点可以发生变换**。\n\n仿射变换是单纯对图片进行平移，缩放，倾斜和旋转，而这几个操作都不会改变图片线之间的平行关系。\n\n$$\nx^{,}= A \\cdot x_{0} + b\n$$\n\n如果用三维去线性表达，那么就是：\n$$\n\\begin{bmatrix}\nx^{,}\\\\ \ny^{,}\\\\ \n1\n\n\\end{bmatrix}\n= \n\n\\begin{bmatrix}\na11 &a12  &b1 \\\\ \na21 &  a22& b2\\\\ \n 0&0  & 1\n\\end{bmatrix}\n\n\\cdot\n\n\\begin{bmatrix}\nx\\\\ \ny\\\\ \n1\n\n\\end{bmatrix}\n$$\n\n### 什么是透视变换\n\n如果说仿射变换是在二维空间中的旋转，平移和缩放。**那么透视变换则是在三维空间中视角的变化。**\n\n**相对于仿射。透视变换能保持“直线性”，即原图像里面的直线，经透视变换后仍为直线**\n\n![image-20210515224105702](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/46eb52459edc83ef1dcfccaaa8e144d0.png)\n\n\n\n\n\n这里讲一下，如果说，仿射变化是三维空间中对某个平面的一些二维变化。\n\n那么透视变化就是对这个平面进行变换，并且利用视觉原理将图像进行一定处理（近大，远小）。\n\n![OpenCV-透视变换及对二维点求透视变换之后的坐标_leonardohaig的博客-CSDN博客](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/54e4529e9550f5cc8881ef96792434b9.png)\n\n\n\n**也就是说，先将图像旋转到$A^{,}B^{,}C^{,}$**\n\n**然后投影到平面$ABC$**\n\n**这里有一下假设，假设我们人是远点，从我们的眼睛去看，垂直与我们的目光的这个轴是$z$轴.**\n\n**在离我们一定距离的地方选一个画布$ABC$，其他所有画像都投影到这个画布上。**\n\n**那么假设平面$z$轴的距离是1.**\n\n**从$A^{,}B^{,}C^{,}$投影到画布$ABC$，计算公式为**\n\n$$\n\\begin{bmatrix}\nx\\\\ \ny\\\\ \n1\n\n\\end{bmatrix}\n=\n(1/z^{,}) \\cdot\n\\begin{bmatrix}\nx^{,}\\\\ \ny^{,}\\\\ \nz^{,}\n\n\\end{bmatrix}\n$$\n\n\n\n有了以上概念，**我们来最后计算一遍**\n\n![image-20210516140838713](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/3d1d091fab6e8ef34769c3833d999b0a.png)\n\n**先进行旋转变换。**\n\n**然后进行投影变换。**\n\n![image-20210516140914286](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/00e32af988032c970845ede0f2f9b581.png)\n\n\n\n然后就是繁琐的解方程过程，**这里是非齐次线性方程组求解**\n\n![image-20210516140938930](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/a92fd5ff6b904e4d6b308b447bf2e97c.png)\n\n\n\n让我们来看一下最后效果。\n\n![image-20210516141108490](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/6b75bb88d0f41f9710a2872e6e6c9f7e.png)\n\n\n\n右边是我们手动实现的。\n\n具体的思路是仿照**opencv**，不过代码是手动用**numpy**实现的，有助于理解。\n\n**核心代码**\n\n```\n#根据四个顶点设置图像透视变换矩阵\npos1 = np.float32([[114, 82], [287, 156], [8, 322], [216, 333]])  # 原来的坐标\npos2 = np.float32([[0, 0], [188, 0], [0, 262], [188, 262]])    # 变换后的坐标\n\n# 实际肉眼看上去的x，y和数组的存储是有区别的\ndef exchangeXY(pos):\n    for i in range(len(pos)):\n        pos[i] = [pos[i][1], pos[i][0]]\n\nexchangeXY(pos1)\nexchangeXY(pos2)\n\n# 计算透视变换矩阵\ndef getPerspectiveTransform(pos1, pos2):\n    length = len(pos1)\n    tmpMatrix = []\n    b = []\n    for i in range(length):\n        x0, y0 = pos1[i]\n        xn, yn = pos2[i]\n        tmpMatrix.append(\n            [x0, y0,1,0,0,0,-1 * x0 * xn, -1 * y0 * xn]\n        )\n        tmpMatrix.append(\n            [0,0,0,x0, y0,1,-1 * x0 * yn, -1 * y0 * yn]\n        )\n\n        b.append(xn)\n        b.append(yn)\n\n\n    tmpMatrix= np.array(tmpMatrix)\n    b = np.array(b)\n    ans =np.dot(np.linalg.inv(tmpMatrix), b)\n    finalMatrix = [\n        [ans[0], ans[1], ans[2]],\n        [ans[3], ans[4], ans[5]],\n        [ans[6], ans[7], 1]\n\n    ]\n    return np.array(finalMatrix)\n\nM = getPerspectiveTransform(pos1, pos2)\n```\n\n\n\n\n\n\n\n## 图像阈值化\n\n图像的二值化或阈值化（Binarization）旨在提取图像中的目标物体，将背景以及噪声区分开来。通常会设定一个阈值T，通过T将图像的像素划分为两类：大于T的像素群和小于T的像素群。\n\n![image-20210516195934138](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/86e4d4c06ed913297cf73df917113377.png)\n\n\n\n**二进制阈值化**\n\n![image-20210516200029306](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/e4bcc8740e408805c15aecc64e58da64.png)\n\n\n\n\n\n所谓其他阈值化，其实也就是不断在基础形式上都不同的类进行一定处理。\n\n## 灰度直方图\n\n### 前置概念\n\n**RGB图像：**\n\nRGB的值分别为0，0，0 表示的是黑色。\n\nRGB的值为255，255，255表示的是白色。\n\n**灰度图像：**\n\n灰度值为0表示黑色。\n\n灰度值为255表示白色。\n\n### 定义\n\n灰度直方图（histogram）是灰度级的函数，描述的是图像中每种灰度级像素的个数，反映图像中每种灰度出现的频率。横坐标是灰度级，纵坐标是灰度级出现的频率。\n\n![image-20210516200650255](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/14f8ae266ebabeb3c974b160502bf0d5.png)\n\n\n\n**用处：**\n\n在使用轮廓线确定物体边界时，通过直方图更好的选择边界阈值，进行阈值化处理；对物体与背景有较强对比的景物的分割特别有用；简单物体的面积和综合光密度IOD可以通过图像的直方图求得。\n\n\n\n### 直方图修正\n\n图像的直方图修正方法主要有直方图均衡化和直方图规定化直方图修正的目的是，**使修正后的图像的灰度间距拉开或者是图像灰度分布均匀，从而增大反差，使图像细节清晰，从而达到图像增强的目的**\n\n我们这里主要**直方图均衡化**。\n\n算法原理，把原有的概率乘以一个数（通常是色值的大小，取整）。这样就可以把一些较为相近的值给化到一起了。\n\n\n\n\n\n\n\n## 灰度值处理\n\n**rbg如何变为灰度值图像呢？**\n\n一种常见的方法是将RGB三个分量求和再取平均值，但更为准确的方法是设置不同的权重，将RGB分量按不同的比例进行灰度划分。比如人类的眼睛感官蓝色的敏感度最低，敏感最高的是绿色，因此将RGB按照0.299、0.587、0.144比例加权平均能得到较合理的灰度图像，\n\n![image-20210516201613044](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/d39f859b6c1f17c27dfe1eb8281277ca.png)\n\n\n\n## 图像灰度线性变换\n\n图像的灰度线性变换是通过建立灰度映射来调整原始图像的灰度，从而改善图像的质量，凸显图像的细节，**提高图像的对比度**\n\n$$\nf(D) = S \\cdot D + b\n$$\n\n**图像灰度非线性变换**\n\n- 例如什么一元二次函数\n- 对数变换\n- 伽玛变换又称为指数变换或幂次变换，是另一种常用的灰度非线性变换。就是指数函数\n\n## 图像锐化\n\n展图像锐化和边缘检测处理，加强原图像的高频部分。锐化突出图像的边缘细节，改善图像的对比度，使模糊的图像变得更清晰。\n\n图像锐化和边缘提取技术可以消除图像中的噪声，**提取图像信息中用来表征图像的一些变量**，为图像识别提供基础。\n\n通常使用**灰度差分法**对图像的边缘、轮廓进行处理，将其凸显。\n\n**如果把每一种算法都用卷积核来表示成矩阵的乘法，那么实际上就是一种卷积运算了**\n\n### Roberts算子（梯度法）\n\n**通过计算梯度从而凸显轮廓**\n\n对于图像 ![[公式]](https://www.zhihu.com/equation?tex=f%28x%2Cy%29) ,在点 ![[公式]](https://www.zhihu.com/equation?tex=%28x%2Cy%29) 处的梯度是一个矢量，定义为![[公式]](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/5d69f9d401c2fd45a0441959401fa85a.png)。\n\n梯度的幅度表示为 ![[公式]](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/e8fbf647c96fe6ec562eabb8ddadf43f.png)\n\n对于数字图像而言， ![[公式]](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/1dec5220f81575ccae6738b7d2466848.png) ，\n\n该式可以简化成 ![[公式]](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/59b6fc46f008b96c4914393b9731915e.png)\n\n\n\n**当梯度计算完之后，可以根据需要生成不同的梯度增强图像，**\n\n1）第一种， ![[公式]](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/bf834d39b57899bd1287107a509ea2cd.png) ，只显示灰度变化大的边缘轮廓，灰度变化平缓的呈黑色。\n\n2）第二种， ![[公式]](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/8d1049d104a4514f8715597d718d8069.png)\n\n可以显示出非常明显的边缘轮廓，又不会破坏原灰度变化平缓的背景。\n\n3）第三种， ![[公式]](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/f3b342875660dc887dcbd05121d8025d.png)\n\n。。。。还有很多类似的\n\n### **Sobel算子**\n\n采用梯度微分锐化图像，会让噪声、条纹得到增强，Sobel算子在一定程度上解决了这个问题， ![[公式]](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/8b9e97d5e86c30259dfe8709143352e3.png)\n\n从这个式子中，可以得到两个性质，\n\n- Sobel引入了平均的因素，因此对噪声有一定的平滑作用\n\n- Sobel算子的操作就是相隔两个行（列）的差分，所以边缘两侧元素的得到了增强，因此边缘显得粗而亮。\n\n- Sobel算子表示形式为：\n\n  ![[公式]](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/21ff5ffbd08ae34f86890889c335e850.png)\n\n###  **拉普拉斯算子（二阶微分）**\n\n拉普拉斯运算也是各向同性的线性运算。拉普拉斯算子为： ![[公式]](https://www.zhihu.com/equation?tex=+%5Cnabla+%5E2f%3D%5Cfrac%7B%5Cpartial+%5E2f%7D%7B%5Cpartial+x%5E2%7D%2B%5Cfrac%7B%5Cpartial+%5E2f%7D%7B%5Cpartial+y%5E2%7D++) ,锐化之后的图像 ![[公式]](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/05df0a4434c3b690175bd3491e580147.png)\n\n![[公式]](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/5a1c7b5cfeb56ef056d85fb12781544a.png) 为扩散效应的系数。\n\n![[公式]](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/c3d8d679c4bcc9fb05de4e54af9d5044.png)\n\n![[公式]](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/3c2471b3e33e37a96943870aa3f76c3d.png)\n\n由此式可知，数字图像在 ![[公式]](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/4930ba4025f56d086cf539962a9f0f08.png) 点的拉普拉斯算子，可以由该点的灰度值减去该点及其邻域四个点的平均灰度值求得。\n\n\n\n\n\n### Canny算子\n\n**1.使用高斯平滑（如公式所示）去除噪声。**\n\n![image-20210517111128781](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/5d6282b25a7dd374504724d07aec9471.png)\n\n**2.按照Sobel滤波器步骤计算梯度幅值和方向，寻找图像的强度梯度。先将卷积模板分别作用x和y方向，再计算梯度幅值和方向，其公式如下所示。梯度方向一般取0度、45度、90度和135度四个方向。**\n\n![image-20210517111159837](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/44a4ec5fe12053aad7f1576a45bc43b6.png)\n\n**3.通过非极大值抑制（Non-maximum Suppression）过滤掉非边缘像素，将模糊的边界变得清晰。该过程保留了每个像素点上梯度强度的极大值，过滤掉其他的值。**\n\n\n\n**4.利用滞后技术来跟踪边界。若某一像素位置和强边界相连的弱边界认为是边界，其他的弱边界则被删除。**\n\n\n\n\n\n## 边缘线检测\n\n边缘检测算法主要是基于图像强度的一阶和二阶导数，但**导数通常对噪声很敏感，**因此需要采用**滤波器来过滤噪声**，并**调用图像增强或阈值化算法进行处理**，**最后再进行边缘检测**。\n\n而所谓边缘检测，其实是用锐化算法算出边缘，然后通过一些细节处理捕捉边缘。\n","slug":"综合/数字图像处理","published":1,"date":"2023-02-26T15:28:35.066Z","updated":"2023-02-27T11:34:33.142Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsyd700210gcnjzmh38gg","content":"<h1 id=\"数字图像处理\"><a href=\"#数字图像处理\" class=\"headerlink\" title=\"数字图像处理\"></a>数字图像处理</h1><p>本博客主要涉及算法方面。需要堆图形由一定了解</p>\n<h2 id=\"预处理，加载，存储\"><a href=\"#预处理，加载，存储\" class=\"headerlink\" title=\"预处理，加载，存储\"></a>预处理，加载，存储</h2><p>使用<strong>pillow</strong>进行加载</p>\n<pre><code>from PIL import Image\nim = Image.open(&#39;./../image/lena.png&#39;)</code></pre><p>存储</p>\n<pre><code># 把图像用png格式保存:\nim.save(&#39;thumbnail.png&#39;, &#39;png&#39;)</code></pre><p> 转换成<strong>numpy</strong>形式</p>\n<pre><code>img = np.array(im)      # image类 转 numpy</code></pre><p>将<strong>numpy</strong>格式数组用图片显示</p>\n<pre><code>from matplotlib import pyplot as plt\nplt.imshow(img)\nplt.show()</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/333857553eedebc6deb8e041b4545289.png\" alt=\"image-20210515125837128\"></p>\n<p>分为不同得<strong>通道</strong>显示</p>\n<pre><code>b = img[:,:,0:1]\nplt.imshow(img, &#39;Blues&#39;)</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/927046a194025ee3737ec606f971dc0f.png\" alt=\"image-20210515125815860\"></p>\n<h2 id=\"关于图像平滑处理\"><a href=\"#关于图像平滑处理\" class=\"headerlink\" title=\"关于图像平滑处理\"></a>关于图像平滑处理</h2><h3 id=\"首先对图像添加噪声\"><a href=\"#首先对图像添加噪声\" class=\"headerlink\" title=\"首先对图像添加噪声\"></a>首先对图像添加噪声</h3><p>我们这里添加白色小点得噪声</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/15d8b11c13f91f944e46ebe71a19ab91.png\" alt=\"image-20210515130157855\"></p>\n<p><strong>白色得噪声是（255，255，255）</strong></p>\n<p>得到噪声图</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/5b13d9bf970f9413668d1cecf0b27609.png\" alt=\"image-20210515143316188\"></p>\n<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>图像平滑是一种区域增强的算法，平滑算法有<strong>邻域平均法、中指滤波、边界保持类滤波</strong>等。在图像产生、传输和复制过程中，常常会因为多方面原因而<strong>被噪声干扰或出现数据丢失，降低了图像的质量</strong>（某一像素，如果它与周围像素点相比有明显的不同，则该点被噪声所感染）。这就需要<strong>对图像进行一定的增强处理以减小这些缺陷带来的影响</strong>。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/35297be9cf4efdf048196eb5138323c7.png\" alt=\"img\"></p>\n<h3 id=\"邻域平均法和均值滤波\"><a href=\"#邻域平均法和均值滤波\" class=\"headerlink\" title=\"邻域平均法和均值滤波\"></a>邻域平均法和均值滤波</h3><p>其实就是一个<strong>卷积运算</strong></p>\n<p>可以类比一下卷积神经网络</p>\n<p>$$g(x,y)= 1/M  \\sum_{(x,y)∈S} f(x,y)$$</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/5343ce925ad238e9703e83ae8204d358.png\" alt=\"image-20210515132244573\"></p>\n<p><strong>如图</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/5758d6bca49a5c3c0f0085379ea926bc.png\" alt=\"image-20210515132401506\"></p>\n<ul>\n<li>我们这里先写一个单通道单核得卷积</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/96e3429d00a616af6f0ecbd9dba263eb.png\" alt=\"image-20210515134556505\"></p>\n<ul>\n<li><p>初始化一个卷积核</p>\n<pre><code># filterKernel = np.array([\n#     [1, 1, 1],\n#     [1, 1, 1],\n#     [1, 1, 1]\n# ])\nfilterKernel = np.ones((6,6))</code></pre></li>\n</ul>\n<ul>\n<li>查看结果</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/4c10222326786736ab57b0127f064dd2.png\" alt=\"image-20210515134707303\"></p>\n<ul>\n<li><p><strong>很明显有效果， 然后就是变单通道为多通道，单核为多核</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/c09bd424c04c84d241b42755255f61b9.png\" alt=\"image-20210515143402138\"></p>\n</li>\n</ul>\n<p><strong>success</strong></p>\n<h3 id=\"高斯平滑\"><a href=\"#高斯平滑\" class=\"headerlink\" title=\"高斯平滑\"></a>高斯平滑</h3><p>为了克服简单局部平均法的弊端(图像模糊)，目前已提出许多保持边缘、细节的局部平滑算法。它们的出发点都集中在如何选择邻域的大小、形状和方向、参数加平均及邻域各店的权重系数等。<br><strong>图像高斯平滑也是邻域平均的思想对图像进行平滑的一种方法</strong>，在图像高斯平滑中，对图像进行平均时，不同位置的像素被赋予了不同的权重。高斯平滑与简单平滑不同，它在对邻域内像素进行平均时，给予不同位置的像素不同的权值，下图的所示的 3 * 3 和 5 * 5 领域的高斯模板。</p>\n<p><strong>其实就是用二维高斯去生成一个卷积核</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/d9525903cbf9afe8b2274131a8b454dc.png\" alt=\"image-20210517100746197\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>到这里，一些基本得卷积算法就已经剖析完毕，剩下得就只是对这些卷积核做一定处理。</p>\n<h3 id=\"引申滤波的概念\"><a href=\"#引申滤波的概念\" class=\"headerlink\" title=\"引申滤波的概念\"></a><strong>引申滤波的概念</strong></h3><p>滤波的目的主要两个：</p>\n<p>1.通过滤波来提取图像特征，简化图像所带的信息作为后续其它的图像处理</p>\n<p>2.为适应图像处理的需求，通过滤波消除图像数字化时所混入的噪声</p>\n<p><strong>其中第一点就是边缘检测中所使用的基本思想，即简化图像信息，使用边缘线代表图像所携带信息</strong></p>\n<p><strong>滤波可理解为滤波器(通常为3<em>3、5</em>5矩阵)在图像上进行从上到下，从左到右的遍历，计算滤波器与对应像素的值并根据滤波目的进行数值计算返回值到当前像素点</strong>，实际就是卷积</p>\n<h2 id=\"图像几何变换（缩放、图像旋转、图像翻转与图像平移）\"><a href=\"#图像几何变换（缩放、图像旋转、图像翻转与图像平移）\" class=\"headerlink\" title=\"图像几何变换（缩放、图像旋转、图像翻转与图像平移）\"></a>图像几何变换（缩放、图像旋转、图像翻转与图像平移）</h2><p>主要知识：<strong>线性代数</strong></p>\n<h3 id=\"提前概念\"><a href=\"#提前概念\" class=\"headerlink\" title=\"提前概念\"></a>提前概念</h3><p>对于一个图像，我们可以表达成一个<strong>二维函数</strong></p>\n<p>$$f(x, y) = 色值 $$</p>\n<p><strong>而几何变换，并不改变色值，仅仅改变x，y得位置。</strong></p>\n<p>也就是说</p>\n<p>$$f(x^{<code>}, y^{</code>}) = f(x, y)$$</p>\n<p><strong>是一个映射</strong></p>\n<p><strong>（以下得图转载）</strong></p>\n<h3 id=\"平移\"><a href=\"#平移\" class=\"headerlink\" title=\"平移\"></a>平移</h3><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/b2fce96fbb8c74f1c2cb9902dcaa9c68.png\" alt=\"image-20210515144701393\"></p>\n<h3 id=\"缩放\"><a href=\"#缩放\" class=\"headerlink\" title=\"缩放\"></a>缩放</h3><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/fd41ef949d9d0f9342da8e83640b3fc1.png\" alt=\"image-20210515144734355\"></p>\n<h3 id=\"旋转\"><a href=\"#旋转\" class=\"headerlink\" title=\"旋转\"></a>旋转</h3><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/d05eb9f612c3792dbbc3d6f9d7486cca.png\" alt=\"image-20210515144811005\"></p>\n<h3 id=\"镜像变换\"><a href=\"#镜像变换\" class=\"headerlink\" title=\"镜像变换\"></a>镜像变换</h3><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/95d09b33b89068365bf9bae6a0028389.png\" alt=\"image-20210515145002510\"></p>\n<h3 id=\"插值算法\"><a href=\"#插值算法\" class=\"headerlink\" title=\"插值算法\"></a>插值算法</h3><p>关于以上变换有个要注意得问题。</p>\n<p><strong>变换后得坐标，定义域不一定和值域完全重合。</strong></p>\n<p>也就是说，变换后得点可能落不到整数上（一种情况。）</p>\n<p><strong>那么就需要插值算法了。</strong> （简单起见，这里只讲线性插值算法）</p>\n<p>先讲一下整体得套路：</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/c8cc26d6cfd020290b757289e0a21486.png\" alt=\"7B0D9C468E20156153764274EE6DAABA\"></p>\n<h4 id=\"邻近插值算法\"><a href=\"#邻近插值算法\" class=\"headerlink\" title=\"邻近插值算法\"></a>邻近插值算法</h4><p>简单来说就是，直接对x和y进行取整。</p>\n<p>按照上述思路实现。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/ca4ba14ff7ecf0625b840a83c51535c4.png\" alt=\"image-20210515185639914\"></p>\n<p>不难看出，效果还行。</p>\n<p>试试旋转矩阵</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/ada1ca6ce4fcc253cc936cd9ba1ebd38.png\" alt=\"image-20210515193419491\"></p>\n<h4 id=\"双线性插值\"><a href=\"#双线性插值\" class=\"headerlink\" title=\"双线性插值\"></a>双线性插值</h4><p><strong>双线性插值是线性插值在二维时的推广,在两个方向上共做了三次线性插值。</strong>定义了一个双曲抛物面与四个已知点拟合。</p>\n<p>具体操作为在X方向上进行两次线性插值计算，然后在Y方向上进行一次插值计算</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/c943151c48efef8c4e8b14335bd00cf5.png\" alt=\"image-20210515185941228\"></p>\n<p><strong>具体得公式</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/67eddb619bd8277f01dc03339b6f8009.png\" alt=\"image-20210515190007957\"></p>\n<p><strong>（我这里踩了坑，原有的图像数据的大小是8位的，最大255）所以在上述运算中很容易就溢出了。</strong></p>\n<p>结果</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/4da8e80612ea6115e92c6ebea9587fa5.png\" alt=\"image-20210515222501615\"></p>\n<p><strong>success</strong></p>\n<h2 id=\"仿射变换与透视变换\"><a href=\"#仿射变换与透视变换\" class=\"headerlink\" title=\"仿射变换与透视变换\"></a>仿射变换与透视变换</h2><h3 id=\"提前概念（二维为例子）\"><a href=\"#提前概念（二维为例子）\" class=\"headerlink\" title=\"提前概念（二维为例子）\"></a>提前概念（二维为例子）</h3><ul>\n<li>什么是线性变换？</li>\n</ul>\n<p>$$<br>x^{,}= A \\cdot x_{0}<br>$$</p>\n<p>原点不变，且原有的平行关系和倍数关系都不变</p>\n<h3 id=\"仿射变换\"><a href=\"#仿射变换\" class=\"headerlink\" title=\"仿射变换\"></a>仿射变换</h3><p>在线性变换的基础上，<strong>原点可以发生变换</strong>。</p>\n<p>仿射变换是单纯对图片进行平移，缩放，倾斜和旋转，而这几个操作都不会改变图片线之间的平行关系。</p>\n<p>$$<br>x^{,}= A \\cdot x_{0} + b<br>$$</p>\n<p>如果用三维去线性表达，那么就是：<br>$$<br>\\begin{bmatrix}<br>x^{,}\\<br>y^{,}\\<br>1</p>\n<p>\\end{bmatrix}<br>= </p>\n<p>\\begin{bmatrix}<br>a11 &amp;a12  &amp;b1 \\<br>a21 &amp;  a22&amp; b2\\<br> 0&amp;0  &amp; 1<br>\\end{bmatrix}</p>\n<p>\\cdot</p>\n<p>\\begin{bmatrix}<br>x\\<br>y\\<br>1</p>\n<p>\\end{bmatrix}<br>$$</p>\n<h3 id=\"什么是透视变换\"><a href=\"#什么是透视变换\" class=\"headerlink\" title=\"什么是透视变换\"></a>什么是透视变换</h3><p>如果说仿射变换是在二维空间中的旋转，平移和缩放。<strong>那么透视变换则是在三维空间中视角的变化。</strong></p>\n<p><strong>相对于仿射。透视变换能保持“直线性”，即原图像里面的直线，经透视变换后仍为直线</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/46eb52459edc83ef1dcfccaaa8e144d0.png\" alt=\"image-20210515224105702\"></p>\n<p>这里讲一下，如果说，仿射变化是三维空间中对某个平面的一些二维变化。</p>\n<p>那么透视变化就是对这个平面进行变换，并且利用视觉原理将图像进行一定处理（近大，远小）。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/54e4529e9550f5cc8881ef96792434b9.png\" alt=\"OpenCV-透视变换及对二维点求透视变换之后的坐标_leonardohaig的博客-CSDN博客\"></p>\n<p><strong>也就是说，先将图像旋转到$A^{,}B^{,}C^{,}$</strong></p>\n<p><strong>然后投影到平面$ABC$</strong></p>\n<p><strong>这里有一下假设，假设我们人是远点，从我们的眼睛去看，垂直与我们的目光的这个轴是$z$轴.</strong></p>\n<p><strong>在离我们一定距离的地方选一个画布$ABC$，其他所有画像都投影到这个画布上。</strong></p>\n<p><strong>那么假设平面$z$轴的距离是1.</strong></p>\n<p><strong>从$A^{,}B^{,}C^{,}$投影到画布$ABC$，计算公式为</strong></p>\n<p>$$<br>\\begin{bmatrix}<br>x\\<br>y\\<br>1</p>\n<p>\\end{bmatrix}<br>=<br>(1/z^{,}) \\cdot<br>\\begin{bmatrix}<br>x^{,}\\<br>y^{,}\\<br>z^{,}</p>\n<p>\\end{bmatrix}<br>$$</p>\n<p>有了以上概念，<strong>我们来最后计算一遍</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/3d1d091fab6e8ef34769c3833d999b0a.png\" alt=\"image-20210516140838713\"></p>\n<p><strong>先进行旋转变换。</strong></p>\n<p><strong>然后进行投影变换。</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/00e32af988032c970845ede0f2f9b581.png\" alt=\"image-20210516140914286\"></p>\n<p>然后就是繁琐的解方程过程，<strong>这里是非齐次线性方程组求解</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/a92fd5ff6b904e4d6b308b447bf2e97c.png\" alt=\"image-20210516140938930\"></p>\n<p>让我们来看一下最后效果。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/6b75bb88d0f41f9710a2872e6e6c9f7e.png\" alt=\"image-20210516141108490\"></p>\n<p>右边是我们手动实现的。</p>\n<p>具体的思路是仿照<strong>opencv</strong>，不过代码是手动用<strong>numpy</strong>实现的，有助于理解。</p>\n<p><strong>核心代码</strong></p>\n<pre><code>#根据四个顶点设置图像透视变换矩阵\npos1 = np.float32([[114, 82], [287, 156], [8, 322], [216, 333]])  # 原来的坐标\npos2 = np.float32([[0, 0], [188, 0], [0, 262], [188, 262]])    # 变换后的坐标\n\n# 实际肉眼看上去的x，y和数组的存储是有区别的\ndef exchangeXY(pos):\n    for i in range(len(pos)):\n        pos[i] = [pos[i][1], pos[i][0]]\n\nexchangeXY(pos1)\nexchangeXY(pos2)\n\n# 计算透视变换矩阵\ndef getPerspectiveTransform(pos1, pos2):\n    length = len(pos1)\n    tmpMatrix = []\n    b = []\n    for i in range(length):\n        x0, y0 = pos1[i]\n        xn, yn = pos2[i]\n        tmpMatrix.append(\n            [x0, y0,1,0,0,0,-1 * x0 * xn, -1 * y0 * xn]\n        )\n        tmpMatrix.append(\n            [0,0,0,x0, y0,1,-1 * x0 * yn, -1 * y0 * yn]\n        )\n\n        b.append(xn)\n        b.append(yn)\n\n\n    tmpMatrix= np.array(tmpMatrix)\n    b = np.array(b)\n    ans =np.dot(np.linalg.inv(tmpMatrix), b)\n    finalMatrix = [\n        [ans[0], ans[1], ans[2]],\n        [ans[3], ans[4], ans[5]],\n        [ans[6], ans[7], 1]\n\n    ]\n    return np.array(finalMatrix)\n\nM = getPerspectiveTransform(pos1, pos2)</code></pre><h2 id=\"图像阈值化\"><a href=\"#图像阈值化\" class=\"headerlink\" title=\"图像阈值化\"></a>图像阈值化</h2><p>图像的二值化或阈值化（Binarization）旨在提取图像中的目标物体，将背景以及噪声区分开来。通常会设定一个阈值T，通过T将图像的像素划分为两类：大于T的像素群和小于T的像素群。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/86e4d4c06ed913297cf73df917113377.png\" alt=\"image-20210516195934138\"></p>\n<p><strong>二进制阈值化</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/e4bcc8740e408805c15aecc64e58da64.png\" alt=\"image-20210516200029306\"></p>\n<p>所谓其他阈值化，其实也就是不断在基础形式上都不同的类进行一定处理。</p>\n<h2 id=\"灰度直方图\"><a href=\"#灰度直方图\" class=\"headerlink\" title=\"灰度直方图\"></a>灰度直方图</h2><h3 id=\"前置概念\"><a href=\"#前置概念\" class=\"headerlink\" title=\"前置概念\"></a>前置概念</h3><p><strong>RGB图像：</strong></p>\n<p>RGB的值分别为0，0，0 表示的是黑色。</p>\n<p>RGB的值为255，255，255表示的是白色。</p>\n<p><strong>灰度图像：</strong></p>\n<p>灰度值为0表示黑色。</p>\n<p>灰度值为255表示白色。</p>\n<h3 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>灰度直方图（histogram）是灰度级的函数，描述的是图像中每种灰度级像素的个数，反映图像中每种灰度出现的频率。横坐标是灰度级，纵坐标是灰度级出现的频率。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/14f8ae266ebabeb3c974b160502bf0d5.png\" alt=\"image-20210516200650255\"></p>\n<p><strong>用处：</strong></p>\n<p>在使用轮廓线确定物体边界时，通过直方图更好的选择边界阈值，进行阈值化处理；对物体与背景有较强对比的景物的分割特别有用；简单物体的面积和综合光密度IOD可以通过图像的直方图求得。</p>\n<h3 id=\"直方图修正\"><a href=\"#直方图修正\" class=\"headerlink\" title=\"直方图修正\"></a>直方图修正</h3><p>图像的直方图修正方法主要有直方图均衡化和直方图规定化直方图修正的目的是，<strong>使修正后的图像的灰度间距拉开或者是图像灰度分布均匀，从而增大反差，使图像细节清晰，从而达到图像增强的目的</strong></p>\n<p>我们这里主要<strong>直方图均衡化</strong>。</p>\n<p>算法原理，把原有的概率乘以一个数（通常是色值的大小，取整）。这样就可以把一些较为相近的值给化到一起了。</p>\n<h2 id=\"灰度值处理\"><a href=\"#灰度值处理\" class=\"headerlink\" title=\"灰度值处理\"></a>灰度值处理</h2><p><strong>rbg如何变为灰度值图像呢？</strong></p>\n<p>一种常见的方法是将RGB三个分量求和再取平均值，但更为准确的方法是设置不同的权重，将RGB分量按不同的比例进行灰度划分。比如人类的眼睛感官蓝色的敏感度最低，敏感最高的是绿色，因此将RGB按照0.299、0.587、0.144比例加权平均能得到较合理的灰度图像，</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/d39f859b6c1f17c27dfe1eb8281277ca.png\" alt=\"image-20210516201613044\"></p>\n<h2 id=\"图像灰度线性变换\"><a href=\"#图像灰度线性变换\" class=\"headerlink\" title=\"图像灰度线性变换\"></a>图像灰度线性变换</h2><p>图像的灰度线性变换是通过建立灰度映射来调整原始图像的灰度，从而改善图像的质量，凸显图像的细节，<strong>提高图像的对比度</strong></p>\n<p>$$<br>f(D) = S \\cdot D + b<br>$$</p>\n<p><strong>图像灰度非线性变换</strong></p>\n<ul>\n<li>例如什么一元二次函数</li>\n<li>对数变换</li>\n<li>伽玛变换又称为指数变换或幂次变换，是另一种常用的灰度非线性变换。就是指数函数</li>\n</ul>\n<h2 id=\"图像锐化\"><a href=\"#图像锐化\" class=\"headerlink\" title=\"图像锐化\"></a>图像锐化</h2><p>展图像锐化和边缘检测处理，加强原图像的高频部分。锐化突出图像的边缘细节，改善图像的对比度，使模糊的图像变得更清晰。</p>\n<p>图像锐化和边缘提取技术可以消除图像中的噪声，<strong>提取图像信息中用来表征图像的一些变量</strong>，为图像识别提供基础。</p>\n<p>通常使用<strong>灰度差分法</strong>对图像的边缘、轮廓进行处理，将其凸显。</p>\n<p><strong>如果把每一种算法都用卷积核来表示成矩阵的乘法，那么实际上就是一种卷积运算了</strong></p>\n<h3 id=\"Roberts算子（梯度法）\"><a href=\"#Roberts算子（梯度法）\" class=\"headerlink\" title=\"Roberts算子（梯度法）\"></a>Roberts算子（梯度法）</h3><p><strong>通过计算梯度从而凸显轮廓</strong></p>\n<p>对于图像 <img src=\"https://www.zhihu.com/equation?tex=f%28x%2Cy%29\" alt=\"[公式]\"> ,在点 <img src=\"https://www.zhihu.com/equation?tex=%28x%2Cy%29\" alt=\"[公式]\"> 处的梯度是一个矢量，定义为<img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/5d69f9d401c2fd45a0441959401fa85a.png\" alt=\"[公式]\">。</p>\n<p>梯度的幅度表示为 <img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/e8fbf647c96fe6ec562eabb8ddadf43f.png\" alt=\"[公式]\"></p>\n<p>对于数字图像而言， <img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/1dec5220f81575ccae6738b7d2466848.png\" alt=\"[公式]\"> ，</p>\n<p>该式可以简化成 <img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/59b6fc46f008b96c4914393b9731915e.png\" alt=\"[公式]\"></p>\n<p><strong>当梯度计算完之后，可以根据需要生成不同的梯度增强图像，</strong></p>\n<p>1）第一种， <img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/bf834d39b57899bd1287107a509ea2cd.png\" alt=\"[公式]\"> ，只显示灰度变化大的边缘轮廓，灰度变化平缓的呈黑色。</p>\n<p>2）第二种， <img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/8d1049d104a4514f8715597d718d8069.png\" alt=\"[公式]\"></p>\n<p>可以显示出非常明显的边缘轮廓，又不会破坏原灰度变化平缓的背景。</p>\n<p>3）第三种， <img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/f3b342875660dc887dcbd05121d8025d.png\" alt=\"[公式]\"></p>\n<p>。。。。还有很多类似的</p>\n<h3 id=\"Sobel算子\"><a href=\"#Sobel算子\" class=\"headerlink\" title=\"Sobel算子\"></a><strong>Sobel算子</strong></h3><p>采用梯度微分锐化图像，会让噪声、条纹得到增强，Sobel算子在一定程度上解决了这个问题， <img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/8b9e97d5e86c30259dfe8709143352e3.png\" alt=\"[公式]\"></p>\n<p>从这个式子中，可以得到两个性质，</p>\n<ul>\n<li><p>Sobel引入了平均的因素，因此对噪声有一定的平滑作用</p>\n</li>\n<li><p>Sobel算子的操作就是相隔两个行（列）的差分，所以边缘两侧元素的得到了增强，因此边缘显得粗而亮。</p>\n</li>\n<li><p>Sobel算子表示形式为：</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/21ff5ffbd08ae34f86890889c335e850.png\" alt=\"[公式]\"></p>\n</li>\n</ul>\n<h3 id=\"拉普拉斯算子（二阶微分）\"><a href=\"#拉普拉斯算子（二阶微分）\" class=\"headerlink\" title=\"拉普拉斯算子（二阶微分）\"></a><strong>拉普拉斯算子（二阶微分）</strong></h3><p>拉普拉斯运算也是各向同性的线性运算。拉普拉斯算子为： <img src=\"https://www.zhihu.com/equation?tex=+%5Cnabla+%5E2f%3D%5Cfrac%7B%5Cpartial+%5E2f%7D%7B%5Cpartial+x%5E2%7D%2B%5Cfrac%7B%5Cpartial+%5E2f%7D%7B%5Cpartial+y%5E2%7D++\" alt=\"[公式]\"> ,锐化之后的图像 <img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/05df0a4434c3b690175bd3491e580147.png\" alt=\"[公式]\"></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/5a1c7b5cfeb56ef056d85fb12781544a.png\" alt=\"[公式]\"> 为扩散效应的系数。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/c3d8d679c4bcc9fb05de4e54af9d5044.png\" alt=\"[公式]\"></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/3c2471b3e33e37a96943870aa3f76c3d.png\" alt=\"[公式]\"></p>\n<p>由此式可知，数字图像在 <img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/4930ba4025f56d086cf539962a9f0f08.png\" alt=\"[公式]\"> 点的拉普拉斯算子，可以由该点的灰度值减去该点及其邻域四个点的平均灰度值求得。</p>\n<h3 id=\"Canny算子\"><a href=\"#Canny算子\" class=\"headerlink\" title=\"Canny算子\"></a>Canny算子</h3><p><strong>1.使用高斯平滑（如公式所示）去除噪声。</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/5d6282b25a7dd374504724d07aec9471.png\" alt=\"image-20210517111128781\"></p>\n<p><strong>2.按照Sobel滤波器步骤计算梯度幅值和方向，寻找图像的强度梯度。先将卷积模板分别作用x和y方向，再计算梯度幅值和方向，其公式如下所示。梯度方向一般取0度、45度、90度和135度四个方向。</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/44a4ec5fe12053aad7f1576a45bc43b6.png\" alt=\"image-20210517111159837\"></p>\n<p><strong>3.通过非极大值抑制（Non-maximum Suppression）过滤掉非边缘像素，将模糊的边界变得清晰。该过程保留了每个像素点上梯度强度的极大值，过滤掉其他的值。</strong></p>\n<p><strong>4.利用滞后技术来跟踪边界。若某一像素位置和强边界相连的弱边界认为是边界，其他的弱边界则被删除。</strong></p>\n<h2 id=\"边缘线检测\"><a href=\"#边缘线检测\" class=\"headerlink\" title=\"边缘线检测\"></a>边缘线检测</h2><p>边缘检测算法主要是基于图像强度的一阶和二阶导数，但<strong>导数通常对噪声很敏感，</strong>因此需要采用<strong>滤波器来过滤噪声</strong>，并<strong>调用图像增强或阈值化算法进行处理</strong>，<strong>最后再进行边缘检测</strong>。</p>\n<p>而所谓边缘检测，其实是用锐化算法算出边缘，然后通过一些细节处理捕捉边缘。</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"数字图像处理\"><a href=\"#数字图像处理\" class=\"headerlink\" title=\"数字图像处理\"></a>数字图像处理</h1><p>本博客主要涉及算法方面。需要堆图形由一定了解</p>\n<h2 id=\"预处理，加载，存储\"><a href=\"#预处理，加载，存储\" class=\"headerlink\" title=\"预处理，加载，存储\"></a>预处理，加载，存储</h2><p>使用<strong>pillow</strong>进行加载</p>\n<pre><code>from PIL import Image\nim = Image.open(&#39;./../image/lena.png&#39;)</code></pre><p>存储</p>\n<pre><code># 把图像用png格式保存:\nim.save(&#39;thumbnail.png&#39;, &#39;png&#39;)</code></pre><p> 转换成<strong>numpy</strong>形式</p>\n<pre><code>img = np.array(im)      # image类 转 numpy</code></pre><p>将<strong>numpy</strong>格式数组用图片显示</p>\n<pre><code>from matplotlib import pyplot as plt\nplt.imshow(img)\nplt.show()</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/333857553eedebc6deb8e041b4545289.png\" alt=\"image-20210515125837128\"></p>\n<p>分为不同得<strong>通道</strong>显示</p>\n<pre><code>b = img[:,:,0:1]\nplt.imshow(img, &#39;Blues&#39;)</code></pre><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/927046a194025ee3737ec606f971dc0f.png\" alt=\"image-20210515125815860\"></p>\n<h2 id=\"关于图像平滑处理\"><a href=\"#关于图像平滑处理\" class=\"headerlink\" title=\"关于图像平滑处理\"></a>关于图像平滑处理</h2><h3 id=\"首先对图像添加噪声\"><a href=\"#首先对图像添加噪声\" class=\"headerlink\" title=\"首先对图像添加噪声\"></a>首先对图像添加噪声</h3><p>我们这里添加白色小点得噪声</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/15d8b11c13f91f944e46ebe71a19ab91.png\" alt=\"image-20210515130157855\"></p>\n<p><strong>白色得噪声是（255，255，255）</strong></p>\n<p>得到噪声图</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/5b13d9bf970f9413668d1cecf0b27609.png\" alt=\"image-20210515143316188\"></p>\n<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>图像平滑是一种区域增强的算法，平滑算法有<strong>邻域平均法、中指滤波、边界保持类滤波</strong>等。在图像产生、传输和复制过程中，常常会因为多方面原因而<strong>被噪声干扰或出现数据丢失，降低了图像的质量</strong>（某一像素，如果它与周围像素点相比有明显的不同，则该点被噪声所感染）。这就需要<strong>对图像进行一定的增强处理以减小这些缺陷带来的影响</strong>。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/35297be9cf4efdf048196eb5138323c7.png\" alt=\"img\"></p>\n<h3 id=\"邻域平均法和均值滤波\"><a href=\"#邻域平均法和均值滤波\" class=\"headerlink\" title=\"邻域平均法和均值滤波\"></a>邻域平均法和均值滤波</h3><p>其实就是一个<strong>卷积运算</strong></p>\n<p>可以类比一下卷积神经网络</p>\n<p>$$g(x,y)= 1/M  \\sum_{(x,y)∈S} f(x,y)$$</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/5343ce925ad238e9703e83ae8204d358.png\" alt=\"image-20210515132244573\"></p>\n<p><strong>如图</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/5758d6bca49a5c3c0f0085379ea926bc.png\" alt=\"image-20210515132401506\"></p>\n<ul>\n<li>我们这里先写一个单通道单核得卷积</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/96e3429d00a616af6f0ecbd9dba263eb.png\" alt=\"image-20210515134556505\"></p>\n<ul>\n<li><p>初始化一个卷积核</p>\n<pre><code># filterKernel = np.array([\n#     [1, 1, 1],\n#     [1, 1, 1],\n#     [1, 1, 1]\n# ])\nfilterKernel = np.ones((6,6))</code></pre></li>\n</ul>\n<ul>\n<li>查看结果</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/4c10222326786736ab57b0127f064dd2.png\" alt=\"image-20210515134707303\"></p>\n<ul>\n<li><p><strong>很明显有效果， 然后就是变单通道为多通道，单核为多核</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/c09bd424c04c84d241b42755255f61b9.png\" alt=\"image-20210515143402138\"></p>\n</li>\n</ul>\n<p><strong>success</strong></p>\n<h3 id=\"高斯平滑\"><a href=\"#高斯平滑\" class=\"headerlink\" title=\"高斯平滑\"></a>高斯平滑</h3><p>为了克服简单局部平均法的弊端(图像模糊)，目前已提出许多保持边缘、细节的局部平滑算法。它们的出发点都集中在如何选择邻域的大小、形状和方向、参数加平均及邻域各店的权重系数等。<br><strong>图像高斯平滑也是邻域平均的思想对图像进行平滑的一种方法</strong>，在图像高斯平滑中，对图像进行平均时，不同位置的像素被赋予了不同的权重。高斯平滑与简单平滑不同，它在对邻域内像素进行平均时，给予不同位置的像素不同的权值，下图的所示的 3 * 3 和 5 * 5 领域的高斯模板。</p>\n<p><strong>其实就是用二维高斯去生成一个卷积核</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/d9525903cbf9afe8b2274131a8b454dc.png\" alt=\"image-20210517100746197\"></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>到这里，一些基本得卷积算法就已经剖析完毕，剩下得就只是对这些卷积核做一定处理。</p>\n<h3 id=\"引申滤波的概念\"><a href=\"#引申滤波的概念\" class=\"headerlink\" title=\"引申滤波的概念\"></a><strong>引申滤波的概念</strong></h3><p>滤波的目的主要两个：</p>\n<p>1.通过滤波来提取图像特征，简化图像所带的信息作为后续其它的图像处理</p>\n<p>2.为适应图像处理的需求，通过滤波消除图像数字化时所混入的噪声</p>\n<p><strong>其中第一点就是边缘检测中所使用的基本思想，即简化图像信息，使用边缘线代表图像所携带信息</strong></p>\n<p><strong>滤波可理解为滤波器(通常为3<em>3、5</em>5矩阵)在图像上进行从上到下，从左到右的遍历，计算滤波器与对应像素的值并根据滤波目的进行数值计算返回值到当前像素点</strong>，实际就是卷积</p>\n<h2 id=\"图像几何变换（缩放、图像旋转、图像翻转与图像平移）\"><a href=\"#图像几何变换（缩放、图像旋转、图像翻转与图像平移）\" class=\"headerlink\" title=\"图像几何变换（缩放、图像旋转、图像翻转与图像平移）\"></a>图像几何变换（缩放、图像旋转、图像翻转与图像平移）</h2><p>主要知识：<strong>线性代数</strong></p>\n<h3 id=\"提前概念\"><a href=\"#提前概念\" class=\"headerlink\" title=\"提前概念\"></a>提前概念</h3><p>对于一个图像，我们可以表达成一个<strong>二维函数</strong></p>\n<p>$$f(x, y) = 色值 $$</p>\n<p><strong>而几何变换，并不改变色值，仅仅改变x，y得位置。</strong></p>\n<p>也就是说</p>\n<p>$$f(x^{<code>}, y^{</code>}) = f(x, y)$$</p>\n<p><strong>是一个映射</strong></p>\n<p><strong>（以下得图转载）</strong></p>\n<h3 id=\"平移\"><a href=\"#平移\" class=\"headerlink\" title=\"平移\"></a>平移</h3><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/b2fce96fbb8c74f1c2cb9902dcaa9c68.png\" alt=\"image-20210515144701393\"></p>\n<h3 id=\"缩放\"><a href=\"#缩放\" class=\"headerlink\" title=\"缩放\"></a>缩放</h3><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/fd41ef949d9d0f9342da8e83640b3fc1.png\" alt=\"image-20210515144734355\"></p>\n<h3 id=\"旋转\"><a href=\"#旋转\" class=\"headerlink\" title=\"旋转\"></a>旋转</h3><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/d05eb9f612c3792dbbc3d6f9d7486cca.png\" alt=\"image-20210515144811005\"></p>\n<h3 id=\"镜像变换\"><a href=\"#镜像变换\" class=\"headerlink\" title=\"镜像变换\"></a>镜像变换</h3><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/95d09b33b89068365bf9bae6a0028389.png\" alt=\"image-20210515145002510\"></p>\n<h3 id=\"插值算法\"><a href=\"#插值算法\" class=\"headerlink\" title=\"插值算法\"></a>插值算法</h3><p>关于以上变换有个要注意得问题。</p>\n<p><strong>变换后得坐标，定义域不一定和值域完全重合。</strong></p>\n<p>也就是说，变换后得点可能落不到整数上（一种情况。）</p>\n<p><strong>那么就需要插值算法了。</strong> （简单起见，这里只讲线性插值算法）</p>\n<p>先讲一下整体得套路：</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/c8cc26d6cfd020290b757289e0a21486.png\" alt=\"7B0D9C468E20156153764274EE6DAABA\"></p>\n<h4 id=\"邻近插值算法\"><a href=\"#邻近插值算法\" class=\"headerlink\" title=\"邻近插值算法\"></a>邻近插值算法</h4><p>简单来说就是，直接对x和y进行取整。</p>\n<p>按照上述思路实现。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/ca4ba14ff7ecf0625b840a83c51535c4.png\" alt=\"image-20210515185639914\"></p>\n<p>不难看出，效果还行。</p>\n<p>试试旋转矩阵</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/ada1ca6ce4fcc253cc936cd9ba1ebd38.png\" alt=\"image-20210515193419491\"></p>\n<h4 id=\"双线性插值\"><a href=\"#双线性插值\" class=\"headerlink\" title=\"双线性插值\"></a>双线性插值</h4><p><strong>双线性插值是线性插值在二维时的推广,在两个方向上共做了三次线性插值。</strong>定义了一个双曲抛物面与四个已知点拟合。</p>\n<p>具体操作为在X方向上进行两次线性插值计算，然后在Y方向上进行一次插值计算</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/c943151c48efef8c4e8b14335bd00cf5.png\" alt=\"image-20210515185941228\"></p>\n<p><strong>具体得公式</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/67eddb619bd8277f01dc03339b6f8009.png\" alt=\"image-20210515190007957\"></p>\n<p><strong>（我这里踩了坑，原有的图像数据的大小是8位的，最大255）所以在上述运算中很容易就溢出了。</strong></p>\n<p>结果</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/4da8e80612ea6115e92c6ebea9587fa5.png\" alt=\"image-20210515222501615\"></p>\n<p><strong>success</strong></p>\n<h2 id=\"仿射变换与透视变换\"><a href=\"#仿射变换与透视变换\" class=\"headerlink\" title=\"仿射变换与透视变换\"></a>仿射变换与透视变换</h2><h3 id=\"提前概念（二维为例子）\"><a href=\"#提前概念（二维为例子）\" class=\"headerlink\" title=\"提前概念（二维为例子）\"></a>提前概念（二维为例子）</h3><ul>\n<li>什么是线性变换？</li>\n</ul>\n<p>$$<br>x^{,}= A \\cdot x_{0}<br>$$</p>\n<p>原点不变，且原有的平行关系和倍数关系都不变</p>\n<h3 id=\"仿射变换\"><a href=\"#仿射变换\" class=\"headerlink\" title=\"仿射变换\"></a>仿射变换</h3><p>在线性变换的基础上，<strong>原点可以发生变换</strong>。</p>\n<p>仿射变换是单纯对图片进行平移，缩放，倾斜和旋转，而这几个操作都不会改变图片线之间的平行关系。</p>\n<p>$$<br>x^{,}= A \\cdot x_{0} + b<br>$$</p>\n<p>如果用三维去线性表达，那么就是：<br>$$<br>\\begin{bmatrix}<br>x^{,}\\<br>y^{,}\\<br>1</p>\n<p>\\end{bmatrix}<br>= </p>\n<p>\\begin{bmatrix}<br>a11 &amp;a12  &amp;b1 \\<br>a21 &amp;  a22&amp; b2\\<br> 0&amp;0  &amp; 1<br>\\end{bmatrix}</p>\n<p>\\cdot</p>\n<p>\\begin{bmatrix}<br>x\\<br>y\\<br>1</p>\n<p>\\end{bmatrix}<br>$$</p>\n<h3 id=\"什么是透视变换\"><a href=\"#什么是透视变换\" class=\"headerlink\" title=\"什么是透视变换\"></a>什么是透视变换</h3><p>如果说仿射变换是在二维空间中的旋转，平移和缩放。<strong>那么透视变换则是在三维空间中视角的变化。</strong></p>\n<p><strong>相对于仿射。透视变换能保持“直线性”，即原图像里面的直线，经透视变换后仍为直线</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/46eb52459edc83ef1dcfccaaa8e144d0.png\" alt=\"image-20210515224105702\"></p>\n<p>这里讲一下，如果说，仿射变化是三维空间中对某个平面的一些二维变化。</p>\n<p>那么透视变化就是对这个平面进行变换，并且利用视觉原理将图像进行一定处理（近大，远小）。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/54e4529e9550f5cc8881ef96792434b9.png\" alt=\"OpenCV-透视变换及对二维点求透视变换之后的坐标_leonardohaig的博客-CSDN博客\"></p>\n<p><strong>也就是说，先将图像旋转到$A^{,}B^{,}C^{,}$</strong></p>\n<p><strong>然后投影到平面$ABC$</strong></p>\n<p><strong>这里有一下假设，假设我们人是远点，从我们的眼睛去看，垂直与我们的目光的这个轴是$z$轴.</strong></p>\n<p><strong>在离我们一定距离的地方选一个画布$ABC$，其他所有画像都投影到这个画布上。</strong></p>\n<p><strong>那么假设平面$z$轴的距离是1.</strong></p>\n<p><strong>从$A^{,}B^{,}C^{,}$投影到画布$ABC$，计算公式为</strong></p>\n<p>$$<br>\\begin{bmatrix}<br>x\\<br>y\\<br>1</p>\n<p>\\end{bmatrix}<br>=<br>(1/z^{,}) \\cdot<br>\\begin{bmatrix}<br>x^{,}\\<br>y^{,}\\<br>z^{,}</p>\n<p>\\end{bmatrix}<br>$$</p>\n<p>有了以上概念，<strong>我们来最后计算一遍</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/3d1d091fab6e8ef34769c3833d999b0a.png\" alt=\"image-20210516140838713\"></p>\n<p><strong>先进行旋转变换。</strong></p>\n<p><strong>然后进行投影变换。</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/00e32af988032c970845ede0f2f9b581.png\" alt=\"image-20210516140914286\"></p>\n<p>然后就是繁琐的解方程过程，<strong>这里是非齐次线性方程组求解</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/a92fd5ff6b904e4d6b308b447bf2e97c.png\" alt=\"image-20210516140938930\"></p>\n<p>让我们来看一下最后效果。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/6b75bb88d0f41f9710a2872e6e6c9f7e.png\" alt=\"image-20210516141108490\"></p>\n<p>右边是我们手动实现的。</p>\n<p>具体的思路是仿照<strong>opencv</strong>，不过代码是手动用<strong>numpy</strong>实现的，有助于理解。</p>\n<p><strong>核心代码</strong></p>\n<pre><code>#根据四个顶点设置图像透视变换矩阵\npos1 = np.float32([[114, 82], [287, 156], [8, 322], [216, 333]])  # 原来的坐标\npos2 = np.float32([[0, 0], [188, 0], [0, 262], [188, 262]])    # 变换后的坐标\n\n# 实际肉眼看上去的x，y和数组的存储是有区别的\ndef exchangeXY(pos):\n    for i in range(len(pos)):\n        pos[i] = [pos[i][1], pos[i][0]]\n\nexchangeXY(pos1)\nexchangeXY(pos2)\n\n# 计算透视变换矩阵\ndef getPerspectiveTransform(pos1, pos2):\n    length = len(pos1)\n    tmpMatrix = []\n    b = []\n    for i in range(length):\n        x0, y0 = pos1[i]\n        xn, yn = pos2[i]\n        tmpMatrix.append(\n            [x0, y0,1,0,0,0,-1 * x0 * xn, -1 * y0 * xn]\n        )\n        tmpMatrix.append(\n            [0,0,0,x0, y0,1,-1 * x0 * yn, -1 * y0 * yn]\n        )\n\n        b.append(xn)\n        b.append(yn)\n\n\n    tmpMatrix= np.array(tmpMatrix)\n    b = np.array(b)\n    ans =np.dot(np.linalg.inv(tmpMatrix), b)\n    finalMatrix = [\n        [ans[0], ans[1], ans[2]],\n        [ans[3], ans[4], ans[5]],\n        [ans[6], ans[7], 1]\n\n    ]\n    return np.array(finalMatrix)\n\nM = getPerspectiveTransform(pos1, pos2)</code></pre><h2 id=\"图像阈值化\"><a href=\"#图像阈值化\" class=\"headerlink\" title=\"图像阈值化\"></a>图像阈值化</h2><p>图像的二值化或阈值化（Binarization）旨在提取图像中的目标物体，将背景以及噪声区分开来。通常会设定一个阈值T，通过T将图像的像素划分为两类：大于T的像素群和小于T的像素群。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/86e4d4c06ed913297cf73df917113377.png\" alt=\"image-20210516195934138\"></p>\n<p><strong>二进制阈值化</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/e4bcc8740e408805c15aecc64e58da64.png\" alt=\"image-20210516200029306\"></p>\n<p>所谓其他阈值化，其实也就是不断在基础形式上都不同的类进行一定处理。</p>\n<h2 id=\"灰度直方图\"><a href=\"#灰度直方图\" class=\"headerlink\" title=\"灰度直方图\"></a>灰度直方图</h2><h3 id=\"前置概念\"><a href=\"#前置概念\" class=\"headerlink\" title=\"前置概念\"></a>前置概念</h3><p><strong>RGB图像：</strong></p>\n<p>RGB的值分别为0，0，0 表示的是黑色。</p>\n<p>RGB的值为255，255，255表示的是白色。</p>\n<p><strong>灰度图像：</strong></p>\n<p>灰度值为0表示黑色。</p>\n<p>灰度值为255表示白色。</p>\n<h3 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>灰度直方图（histogram）是灰度级的函数，描述的是图像中每种灰度级像素的个数，反映图像中每种灰度出现的频率。横坐标是灰度级，纵坐标是灰度级出现的频率。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/14f8ae266ebabeb3c974b160502bf0d5.png\" alt=\"image-20210516200650255\"></p>\n<p><strong>用处：</strong></p>\n<p>在使用轮廓线确定物体边界时，通过直方图更好的选择边界阈值，进行阈值化处理；对物体与背景有较强对比的景物的分割特别有用；简单物体的面积和综合光密度IOD可以通过图像的直方图求得。</p>\n<h3 id=\"直方图修正\"><a href=\"#直方图修正\" class=\"headerlink\" title=\"直方图修正\"></a>直方图修正</h3><p>图像的直方图修正方法主要有直方图均衡化和直方图规定化直方图修正的目的是，<strong>使修正后的图像的灰度间距拉开或者是图像灰度分布均匀，从而增大反差，使图像细节清晰，从而达到图像增强的目的</strong></p>\n<p>我们这里主要<strong>直方图均衡化</strong>。</p>\n<p>算法原理，把原有的概率乘以一个数（通常是色值的大小，取整）。这样就可以把一些较为相近的值给化到一起了。</p>\n<h2 id=\"灰度值处理\"><a href=\"#灰度值处理\" class=\"headerlink\" title=\"灰度值处理\"></a>灰度值处理</h2><p><strong>rbg如何变为灰度值图像呢？</strong></p>\n<p>一种常见的方法是将RGB三个分量求和再取平均值，但更为准确的方法是设置不同的权重，将RGB分量按不同的比例进行灰度划分。比如人类的眼睛感官蓝色的敏感度最低，敏感最高的是绿色，因此将RGB按照0.299、0.587、0.144比例加权平均能得到较合理的灰度图像，</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/d39f859b6c1f17c27dfe1eb8281277ca.png\" alt=\"image-20210516201613044\"></p>\n<h2 id=\"图像灰度线性变换\"><a href=\"#图像灰度线性变换\" class=\"headerlink\" title=\"图像灰度线性变换\"></a>图像灰度线性变换</h2><p>图像的灰度线性变换是通过建立灰度映射来调整原始图像的灰度，从而改善图像的质量，凸显图像的细节，<strong>提高图像的对比度</strong></p>\n<p>$$<br>f(D) = S \\cdot D + b<br>$$</p>\n<p><strong>图像灰度非线性变换</strong></p>\n<ul>\n<li>例如什么一元二次函数</li>\n<li>对数变换</li>\n<li>伽玛变换又称为指数变换或幂次变换，是另一种常用的灰度非线性变换。就是指数函数</li>\n</ul>\n<h2 id=\"图像锐化\"><a href=\"#图像锐化\" class=\"headerlink\" title=\"图像锐化\"></a>图像锐化</h2><p>展图像锐化和边缘检测处理，加强原图像的高频部分。锐化突出图像的边缘细节，改善图像的对比度，使模糊的图像变得更清晰。</p>\n<p>图像锐化和边缘提取技术可以消除图像中的噪声，<strong>提取图像信息中用来表征图像的一些变量</strong>，为图像识别提供基础。</p>\n<p>通常使用<strong>灰度差分法</strong>对图像的边缘、轮廓进行处理，将其凸显。</p>\n<p><strong>如果把每一种算法都用卷积核来表示成矩阵的乘法，那么实际上就是一种卷积运算了</strong></p>\n<h3 id=\"Roberts算子（梯度法）\"><a href=\"#Roberts算子（梯度法）\" class=\"headerlink\" title=\"Roberts算子（梯度法）\"></a>Roberts算子（梯度法）</h3><p><strong>通过计算梯度从而凸显轮廓</strong></p>\n<p>对于图像 <img src=\"https://www.zhihu.com/equation?tex=f%28x%2Cy%29\" alt=\"[公式]\"> ,在点 <img src=\"https://www.zhihu.com/equation?tex=%28x%2Cy%29\" alt=\"[公式]\"> 处的梯度是一个矢量，定义为<img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/5d69f9d401c2fd45a0441959401fa85a.png\" alt=\"[公式]\">。</p>\n<p>梯度的幅度表示为 <img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/e8fbf647c96fe6ec562eabb8ddadf43f.png\" alt=\"[公式]\"></p>\n<p>对于数字图像而言， <img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/1dec5220f81575ccae6738b7d2466848.png\" alt=\"[公式]\"> ，</p>\n<p>该式可以简化成 <img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/59b6fc46f008b96c4914393b9731915e.png\" alt=\"[公式]\"></p>\n<p><strong>当梯度计算完之后，可以根据需要生成不同的梯度增强图像，</strong></p>\n<p>1）第一种， <img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/bf834d39b57899bd1287107a509ea2cd.png\" alt=\"[公式]\"> ，只显示灰度变化大的边缘轮廓，灰度变化平缓的呈黑色。</p>\n<p>2）第二种， <img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/8d1049d104a4514f8715597d718d8069.png\" alt=\"[公式]\"></p>\n<p>可以显示出非常明显的边缘轮廓，又不会破坏原灰度变化平缓的背景。</p>\n<p>3）第三种， <img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/f3b342875660dc887dcbd05121d8025d.png\" alt=\"[公式]\"></p>\n<p>。。。。还有很多类似的</p>\n<h3 id=\"Sobel算子\"><a href=\"#Sobel算子\" class=\"headerlink\" title=\"Sobel算子\"></a><strong>Sobel算子</strong></h3><p>采用梯度微分锐化图像，会让噪声、条纹得到增强，Sobel算子在一定程度上解决了这个问题， <img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/8b9e97d5e86c30259dfe8709143352e3.png\" alt=\"[公式]\"></p>\n<p>从这个式子中，可以得到两个性质，</p>\n<ul>\n<li><p>Sobel引入了平均的因素，因此对噪声有一定的平滑作用</p>\n</li>\n<li><p>Sobel算子的操作就是相隔两个行（列）的差分，所以边缘两侧元素的得到了增强，因此边缘显得粗而亮。</p>\n</li>\n<li><p>Sobel算子表示形式为：</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/21ff5ffbd08ae34f86890889c335e850.png\" alt=\"[公式]\"></p>\n</li>\n</ul>\n<h3 id=\"拉普拉斯算子（二阶微分）\"><a href=\"#拉普拉斯算子（二阶微分）\" class=\"headerlink\" title=\"拉普拉斯算子（二阶微分）\"></a><strong>拉普拉斯算子（二阶微分）</strong></h3><p>拉普拉斯运算也是各向同性的线性运算。拉普拉斯算子为： <img src=\"https://www.zhihu.com/equation?tex=+%5Cnabla+%5E2f%3D%5Cfrac%7B%5Cpartial+%5E2f%7D%7B%5Cpartial+x%5E2%7D%2B%5Cfrac%7B%5Cpartial+%5E2f%7D%7B%5Cpartial+y%5E2%7D++\" alt=\"[公式]\"> ,锐化之后的图像 <img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/05df0a4434c3b690175bd3491e580147.png\" alt=\"[公式]\"></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/5a1c7b5cfeb56ef056d85fb12781544a.png\" alt=\"[公式]\"> 为扩散效应的系数。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/c3d8d679c4bcc9fb05de4e54af9d5044.png\" alt=\"[公式]\"></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/3c2471b3e33e37a96943870aa3f76c3d.png\" alt=\"[公式]\"></p>\n<p>由此式可知，数字图像在 <img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/4930ba4025f56d086cf539962a9f0f08.png\" alt=\"[公式]\"> 点的拉普拉斯算子，可以由该点的灰度值减去该点及其邻域四个点的平均灰度值求得。</p>\n<h3 id=\"Canny算子\"><a href=\"#Canny算子\" class=\"headerlink\" title=\"Canny算子\"></a>Canny算子</h3><p><strong>1.使用高斯平滑（如公式所示）去除噪声。</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/5d6282b25a7dd374504724d07aec9471.png\" alt=\"image-20210517111128781\"></p>\n<p><strong>2.按照Sobel滤波器步骤计算梯度幅值和方向，寻找图像的强度梯度。先将卷积模板分别作用x和y方向，再计算梯度幅值和方向，其公式如下所示。梯度方向一般取0度、45度、90度和135度四个方向。</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/84ec341a66fdbd14311e39fb5b266923/44a4ec5fe12053aad7f1576a45bc43b6.png\" alt=\"image-20210517111159837\"></p>\n<p><strong>3.通过非极大值抑制（Non-maximum Suppression）过滤掉非边缘像素，将模糊的边界变得清晰。该过程保留了每个像素点上梯度强度的极大值，过滤掉其他的值。</strong></p>\n<p><strong>4.利用滞后技术来跟踪边界。若某一像素位置和强边界相连的弱边界认为是边界，其他的弱边界则被删除。</strong></p>\n<h2 id=\"边缘线检测\"><a href=\"#边缘线检测\" class=\"headerlink\" title=\"边缘线检测\"></a>边缘线检测</h2><p>边缘检测算法主要是基于图像强度的一阶和二阶导数，但<strong>导数通常对噪声很敏感，</strong>因此需要采用<strong>滤波器来过滤噪声</strong>，并<strong>调用图像增强或阈值化算法进行处理</strong>，<strong>最后再进行边缘检测</strong>。</p>\n<p>而所谓边缘检测，其实是用锐化算法算出边缘，然后通过一些细节处理捕捉边缘。</p>\n"},{"_content":"# 简单前后端分离项目部署\n\n## 简介\n我是部署我的简单动漫网站的时候碰到这方面的问题。\n我的项目技术栈：\n- 使用python flask 作为后端\n- 使用vue编写前端\n\n## 文件传输到服务器上\n方法有很多，我直接将项目上传到github， 然后pull到云端。\n\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/094dfb8d4ef2f50f210c7d07055e80cd/cd510c499c0e74e32f1ed379f0f5ce8b.png)\n\n## 将后端跑起来\n我这里直接使用python命令行启动\n```\npython /root/lwl/code/python/deploy/flaskApi.py &  # 运行指定项目\n```\n虽然后端运行了起来，但是这时候我们还不能通过公网ip去进行访问。\n要将防火墙打开。\n```\nfirewall-cmd --zone=public --add-port=5000/tcp    &  #开启防火墙端口\n```\n同时腾讯这也要进行防火墙管理\n\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/094dfb8d4ef2f50f210c7d07055e80cd/6e695ac81c1d3314a806286039a7db31.png)\n\n\n\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/094dfb8d4ef2f50f210c7d07055e80cd/b96facacb147685c47dd15bc027b51ef.png)\n\n\n然后就可以访问到了\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/094dfb8d4ef2f50f210c7d07055e80cd/c91e9ffe8ebede1e195764ce6783d8fa.png)\n\n\n## 前端部署\n我这里的前端， 属于传统前端，主要有html，css，js等静态文件组成。\n\n我使用VUE，所以使用npm run build 进行打包\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/094dfb8d4ef2f50f210c7d07055e80cd/95a677fdc6a23c7292e9319baeea517f.png)\n这时候，我们的前端就已经打包完毕了。\n\n重点来了\n**使用某个服务器对静态资源进行代理**\n我使用的是nginx。\n以下是我的配置\n```\nuser  root;  # 用户\nworker_processes auto;\nerror_log  /www/wwwlogs/nginx_error.log  crit;\npid        /www/server/nginx/logs/nginx.pid;\nworker_rlimit_nofile 51200;\n\nevents\n    {\n        use epoll;\n        worker_connections 51200;\n        multi_accept on;\n    }\n\nhttp\n    {\n        include       mime.types;\n                #include luawaf.conf;\n\n                include proxy.conf;\n\n        default_type  application/octet-stream;\n\n        server_names_hash_bucket_size 512;\n        client_header_buffer_size 32k;\n        large_client_header_buffers 4 32k;\n        client_max_body_size 50m;\n\n        sendfile   on;\n        tcp_nopush on;\n\n        keepalive_timeout 60;\n\n        tcp_nodelay on;\n\n        fastcgi_connect_timeout 300;\n        fastcgi_send_timeout 300;\n        fastcgi_read_timeout 300;\n        fastcgi_buffer_size 64k;\n        fastcgi_buffers 4 64k;\n        fastcgi_busy_buffers_size 128k;\n        fastcgi_temp_file_write_size 256k;\n                fastcgi_intercept_errors on;\n\n        gzip on;\n        gzip_min_length  1k;\n        gzip_buffers     4 16k;\n        gzip_http_version 1.1;\n        gzip_comp_level 2;\n        gzip_types     text/plain application/javascript application/x-javascript text/javascript text/css application/xml;\n        gzip_vary on;\n        gzip_proxied   expired no-cache no-store private auth;\n        gzip_disable   \"MSIE [1-6]\\.\";\n\n        limit_conn_zone $binary_remote_addr zone=perip:10m;\n                limit_conn_zone $server_name zone=perserver:10m;\n\n        server_tokens off;\n\n\n# 访问日志配置在这\n\n#自定义名为main得日志格式\n\n\nlog_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                    '$status $body_bytes_sent \"$http_referer\" '\n                    '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\naccess_log /www/wwwlogs/access.log    main;  # 这里是具体路径\n\n# 这里是我们需要注意的东西，也是配置主要需要修改的东西\n   server {\n   \n   #我们访问119.29.143.49：88\n        listen       80;               # 端口\n        server_name  119.29.143.49;    # 服务器名， 要代理的服务器的名字\n\n\n        #存放静态资源的文件路径\n         root   /root/lwl/code/python/deploy/front/dist;\n\n        \n        #ngix的配置文件\n        include /www/nginx/conf/*.conf;\n\n        location / {\n        }\n\n        error_page 404 /404.html;\n            location = /40x.html {\n        }\n\n        error_page 500 502 503 504 /50x.html;\n            location = /50x.html {\n        }\n    }\n\n\n\ninclude /www/server/panel/vhost/nginx/*.conf;\n}\n```\n\n\n我这里只对简单的静态资源代理进行举例，关于后端的代理可以自行浏览nginx的用例\n\n\n### Nginx下vue等打包静态资源的路由问题\n因为vue打包后是单个html，url也是vue内部的。所以刷新页面会出现下面问题。\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/094dfb8d4ef2f50f210c7d07055e80cd/aa3390a399ce523d9f85a60991af0fb0.png)\n\n\n参考资料[链接](https://learnku.com/articles/34440)\n\n\n解决问题\n在服务端nginx配置里添加vue-route的跳转设置（这里首页是index.html，如果是index.php就在下面对应位置替换），正确配置如下：\n```\nserver\n{\n    listen 80;\n    server_name testwx.wangshibo.com;\n    index index.php index.html index.htm default.php default.htm default.html;\n    root /www/wwwroot/ssoShuang/dist;\n\n    #vue-router配置\n    location / {\n        try_files $uri $uri/ @router;\n        index index.html;\n    }\n    location @router {\n        rewrite ^.*$ /index.html last;\n    }\n}\n```\n\n重启 nginx 后，问题就迎刃而解了。\n\n\n\n## 最后讲解自动启动问题\n\n使用ssh 连接后，终端退出那么任务也就没了\n所以我使用自动启动\n这里主要用systemctl\n\n我的服务器使用centos7，他的systemctl自动启动项在目录 ` /usr/lib/systemd/system/ `\n新建service文件：\n我新建了lwl.service文件\n\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/094dfb8d4ef2f50f210c7d07055e80cd/d0e1d7499ec41e61352e770dce643276.png)\n\n具体配置\n```\n[Unit]\nDescription=lwl       #描述\nAfter=network.target  #前置启动的程序\n\n[Service]            #具体的命令了\nType=forking\nExecStart=/root/init.sh   # 开启该任务的命令\nExecReload=/root/init.sh  #重启\nExecStop=/root/init.sh    #关闭\n\n[Install]  \nWantedBy=multi-user.target\n```\n\n**注意**\n**systemctl执行脚本时需要知道脚本的解释器**\n解决方法：\n在/root/init.sh脚本的开头加上`#!/bin/sh`\n\n最后的init.sh\n\n```\n#!/bin/sh\n\nfirewall-cmd --zone=public --add-port=5000/tcp    &  #开启防火墙端口\n\npython /root/lwl/code/python/deploy/flaskApi.py &  # 运行指定项目\n\n\n#用来查找某个端口的进程pid\n#netstat -nlp | grep 5000 | awk '{print $7}' | awk -F\"/\" '{ print $1 }'\n```\n\n\n然后就是一些命令了\n```\n\n#查看日志\n$ sudo journalctl -f -u nginx.service\n— Logs begin at 四 2015-06-25 17:32:20 CST. —\n6月 25 10:28:24 Leco.lan systemd[1]: Starting nginx – high performance web server…\n  \n启动一个服务：systemctl start nginx.service\n关闭一个服务：systemctl stop postfix.service\n重启一个服务：systemctl restart nginx.service\n显示一个服务的状态：systemctl status postfix.service\n在开机时启用一个服务：systemctl enable nginx.service\n在开机时禁用一个服务：systemctl disable nginx.service\n查看服务是否开机启动：systemctl is-enabled nginx.service\n查看已启动的服务列表：systemctl list-unit-files|grep enabled\n\n\n刚刚配置的服务需要让systemctl能识别，就必须刷新配置\n$ systemctl daemon-reload\n```\n\n**尽量将运行命令写的精确**\n比如我的python有多个版本，那么尽量写成\n`/usr/bin/python   /root/lwl/code/python/deploy/flaskApi.py &  # 运行指定项目`\n\n\n\n### 简单讲程序放入后台\nnohup命令：\n如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。nohup就是不挂起的意思。\n\n我们现在开始启动服务 python pyserver.py，并且希望在后台运行.我们就可以使用nohup，命令如下：\n\n`nohup python pyserver.py `","source":"_posts/综合/简单前后端分离项目部署.md","raw":"# 简单前后端分离项目部署\n\n## 简介\n我是部署我的简单动漫网站的时候碰到这方面的问题。\n我的项目技术栈：\n- 使用python flask 作为后端\n- 使用vue编写前端\n\n## 文件传输到服务器上\n方法有很多，我直接将项目上传到github， 然后pull到云端。\n\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/094dfb8d4ef2f50f210c7d07055e80cd/cd510c499c0e74e32f1ed379f0f5ce8b.png)\n\n## 将后端跑起来\n我这里直接使用python命令行启动\n```\npython /root/lwl/code/python/deploy/flaskApi.py &  # 运行指定项目\n```\n虽然后端运行了起来，但是这时候我们还不能通过公网ip去进行访问。\n要将防火墙打开。\n```\nfirewall-cmd --zone=public --add-port=5000/tcp    &  #开启防火墙端口\n```\n同时腾讯这也要进行防火墙管理\n\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/094dfb8d4ef2f50f210c7d07055e80cd/6e695ac81c1d3314a806286039a7db31.png)\n\n\n\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/094dfb8d4ef2f50f210c7d07055e80cd/b96facacb147685c47dd15bc027b51ef.png)\n\n\n然后就可以访问到了\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/094dfb8d4ef2f50f210c7d07055e80cd/c91e9ffe8ebede1e195764ce6783d8fa.png)\n\n\n## 前端部署\n我这里的前端， 属于传统前端，主要有html，css，js等静态文件组成。\n\n我使用VUE，所以使用npm run build 进行打包\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/094dfb8d4ef2f50f210c7d07055e80cd/95a677fdc6a23c7292e9319baeea517f.png)\n这时候，我们的前端就已经打包完毕了。\n\n重点来了\n**使用某个服务器对静态资源进行代理**\n我使用的是nginx。\n以下是我的配置\n```\nuser  root;  # 用户\nworker_processes auto;\nerror_log  /www/wwwlogs/nginx_error.log  crit;\npid        /www/server/nginx/logs/nginx.pid;\nworker_rlimit_nofile 51200;\n\nevents\n    {\n        use epoll;\n        worker_connections 51200;\n        multi_accept on;\n    }\n\nhttp\n    {\n        include       mime.types;\n                #include luawaf.conf;\n\n                include proxy.conf;\n\n        default_type  application/octet-stream;\n\n        server_names_hash_bucket_size 512;\n        client_header_buffer_size 32k;\n        large_client_header_buffers 4 32k;\n        client_max_body_size 50m;\n\n        sendfile   on;\n        tcp_nopush on;\n\n        keepalive_timeout 60;\n\n        tcp_nodelay on;\n\n        fastcgi_connect_timeout 300;\n        fastcgi_send_timeout 300;\n        fastcgi_read_timeout 300;\n        fastcgi_buffer_size 64k;\n        fastcgi_buffers 4 64k;\n        fastcgi_busy_buffers_size 128k;\n        fastcgi_temp_file_write_size 256k;\n                fastcgi_intercept_errors on;\n\n        gzip on;\n        gzip_min_length  1k;\n        gzip_buffers     4 16k;\n        gzip_http_version 1.1;\n        gzip_comp_level 2;\n        gzip_types     text/plain application/javascript application/x-javascript text/javascript text/css application/xml;\n        gzip_vary on;\n        gzip_proxied   expired no-cache no-store private auth;\n        gzip_disable   \"MSIE [1-6]\\.\";\n\n        limit_conn_zone $binary_remote_addr zone=perip:10m;\n                limit_conn_zone $server_name zone=perserver:10m;\n\n        server_tokens off;\n\n\n# 访问日志配置在这\n\n#自定义名为main得日志格式\n\n\nlog_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                    '$status $body_bytes_sent \"$http_referer\" '\n                    '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\naccess_log /www/wwwlogs/access.log    main;  # 这里是具体路径\n\n# 这里是我们需要注意的东西，也是配置主要需要修改的东西\n   server {\n   \n   #我们访问119.29.143.49：88\n        listen       80;               # 端口\n        server_name  119.29.143.49;    # 服务器名， 要代理的服务器的名字\n\n\n        #存放静态资源的文件路径\n         root   /root/lwl/code/python/deploy/front/dist;\n\n        \n        #ngix的配置文件\n        include /www/nginx/conf/*.conf;\n\n        location / {\n        }\n\n        error_page 404 /404.html;\n            location = /40x.html {\n        }\n\n        error_page 500 502 503 504 /50x.html;\n            location = /50x.html {\n        }\n    }\n\n\n\ninclude /www/server/panel/vhost/nginx/*.conf;\n}\n```\n\n\n我这里只对简单的静态资源代理进行举例，关于后端的代理可以自行浏览nginx的用例\n\n\n### Nginx下vue等打包静态资源的路由问题\n因为vue打包后是单个html，url也是vue内部的。所以刷新页面会出现下面问题。\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/094dfb8d4ef2f50f210c7d07055e80cd/aa3390a399ce523d9f85a60991af0fb0.png)\n\n\n参考资料[链接](https://learnku.com/articles/34440)\n\n\n解决问题\n在服务端nginx配置里添加vue-route的跳转设置（这里首页是index.html，如果是index.php就在下面对应位置替换），正确配置如下：\n```\nserver\n{\n    listen 80;\n    server_name testwx.wangshibo.com;\n    index index.php index.html index.htm default.php default.htm default.html;\n    root /www/wwwroot/ssoShuang/dist;\n\n    #vue-router配置\n    location / {\n        try_files $uri $uri/ @router;\n        index index.html;\n    }\n    location @router {\n        rewrite ^.*$ /index.html last;\n    }\n}\n```\n\n重启 nginx 后，问题就迎刃而解了。\n\n\n\n## 最后讲解自动启动问题\n\n使用ssh 连接后，终端退出那么任务也就没了\n所以我使用自动启动\n这里主要用systemctl\n\n我的服务器使用centos7，他的systemctl自动启动项在目录 ` /usr/lib/systemd/system/ `\n新建service文件：\n我新建了lwl.service文件\n\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/094dfb8d4ef2f50f210c7d07055e80cd/d0e1d7499ec41e61352e770dce643276.png)\n\n具体配置\n```\n[Unit]\nDescription=lwl       #描述\nAfter=network.target  #前置启动的程序\n\n[Service]            #具体的命令了\nType=forking\nExecStart=/root/init.sh   # 开启该任务的命令\nExecReload=/root/init.sh  #重启\nExecStop=/root/init.sh    #关闭\n\n[Install]  \nWantedBy=multi-user.target\n```\n\n**注意**\n**systemctl执行脚本时需要知道脚本的解释器**\n解决方法：\n在/root/init.sh脚本的开头加上`#!/bin/sh`\n\n最后的init.sh\n\n```\n#!/bin/sh\n\nfirewall-cmd --zone=public --add-port=5000/tcp    &  #开启防火墙端口\n\npython /root/lwl/code/python/deploy/flaskApi.py &  # 运行指定项目\n\n\n#用来查找某个端口的进程pid\n#netstat -nlp | grep 5000 | awk '{print $7}' | awk -F\"/\" '{ print $1 }'\n```\n\n\n然后就是一些命令了\n```\n\n#查看日志\n$ sudo journalctl -f -u nginx.service\n— Logs begin at 四 2015-06-25 17:32:20 CST. —\n6月 25 10:28:24 Leco.lan systemd[1]: Starting nginx – high performance web server…\n  \n启动一个服务：systemctl start nginx.service\n关闭一个服务：systemctl stop postfix.service\n重启一个服务：systemctl restart nginx.service\n显示一个服务的状态：systemctl status postfix.service\n在开机时启用一个服务：systemctl enable nginx.service\n在开机时禁用一个服务：systemctl disable nginx.service\n查看服务是否开机启动：systemctl is-enabled nginx.service\n查看已启动的服务列表：systemctl list-unit-files|grep enabled\n\n\n刚刚配置的服务需要让systemctl能识别，就必须刷新配置\n$ systemctl daemon-reload\n```\n\n**尽量将运行命令写的精确**\n比如我的python有多个版本，那么尽量写成\n`/usr/bin/python   /root/lwl/code/python/deploy/flaskApi.py &  # 运行指定项目`\n\n\n\n### 简单讲程序放入后台\nnohup命令：\n如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。nohup就是不挂起的意思。\n\n我们现在开始启动服务 python pyserver.py，并且希望在后台运行.我们就可以使用nohup，命令如下：\n\n`nohup python pyserver.py `","slug":"综合/简单前后端分离项目部署","published":1,"date":"2023-02-27T11:33:23.580Z","updated":"2023-02-27T11:34:33.138Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsyda00220gcn0c217siw","content":"<h1 id=\"简单前后端分离项目部署\"><a href=\"#简单前后端分离项目部署\" class=\"headerlink\" title=\"简单前后端分离项目部署\"></a>简单前后端分离项目部署</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>我是部署我的简单动漫网站的时候碰到这方面的问题。<br>我的项目技术栈：</p>\n<ul>\n<li>使用python flask 作为后端</li>\n<li>使用vue编写前端</li>\n</ul>\n<h2 id=\"文件传输到服务器上\"><a href=\"#文件传输到服务器上\" class=\"headerlink\" title=\"文件传输到服务器上\"></a>文件传输到服务器上</h2><p>方法有很多，我直接将项目上传到github， 然后pull到云端。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/094dfb8d4ef2f50f210c7d07055e80cd/cd510c499c0e74e32f1ed379f0f5ce8b.png\" alt></p>\n<h2 id=\"将后端跑起来\"><a href=\"#将后端跑起来\" class=\"headerlink\" title=\"将后端跑起来\"></a>将后端跑起来</h2><p>我这里直接使用python命令行启动</p>\n<pre><code>python /root/lwl/code/python/deploy/flaskApi.py &amp;  # 运行指定项目</code></pre><p>虽然后端运行了起来，但是这时候我们还不能通过公网ip去进行访问。<br>要将防火墙打开。</p>\n<pre><code>firewall-cmd --zone=public --add-port=5000/tcp    &amp;  #开启防火墙端口</code></pre><p>同时腾讯这也要进行防火墙管理</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/094dfb8d4ef2f50f210c7d07055e80cd/6e695ac81c1d3314a806286039a7db31.png\" alt></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/094dfb8d4ef2f50f210c7d07055e80cd/b96facacb147685c47dd15bc027b51ef.png\" alt></p>\n<p>然后就可以访问到了<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/094dfb8d4ef2f50f210c7d07055e80cd/c91e9ffe8ebede1e195764ce6783d8fa.png\" alt></p>\n<h2 id=\"前端部署\"><a href=\"#前端部署\" class=\"headerlink\" title=\"前端部署\"></a>前端部署</h2><p>我这里的前端， 属于传统前端，主要有html，css，js等静态文件组成。</p>\n<p>我使用VUE，所以使用npm run build 进行打包<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/094dfb8d4ef2f50f210c7d07055e80cd/95a677fdc6a23c7292e9319baeea517f.png\" alt><br>这时候，我们的前端就已经打包完毕了。</p>\n<p>重点来了<br><strong>使用某个服务器对静态资源进行代理</strong><br>我使用的是nginx。<br>以下是我的配置</p>\n<pre><code>user  root;  # 用户\nworker_processes auto;\nerror_log  /www/wwwlogs/nginx_error.log  crit;\npid        /www/server/nginx/logs/nginx.pid;\nworker_rlimit_nofile 51200;\n\nevents\n    {\n        use epoll;\n        worker_connections 51200;\n        multi_accept on;\n    }\n\nhttp\n    {\n        include       mime.types;\n                #include luawaf.conf;\n\n                include proxy.conf;\n\n        default_type  application/octet-stream;\n\n        server_names_hash_bucket_size 512;\n        client_header_buffer_size 32k;\n        large_client_header_buffers 4 32k;\n        client_max_body_size 50m;\n\n        sendfile   on;\n        tcp_nopush on;\n\n        keepalive_timeout 60;\n\n        tcp_nodelay on;\n\n        fastcgi_connect_timeout 300;\n        fastcgi_send_timeout 300;\n        fastcgi_read_timeout 300;\n        fastcgi_buffer_size 64k;\n        fastcgi_buffers 4 64k;\n        fastcgi_busy_buffers_size 128k;\n        fastcgi_temp_file_write_size 256k;\n                fastcgi_intercept_errors on;\n\n        gzip on;\n        gzip_min_length  1k;\n        gzip_buffers     4 16k;\n        gzip_http_version 1.1;\n        gzip_comp_level 2;\n        gzip_types     text/plain application/javascript application/x-javascript text/javascript text/css application/xml;\n        gzip_vary on;\n        gzip_proxied   expired no-cache no-store private auth;\n        gzip_disable   &quot;MSIE [1-6]\\.&quot;;\n\n        limit_conn_zone $binary_remote_addr zone=perip:10m;\n                limit_conn_zone $server_name zone=perserver:10m;\n\n        server_tokens off;\n\n\n# 访问日志配置在这\n\n#自定义名为main得日志格式\n\n\nlog_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;\n                    &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;\n                    &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;\n\naccess_log /www/wwwlogs/access.log    main;  # 这里是具体路径\n\n# 这里是我们需要注意的东西，也是配置主要需要修改的东西\n   server {\n\n   #我们访问119.29.143.49：88\n        listen       80;               # 端口\n        server_name  119.29.143.49;    # 服务器名， 要代理的服务器的名字\n\n\n        #存放静态资源的文件路径\n         root   /root/lwl/code/python/deploy/front/dist;\n\n\n        #ngix的配置文件\n        include /www/nginx/conf/*.conf;\n\n        location / {\n        }\n\n        error_page 404 /404.html;\n            location = /40x.html {\n        }\n\n        error_page 500 502 503 504 /50x.html;\n            location = /50x.html {\n        }\n    }\n\n\n\ninclude /www/server/panel/vhost/nginx/*.conf;\n}</code></pre><p>我这里只对简单的静态资源代理进行举例，关于后端的代理可以自行浏览nginx的用例</p>\n<h3 id=\"Nginx下vue等打包静态资源的路由问题\"><a href=\"#Nginx下vue等打包静态资源的路由问题\" class=\"headerlink\" title=\"Nginx下vue等打包静态资源的路由问题\"></a>Nginx下vue等打包静态资源的路由问题</h3><p>因为vue打包后是单个html，url也是vue内部的。所以刷新页面会出现下面问题。<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/094dfb8d4ef2f50f210c7d07055e80cd/aa3390a399ce523d9f85a60991af0fb0.png\" alt></p>\n<p>参考资料<a href=\"https://learnku.com/articles/34440\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<p>解决问题<br>在服务端nginx配置里添加vue-route的跳转设置（这里首页是index.html，如果是index.php就在下面对应位置替换），正确配置如下：</p>\n<pre><code>server\n{\n    listen 80;\n    server_name testwx.wangshibo.com;\n    index index.php index.html index.htm default.php default.htm default.html;\n    root /www/wwwroot/ssoShuang/dist;\n\n    #vue-router配置\n    location / {\n        try_files $uri $uri/ @router;\n        index index.html;\n    }\n    location @router {\n        rewrite ^.*$ /index.html last;\n    }\n}</code></pre><p>重启 nginx 后，问题就迎刃而解了。</p>\n<h2 id=\"最后讲解自动启动问题\"><a href=\"#最后讲解自动启动问题\" class=\"headerlink\" title=\"最后讲解自动启动问题\"></a>最后讲解自动启动问题</h2><p>使用ssh 连接后，终端退出那么任务也就没了<br>所以我使用自动启动<br>这里主要用systemctl</p>\n<p>我的服务器使用centos7，他的systemctl自动启动项在目录 <code>/usr/lib/systemd/system/</code><br>新建service文件：<br>我新建了lwl.service文件</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/094dfb8d4ef2f50f210c7d07055e80cd/d0e1d7499ec41e61352e770dce643276.png\" alt></p>\n<p>具体配置</p>\n<pre><code>[Unit]\nDescription=lwl       #描述\nAfter=network.target  #前置启动的程序\n\n[Service]            #具体的命令了\nType=forking\nExecStart=/root/init.sh   # 开启该任务的命令\nExecReload=/root/init.sh  #重启\nExecStop=/root/init.sh    #关闭\n\n[Install]  \nWantedBy=multi-user.target</code></pre><p><strong>注意</strong><br><strong>systemctl执行脚本时需要知道脚本的解释器</strong><br>解决方法：<br>在/root/init.sh脚本的开头加上<code>#!/bin/sh</code></p>\n<p>最后的init.sh</p>\n<pre><code>#!/bin/sh\n\nfirewall-cmd --zone=public --add-port=5000/tcp    &amp;  #开启防火墙端口\n\npython /root/lwl/code/python/deploy/flaskApi.py &amp;  # 运行指定项目\n\n\n#用来查找某个端口的进程pid\n#netstat -nlp | grep 5000 | awk &#39;{print $7}&#39; | awk -F&quot;/&quot; &#39;{ print $1 }&#39;</code></pre><p>然后就是一些命令了</p>\n<pre><code>\n#查看日志\n$ sudo journalctl -f -u nginx.service\n— Logs begin at 四 2015-06-25 17:32:20 CST. —\n6月 25 10:28:24 Leco.lan systemd[1]: Starting nginx – high performance web server…\n\n启动一个服务：systemctl start nginx.service\n关闭一个服务：systemctl stop postfix.service\n重启一个服务：systemctl restart nginx.service\n显示一个服务的状态：systemctl status postfix.service\n在开机时启用一个服务：systemctl enable nginx.service\n在开机时禁用一个服务：systemctl disable nginx.service\n查看服务是否开机启动：systemctl is-enabled nginx.service\n查看已启动的服务列表：systemctl list-unit-files|grep enabled\n\n\n刚刚配置的服务需要让systemctl能识别，就必须刷新配置\n$ systemctl daemon-reload</code></pre><p><strong>尽量将运行命令写的精确</strong><br>比如我的python有多个版本，那么尽量写成<br><code>/usr/bin/python   /root/lwl/code/python/deploy/flaskApi.py &amp;  # 运行指定项目</code></p>\n<h3 id=\"简单讲程序放入后台\"><a href=\"#简单讲程序放入后台\" class=\"headerlink\" title=\"简单讲程序放入后台\"></a>简单讲程序放入后台</h3><p>nohup命令：<br>如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。nohup就是不挂起的意思。</p>\n<p>我们现在开始启动服务 python pyserver.py，并且希望在后台运行.我们就可以使用nohup，命令如下：</p>\n<p><code>nohup python pyserver.py</code></p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"简单前后端分离项目部署\"><a href=\"#简单前后端分离项目部署\" class=\"headerlink\" title=\"简单前后端分离项目部署\"></a>简单前后端分离项目部署</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>我是部署我的简单动漫网站的时候碰到这方面的问题。<br>我的项目技术栈：</p>\n<ul>\n<li>使用python flask 作为后端</li>\n<li>使用vue编写前端</li>\n</ul>\n<h2 id=\"文件传输到服务器上\"><a href=\"#文件传输到服务器上\" class=\"headerlink\" title=\"文件传输到服务器上\"></a>文件传输到服务器上</h2><p>方法有很多，我直接将项目上传到github， 然后pull到云端。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/094dfb8d4ef2f50f210c7d07055e80cd/cd510c499c0e74e32f1ed379f0f5ce8b.png\" alt></p>\n<h2 id=\"将后端跑起来\"><a href=\"#将后端跑起来\" class=\"headerlink\" title=\"将后端跑起来\"></a>将后端跑起来</h2><p>我这里直接使用python命令行启动</p>\n<pre><code>python /root/lwl/code/python/deploy/flaskApi.py &amp;  # 运行指定项目</code></pre><p>虽然后端运行了起来，但是这时候我们还不能通过公网ip去进行访问。<br>要将防火墙打开。</p>\n<pre><code>firewall-cmd --zone=public --add-port=5000/tcp    &amp;  #开启防火墙端口</code></pre><p>同时腾讯这也要进行防火墙管理</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/094dfb8d4ef2f50f210c7d07055e80cd/6e695ac81c1d3314a806286039a7db31.png\" alt></p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/094dfb8d4ef2f50f210c7d07055e80cd/b96facacb147685c47dd15bc027b51ef.png\" alt></p>\n<p>然后就可以访问到了<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/094dfb8d4ef2f50f210c7d07055e80cd/c91e9ffe8ebede1e195764ce6783d8fa.png\" alt></p>\n<h2 id=\"前端部署\"><a href=\"#前端部署\" class=\"headerlink\" title=\"前端部署\"></a>前端部署</h2><p>我这里的前端， 属于传统前端，主要有html，css，js等静态文件组成。</p>\n<p>我使用VUE，所以使用npm run build 进行打包<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/094dfb8d4ef2f50f210c7d07055e80cd/95a677fdc6a23c7292e9319baeea517f.png\" alt><br>这时候，我们的前端就已经打包完毕了。</p>\n<p>重点来了<br><strong>使用某个服务器对静态资源进行代理</strong><br>我使用的是nginx。<br>以下是我的配置</p>\n<pre><code>user  root;  # 用户\nworker_processes auto;\nerror_log  /www/wwwlogs/nginx_error.log  crit;\npid        /www/server/nginx/logs/nginx.pid;\nworker_rlimit_nofile 51200;\n\nevents\n    {\n        use epoll;\n        worker_connections 51200;\n        multi_accept on;\n    }\n\nhttp\n    {\n        include       mime.types;\n                #include luawaf.conf;\n\n                include proxy.conf;\n\n        default_type  application/octet-stream;\n\n        server_names_hash_bucket_size 512;\n        client_header_buffer_size 32k;\n        large_client_header_buffers 4 32k;\n        client_max_body_size 50m;\n\n        sendfile   on;\n        tcp_nopush on;\n\n        keepalive_timeout 60;\n\n        tcp_nodelay on;\n\n        fastcgi_connect_timeout 300;\n        fastcgi_send_timeout 300;\n        fastcgi_read_timeout 300;\n        fastcgi_buffer_size 64k;\n        fastcgi_buffers 4 64k;\n        fastcgi_busy_buffers_size 128k;\n        fastcgi_temp_file_write_size 256k;\n                fastcgi_intercept_errors on;\n\n        gzip on;\n        gzip_min_length  1k;\n        gzip_buffers     4 16k;\n        gzip_http_version 1.1;\n        gzip_comp_level 2;\n        gzip_types     text/plain application/javascript application/x-javascript text/javascript text/css application/xml;\n        gzip_vary on;\n        gzip_proxied   expired no-cache no-store private auth;\n        gzip_disable   &quot;MSIE [1-6]\\.&quot;;\n\n        limit_conn_zone $binary_remote_addr zone=perip:10m;\n                limit_conn_zone $server_name zone=perserver:10m;\n\n        server_tokens off;\n\n\n# 访问日志配置在这\n\n#自定义名为main得日志格式\n\n\nlog_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;\n                    &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;\n                    &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;\n\naccess_log /www/wwwlogs/access.log    main;  # 这里是具体路径\n\n# 这里是我们需要注意的东西，也是配置主要需要修改的东西\n   server {\n\n   #我们访问119.29.143.49：88\n        listen       80;               # 端口\n        server_name  119.29.143.49;    # 服务器名， 要代理的服务器的名字\n\n\n        #存放静态资源的文件路径\n         root   /root/lwl/code/python/deploy/front/dist;\n\n\n        #ngix的配置文件\n        include /www/nginx/conf/*.conf;\n\n        location / {\n        }\n\n        error_page 404 /404.html;\n            location = /40x.html {\n        }\n\n        error_page 500 502 503 504 /50x.html;\n            location = /50x.html {\n        }\n    }\n\n\n\ninclude /www/server/panel/vhost/nginx/*.conf;\n}</code></pre><p>我这里只对简单的静态资源代理进行举例，关于后端的代理可以自行浏览nginx的用例</p>\n<h3 id=\"Nginx下vue等打包静态资源的路由问题\"><a href=\"#Nginx下vue等打包静态资源的路由问题\" class=\"headerlink\" title=\"Nginx下vue等打包静态资源的路由问题\"></a>Nginx下vue等打包静态资源的路由问题</h3><p>因为vue打包后是单个html，url也是vue内部的。所以刷新页面会出现下面问题。<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/094dfb8d4ef2f50f210c7d07055e80cd/aa3390a399ce523d9f85a60991af0fb0.png\" alt></p>\n<p>参考资料<a href=\"https://learnku.com/articles/34440\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<p>解决问题<br>在服务端nginx配置里添加vue-route的跳转设置（这里首页是index.html，如果是index.php就在下面对应位置替换），正确配置如下：</p>\n<pre><code>server\n{\n    listen 80;\n    server_name testwx.wangshibo.com;\n    index index.php index.html index.htm default.php default.htm default.html;\n    root /www/wwwroot/ssoShuang/dist;\n\n    #vue-router配置\n    location / {\n        try_files $uri $uri/ @router;\n        index index.html;\n    }\n    location @router {\n        rewrite ^.*$ /index.html last;\n    }\n}</code></pre><p>重启 nginx 后，问题就迎刃而解了。</p>\n<h2 id=\"最后讲解自动启动问题\"><a href=\"#最后讲解自动启动问题\" class=\"headerlink\" title=\"最后讲解自动启动问题\"></a>最后讲解自动启动问题</h2><p>使用ssh 连接后，终端退出那么任务也就没了<br>所以我使用自动启动<br>这里主要用systemctl</p>\n<p>我的服务器使用centos7，他的systemctl自动启动项在目录 <code>/usr/lib/systemd/system/</code><br>新建service文件：<br>我新建了lwl.service文件</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/094dfb8d4ef2f50f210c7d07055e80cd/d0e1d7499ec41e61352e770dce643276.png\" alt></p>\n<p>具体配置</p>\n<pre><code>[Unit]\nDescription=lwl       #描述\nAfter=network.target  #前置启动的程序\n\n[Service]            #具体的命令了\nType=forking\nExecStart=/root/init.sh   # 开启该任务的命令\nExecReload=/root/init.sh  #重启\nExecStop=/root/init.sh    #关闭\n\n[Install]  \nWantedBy=multi-user.target</code></pre><p><strong>注意</strong><br><strong>systemctl执行脚本时需要知道脚本的解释器</strong><br>解决方法：<br>在/root/init.sh脚本的开头加上<code>#!/bin/sh</code></p>\n<p>最后的init.sh</p>\n<pre><code>#!/bin/sh\n\nfirewall-cmd --zone=public --add-port=5000/tcp    &amp;  #开启防火墙端口\n\npython /root/lwl/code/python/deploy/flaskApi.py &amp;  # 运行指定项目\n\n\n#用来查找某个端口的进程pid\n#netstat -nlp | grep 5000 | awk &#39;{print $7}&#39; | awk -F&quot;/&quot; &#39;{ print $1 }&#39;</code></pre><p>然后就是一些命令了</p>\n<pre><code>\n#查看日志\n$ sudo journalctl -f -u nginx.service\n— Logs begin at 四 2015-06-25 17:32:20 CST. —\n6月 25 10:28:24 Leco.lan systemd[1]: Starting nginx – high performance web server…\n\n启动一个服务：systemctl start nginx.service\n关闭一个服务：systemctl stop postfix.service\n重启一个服务：systemctl restart nginx.service\n显示一个服务的状态：systemctl status postfix.service\n在开机时启用一个服务：systemctl enable nginx.service\n在开机时禁用一个服务：systemctl disable nginx.service\n查看服务是否开机启动：systemctl is-enabled nginx.service\n查看已启动的服务列表：systemctl list-unit-files|grep enabled\n\n\n刚刚配置的服务需要让systemctl能识别，就必须刷新配置\n$ systemctl daemon-reload</code></pre><p><strong>尽量将运行命令写的精确</strong><br>比如我的python有多个版本，那么尽量写成<br><code>/usr/bin/python   /root/lwl/code/python/deploy/flaskApi.py &amp;  # 运行指定项目</code></p>\n<h3 id=\"简单讲程序放入后台\"><a href=\"#简单讲程序放入后台\" class=\"headerlink\" title=\"简单讲程序放入后台\"></a>简单讲程序放入后台</h3><p>nohup命令：<br>如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。nohup就是不挂起的意思。</p>\n<p>我们现在开始启动服务 python pyserver.py，并且希望在后台运行.我们就可以使用nohup，命令如下：</p>\n<p><code>nohup python pyserver.py</code></p>\n"},{"_content":"# 电视机TV盒子\n\n众所周知，很多电视机一般都会带有机顶盒，但是很多时候这个机顶盒大多不好用。\n\n要么性能太差了，要么使用起来太繁琐，各种广告，各种需要进入某个app才能用。\n\n\n\n# solutions\n\n\n\n## 方案1 使用电视家等app\n\n遵守以下设置，能够得到不错的体验感。\n\n![image-20221224210906834](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7f64d648174bc0ffb590feddcf140ff6/aadd7d9c3e6c68ad5f8eecd5d069fdef.png)\n\n收藏里面可以设置需要的频道。\n\n\n\n## 方案2 使用kodi的iptv直播源\n\nkodi是一个非常优秀的开源视频播放应用，跨平台，且生态丰富。\n\n注意以下设置\n\n- root机顶盒，将机顶盒设置成开机自动进入kodi\n- kodi内部设置启动app自动进入电视播放\n- 选择一个稳定的iptv源\n- 利用云端url实现m3u源对本地电视节目的控制\n- 云端时间可视化修改m3u源，实现定制化，台太多也不好。","source":"_posts/综合/电视盒子搭建方案.md","raw":"# 电视机TV盒子\n\n众所周知，很多电视机一般都会带有机顶盒，但是很多时候这个机顶盒大多不好用。\n\n要么性能太差了，要么使用起来太繁琐，各种广告，各种需要进入某个app才能用。\n\n\n\n# solutions\n\n\n\n## 方案1 使用电视家等app\n\n遵守以下设置，能够得到不错的体验感。\n\n![image-20221224210906834](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7f64d648174bc0ffb590feddcf140ff6/aadd7d9c3e6c68ad5f8eecd5d069fdef.png)\n\n收藏里面可以设置需要的频道。\n\n\n\n## 方案2 使用kodi的iptv直播源\n\nkodi是一个非常优秀的开源视频播放应用，跨平台，且生态丰富。\n\n注意以下设置\n\n- root机顶盒，将机顶盒设置成开机自动进入kodi\n- kodi内部设置启动app自动进入电视播放\n- 选择一个稳定的iptv源\n- 利用云端url实现m3u源对本地电视节目的控制\n- 云端时间可视化修改m3u源，实现定制化，台太多也不好。","slug":"综合/电视盒子搭建方案","published":1,"date":"2023-02-27T11:33:23.582Z","updated":"2023-02-27T11:34:33.141Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsydb00230gcndzedcqq7","content":"<h1 id=\"电视机TV盒子\"><a href=\"#电视机TV盒子\" class=\"headerlink\" title=\"电视机TV盒子\"></a>电视机TV盒子</h1><p>众所周知，很多电视机一般都会带有机顶盒，但是很多时候这个机顶盒大多不好用。</p>\n<p>要么性能太差了，要么使用起来太繁琐，各种广告，各种需要进入某个app才能用。</p>\n<h1 id=\"solutions\"><a href=\"#solutions\" class=\"headerlink\" title=\"solutions\"></a>solutions</h1><h2 id=\"方案1-使用电视家等app\"><a href=\"#方案1-使用电视家等app\" class=\"headerlink\" title=\"方案1 使用电视家等app\"></a>方案1 使用电视家等app</h2><p>遵守以下设置，能够得到不错的体验感。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7f64d648174bc0ffb590feddcf140ff6/aadd7d9c3e6c68ad5f8eecd5d069fdef.png\" alt=\"image-20221224210906834\"></p>\n<p>收藏里面可以设置需要的频道。</p>\n<h2 id=\"方案2-使用kodi的iptv直播源\"><a href=\"#方案2-使用kodi的iptv直播源\" class=\"headerlink\" title=\"方案2 使用kodi的iptv直播源\"></a>方案2 使用kodi的iptv直播源</h2><p>kodi是一个非常优秀的开源视频播放应用，跨平台，且生态丰富。</p>\n<p>注意以下设置</p>\n<ul>\n<li>root机顶盒，将机顶盒设置成开机自动进入kodi</li>\n<li>kodi内部设置启动app自动进入电视播放</li>\n<li>选择一个稳定的iptv源</li>\n<li>利用云端url实现m3u源对本地电视节目的控制</li>\n<li>云端时间可视化修改m3u源，实现定制化，台太多也不好。</li>\n</ul>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"电视机TV盒子\"><a href=\"#电视机TV盒子\" class=\"headerlink\" title=\"电视机TV盒子\"></a>电视机TV盒子</h1><p>众所周知，很多电视机一般都会带有机顶盒，但是很多时候这个机顶盒大多不好用。</p>\n<p>要么性能太差了，要么使用起来太繁琐，各种广告，各种需要进入某个app才能用。</p>\n<h1 id=\"solutions\"><a href=\"#solutions\" class=\"headerlink\" title=\"solutions\"></a>solutions</h1><h2 id=\"方案1-使用电视家等app\"><a href=\"#方案1-使用电视家等app\" class=\"headerlink\" title=\"方案1 使用电视家等app\"></a>方案1 使用电视家等app</h2><p>遵守以下设置，能够得到不错的体验感。</p>\n<p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/7f64d648174bc0ffb590feddcf140ff6/aadd7d9c3e6c68ad5f8eecd5d069fdef.png\" alt=\"image-20221224210906834\"></p>\n<p>收藏里面可以设置需要的频道。</p>\n<h2 id=\"方案2-使用kodi的iptv直播源\"><a href=\"#方案2-使用kodi的iptv直播源\" class=\"headerlink\" title=\"方案2 使用kodi的iptv直播源\"></a>方案2 使用kodi的iptv直播源</h2><p>kodi是一个非常优秀的开源视频播放应用，跨平台，且生态丰富。</p>\n<p>注意以下设置</p>\n<ul>\n<li>root机顶盒，将机顶盒设置成开机自动进入kodi</li>\n<li>kodi内部设置启动app自动进入电视播放</li>\n<li>选择一个稳定的iptv源</li>\n<li>利用云端url实现m3u源对本地电视节目的控制</li>\n<li>云端时间可视化修改m3u源，实现定制化，台太多也不好。</li>\n</ul>\n"},{"_content":"# 贝塞尔曲线推导以及python代码实现\n\n## 原理\n\n![在这里插入图片描述](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/5304707d10f5d20948c5c1d56e41c9d4/8fb43142fcbe58872d69fb76f92fb3c8.png)\n\n\n保持比例不变\n![在这里插入图片描述](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/5304707d10f5d20948c5c1d56e41c9d4/7dbb2455a81ed2a24475512e315108e4.png)\n不断运动，最后\n![在这里插入图片描述](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/5304707d10f5d20948c5c1d56e41c9d4/64ab10fbfb0de42eccbfecedc755d5b7.png)\n\n## 拓展到高阶\n不断**两两连线**\nn阶可以变成n-1阶。\n从而不断递推到0阶（也就是说只有一个点）\n\n在不断变化过程，保持各线段的比例相等。\n\n运动的变量也是比例rate，从[0,1]\n\n```sql\n\nfrom matplotlib import pyplot\nimport numpy as np\npoints = [\n    [0,0],\n    [1,0],\n    [1, 1],\n    [2,1]\n]\n\npoints = np.array(points)\n\n\n\n# 通过递归构造贝塞尔曲线\ndef calNextPoints(points, rate): # 如果给定了具体的n， 那么可以直接得到计算方程\n    if len(points) == 1:\n        return points\n\n    left = points[0]\n    ans = []\n    for i in range(1, len(points)): # 根据比例计算当前的点的坐标，一层层的推进\n        right = points[i]\n        disX = right[0] - left[0]\n        disY = right[1] - left[1]\n\n        nowX = left[0] + disX * rate\n        nowY = left[1] + disY * rate\n        ans.append([nowX, nowY])\n\n        # 更新left\n        left = right\n\n    return calNextPoints(ans, rate)\n\nX= []\nY = []\nfor r in range(1, 100):\n    r = r / 100\n    a = calNextPoints(points, rate=r)\n    # print(a)\n    x = a[0][0]\n    y = a[0][1]\n    X.append(x)\n    Y.append(y)\n\n\nprint(points[:,1])\npyplot.scatter(points[:,0], points[:,1], c='blue')\npyplot.plot(X, Y)\n\npyplot.show()\n```\n","source":"_posts/综合/贝塞尔曲线.md","raw":"# 贝塞尔曲线推导以及python代码实现\n\n## 原理\n\n![在这里插入图片描述](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/5304707d10f5d20948c5c1d56e41c9d4/8fb43142fcbe58872d69fb76f92fb3c8.png)\n\n\n保持比例不变\n![在这里插入图片描述](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/5304707d10f5d20948c5c1d56e41c9d4/7dbb2455a81ed2a24475512e315108e4.png)\n不断运动，最后\n![在这里插入图片描述](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/5304707d10f5d20948c5c1d56e41c9d4/64ab10fbfb0de42eccbfecedc755d5b7.png)\n\n## 拓展到高阶\n不断**两两连线**\nn阶可以变成n-1阶。\n从而不断递推到0阶（也就是说只有一个点）\n\n在不断变化过程，保持各线段的比例相等。\n\n运动的变量也是比例rate，从[0,1]\n\n```sql\n\nfrom matplotlib import pyplot\nimport numpy as np\npoints = [\n    [0,0],\n    [1,0],\n    [1, 1],\n    [2,1]\n]\n\npoints = np.array(points)\n\n\n\n# 通过递归构造贝塞尔曲线\ndef calNextPoints(points, rate): # 如果给定了具体的n， 那么可以直接得到计算方程\n    if len(points) == 1:\n        return points\n\n    left = points[0]\n    ans = []\n    for i in range(1, len(points)): # 根据比例计算当前的点的坐标，一层层的推进\n        right = points[i]\n        disX = right[0] - left[0]\n        disY = right[1] - left[1]\n\n        nowX = left[0] + disX * rate\n        nowY = left[1] + disY * rate\n        ans.append([nowX, nowY])\n\n        # 更新left\n        left = right\n\n    return calNextPoints(ans, rate)\n\nX= []\nY = []\nfor r in range(1, 100):\n    r = r / 100\n    a = calNextPoints(points, rate=r)\n    # print(a)\n    x = a[0][0]\n    y = a[0][1]\n    X.append(x)\n    Y.append(y)\n\n\nprint(points[:,1])\npyplot.scatter(points[:,0], points[:,1], c='blue')\npyplot.plot(X, Y)\n\npyplot.show()\n```\n","slug":"综合/贝塞尔曲线","published":1,"date":"2023-02-27T11:33:23.578Z","updated":"2023-02-27T11:34:33.137Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsydb00240gcny3fch3f8","content":"<h1 id=\"贝塞尔曲线推导以及python代码实现\"><a href=\"#贝塞尔曲线推导以及python代码实现\" class=\"headerlink\" title=\"贝塞尔曲线推导以及python代码实现\"></a>贝塞尔曲线推导以及python代码实现</h1><h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/5304707d10f5d20948c5c1d56e41c9d4/8fb43142fcbe58872d69fb76f92fb3c8.png\" alt=\"在这里插入图片描述\"></p>\n<p>保持比例不变<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/5304707d10f5d20948c5c1d56e41c9d4/7dbb2455a81ed2a24475512e315108e4.png\" alt=\"在这里插入图片描述\"><br>不断运动，最后<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/5304707d10f5d20948c5c1d56e41c9d4/64ab10fbfb0de42eccbfecedc755d5b7.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"拓展到高阶\"><a href=\"#拓展到高阶\" class=\"headerlink\" title=\"拓展到高阶\"></a>拓展到高阶</h2><p>不断<strong>两两连线</strong><br>n阶可以变成n-1阶。<br>从而不断递推到0阶（也就是说只有一个点）</p>\n<p>在不断变化过程，保持各线段的比例相等。</p>\n<p>运动的变量也是比例rate，从[0,1]</p>\n<pre class=\"line-numbers language-sql\"><code class=\"language-sql\">\n<span class=\"token keyword\">from</span> matplotlib <span class=\"token keyword\">import</span> pyplot\n<span class=\"token keyword\">import</span> numpy <span class=\"token keyword\">as</span> np\npoints <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">]</span>\n\npoints <span class=\"token operator\">=</span> np<span class=\"token punctuation\">.</span>array<span class=\"token punctuation\">(</span>points<span class=\"token punctuation\">)</span>\n\n\n\n<span class=\"token comment\" spellcheck=\"true\"># 通过递归构造贝塞尔曲线</span>\n<span class=\"token number\">def</span> calNextPoints<span class=\"token punctuation\">(</span>points<span class=\"token punctuation\">,</span> rate<span class=\"token punctuation\">)</span>: <span class=\"token comment\" spellcheck=\"true\"># 如果给定了具体的n， 那么可以直接得到计算方程</span>\n    <span class=\"token keyword\">if</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>points<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">=</span> <span class=\"token number\">1</span>:\n        <span class=\"token keyword\">return</span> points\n\n    <span class=\"token keyword\">left</span> <span class=\"token operator\">=</span> points<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n    ans <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token operator\">in</span> range<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>points<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>: <span class=\"token comment\" spellcheck=\"true\"># 根据比例计算当前的点的坐标，一层层的推进</span>\n        <span class=\"token keyword\">right</span> <span class=\"token operator\">=</span> points<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n        disX <span class=\"token operator\">=</span> <span class=\"token keyword\">right</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> <span class=\"token keyword\">left</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n        disY <span class=\"token operator\">=</span> <span class=\"token keyword\">right</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> <span class=\"token keyword\">left</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n\n        nowX <span class=\"token operator\">=</span> <span class=\"token keyword\">left</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> disX <span class=\"token operator\">*</span> rate\n        nowY <span class=\"token operator\">=</span> <span class=\"token keyword\">left</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> disY <span class=\"token operator\">*</span> rate\n        ans<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>nowX<span class=\"token punctuation\">,</span> nowY<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n        <span class=\"token comment\" spellcheck=\"true\"># 更新left</span>\n        <span class=\"token keyword\">left</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">right</span>\n\n    <span class=\"token keyword\">return</span> calNextPoints<span class=\"token punctuation\">(</span>ans<span class=\"token punctuation\">,</span> rate<span class=\"token punctuation\">)</span>\n\nX<span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\nY <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">for</span> r <span class=\"token operator\">in</span> range<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span>:\n    r <span class=\"token operator\">=</span> r <span class=\"token operator\">/</span> <span class=\"token number\">100</span>\n    <span class=\"token number\">a</span> <span class=\"token operator\">=</span> calNextPoints<span class=\"token punctuation\">(</span>points<span class=\"token punctuation\">,</span> rate<span class=\"token operator\">=</span>r<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\" spellcheck=\"true\"># print(a)</span>\n    x <span class=\"token operator\">=</span> <span class=\"token number\">a</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n    y <span class=\"token operator\">=</span> <span class=\"token number\">a</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n    X<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span>\n    Y<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>y<span class=\"token punctuation\">)</span>\n\n\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>points<span class=\"token punctuation\">[</span>:<span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\npyplot<span class=\"token punctuation\">.</span>scatter<span class=\"token punctuation\">(</span>points<span class=\"token punctuation\">[</span>:<span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> points<span class=\"token punctuation\">[</span>:<span class=\"token punctuation\">,</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token number\">c</span><span class=\"token operator\">=</span><span class=\"token string\">'blue'</span><span class=\"token punctuation\">)</span>\npyplot<span class=\"token punctuation\">.</span>plot<span class=\"token punctuation\">(</span>X<span class=\"token punctuation\">,</span> Y<span class=\"token punctuation\">)</span>\n\npyplot<span class=\"token punctuation\">.</span><span class=\"token keyword\">show</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"贝塞尔曲线推导以及python代码实现\"><a href=\"#贝塞尔曲线推导以及python代码实现\" class=\"headerlink\" title=\"贝塞尔曲线推导以及python代码实现\"></a>贝塞尔曲线推导以及python代码实现</h1><h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/5304707d10f5d20948c5c1d56e41c9d4/8fb43142fcbe58872d69fb76f92fb3c8.png\" alt=\"在这里插入图片描述\"></p>\n<p>保持比例不变<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/5304707d10f5d20948c5c1d56e41c9d4/7dbb2455a81ed2a24475512e315108e4.png\" alt=\"在这里插入图片描述\"><br>不断运动，最后<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/5304707d10f5d20948c5c1d56e41c9d4/64ab10fbfb0de42eccbfecedc755d5b7.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"拓展到高阶\"><a href=\"#拓展到高阶\" class=\"headerlink\" title=\"拓展到高阶\"></a>拓展到高阶</h2><p>不断<strong>两两连线</strong><br>n阶可以变成n-1阶。<br>从而不断递推到0阶（也就是说只有一个点）</p>\n<p>在不断变化过程，保持各线段的比例相等。</p>\n<p>运动的变量也是比例rate，从[0,1]</p>\n<pre><code class=\"sql\">\nfrom matplotlib import pyplot\nimport numpy as np\npoints = [\n    [0,0],\n    [1,0],\n    [1, 1],\n    [2,1]\n]\n\npoints = np.array(points)\n\n\n\n# 通过递归构造贝塞尔曲线\ndef calNextPoints(points, rate): # 如果给定了具体的n， 那么可以直接得到计算方程\n    if len(points) == 1:\n        return points\n\n    left = points[0]\n    ans = []\n    for i in range(1, len(points)): # 根据比例计算当前的点的坐标，一层层的推进\n        right = points[i]\n        disX = right[0] - left[0]\n        disY = right[1] - left[1]\n\n        nowX = left[0] + disX * rate\n        nowY = left[1] + disY * rate\n        ans.append([nowX, nowY])\n\n        # 更新left\n        left = right\n\n    return calNextPoints(ans, rate)\n\nX= []\nY = []\nfor r in range(1, 100):\n    r = r / 100\n    a = calNextPoints(points, rate=r)\n    # print(a)\n    x = a[0][0]\n    y = a[0][1]\n    X.append(x)\n    Y.append(y)\n\n\nprint(points[:,1])\npyplot.scatter(points[:,0], points[:,1], c=&#39;blue&#39;)\npyplot.plot(X, Y)\n\npyplot.show()</code></pre>\n"},{"_content":"# 算法比赛套路\n\n## leetcode得进阶套路\n### 如何判断出当前是第多少个case\n```angular2html\nimport math\nmath.a=0\nclass Solution:\n\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n\n        math.a+=1\n        print(math.a)\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[i] + nums[j] == target:\n                    return [i, j]\n        \n        return []\n\n```\n\n## python 常见语法，常用函数\n\n### 字符串篇\n```\na = 'Aaaaa'\nprint(a.count('a'))  #统计某个字符串的次数\nprint(a.lower())\nprint(a.upper())\n\nb= a.replace('a', 'b')  # 进行替换\nprint(b)\n\n```\n\n**正则表达式**\n```\nimport re   #引入正则表达式包\ns  = \"abcadffiwef/sdfsdf\"\nb = re.match('abc.*', s)\nprint(b[0])\n\nc= re.search('c.*', s)\nprint(c[0])\n\nout：\nabcadffiwef/sdfsdf\ncadffiwef/sdfsdf\n```\n\n**format 格式化**\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/fc0be165a0bc9778d3c91526f418f9cb/102c800bccc240e3638f91a2b3a8cc2a.png)\n```\ns = 'asdf{},adfsdf{}'\nprint(s.format(2,1))\n\nprint('asdf{0},adfsdf{2}'.format(1,2,3)) #利用下标进行索引\n\nprint('asdf{name},adfsdf{pwd}'.format(name = 1, pwd = 32))  # 利用字符串进行替换，参数\n\nprint('{:.2f}'.format(2.339))\n\n```\n\n### eval（） NB\n\n```\nx  = 10\nans  = eval('x + 2')\nprint(ans)\n\nans = eval('pow(2,x)')\nprint(ans)\n\n\nout：\n12\n1024\n\n```\n\n\n### 上下界的查询\n使用python的库bisect\n```\nimport bisect\na  = [1,2,3]\n\ntmp = bisect.bisect_right(a, 3)  #查询到右边\nprint(tmp)\n\n```\n\n\n### 位运算\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/fc0be165a0bc9778d3c91526f418f9cb/19c77f3864081a14794e00af87337e2c.png)\n\n\n\n### 保留小数位\n```\nx = 1.512187\nprint(round(x,4))  # 四舍五入保留几位\nprint(round(x,100)) # 但是不能强制输出多位\n\n\nprint('%.4f'%x)\nprint('%.10f'%x) #可以强制输出\n\nimport math\nprint(math.floor(x)) # 向下取整\nprint(math.ceil(x))  #向上取整\n```\n### 队列List\n删除操作，添加操作\n```\n只是有这些操作而已，不过效率低下\n\nnums = ['a', 'b', 'c', 'd']\n\nnums.__delitem__(0)根据下标  # 类似的 {}集合也有这个方法\nprint(nums)\n\nnums.append('a')\nnums.append('b')  # 添加\nnums.insert(1,'F') # 往下标所在位置插入\n\nprint(nums)\n\nnums.remove('b')\n\nprint(nums)\n\nnums.remove('b')  #删除看到的第一个元素\n\nprint(nums)\n\nnums.extend([1,1])这个比加法运算符效率稍微高点\n\n```\n\n\n### 进制转换\n```\nx  =14\nprint(bin(x))# 2进制\n'{:018b}'.format(i) # 这样可以转化为进制后补0。 这里b代表二进制， 18 代表18位\n\nprint(oct(x))  # 8进制\nprint(hex(x))# 16进制\nprint(int(x))# 10进制\n\n\n#将10 进制转化为N进制\ndef TentoN(num, N):\n    num = int(num)\n    ans =[]\n    while num !=0:\n        rest = num % N\n        num = num // N\n        ans.append(rest)\n\n    ans.reverse()\n    return ans\n\n\n# 将N进制转化为10进制\ndef NtoTen(num, N):\n    ans =0\n    num = str(num)\n    for i in num:\n        ans= ans * N + int(i)\n\n    return ans\n\n```\n\n### 数学排列组合\n```\nimport math\n\ndef factorial_(n):\n    result=1\n    for i in range(2,n+1):\n        result=result*i\n    return result\n\ndef comb_1(n,m):\n    return math.factorial(n)//(math.factorial(n-m)*math.factorial(m))  #直接使用math里的阶乘函数计算组合数\n\ndef comb_2(n,m):\n    return factorial_(n)//(factorial_(n-m)*factorial_(m))              #使用自己的阶乘函数计算组合数\n\ndef perm_1(n,m):\n    return math.factorial(n)//math.factorial(n-m)                        #直接使用math里的阶乘函数计算排列数\n\ndef perm_2(n,m):\n    return math.factorial(n)//math.factorial(n-m)                        #使用自己的阶乘函数计算排列数\n\nif __name__=='__main__':\n    print(comb_1(3,2))\n    print(comb_2(3,2))\n    print(perm_1(3,2))\n    print(perm_2(3,2))\n\n```\n\n\n## 数据结构篇\n\n### 常规的树\n\n\n```\n\nclass node:\n    def __init__(self):\n        self.parent =None\n        self.children =[]\n        self.deep = None  # 层级\n        self.tag = None\n        self.id = None\n        self.index =None\n\n    def show(self):\n        print('.' * self.deep*2, end='')\n        # print(self.id, end=' ')\n        print(self.tag + ' ')\n        for i in self.children:\n            i.show()\n\n```\n\n\n### 并查集\n判断元素是否同集合以及合并\n\n```\n\nclass BQSet():\n    def __init__(self):\n        self.f = {}  # f[i]代表i的父节点\n        # #init\n        # for i in range(10):\n        #     f[i] = i\n\n    def getFather(self,origin):\n        a = origin\n        while self.f[a] != a:\n            a = self.f[a]\n        self.f[origin] = a\n        return a\n\n    # 只需要看a， b 是否 有共同父节点\n    def judge(self,a, b):\n        a  = self.getFather(a)\n        b = self.getFather(b)\n\n        if self.f[a] == self.f[b]:\n            return True\n        else:\n            return False\n\n    def Union(self,source, a):\n        a = self.getFather(a)\n        sF = self.getFather(source)\n        self.f[a] = sF\n\nif __name__ == '__main__':\n    bq = BQSet()\n    for i in range(10):\n        bq.f[i] =i\n\n    bq.f[2] =1\n    a= bq.judge(1,2)\n    bq.Union(2,3)\n    print(a)\n```\n\n\n\n### 最小生成树 Kruskal\n边权值和最小\n```\nn, m = input().split(' ')\nn = int(n)\n\n# print(n)\nm = int(m)\nedges = []\nfor i in range(m):\n    s = input().split(' ')\n    edges.append((int(s[0]), int(s[1]), int(s[2])))\n\n\n# 并查集\nclass BQSet():\n    def __init__(self):\n        self.f = {}\n        # #init\n        # for i in range(10):\n        #     f[i] = i\n\n    def getFather(self, origin):\n        a = origin\n        while self.f[a] != a:\n            a = self.f[a]\n        self.f[origin] = a\n        return a\n\n    # 只需要看a， b 是否 有共同父节点\n    def judge(self, a, b):\n        a = self.getFather(a)\n        b = self.getFather(b)\n\n        if self.f[a] == self.f[b]:\n            return True\n        else:\n            return False\n\n    def Union(self, source, a):\n        a = self.getFather(a)\n        sF = self.getFather(source)\n        self.f[a] = sF\n\n\n#  Kruskal 关键是判断是不是同一个集合里面\n\n\ndef kruskal(edges):\n    bq = BQSet()\n\n    # 初始化并查集\n    for i in range(1, n + 1):\n        bq.f[i] = i\n\n    # 先进行排序\n    edges = sorted(edges, key=lambda x: x[2])\n    # print(edges)\n    arried = {}\n    # finalE =[]\n    sum = 0\n    count = 0\n    for u, v, w in edges:\n        if bq.judge(u, v):\n            pass\n        else:  # 如果边不在同一个集合，就加入\n            bq.Union(u, v)\n            sum += w\n            count += 1\n\n    if count == n - 1:\n        print(sum)\n    else:\n        print('orz')\n\n\n# print(count)\n\n\nkruskal(edges)\n```\n\n\n\n\n## 算法板子\n\n\n\n### 快排板子\n\n```\n\n# 可以自定义比较函数，决定排序方式\ndef cmp(a,b):\n    return a>b\n\n\nclass quiteSort:\n    def __init__(self):\n        self.cmp = lambda a, b:a< b\n\n    # 设置比较函数\n    def setCmp(self, cmp):\n        self.cmp =cmp\n\n    # 随机找一个中间基准值，将数据分成左右两堆\n    def randomized_partition(self, nums, l, r):\n        import random\n        pivot = random.randint(l, r)\n        nums[pivot], nums[r] = nums[r], nums[pivot]\n        i = l - 1\n        for j in range(l, r):\n            if self.cmp(nums[j],nums[r]):\n                i += 1\n                nums[j], nums[i] = nums[i], nums[j]\n        i += 1\n        nums[i], nums[r] = nums[r], nums[i]\n        return i\n\n    # 不断进行细分\n    def randomized_quicksort(self, nums, l, r):\n        if r - l <= 0:\n            return\n        mid = self.randomized_partition(nums, l, r)\n        self.randomized_quicksort(nums, l, mid - 1)\n        self.randomized_quicksort(nums, mid + 1, r)\n\n    def sortArray(self, nums):\n        self.randomized_quicksort(nums, 0, len(nums) - 1)\n        return nums\n\n```\n\n\n### 自定义二分查找\n```\nclass DichotomousSearch():\n    def __init__(self):\n        pass\n\n\n    # 查找k在有序数组nums 中得位置。 nums是升序得\n    #return index, flag flag是代表是否有和k匹配得数得bool。\n    def search(self, nums, k):\n        l = 0\n        r = len(nums)-1\n\n        while l<r:\n            mid = (l + r) // 2\n\n            if nums[mid]> k:   #  向左边找\n                r = mid - 1\n            elif nums[mid] <k:  # 向右边找\n                l = mid +1\n            elif nums[mid] == k:\n                l = r = mid\n                break\n\n\n        if nums[l] == k:\n            return l, True\n        else:\n            return l, False\n\n\n```\n\n### Dijstra 最短路径\n```\nimport collections\nINF =float('inf')\nimport heapq\nclass Solution(object):\n    def networkDelayTime(self, times, N, K):\n        \"\"\"\n        :type times: List[List[int]]\n        :type N: int\n        :type K: int\n        :rtype: int\n        \"\"\"\n\n\n        adj ={} # 邻接表\n        for i in range(1,N+1):\n            adj[i] ={}\n\n\n\n        for u, v, w in times:\n            adj[u][v] =w\n\n\n        def dijkstra(adj, K): #K是出发的点， 这里默认到达所有点\n            arrived ={}   # 已经到的点\n            pq = [(0, K)]# 存储需要到的点的最短值\n            while pq:\n                d, node = heapq.heappop(pq)\n                if node in arrived: # 如果已经到达，\n                    continue\n                arrived[node] = d\n                # print(node)\n                for nei in adj[node]:\n                    if nei not in arrived:\n                        heapq.heappush(pq, (d + adj[node][nei], nei))\n\n            return arrived\n\n\n        print(dijkstra(adj, K))\n\nSolution.networkDelayTime(None,times = [[2,1,1],[2,3,1],[3,4,1]], N = 4, K = 2)\n```\n\n\n### SPFA最短路\n```\n# 总结一下，SPFA是如何做到“只更新可能更新的点”的？\n#\n# 只让当前点能到达的点入队\n# 如果一个点已经在队列里，便不重复入队\n# 如果一条边未被更新，那么它的终点不入队\n\n\nINF =float('inf')\nclass SPFA(object):\n    def networkDelayTime(self, edges, N, K):\n        \"\"\"\n        :type times: List[List[int]]\n        :type N: int\n        :type K: int\n        :rtype: int\n        \"\"\"\n        times =edges\n        arrived ={}   # 已经到的点\n        for i in range(1, N + 1):\n            arrived[i] = INF\n        arrived[K] = 0\n\n\n        adj ={} # 邻接表\n        for i in range(1,N+1):\n            adj[i] ={}\n\n        for u, v, w in times:\n            adj[u][v] =w\n\n        q = [K]  # 优化队列\n        vis ={}  # 是否正在队列里\n        count = {}  # 统计在队列里出现多少次\n        for i in range(1,N+1):\n            vis[i] = False\n            count[i] = 0\n        vis[K] = True  # 代表在队列里面\n        count[K] +=1\n        while q:\n\n            now = q.pop()\n            vis[now] = False\n            for i in adj[now]:\n                to = i\n                # 进行了松弛的点\n                if arrived[to]> arrived[now] + adj[now][to]:\n                    arrived[to] =  arrived[now] + adj[now][to]\n                    if not vis[to]:\n                        vis[to] = True\n                        count[to] +=1\n                        q.append(to)\n                        if count[to] > N+1:  #  //判断负环\n                            return False\n\n\n        return arrived\n\n\n\n\na = SPFA.networkDelayTime(None,[[1,2,1],[2,3,7],[1,3,4],[2,1,2]],\n3,\n2)\nprint(a)\n```\n\n\n### floyd最短路\n```\n\n# 2、Floyd算法可以解决多源最短路径；\n# k 前k个点代表在前k个的前提下的最短路径\n\nimport collections\nINF =float('inf')\nclass Solution(object):\n    def networkDelayTime(self, times, N, K):\n        \"\"\"\n        :type times: List[List[int]]\n        :type N: int\n        :type K: int\n        :rtype: int\n        \"\"\"\n\n\n        adj ={} # 邻接表\n        # 初始化邻接表\n        for i in range(1,N+1):\n            adj[i]={}\n            for j in range(1,N+1):\n                adj[i][j]  = INF\n                if i ==j:\n                    adj[i][j] = 0\n\n        for u, v, w in times:\n            adj[u][v] =w\n\n        def floyd(adj):\n            for k in range(1, N+1):\n                for i in range(1, N + 1):\n                    for j in range(1, N + 1):\n                        adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n\n\n            return adj\n\n        adj = floyd(adj)\n\n\n        if max(adj[K].values()) == INF:\n            return -1\n\n        return max(adj[K].values())\n\n\na = Solution.networkDelayTime(None,times = [[2,1,1],[2,3,1],[3,4,1]], N = 4, K = 2)\nprint(a)\n```\n\n\n\n\n### 拓补排序\n\n- 不断找入度为0的点\n\n\n\n### 线段树\n\n```\n\n```\n\n\n### 回溯全排列\n\n```\narr = [i+1 for i in range(5)]\n\n\nvisit = [True for i in range(len(arr))]\ntemp = [\"\" for x in range(0, len(arr))]\n# 回溯记录\n\ndef dfs(position):\n    if position == len(arr):\n        print(temp)\n        return None\n\n    for index in range(0, len(arr)):\n        if visit[index] == True:\n            temp[position] = arr[index]\n            visit[index] = False\n            dfs(position + 1)\n            visit[index] = True\n\n\ndfs(0)\n```\n\n\n\n### 查分约束\n转化为图的问题\n\n### KMP字符串匹配\n自动状态机\n\n```\n\nclass Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        if haystack == '':\n            if needle =='':\n                return 0\n            else:\n                return -1\n        elif needle =='':\n            return 0\n\n\n\n        # 计算next数组， next[i]代表前i个字符串的最长子串\n        def getnext(s):\n            n = len(s)\n            next = [0,0]  # 第一个0代表空字符串\n            for i in range(2, n+1):\n                # print(next, s, i-1)\n                if s[next[i-1]] == s[i-1]:\n                    next.append(next[i-1] +1)\n                else:\n                    j = next[next[i-1]]\n                    while j > 0:\n                        if s[j] == s[i-1]:\n                            next.append(j+1)\n                            break\n                        j = next[j]\n                    if j ==0:\n                        if s[i-1] == s[0]:\n                            next.append(1)\n                        else:\n                            next.append(0)\n\n            return next\n\n        next  =getnext(needle)\n        print(next)\n\n\n        # 构造有限状态机\n        def kmp(s, next):  # 一个状态机\n            n = len(s)\n            state = {'other':True}\n            for i in s:\n                state[i] = True\n\n            matrix = [{} for i in range(n+1)]\n\n            #初始化\n            for i in state:\n                matrix[0][i] = 0\n            matrix[0][s[0]] =1\n\n\n            # 归纳法进行递推\n            for i in range(1, n+1):\n\n                j = i\n                while j> 0:\n                    if j >= n:\n                        j = next[j]\n                        continue\n                    char = s[j]\n                    if char not in matrix[i]:\n                        matrix[i][char] = j+1\n                    j = next[j]\n                if j ==0:\n                    if s[0] not in matrix[i]:\n                        matrix[i][s[0]] =1\n                for k in state:\n                    if k not in matrix[i]:\n                        matrix[i][k] = 0\n            return matrix, state\n\n\n\n\n\n\n        m,state = kmp(needle, next)\n        for i in range(len(m)):\n            print(i, m[i])\n        print(m)\n\n\n        def search(txt):\n            N = len(txt)\n            l = len(needle)\n            stateNow = 0\n            for i in range(N):\n                char = txt[i]\n                if char in state:\n                    stateNow = m[stateNow][char]\n                else:\n                    stateNow = m[stateNow]['other']\n\n                if stateNow == l:\n                    return i- l+1\n            return -1\n\n        print(search(haystack))\n        return search(haystack)\n\n\n\n\nSolution.strStr(None,\"ababcaababcaabc\",\n\"ababcaabc\")\n\n\n\n```","source":"_posts/综合/算法比赛套路.md","raw":"# 算法比赛套路\n\n## leetcode得进阶套路\n### 如何判断出当前是第多少个case\n```angular2html\nimport math\nmath.a=0\nclass Solution:\n\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n\n        math.a+=1\n        print(math.a)\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[i] + nums[j] == target:\n                    return [i, j]\n        \n        return []\n\n```\n\n## python 常见语法，常用函数\n\n### 字符串篇\n```\na = 'Aaaaa'\nprint(a.count('a'))  #统计某个字符串的次数\nprint(a.lower())\nprint(a.upper())\n\nb= a.replace('a', 'b')  # 进行替换\nprint(b)\n\n```\n\n**正则表达式**\n```\nimport re   #引入正则表达式包\ns  = \"abcadffiwef/sdfsdf\"\nb = re.match('abc.*', s)\nprint(b[0])\n\nc= re.search('c.*', s)\nprint(c[0])\n\nout：\nabcadffiwef/sdfsdf\ncadffiwef/sdfsdf\n```\n\n**format 格式化**\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/fc0be165a0bc9778d3c91526f418f9cb/102c800bccc240e3638f91a2b3a8cc2a.png)\n```\ns = 'asdf{},adfsdf{}'\nprint(s.format(2,1))\n\nprint('asdf{0},adfsdf{2}'.format(1,2,3)) #利用下标进行索引\n\nprint('asdf{name},adfsdf{pwd}'.format(name = 1, pwd = 32))  # 利用字符串进行替换，参数\n\nprint('{:.2f}'.format(2.339))\n\n```\n\n### eval（） NB\n\n```\nx  = 10\nans  = eval('x + 2')\nprint(ans)\n\nans = eval('pow(2,x)')\nprint(ans)\n\n\nout：\n12\n1024\n\n```\n\n\n### 上下界的查询\n使用python的库bisect\n```\nimport bisect\na  = [1,2,3]\n\ntmp = bisect.bisect_right(a, 3)  #查询到右边\nprint(tmp)\n\n```\n\n\n### 位运算\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/fc0be165a0bc9778d3c91526f418f9cb/19c77f3864081a14794e00af87337e2c.png)\n\n\n\n### 保留小数位\n```\nx = 1.512187\nprint(round(x,4))  # 四舍五入保留几位\nprint(round(x,100)) # 但是不能强制输出多位\n\n\nprint('%.4f'%x)\nprint('%.10f'%x) #可以强制输出\n\nimport math\nprint(math.floor(x)) # 向下取整\nprint(math.ceil(x))  #向上取整\n```\n### 队列List\n删除操作，添加操作\n```\n只是有这些操作而已，不过效率低下\n\nnums = ['a', 'b', 'c', 'd']\n\nnums.__delitem__(0)根据下标  # 类似的 {}集合也有这个方法\nprint(nums)\n\nnums.append('a')\nnums.append('b')  # 添加\nnums.insert(1,'F') # 往下标所在位置插入\n\nprint(nums)\n\nnums.remove('b')\n\nprint(nums)\n\nnums.remove('b')  #删除看到的第一个元素\n\nprint(nums)\n\nnums.extend([1,1])这个比加法运算符效率稍微高点\n\n```\n\n\n### 进制转换\n```\nx  =14\nprint(bin(x))# 2进制\n'{:018b}'.format(i) # 这样可以转化为进制后补0。 这里b代表二进制， 18 代表18位\n\nprint(oct(x))  # 8进制\nprint(hex(x))# 16进制\nprint(int(x))# 10进制\n\n\n#将10 进制转化为N进制\ndef TentoN(num, N):\n    num = int(num)\n    ans =[]\n    while num !=0:\n        rest = num % N\n        num = num // N\n        ans.append(rest)\n\n    ans.reverse()\n    return ans\n\n\n# 将N进制转化为10进制\ndef NtoTen(num, N):\n    ans =0\n    num = str(num)\n    for i in num:\n        ans= ans * N + int(i)\n\n    return ans\n\n```\n\n### 数学排列组合\n```\nimport math\n\ndef factorial_(n):\n    result=1\n    for i in range(2,n+1):\n        result=result*i\n    return result\n\ndef comb_1(n,m):\n    return math.factorial(n)//(math.factorial(n-m)*math.factorial(m))  #直接使用math里的阶乘函数计算组合数\n\ndef comb_2(n,m):\n    return factorial_(n)//(factorial_(n-m)*factorial_(m))              #使用自己的阶乘函数计算组合数\n\ndef perm_1(n,m):\n    return math.factorial(n)//math.factorial(n-m)                        #直接使用math里的阶乘函数计算排列数\n\ndef perm_2(n,m):\n    return math.factorial(n)//math.factorial(n-m)                        #使用自己的阶乘函数计算排列数\n\nif __name__=='__main__':\n    print(comb_1(3,2))\n    print(comb_2(3,2))\n    print(perm_1(3,2))\n    print(perm_2(3,2))\n\n```\n\n\n## 数据结构篇\n\n### 常规的树\n\n\n```\n\nclass node:\n    def __init__(self):\n        self.parent =None\n        self.children =[]\n        self.deep = None  # 层级\n        self.tag = None\n        self.id = None\n        self.index =None\n\n    def show(self):\n        print('.' * self.deep*2, end='')\n        # print(self.id, end=' ')\n        print(self.tag + ' ')\n        for i in self.children:\n            i.show()\n\n```\n\n\n### 并查集\n判断元素是否同集合以及合并\n\n```\n\nclass BQSet():\n    def __init__(self):\n        self.f = {}  # f[i]代表i的父节点\n        # #init\n        # for i in range(10):\n        #     f[i] = i\n\n    def getFather(self,origin):\n        a = origin\n        while self.f[a] != a:\n            a = self.f[a]\n        self.f[origin] = a\n        return a\n\n    # 只需要看a， b 是否 有共同父节点\n    def judge(self,a, b):\n        a  = self.getFather(a)\n        b = self.getFather(b)\n\n        if self.f[a] == self.f[b]:\n            return True\n        else:\n            return False\n\n    def Union(self,source, a):\n        a = self.getFather(a)\n        sF = self.getFather(source)\n        self.f[a] = sF\n\nif __name__ == '__main__':\n    bq = BQSet()\n    for i in range(10):\n        bq.f[i] =i\n\n    bq.f[2] =1\n    a= bq.judge(1,2)\n    bq.Union(2,3)\n    print(a)\n```\n\n\n\n### 最小生成树 Kruskal\n边权值和最小\n```\nn, m = input().split(' ')\nn = int(n)\n\n# print(n)\nm = int(m)\nedges = []\nfor i in range(m):\n    s = input().split(' ')\n    edges.append((int(s[0]), int(s[1]), int(s[2])))\n\n\n# 并查集\nclass BQSet():\n    def __init__(self):\n        self.f = {}\n        # #init\n        # for i in range(10):\n        #     f[i] = i\n\n    def getFather(self, origin):\n        a = origin\n        while self.f[a] != a:\n            a = self.f[a]\n        self.f[origin] = a\n        return a\n\n    # 只需要看a， b 是否 有共同父节点\n    def judge(self, a, b):\n        a = self.getFather(a)\n        b = self.getFather(b)\n\n        if self.f[a] == self.f[b]:\n            return True\n        else:\n            return False\n\n    def Union(self, source, a):\n        a = self.getFather(a)\n        sF = self.getFather(source)\n        self.f[a] = sF\n\n\n#  Kruskal 关键是判断是不是同一个集合里面\n\n\ndef kruskal(edges):\n    bq = BQSet()\n\n    # 初始化并查集\n    for i in range(1, n + 1):\n        bq.f[i] = i\n\n    # 先进行排序\n    edges = sorted(edges, key=lambda x: x[2])\n    # print(edges)\n    arried = {}\n    # finalE =[]\n    sum = 0\n    count = 0\n    for u, v, w in edges:\n        if bq.judge(u, v):\n            pass\n        else:  # 如果边不在同一个集合，就加入\n            bq.Union(u, v)\n            sum += w\n            count += 1\n\n    if count == n - 1:\n        print(sum)\n    else:\n        print('orz')\n\n\n# print(count)\n\n\nkruskal(edges)\n```\n\n\n\n\n## 算法板子\n\n\n\n### 快排板子\n\n```\n\n# 可以自定义比较函数，决定排序方式\ndef cmp(a,b):\n    return a>b\n\n\nclass quiteSort:\n    def __init__(self):\n        self.cmp = lambda a, b:a< b\n\n    # 设置比较函数\n    def setCmp(self, cmp):\n        self.cmp =cmp\n\n    # 随机找一个中间基准值，将数据分成左右两堆\n    def randomized_partition(self, nums, l, r):\n        import random\n        pivot = random.randint(l, r)\n        nums[pivot], nums[r] = nums[r], nums[pivot]\n        i = l - 1\n        for j in range(l, r):\n            if self.cmp(nums[j],nums[r]):\n                i += 1\n                nums[j], nums[i] = nums[i], nums[j]\n        i += 1\n        nums[i], nums[r] = nums[r], nums[i]\n        return i\n\n    # 不断进行细分\n    def randomized_quicksort(self, nums, l, r):\n        if r - l <= 0:\n            return\n        mid = self.randomized_partition(nums, l, r)\n        self.randomized_quicksort(nums, l, mid - 1)\n        self.randomized_quicksort(nums, mid + 1, r)\n\n    def sortArray(self, nums):\n        self.randomized_quicksort(nums, 0, len(nums) - 1)\n        return nums\n\n```\n\n\n### 自定义二分查找\n```\nclass DichotomousSearch():\n    def __init__(self):\n        pass\n\n\n    # 查找k在有序数组nums 中得位置。 nums是升序得\n    #return index, flag flag是代表是否有和k匹配得数得bool。\n    def search(self, nums, k):\n        l = 0\n        r = len(nums)-1\n\n        while l<r:\n            mid = (l + r) // 2\n\n            if nums[mid]> k:   #  向左边找\n                r = mid - 1\n            elif nums[mid] <k:  # 向右边找\n                l = mid +1\n            elif nums[mid] == k:\n                l = r = mid\n                break\n\n\n        if nums[l] == k:\n            return l, True\n        else:\n            return l, False\n\n\n```\n\n### Dijstra 最短路径\n```\nimport collections\nINF =float('inf')\nimport heapq\nclass Solution(object):\n    def networkDelayTime(self, times, N, K):\n        \"\"\"\n        :type times: List[List[int]]\n        :type N: int\n        :type K: int\n        :rtype: int\n        \"\"\"\n\n\n        adj ={} # 邻接表\n        for i in range(1,N+1):\n            adj[i] ={}\n\n\n\n        for u, v, w in times:\n            adj[u][v] =w\n\n\n        def dijkstra(adj, K): #K是出发的点， 这里默认到达所有点\n            arrived ={}   # 已经到的点\n            pq = [(0, K)]# 存储需要到的点的最短值\n            while pq:\n                d, node = heapq.heappop(pq)\n                if node in arrived: # 如果已经到达，\n                    continue\n                arrived[node] = d\n                # print(node)\n                for nei in adj[node]:\n                    if nei not in arrived:\n                        heapq.heappush(pq, (d + adj[node][nei], nei))\n\n            return arrived\n\n\n        print(dijkstra(adj, K))\n\nSolution.networkDelayTime(None,times = [[2,1,1],[2,3,1],[3,4,1]], N = 4, K = 2)\n```\n\n\n### SPFA最短路\n```\n# 总结一下，SPFA是如何做到“只更新可能更新的点”的？\n#\n# 只让当前点能到达的点入队\n# 如果一个点已经在队列里，便不重复入队\n# 如果一条边未被更新，那么它的终点不入队\n\n\nINF =float('inf')\nclass SPFA(object):\n    def networkDelayTime(self, edges, N, K):\n        \"\"\"\n        :type times: List[List[int]]\n        :type N: int\n        :type K: int\n        :rtype: int\n        \"\"\"\n        times =edges\n        arrived ={}   # 已经到的点\n        for i in range(1, N + 1):\n            arrived[i] = INF\n        arrived[K] = 0\n\n\n        adj ={} # 邻接表\n        for i in range(1,N+1):\n            adj[i] ={}\n\n        for u, v, w in times:\n            adj[u][v] =w\n\n        q = [K]  # 优化队列\n        vis ={}  # 是否正在队列里\n        count = {}  # 统计在队列里出现多少次\n        for i in range(1,N+1):\n            vis[i] = False\n            count[i] = 0\n        vis[K] = True  # 代表在队列里面\n        count[K] +=1\n        while q:\n\n            now = q.pop()\n            vis[now] = False\n            for i in adj[now]:\n                to = i\n                # 进行了松弛的点\n                if arrived[to]> arrived[now] + adj[now][to]:\n                    arrived[to] =  arrived[now] + adj[now][to]\n                    if not vis[to]:\n                        vis[to] = True\n                        count[to] +=1\n                        q.append(to)\n                        if count[to] > N+1:  #  //判断负环\n                            return False\n\n\n        return arrived\n\n\n\n\na = SPFA.networkDelayTime(None,[[1,2,1],[2,3,7],[1,3,4],[2,1,2]],\n3,\n2)\nprint(a)\n```\n\n\n### floyd最短路\n```\n\n# 2、Floyd算法可以解决多源最短路径；\n# k 前k个点代表在前k个的前提下的最短路径\n\nimport collections\nINF =float('inf')\nclass Solution(object):\n    def networkDelayTime(self, times, N, K):\n        \"\"\"\n        :type times: List[List[int]]\n        :type N: int\n        :type K: int\n        :rtype: int\n        \"\"\"\n\n\n        adj ={} # 邻接表\n        # 初始化邻接表\n        for i in range(1,N+1):\n            adj[i]={}\n            for j in range(1,N+1):\n                adj[i][j]  = INF\n                if i ==j:\n                    adj[i][j] = 0\n\n        for u, v, w in times:\n            adj[u][v] =w\n\n        def floyd(adj):\n            for k in range(1, N+1):\n                for i in range(1, N + 1):\n                    for j in range(1, N + 1):\n                        adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n\n\n            return adj\n\n        adj = floyd(adj)\n\n\n        if max(adj[K].values()) == INF:\n            return -1\n\n        return max(adj[K].values())\n\n\na = Solution.networkDelayTime(None,times = [[2,1,1],[2,3,1],[3,4,1]], N = 4, K = 2)\nprint(a)\n```\n\n\n\n\n### 拓补排序\n\n- 不断找入度为0的点\n\n\n\n### 线段树\n\n```\n\n```\n\n\n### 回溯全排列\n\n```\narr = [i+1 for i in range(5)]\n\n\nvisit = [True for i in range(len(arr))]\ntemp = [\"\" for x in range(0, len(arr))]\n# 回溯记录\n\ndef dfs(position):\n    if position == len(arr):\n        print(temp)\n        return None\n\n    for index in range(0, len(arr)):\n        if visit[index] == True:\n            temp[position] = arr[index]\n            visit[index] = False\n            dfs(position + 1)\n            visit[index] = True\n\n\ndfs(0)\n```\n\n\n\n### 查分约束\n转化为图的问题\n\n### KMP字符串匹配\n自动状态机\n\n```\n\nclass Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        if haystack == '':\n            if needle =='':\n                return 0\n            else:\n                return -1\n        elif needle =='':\n            return 0\n\n\n\n        # 计算next数组， next[i]代表前i个字符串的最长子串\n        def getnext(s):\n            n = len(s)\n            next = [0,0]  # 第一个0代表空字符串\n            for i in range(2, n+1):\n                # print(next, s, i-1)\n                if s[next[i-1]] == s[i-1]:\n                    next.append(next[i-1] +1)\n                else:\n                    j = next[next[i-1]]\n                    while j > 0:\n                        if s[j] == s[i-1]:\n                            next.append(j+1)\n                            break\n                        j = next[j]\n                    if j ==0:\n                        if s[i-1] == s[0]:\n                            next.append(1)\n                        else:\n                            next.append(0)\n\n            return next\n\n        next  =getnext(needle)\n        print(next)\n\n\n        # 构造有限状态机\n        def kmp(s, next):  # 一个状态机\n            n = len(s)\n            state = {'other':True}\n            for i in s:\n                state[i] = True\n\n            matrix = [{} for i in range(n+1)]\n\n            #初始化\n            for i in state:\n                matrix[0][i] = 0\n            matrix[0][s[0]] =1\n\n\n            # 归纳法进行递推\n            for i in range(1, n+1):\n\n                j = i\n                while j> 0:\n                    if j >= n:\n                        j = next[j]\n                        continue\n                    char = s[j]\n                    if char not in matrix[i]:\n                        matrix[i][char] = j+1\n                    j = next[j]\n                if j ==0:\n                    if s[0] not in matrix[i]:\n                        matrix[i][s[0]] =1\n                for k in state:\n                    if k not in matrix[i]:\n                        matrix[i][k] = 0\n            return matrix, state\n\n\n\n\n\n\n        m,state = kmp(needle, next)\n        for i in range(len(m)):\n            print(i, m[i])\n        print(m)\n\n\n        def search(txt):\n            N = len(txt)\n            l = len(needle)\n            stateNow = 0\n            for i in range(N):\n                char = txt[i]\n                if char in state:\n                    stateNow = m[stateNow][char]\n                else:\n                    stateNow = m[stateNow]['other']\n\n                if stateNow == l:\n                    return i- l+1\n            return -1\n\n        print(search(haystack))\n        return search(haystack)\n\n\n\n\nSolution.strStr(None,\"ababcaababcaabc\",\n\"ababcaabc\")\n\n\n\n```","slug":"综合/算法比赛套路","published":1,"date":"2023-02-26T15:28:35.068Z","updated":"2023-02-27T11:34:33.136Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsydb00250gcnxxlpfc5s","content":"<h1 id=\"算法比赛套路\"><a href=\"#算法比赛套路\" class=\"headerlink\" title=\"算法比赛套路\"></a>算法比赛套路</h1><h2 id=\"leetcode得进阶套路\"><a href=\"#leetcode得进阶套路\" class=\"headerlink\" title=\"leetcode得进阶套路\"></a>leetcode得进阶套路</h2><h3 id=\"如何判断出当前是第多少个case\"><a href=\"#如何判断出当前是第多少个case\" class=\"headerlink\" title=\"如何判断出当前是第多少个case\"></a>如何判断出当前是第多少个case</h3><pre class=\"line-numbers language-angular2html\"><code class=\"language-angular2html\">import math\nmath.a=0\nclass Solution:\n\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n\n        math.a+=1\n        print(math.a)\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[i] + nums[j] == target:\n                    return [i, j]\n\n        return []\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"python-常见语法，常用函数\"><a href=\"#python-常见语法，常用函数\" class=\"headerlink\" title=\"python 常见语法，常用函数\"></a>python 常见语法，常用函数</h2><h3 id=\"字符串篇\"><a href=\"#字符串篇\" class=\"headerlink\" title=\"字符串篇\"></a>字符串篇</h3><pre><code>a = &#39;Aaaaa&#39;\nprint(a.count(&#39;a&#39;))  #统计某个字符串的次数\nprint(a.lower())\nprint(a.upper())\n\nb= a.replace(&#39;a&#39;, &#39;b&#39;)  # 进行替换\nprint(b)\n</code></pre><p><strong>正则表达式</strong></p>\n<pre><code>import re   #引入正则表达式包\ns  = &quot;abcadffiwef/sdfsdf&quot;\nb = re.match(&#39;abc.*&#39;, s)\nprint(b[0])\n\nc= re.search(&#39;c.*&#39;, s)\nprint(c[0])\n\nout：\nabcadffiwef/sdfsdf\ncadffiwef/sdfsdf</code></pre><p><strong>format 格式化</strong><br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/fc0be165a0bc9778d3c91526f418f9cb/102c800bccc240e3638f91a2b3a8cc2a.png\" alt></p>\n<pre><code>s = &#39;asdf{},adfsdf{}&#39;\nprint(s.format(2,1))\n\nprint(&#39;asdf{0},adfsdf{2}&#39;.format(1,2,3)) #利用下标进行索引\n\nprint(&#39;asdf{name},adfsdf{pwd}&#39;.format(name = 1, pwd = 32))  # 利用字符串进行替换，参数\n\nprint(&#39;{:.2f}&#39;.format(2.339))\n</code></pre><h3 id=\"eval（）-NB\"><a href=\"#eval（）-NB\" class=\"headerlink\" title=\"eval（） NB\"></a>eval（） NB</h3><pre><code>x  = 10\nans  = eval(&#39;x + 2&#39;)\nprint(ans)\n\nans = eval(&#39;pow(2,x)&#39;)\nprint(ans)\n\n\nout：\n12\n1024\n</code></pre><h3 id=\"上下界的查询\"><a href=\"#上下界的查询\" class=\"headerlink\" title=\"上下界的查询\"></a>上下界的查询</h3><p>使用python的库bisect</p>\n<pre><code>import bisect\na  = [1,2,3]\n\ntmp = bisect.bisect_right(a, 3)  #查询到右边\nprint(tmp)\n</code></pre><h3 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h3><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/fc0be165a0bc9778d3c91526f418f9cb/19c77f3864081a14794e00af87337e2c.png\" alt></p>\n<h3 id=\"保留小数位\"><a href=\"#保留小数位\" class=\"headerlink\" title=\"保留小数位\"></a>保留小数位</h3><pre><code>x = 1.512187\nprint(round(x,4))  # 四舍五入保留几位\nprint(round(x,100)) # 但是不能强制输出多位\n\n\nprint(&#39;%.4f&#39;%x)\nprint(&#39;%.10f&#39;%x) #可以强制输出\n\nimport math\nprint(math.floor(x)) # 向下取整\nprint(math.ceil(x))  #向上取整</code></pre><h3 id=\"队列List\"><a href=\"#队列List\" class=\"headerlink\" title=\"队列List\"></a>队列List</h3><p>删除操作，添加操作</p>\n<pre><code>只是有这些操作而已，不过效率低下\n\nnums = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]\n\nnums.__delitem__(0)根据下标  # 类似的 {}集合也有这个方法\nprint(nums)\n\nnums.append(&#39;a&#39;)\nnums.append(&#39;b&#39;)  # 添加\nnums.insert(1,&#39;F&#39;) # 往下标所在位置插入\n\nprint(nums)\n\nnums.remove(&#39;b&#39;)\n\nprint(nums)\n\nnums.remove(&#39;b&#39;)  #删除看到的第一个元素\n\nprint(nums)\n\nnums.extend([1,1])这个比加法运算符效率稍微高点\n</code></pre><h3 id=\"进制转换\"><a href=\"#进制转换\" class=\"headerlink\" title=\"进制转换\"></a>进制转换</h3><pre><code>x  =14\nprint(bin(x))# 2进制\n&#39;{:018b}&#39;.format(i) # 这样可以转化为进制后补0。 这里b代表二进制， 18 代表18位\n\nprint(oct(x))  # 8进制\nprint(hex(x))# 16进制\nprint(int(x))# 10进制\n\n\n#将10 进制转化为N进制\ndef TentoN(num, N):\n    num = int(num)\n    ans =[]\n    while num !=0:\n        rest = num % N\n        num = num // N\n        ans.append(rest)\n\n    ans.reverse()\n    return ans\n\n\n# 将N进制转化为10进制\ndef NtoTen(num, N):\n    ans =0\n    num = str(num)\n    for i in num:\n        ans= ans * N + int(i)\n\n    return ans\n</code></pre><h3 id=\"数学排列组合\"><a href=\"#数学排列组合\" class=\"headerlink\" title=\"数学排列组合\"></a>数学排列组合</h3><pre><code>import math\n\ndef factorial_(n):\n    result=1\n    for i in range(2,n+1):\n        result=result*i\n    return result\n\ndef comb_1(n,m):\n    return math.factorial(n)//(math.factorial(n-m)*math.factorial(m))  #直接使用math里的阶乘函数计算组合数\n\ndef comb_2(n,m):\n    return factorial_(n)//(factorial_(n-m)*factorial_(m))              #使用自己的阶乘函数计算组合数\n\ndef perm_1(n,m):\n    return math.factorial(n)//math.factorial(n-m)                        #直接使用math里的阶乘函数计算排列数\n\ndef perm_2(n,m):\n    return math.factorial(n)//math.factorial(n-m)                        #使用自己的阶乘函数计算排列数\n\nif __name__==&#39;__main__&#39;:\n    print(comb_1(3,2))\n    print(comb_2(3,2))\n    print(perm_1(3,2))\n    print(perm_2(3,2))\n</code></pre><h2 id=\"数据结构篇\"><a href=\"#数据结构篇\" class=\"headerlink\" title=\"数据结构篇\"></a>数据结构篇</h2><h3 id=\"常规的树\"><a href=\"#常规的树\" class=\"headerlink\" title=\"常规的树\"></a>常规的树</h3><pre><code>\nclass node:\n    def __init__(self):\n        self.parent =None\n        self.children =[]\n        self.deep = None  # 层级\n        self.tag = None\n        self.id = None\n        self.index =None\n\n    def show(self):\n        print(&#39;.&#39; * self.deep*2, end=&#39;&#39;)\n        # print(self.id, end=&#39; &#39;)\n        print(self.tag + &#39; &#39;)\n        for i in self.children:\n            i.show()\n</code></pre><h3 id=\"并查集\"><a href=\"#并查集\" class=\"headerlink\" title=\"并查集\"></a>并查集</h3><p>判断元素是否同集合以及合并</p>\n<pre><code>\nclass BQSet():\n    def __init__(self):\n        self.f = {}  # f[i]代表i的父节点\n        # #init\n        # for i in range(10):\n        #     f[i] = i\n\n    def getFather(self,origin):\n        a = origin\n        while self.f[a] != a:\n            a = self.f[a]\n        self.f[origin] = a\n        return a\n\n    # 只需要看a， b 是否 有共同父节点\n    def judge(self,a, b):\n        a  = self.getFather(a)\n        b = self.getFather(b)\n\n        if self.f[a] == self.f[b]:\n            return True\n        else:\n            return False\n\n    def Union(self,source, a):\n        a = self.getFather(a)\n        sF = self.getFather(source)\n        self.f[a] = sF\n\nif __name__ == &#39;__main__&#39;:\n    bq = BQSet()\n    for i in range(10):\n        bq.f[i] =i\n\n    bq.f[2] =1\n    a= bq.judge(1,2)\n    bq.Union(2,3)\n    print(a)</code></pre><h3 id=\"最小生成树-Kruskal\"><a href=\"#最小生成树-Kruskal\" class=\"headerlink\" title=\"最小生成树 Kruskal\"></a>最小生成树 Kruskal</h3><p>边权值和最小</p>\n<pre><code>n, m = input().split(&#39; &#39;)\nn = int(n)\n\n# print(n)\nm = int(m)\nedges = []\nfor i in range(m):\n    s = input().split(&#39; &#39;)\n    edges.append((int(s[0]), int(s[1]), int(s[2])))\n\n\n# 并查集\nclass BQSet():\n    def __init__(self):\n        self.f = {}\n        # #init\n        # for i in range(10):\n        #     f[i] = i\n\n    def getFather(self, origin):\n        a = origin\n        while self.f[a] != a:\n            a = self.f[a]\n        self.f[origin] = a\n        return a\n\n    # 只需要看a， b 是否 有共同父节点\n    def judge(self, a, b):\n        a = self.getFather(a)\n        b = self.getFather(b)\n\n        if self.f[a] == self.f[b]:\n            return True\n        else:\n            return False\n\n    def Union(self, source, a):\n        a = self.getFather(a)\n        sF = self.getFather(source)\n        self.f[a] = sF\n\n\n#  Kruskal 关键是判断是不是同一个集合里面\n\n\ndef kruskal(edges):\n    bq = BQSet()\n\n    # 初始化并查集\n    for i in range(1, n + 1):\n        bq.f[i] = i\n\n    # 先进行排序\n    edges = sorted(edges, key=lambda x: x[2])\n    # print(edges)\n    arried = {}\n    # finalE =[]\n    sum = 0\n    count = 0\n    for u, v, w in edges:\n        if bq.judge(u, v):\n            pass\n        else:  # 如果边不在同一个集合，就加入\n            bq.Union(u, v)\n            sum += w\n            count += 1\n\n    if count == n - 1:\n        print(sum)\n    else:\n        print(&#39;orz&#39;)\n\n\n# print(count)\n\n\nkruskal(edges)</code></pre><h2 id=\"算法板子\"><a href=\"#算法板子\" class=\"headerlink\" title=\"算法板子\"></a>算法板子</h2><h3 id=\"快排板子\"><a href=\"#快排板子\" class=\"headerlink\" title=\"快排板子\"></a>快排板子</h3><pre><code>\n# 可以自定义比较函数，决定排序方式\ndef cmp(a,b):\n    return a&gt;b\n\n\nclass quiteSort:\n    def __init__(self):\n        self.cmp = lambda a, b:a&lt; b\n\n    # 设置比较函数\n    def setCmp(self, cmp):\n        self.cmp =cmp\n\n    # 随机找一个中间基准值，将数据分成左右两堆\n    def randomized_partition(self, nums, l, r):\n        import random\n        pivot = random.randint(l, r)\n        nums[pivot], nums[r] = nums[r], nums[pivot]\n        i = l - 1\n        for j in range(l, r):\n            if self.cmp(nums[j],nums[r]):\n                i += 1\n                nums[j], nums[i] = nums[i], nums[j]\n        i += 1\n        nums[i], nums[r] = nums[r], nums[i]\n        return i\n\n    # 不断进行细分\n    def randomized_quicksort(self, nums, l, r):\n        if r - l &lt;= 0:\n            return\n        mid = self.randomized_partition(nums, l, r)\n        self.randomized_quicksort(nums, l, mid - 1)\n        self.randomized_quicksort(nums, mid + 1, r)\n\n    def sortArray(self, nums):\n        self.randomized_quicksort(nums, 0, len(nums) - 1)\n        return nums\n</code></pre><h3 id=\"自定义二分查找\"><a href=\"#自定义二分查找\" class=\"headerlink\" title=\"自定义二分查找\"></a>自定义二分查找</h3><pre><code>class DichotomousSearch():\n    def __init__(self):\n        pass\n\n\n    # 查找k在有序数组nums 中得位置。 nums是升序得\n    #return index, flag flag是代表是否有和k匹配得数得bool。\n    def search(self, nums, k):\n        l = 0\n        r = len(nums)-1\n\n        while l&lt;r:\n            mid = (l + r) // 2\n\n            if nums[mid]&gt; k:   #  向左边找\n                r = mid - 1\n            elif nums[mid] &lt;k:  # 向右边找\n                l = mid +1\n            elif nums[mid] == k:\n                l = r = mid\n                break\n\n\n        if nums[l] == k:\n            return l, True\n        else:\n            return l, False\n\n</code></pre><h3 id=\"Dijstra-最短路径\"><a href=\"#Dijstra-最短路径\" class=\"headerlink\" title=\"Dijstra 最短路径\"></a>Dijstra 最短路径</h3><pre><code>import collections\nINF =float(&#39;inf&#39;)\nimport heapq\nclass Solution(object):\n    def networkDelayTime(self, times, N, K):\n        &quot;&quot;&quot;\n        :type times: List[List[int]]\n        :type N: int\n        :type K: int\n        :rtype: int\n        &quot;&quot;&quot;\n\n\n        adj ={} # 邻接表\n        for i in range(1,N+1):\n            adj[i] ={}\n\n\n\n        for u, v, w in times:\n            adj[u][v] =w\n\n\n        def dijkstra(adj, K): #K是出发的点， 这里默认到达所有点\n            arrived ={}   # 已经到的点\n            pq = [(0, K)]# 存储需要到的点的最短值\n            while pq:\n                d, node = heapq.heappop(pq)\n                if node in arrived: # 如果已经到达，\n                    continue\n                arrived[node] = d\n                # print(node)\n                for nei in adj[node]:\n                    if nei not in arrived:\n                        heapq.heappush(pq, (d + adj[node][nei], nei))\n\n            return arrived\n\n\n        print(dijkstra(adj, K))\n\nSolution.networkDelayTime(None,times = [[2,1,1],[2,3,1],[3,4,1]], N = 4, K = 2)</code></pre><h3 id=\"SPFA最短路\"><a href=\"#SPFA最短路\" class=\"headerlink\" title=\"SPFA最短路\"></a>SPFA最短路</h3><pre><code># 总结一下，SPFA是如何做到“只更新可能更新的点”的？\n#\n# 只让当前点能到达的点入队\n# 如果一个点已经在队列里，便不重复入队\n# 如果一条边未被更新，那么它的终点不入队\n\n\nINF =float(&#39;inf&#39;)\nclass SPFA(object):\n    def networkDelayTime(self, edges, N, K):\n        &quot;&quot;&quot;\n        :type times: List[List[int]]\n        :type N: int\n        :type K: int\n        :rtype: int\n        &quot;&quot;&quot;\n        times =edges\n        arrived ={}   # 已经到的点\n        for i in range(1, N + 1):\n            arrived[i] = INF\n        arrived[K] = 0\n\n\n        adj ={} # 邻接表\n        for i in range(1,N+1):\n            adj[i] ={}\n\n        for u, v, w in times:\n            adj[u][v] =w\n\n        q = [K]  # 优化队列\n        vis ={}  # 是否正在队列里\n        count = {}  # 统计在队列里出现多少次\n        for i in range(1,N+1):\n            vis[i] = False\n            count[i] = 0\n        vis[K] = True  # 代表在队列里面\n        count[K] +=1\n        while q:\n\n            now = q.pop()\n            vis[now] = False\n            for i in adj[now]:\n                to = i\n                # 进行了松弛的点\n                if arrived[to]&gt; arrived[now] + adj[now][to]:\n                    arrived[to] =  arrived[now] + adj[now][to]\n                    if not vis[to]:\n                        vis[to] = True\n                        count[to] +=1\n                        q.append(to)\n                        if count[to] &gt; N+1:  #  //判断负环\n                            return False\n\n\n        return arrived\n\n\n\n\na = SPFA.networkDelayTime(None,[[1,2,1],[2,3,7],[1,3,4],[2,1,2]],\n3,\n2)\nprint(a)</code></pre><h3 id=\"floyd最短路\"><a href=\"#floyd最短路\" class=\"headerlink\" title=\"floyd最短路\"></a>floyd最短路</h3><pre><code>\n# 2、Floyd算法可以解决多源最短路径；\n# k 前k个点代表在前k个的前提下的最短路径\n\nimport collections\nINF =float(&#39;inf&#39;)\nclass Solution(object):\n    def networkDelayTime(self, times, N, K):\n        &quot;&quot;&quot;\n        :type times: List[List[int]]\n        :type N: int\n        :type K: int\n        :rtype: int\n        &quot;&quot;&quot;\n\n\n        adj ={} # 邻接表\n        # 初始化邻接表\n        for i in range(1,N+1):\n            adj[i]={}\n            for j in range(1,N+1):\n                adj[i][j]  = INF\n                if i ==j:\n                    adj[i][j] = 0\n\n        for u, v, w in times:\n            adj[u][v] =w\n\n        def floyd(adj):\n            for k in range(1, N+1):\n                for i in range(1, N + 1):\n                    for j in range(1, N + 1):\n                        adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n\n\n            return adj\n\n        adj = floyd(adj)\n\n\n        if max(adj[K].values()) == INF:\n            return -1\n\n        return max(adj[K].values())\n\n\na = Solution.networkDelayTime(None,times = [[2,1,1],[2,3,1],[3,4,1]], N = 4, K = 2)\nprint(a)</code></pre><h3 id=\"拓补排序\"><a href=\"#拓补排序\" class=\"headerlink\" title=\"拓补排序\"></a>拓补排序</h3><ul>\n<li>不断找入度为0的点</li>\n</ul>\n<h3 id=\"线段树\"><a href=\"#线段树\" class=\"headerlink\" title=\"线段树\"></a>线段树</h3><pre><code></code></pre><h3 id=\"回溯全排列\"><a href=\"#回溯全排列\" class=\"headerlink\" title=\"回溯全排列\"></a>回溯全排列</h3><pre><code>arr = [i+1 for i in range(5)]\n\n\nvisit = [True for i in range(len(arr))]\ntemp = [&quot;&quot; for x in range(0, len(arr))]\n# 回溯记录\n\ndef dfs(position):\n    if position == len(arr):\n        print(temp)\n        return None\n\n    for index in range(0, len(arr)):\n        if visit[index] == True:\n            temp[position] = arr[index]\n            visit[index] = False\n            dfs(position + 1)\n            visit[index] = True\n\n\ndfs(0)</code></pre><h3 id=\"查分约束\"><a href=\"#查分约束\" class=\"headerlink\" title=\"查分约束\"></a>查分约束</h3><p>转化为图的问题</p>\n<h3 id=\"KMP字符串匹配\"><a href=\"#KMP字符串匹配\" class=\"headerlink\" title=\"KMP字符串匹配\"></a>KMP字符串匹配</h3><p>自动状态机</p>\n<pre><code>\nclass Solution(object):\n    def strStr(self, haystack, needle):\n        &quot;&quot;&quot;\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        &quot;&quot;&quot;\n        if haystack == &#39;&#39;:\n            if needle ==&#39;&#39;:\n                return 0\n            else:\n                return -1\n        elif needle ==&#39;&#39;:\n            return 0\n\n\n\n        # 计算next数组， next[i]代表前i个字符串的最长子串\n        def getnext(s):\n            n = len(s)\n            next = [0,0]  # 第一个0代表空字符串\n            for i in range(2, n+1):\n                # print(next, s, i-1)\n                if s[next[i-1]] == s[i-1]:\n                    next.append(next[i-1] +1)\n                else:\n                    j = next[next[i-1]]\n                    while j &gt; 0:\n                        if s[j] == s[i-1]:\n                            next.append(j+1)\n                            break\n                        j = next[j]\n                    if j ==0:\n                        if s[i-1] == s[0]:\n                            next.append(1)\n                        else:\n                            next.append(0)\n\n            return next\n\n        next  =getnext(needle)\n        print(next)\n\n\n        # 构造有限状态机\n        def kmp(s, next):  # 一个状态机\n            n = len(s)\n            state = {&#39;other&#39;:True}\n            for i in s:\n                state[i] = True\n\n            matrix = [{} for i in range(n+1)]\n\n            #初始化\n            for i in state:\n                matrix[0][i] = 0\n            matrix[0][s[0]] =1\n\n\n            # 归纳法进行递推\n            for i in range(1, n+1):\n\n                j = i\n                while j&gt; 0:\n                    if j &gt;= n:\n                        j = next[j]\n                        continue\n                    char = s[j]\n                    if char not in matrix[i]:\n                        matrix[i][char] = j+1\n                    j = next[j]\n                if j ==0:\n                    if s[0] not in matrix[i]:\n                        matrix[i][s[0]] =1\n                for k in state:\n                    if k not in matrix[i]:\n                        matrix[i][k] = 0\n            return matrix, state\n\n\n\n\n\n\n        m,state = kmp(needle, next)\n        for i in range(len(m)):\n            print(i, m[i])\n        print(m)\n\n\n        def search(txt):\n            N = len(txt)\n            l = len(needle)\n            stateNow = 0\n            for i in range(N):\n                char = txt[i]\n                if char in state:\n                    stateNow = m[stateNow][char]\n                else:\n                    stateNow = m[stateNow][&#39;other&#39;]\n\n                if stateNow == l:\n                    return i- l+1\n            return -1\n\n        print(search(haystack))\n        return search(haystack)\n\n\n\n\nSolution.strStr(None,&quot;ababcaababcaabc&quot;,\n&quot;ababcaabc&quot;)\n\n\n</code></pre>","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"算法比赛套路\"><a href=\"#算法比赛套路\" class=\"headerlink\" title=\"算法比赛套路\"></a>算法比赛套路</h1><h2 id=\"leetcode得进阶套路\"><a href=\"#leetcode得进阶套路\" class=\"headerlink\" title=\"leetcode得进阶套路\"></a>leetcode得进阶套路</h2><h3 id=\"如何判断出当前是第多少个case\"><a href=\"#如何判断出当前是第多少个case\" class=\"headerlink\" title=\"如何判断出当前是第多少个case\"></a>如何判断出当前是第多少个case</h3><pre><code class=\"angular2html\">import math\nmath.a=0\nclass Solution:\n\n    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:\n\n        math.a+=1\n        print(math.a)\n        n = len(nums)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if nums[i] + nums[j] == target:\n                    return [i, j]\n\n        return []\n</code></pre>\n<h2 id=\"python-常见语法，常用函数\"><a href=\"#python-常见语法，常用函数\" class=\"headerlink\" title=\"python 常见语法，常用函数\"></a>python 常见语法，常用函数</h2><h3 id=\"字符串篇\"><a href=\"#字符串篇\" class=\"headerlink\" title=\"字符串篇\"></a>字符串篇</h3><pre><code>a = &#39;Aaaaa&#39;\nprint(a.count(&#39;a&#39;))  #统计某个字符串的次数\nprint(a.lower())\nprint(a.upper())\n\nb= a.replace(&#39;a&#39;, &#39;b&#39;)  # 进行替换\nprint(b)\n</code></pre><p><strong>正则表达式</strong></p>\n<pre><code>import re   #引入正则表达式包\ns  = &quot;abcadffiwef/sdfsdf&quot;\nb = re.match(&#39;abc.*&#39;, s)\nprint(b[0])\n\nc= re.search(&#39;c.*&#39;, s)\nprint(c[0])\n\nout：\nabcadffiwef/sdfsdf\ncadffiwef/sdfsdf</code></pre><p><strong>format 格式化</strong><br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/fc0be165a0bc9778d3c91526f418f9cb/102c800bccc240e3638f91a2b3a8cc2a.png\" alt></p>\n<pre><code>s = &#39;asdf{},adfsdf{}&#39;\nprint(s.format(2,1))\n\nprint(&#39;asdf{0},adfsdf{2}&#39;.format(1,2,3)) #利用下标进行索引\n\nprint(&#39;asdf{name},adfsdf{pwd}&#39;.format(name = 1, pwd = 32))  # 利用字符串进行替换，参数\n\nprint(&#39;{:.2f}&#39;.format(2.339))\n</code></pre><h3 id=\"eval（）-NB\"><a href=\"#eval（）-NB\" class=\"headerlink\" title=\"eval（） NB\"></a>eval（） NB</h3><pre><code>x  = 10\nans  = eval(&#39;x + 2&#39;)\nprint(ans)\n\nans = eval(&#39;pow(2,x)&#39;)\nprint(ans)\n\n\nout：\n12\n1024\n</code></pre><h3 id=\"上下界的查询\"><a href=\"#上下界的查询\" class=\"headerlink\" title=\"上下界的查询\"></a>上下界的查询</h3><p>使用python的库bisect</p>\n<pre><code>import bisect\na  = [1,2,3]\n\ntmp = bisect.bisect_right(a, 3)  #查询到右边\nprint(tmp)\n</code></pre><h3 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h3><p><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/fc0be165a0bc9778d3c91526f418f9cb/19c77f3864081a14794e00af87337e2c.png\" alt></p>\n<h3 id=\"保留小数位\"><a href=\"#保留小数位\" class=\"headerlink\" title=\"保留小数位\"></a>保留小数位</h3><pre><code>x = 1.512187\nprint(round(x,4))  # 四舍五入保留几位\nprint(round(x,100)) # 但是不能强制输出多位\n\n\nprint(&#39;%.4f&#39;%x)\nprint(&#39;%.10f&#39;%x) #可以强制输出\n\nimport math\nprint(math.floor(x)) # 向下取整\nprint(math.ceil(x))  #向上取整</code></pre><h3 id=\"队列List\"><a href=\"#队列List\" class=\"headerlink\" title=\"队列List\"></a>队列List</h3><p>删除操作，添加操作</p>\n<pre><code>只是有这些操作而已，不过效率低下\n\nnums = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]\n\nnums.__delitem__(0)根据下标  # 类似的 {}集合也有这个方法\nprint(nums)\n\nnums.append(&#39;a&#39;)\nnums.append(&#39;b&#39;)  # 添加\nnums.insert(1,&#39;F&#39;) # 往下标所在位置插入\n\nprint(nums)\n\nnums.remove(&#39;b&#39;)\n\nprint(nums)\n\nnums.remove(&#39;b&#39;)  #删除看到的第一个元素\n\nprint(nums)\n\nnums.extend([1,1])这个比加法运算符效率稍微高点\n</code></pre><h3 id=\"进制转换\"><a href=\"#进制转换\" class=\"headerlink\" title=\"进制转换\"></a>进制转换</h3><pre><code>x  =14\nprint(bin(x))# 2进制\n&#39;{:018b}&#39;.format(i) # 这样可以转化为进制后补0。 这里b代表二进制， 18 代表18位\n\nprint(oct(x))  # 8进制\nprint(hex(x))# 16进制\nprint(int(x))# 10进制\n\n\n#将10 进制转化为N进制\ndef TentoN(num, N):\n    num = int(num)\n    ans =[]\n    while num !=0:\n        rest = num % N\n        num = num // N\n        ans.append(rest)\n\n    ans.reverse()\n    return ans\n\n\n# 将N进制转化为10进制\ndef NtoTen(num, N):\n    ans =0\n    num = str(num)\n    for i in num:\n        ans= ans * N + int(i)\n\n    return ans\n</code></pre><h3 id=\"数学排列组合\"><a href=\"#数学排列组合\" class=\"headerlink\" title=\"数学排列组合\"></a>数学排列组合</h3><pre><code>import math\n\ndef factorial_(n):\n    result=1\n    for i in range(2,n+1):\n        result=result*i\n    return result\n\ndef comb_1(n,m):\n    return math.factorial(n)//(math.factorial(n-m)*math.factorial(m))  #直接使用math里的阶乘函数计算组合数\n\ndef comb_2(n,m):\n    return factorial_(n)//(factorial_(n-m)*factorial_(m))              #使用自己的阶乘函数计算组合数\n\ndef perm_1(n,m):\n    return math.factorial(n)//math.factorial(n-m)                        #直接使用math里的阶乘函数计算排列数\n\ndef perm_2(n,m):\n    return math.factorial(n)//math.factorial(n-m)                        #使用自己的阶乘函数计算排列数\n\nif __name__==&#39;__main__&#39;:\n    print(comb_1(3,2))\n    print(comb_2(3,2))\n    print(perm_1(3,2))\n    print(perm_2(3,2))\n</code></pre><h2 id=\"数据结构篇\"><a href=\"#数据结构篇\" class=\"headerlink\" title=\"数据结构篇\"></a>数据结构篇</h2><h3 id=\"常规的树\"><a href=\"#常规的树\" class=\"headerlink\" title=\"常规的树\"></a>常规的树</h3><pre><code>\nclass node:\n    def __init__(self):\n        self.parent =None\n        self.children =[]\n        self.deep = None  # 层级\n        self.tag = None\n        self.id = None\n        self.index =None\n\n    def show(self):\n        print(&#39;.&#39; * self.deep*2, end=&#39;&#39;)\n        # print(self.id, end=&#39; &#39;)\n        print(self.tag + &#39; &#39;)\n        for i in self.children:\n            i.show()\n</code></pre><h3 id=\"并查集\"><a href=\"#并查集\" class=\"headerlink\" title=\"并查集\"></a>并查集</h3><p>判断元素是否同集合以及合并</p>\n<pre><code>\nclass BQSet():\n    def __init__(self):\n        self.f = {}  # f[i]代表i的父节点\n        # #init\n        # for i in range(10):\n        #     f[i] = i\n\n    def getFather(self,origin):\n        a = origin\n        while self.f[a] != a:\n            a = self.f[a]\n        self.f[origin] = a\n        return a\n\n    # 只需要看a， b 是否 有共同父节点\n    def judge(self,a, b):\n        a  = self.getFather(a)\n        b = self.getFather(b)\n\n        if self.f[a] == self.f[b]:\n            return True\n        else:\n            return False\n\n    def Union(self,source, a):\n        a = self.getFather(a)\n        sF = self.getFather(source)\n        self.f[a] = sF\n\nif __name__ == &#39;__main__&#39;:\n    bq = BQSet()\n    for i in range(10):\n        bq.f[i] =i\n\n    bq.f[2] =1\n    a= bq.judge(1,2)\n    bq.Union(2,3)\n    print(a)</code></pre><h3 id=\"最小生成树-Kruskal\"><a href=\"#最小生成树-Kruskal\" class=\"headerlink\" title=\"最小生成树 Kruskal\"></a>最小生成树 Kruskal</h3><p>边权值和最小</p>\n<pre><code>n, m = input().split(&#39; &#39;)\nn = int(n)\n\n# print(n)\nm = int(m)\nedges = []\nfor i in range(m):\n    s = input().split(&#39; &#39;)\n    edges.append((int(s[0]), int(s[1]), int(s[2])))\n\n\n# 并查集\nclass BQSet():\n    def __init__(self):\n        self.f = {}\n        # #init\n        # for i in range(10):\n        #     f[i] = i\n\n    def getFather(self, origin):\n        a = origin\n        while self.f[a] != a:\n            a = self.f[a]\n        self.f[origin] = a\n        return a\n\n    # 只需要看a， b 是否 有共同父节点\n    def judge(self, a, b):\n        a = self.getFather(a)\n        b = self.getFather(b)\n\n        if self.f[a] == self.f[b]:\n            return True\n        else:\n            return False\n\n    def Union(self, source, a):\n        a = self.getFather(a)\n        sF = self.getFather(source)\n        self.f[a] = sF\n\n\n#  Kruskal 关键是判断是不是同一个集合里面\n\n\ndef kruskal(edges):\n    bq = BQSet()\n\n    # 初始化并查集\n    for i in range(1, n + 1):\n        bq.f[i] = i\n\n    # 先进行排序\n    edges = sorted(edges, key=lambda x: x[2])\n    # print(edges)\n    arried = {}\n    # finalE =[]\n    sum = 0\n    count = 0\n    for u, v, w in edges:\n        if bq.judge(u, v):\n            pass\n        else:  # 如果边不在同一个集合，就加入\n            bq.Union(u, v)\n            sum += w\n            count += 1\n\n    if count == n - 1:\n        print(sum)\n    else:\n        print(&#39;orz&#39;)\n\n\n# print(count)\n\n\nkruskal(edges)</code></pre><h2 id=\"算法板子\"><a href=\"#算法板子\" class=\"headerlink\" title=\"算法板子\"></a>算法板子</h2><h3 id=\"快排板子\"><a href=\"#快排板子\" class=\"headerlink\" title=\"快排板子\"></a>快排板子</h3><pre><code>\n# 可以自定义比较函数，决定排序方式\ndef cmp(a,b):\n    return a&gt;b\n\n\nclass quiteSort:\n    def __init__(self):\n        self.cmp = lambda a, b:a&lt; b\n\n    # 设置比较函数\n    def setCmp(self, cmp):\n        self.cmp =cmp\n\n    # 随机找一个中间基准值，将数据分成左右两堆\n    def randomized_partition(self, nums, l, r):\n        import random\n        pivot = random.randint(l, r)\n        nums[pivot], nums[r] = nums[r], nums[pivot]\n        i = l - 1\n        for j in range(l, r):\n            if self.cmp(nums[j],nums[r]):\n                i += 1\n                nums[j], nums[i] = nums[i], nums[j]\n        i += 1\n        nums[i], nums[r] = nums[r], nums[i]\n        return i\n\n    # 不断进行细分\n    def randomized_quicksort(self, nums, l, r):\n        if r - l &lt;= 0:\n            return\n        mid = self.randomized_partition(nums, l, r)\n        self.randomized_quicksort(nums, l, mid - 1)\n        self.randomized_quicksort(nums, mid + 1, r)\n\n    def sortArray(self, nums):\n        self.randomized_quicksort(nums, 0, len(nums) - 1)\n        return nums\n</code></pre><h3 id=\"自定义二分查找\"><a href=\"#自定义二分查找\" class=\"headerlink\" title=\"自定义二分查找\"></a>自定义二分查找</h3><pre><code>class DichotomousSearch():\n    def __init__(self):\n        pass\n\n\n    # 查找k在有序数组nums 中得位置。 nums是升序得\n    #return index, flag flag是代表是否有和k匹配得数得bool。\n    def search(self, nums, k):\n        l = 0\n        r = len(nums)-1\n\n        while l&lt;r:\n            mid = (l + r) // 2\n\n            if nums[mid]&gt; k:   #  向左边找\n                r = mid - 1\n            elif nums[mid] &lt;k:  # 向右边找\n                l = mid +1\n            elif nums[mid] == k:\n                l = r = mid\n                break\n\n\n        if nums[l] == k:\n            return l, True\n        else:\n            return l, False\n\n</code></pre><h3 id=\"Dijstra-最短路径\"><a href=\"#Dijstra-最短路径\" class=\"headerlink\" title=\"Dijstra 最短路径\"></a>Dijstra 最短路径</h3><pre><code>import collections\nINF =float(&#39;inf&#39;)\nimport heapq\nclass Solution(object):\n    def networkDelayTime(self, times, N, K):\n        &quot;&quot;&quot;\n        :type times: List[List[int]]\n        :type N: int\n        :type K: int\n        :rtype: int\n        &quot;&quot;&quot;\n\n\n        adj ={} # 邻接表\n        for i in range(1,N+1):\n            adj[i] ={}\n\n\n\n        for u, v, w in times:\n            adj[u][v] =w\n\n\n        def dijkstra(adj, K): #K是出发的点， 这里默认到达所有点\n            arrived ={}   # 已经到的点\n            pq = [(0, K)]# 存储需要到的点的最短值\n            while pq:\n                d, node = heapq.heappop(pq)\n                if node in arrived: # 如果已经到达，\n                    continue\n                arrived[node] = d\n                # print(node)\n                for nei in adj[node]:\n                    if nei not in arrived:\n                        heapq.heappush(pq, (d + adj[node][nei], nei))\n\n            return arrived\n\n\n        print(dijkstra(adj, K))\n\nSolution.networkDelayTime(None,times = [[2,1,1],[2,3,1],[3,4,1]], N = 4, K = 2)</code></pre><h3 id=\"SPFA最短路\"><a href=\"#SPFA最短路\" class=\"headerlink\" title=\"SPFA最短路\"></a>SPFA最短路</h3><pre><code># 总结一下，SPFA是如何做到“只更新可能更新的点”的？\n#\n# 只让当前点能到达的点入队\n# 如果一个点已经在队列里，便不重复入队\n# 如果一条边未被更新，那么它的终点不入队\n\n\nINF =float(&#39;inf&#39;)\nclass SPFA(object):\n    def networkDelayTime(self, edges, N, K):\n        &quot;&quot;&quot;\n        :type times: List[List[int]]\n        :type N: int\n        :type K: int\n        :rtype: int\n        &quot;&quot;&quot;\n        times =edges\n        arrived ={}   # 已经到的点\n        for i in range(1, N + 1):\n            arrived[i] = INF\n        arrived[K] = 0\n\n\n        adj ={} # 邻接表\n        for i in range(1,N+1):\n            adj[i] ={}\n\n        for u, v, w in times:\n            adj[u][v] =w\n\n        q = [K]  # 优化队列\n        vis ={}  # 是否正在队列里\n        count = {}  # 统计在队列里出现多少次\n        for i in range(1,N+1):\n            vis[i] = False\n            count[i] = 0\n        vis[K] = True  # 代表在队列里面\n        count[K] +=1\n        while q:\n\n            now = q.pop()\n            vis[now] = False\n            for i in adj[now]:\n                to = i\n                # 进行了松弛的点\n                if arrived[to]&gt; arrived[now] + adj[now][to]:\n                    arrived[to] =  arrived[now] + adj[now][to]\n                    if not vis[to]:\n                        vis[to] = True\n                        count[to] +=1\n                        q.append(to)\n                        if count[to] &gt; N+1:  #  //判断负环\n                            return False\n\n\n        return arrived\n\n\n\n\na = SPFA.networkDelayTime(None,[[1,2,1],[2,3,7],[1,3,4],[2,1,2]],\n3,\n2)\nprint(a)</code></pre><h3 id=\"floyd最短路\"><a href=\"#floyd最短路\" class=\"headerlink\" title=\"floyd最短路\"></a>floyd最短路</h3><pre><code>\n# 2、Floyd算法可以解决多源最短路径；\n# k 前k个点代表在前k个的前提下的最短路径\n\nimport collections\nINF =float(&#39;inf&#39;)\nclass Solution(object):\n    def networkDelayTime(self, times, N, K):\n        &quot;&quot;&quot;\n        :type times: List[List[int]]\n        :type N: int\n        :type K: int\n        :rtype: int\n        &quot;&quot;&quot;\n\n\n        adj ={} # 邻接表\n        # 初始化邻接表\n        for i in range(1,N+1):\n            adj[i]={}\n            for j in range(1,N+1):\n                adj[i][j]  = INF\n                if i ==j:\n                    adj[i][j] = 0\n\n        for u, v, w in times:\n            adj[u][v] =w\n\n        def floyd(adj):\n            for k in range(1, N+1):\n                for i in range(1, N + 1):\n                    for j in range(1, N + 1):\n                        adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j])\n\n\n            return adj\n\n        adj = floyd(adj)\n\n\n        if max(adj[K].values()) == INF:\n            return -1\n\n        return max(adj[K].values())\n\n\na = Solution.networkDelayTime(None,times = [[2,1,1],[2,3,1],[3,4,1]], N = 4, K = 2)\nprint(a)</code></pre><h3 id=\"拓补排序\"><a href=\"#拓补排序\" class=\"headerlink\" title=\"拓补排序\"></a>拓补排序</h3><ul>\n<li>不断找入度为0的点</li>\n</ul>\n<h3 id=\"线段树\"><a href=\"#线段树\" class=\"headerlink\" title=\"线段树\"></a>线段树</h3><pre><code></code></pre><h3 id=\"回溯全排列\"><a href=\"#回溯全排列\" class=\"headerlink\" title=\"回溯全排列\"></a>回溯全排列</h3><pre><code>arr = [i+1 for i in range(5)]\n\n\nvisit = [True for i in range(len(arr))]\ntemp = [&quot;&quot; for x in range(0, len(arr))]\n# 回溯记录\n\ndef dfs(position):\n    if position == len(arr):\n        print(temp)\n        return None\n\n    for index in range(0, len(arr)):\n        if visit[index] == True:\n            temp[position] = arr[index]\n            visit[index] = False\n            dfs(position + 1)\n            visit[index] = True\n\n\ndfs(0)</code></pre><h3 id=\"查分约束\"><a href=\"#查分约束\" class=\"headerlink\" title=\"查分约束\"></a>查分约束</h3><p>转化为图的问题</p>\n<h3 id=\"KMP字符串匹配\"><a href=\"#KMP字符串匹配\" class=\"headerlink\" title=\"KMP字符串匹配\"></a>KMP字符串匹配</h3><p>自动状态机</p>\n<pre><code>\nclass Solution(object):\n    def strStr(self, haystack, needle):\n        &quot;&quot;&quot;\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        &quot;&quot;&quot;\n        if haystack == &#39;&#39;:\n            if needle ==&#39;&#39;:\n                return 0\n            else:\n                return -1\n        elif needle ==&#39;&#39;:\n            return 0\n\n\n\n        # 计算next数组， next[i]代表前i个字符串的最长子串\n        def getnext(s):\n            n = len(s)\n            next = [0,0]  # 第一个0代表空字符串\n            for i in range(2, n+1):\n                # print(next, s, i-1)\n                if s[next[i-1]] == s[i-1]:\n                    next.append(next[i-1] +1)\n                else:\n                    j = next[next[i-1]]\n                    while j &gt; 0:\n                        if s[j] == s[i-1]:\n                            next.append(j+1)\n                            break\n                        j = next[j]\n                    if j ==0:\n                        if s[i-1] == s[0]:\n                            next.append(1)\n                        else:\n                            next.append(0)\n\n            return next\n\n        next  =getnext(needle)\n        print(next)\n\n\n        # 构造有限状态机\n        def kmp(s, next):  # 一个状态机\n            n = len(s)\n            state = {&#39;other&#39;:True}\n            for i in s:\n                state[i] = True\n\n            matrix = [{} for i in range(n+1)]\n\n            #初始化\n            for i in state:\n                matrix[0][i] = 0\n            matrix[0][s[0]] =1\n\n\n            # 归纳法进行递推\n            for i in range(1, n+1):\n\n                j = i\n                while j&gt; 0:\n                    if j &gt;= n:\n                        j = next[j]\n                        continue\n                    char = s[j]\n                    if char not in matrix[i]:\n                        matrix[i][char] = j+1\n                    j = next[j]\n                if j ==0:\n                    if s[0] not in matrix[i]:\n                        matrix[i][s[0]] =1\n                for k in state:\n                    if k not in matrix[i]:\n                        matrix[i][k] = 0\n            return matrix, state\n\n\n\n\n\n\n        m,state = kmp(needle, next)\n        for i in range(len(m)):\n            print(i, m[i])\n        print(m)\n\n\n        def search(txt):\n            N = len(txt)\n            l = len(needle)\n            stateNow = 0\n            for i in range(N):\n                char = txt[i]\n                if char in state:\n                    stateNow = m[stateNow][char]\n                else:\n                    stateNow = m[stateNow][&#39;other&#39;]\n\n                if stateNow == l:\n                    return i- l+1\n            return -1\n\n        print(search(haystack))\n        return search(haystack)\n\n\n\n\nSolution.strStr(None,&quot;ababcaababcaabc&quot;,\n&quot;ababcaabc&quot;)\n\n\n</code></pre>"},{"_content":"# 论文规范要记\n\n## tip\n\n1，各级标题要注意\n2，图片，表格，公式\n一般要居中，要记得编号，并且有格式：如图1所示\n关于图片数字：一般第n章，第i个图片命名为图片n-i\n公式命名为n.i\n例如\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/a30be67b5c7efb80ac6c9c123b5e02c7/5a0978e3dad91466d45d4d0e89058297.png)\n\n3，字体要尽量规范\n4，不同章节之间用分页符\n5，不同小段之间一行空开，段首两个空格\n\n6，摘要\n    摘要的内容不能乱写，\n    摘要三段论\n    - 为什么选这个题目\n    - 论文用什么方法解决什么问题\n    - 论文总结及展望\n\n7，文章中禁止出现我，我们，本文等这种主观性词汇\n\n\n\n## 结构\n\n## 绪论\n\n### 背景以及研究意义\n浅谈目前的社会，市场，发展，谈需求。进而引申出我们需要研究的领域\n\n### 国内外研究现状\n谈谈该领域各种方法的应用与研究现状，引申出目前仍有哪些不足\n\n### 小结\n总结上文，承上启下。浅谈本文所做的改进与研究\n\n\n## 相关技术综述\n\n### 介绍该领域的具体概念\n\n### 介绍某个经典算法，1,2,3\n\n### 小结\n承上启下，归纳应用价值，总结不足，引出改进方向\n\n## 我的研究方向\n\n讲述自己的研究内容\n\n\n## 总结与展望","source":"_posts/综合/论文规范要记.md","raw":"# 论文规范要记\n\n## tip\n\n1，各级标题要注意\n2，图片，表格，公式\n一般要居中，要记得编号，并且有格式：如图1所示\n关于图片数字：一般第n章，第i个图片命名为图片n-i\n公式命名为n.i\n例如\n![](https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/a30be67b5c7efb80ac6c9c123b5e02c7/5a0978e3dad91466d45d4d0e89058297.png)\n\n3，字体要尽量规范\n4，不同章节之间用分页符\n5，不同小段之间一行空开，段首两个空格\n\n6，摘要\n    摘要的内容不能乱写，\n    摘要三段论\n    - 为什么选这个题目\n    - 论文用什么方法解决什么问题\n    - 论文总结及展望\n\n7，文章中禁止出现我，我们，本文等这种主观性词汇\n\n\n\n## 结构\n\n## 绪论\n\n### 背景以及研究意义\n浅谈目前的社会，市场，发展，谈需求。进而引申出我们需要研究的领域\n\n### 国内外研究现状\n谈谈该领域各种方法的应用与研究现状，引申出目前仍有哪些不足\n\n### 小结\n总结上文，承上启下。浅谈本文所做的改进与研究\n\n\n## 相关技术综述\n\n### 介绍该领域的具体概念\n\n### 介绍某个经典算法，1,2,3\n\n### 小结\n承上启下，归纳应用价值，总结不足，引出改进方向\n\n## 我的研究方向\n\n讲述自己的研究内容\n\n\n## 总结与展望","slug":"综合/论文规范要记","published":1,"date":"2023-02-26T15:28:35.068Z","updated":"2023-02-27T11:34:33.135Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsydc00260gcnirrj5z1w","content":"<h1 id=\"论文规范要记\"><a href=\"#论文规范要记\" class=\"headerlink\" title=\"论文规范要记\"></a>论文规范要记</h1><h2 id=\"tip\"><a href=\"#tip\" class=\"headerlink\" title=\"tip\"></a>tip</h2><p>1，各级标题要注意<br>2，图片，表格，公式<br>一般要居中，要记得编号，并且有格式：如图1所示<br>关于图片数字：一般第n章，第i个图片命名为图片n-i<br>公式命名为n.i<br>例如<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/a30be67b5c7efb80ac6c9c123b5e02c7/5a0978e3dad91466d45d4d0e89058297.png\" alt></p>\n<p>3，字体要尽量规范<br>4，不同章节之间用分页符<br>5，不同小段之间一行空开，段首两个空格</p>\n<p>6，摘要<br>    摘要的内容不能乱写，<br>    摘要三段论<br>    - 为什么选这个题目<br>    - 论文用什么方法解决什么问题<br>    - 论文总结及展望</p>\n<p>7，文章中禁止出现我，我们，本文等这种主观性词汇</p>\n<h2 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h2><h2 id=\"绪论\"><a href=\"#绪论\" class=\"headerlink\" title=\"绪论\"></a>绪论</h2><h3 id=\"背景以及研究意义\"><a href=\"#背景以及研究意义\" class=\"headerlink\" title=\"背景以及研究意义\"></a>背景以及研究意义</h3><p>浅谈目前的社会，市场，发展，谈需求。进而引申出我们需要研究的领域</p>\n<h3 id=\"国内外研究现状\"><a href=\"#国内外研究现状\" class=\"headerlink\" title=\"国内外研究现状\"></a>国内外研究现状</h3><p>谈谈该领域各种方法的应用与研究现状，引申出目前仍有哪些不足</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>总结上文，承上启下。浅谈本文所做的改进与研究</p>\n<h2 id=\"相关技术综述\"><a href=\"#相关技术综述\" class=\"headerlink\" title=\"相关技术综述\"></a>相关技术综述</h2><h3 id=\"介绍该领域的具体概念\"><a href=\"#介绍该领域的具体概念\" class=\"headerlink\" title=\"介绍该领域的具体概念\"></a>介绍该领域的具体概念</h3><h3 id=\"介绍某个经典算法，1-2-3\"><a href=\"#介绍某个经典算法，1-2-3\" class=\"headerlink\" title=\"介绍某个经典算法，1,2,3\"></a>介绍某个经典算法，1,2,3</h3><h3 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>承上启下，归纳应用价值，总结不足，引出改进方向</p>\n<h2 id=\"我的研究方向\"><a href=\"#我的研究方向\" class=\"headerlink\" title=\"我的研究方向\"></a>我的研究方向</h2><p>讲述自己的研究内容</p>\n<h2 id=\"总结与展望\"><a href=\"#总结与展望\" class=\"headerlink\" title=\"总结与展望\"></a>总结与展望</h2>","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"论文规范要记\"><a href=\"#论文规范要记\" class=\"headerlink\" title=\"论文规范要记\"></a>论文规范要记</h1><h2 id=\"tip\"><a href=\"#tip\" class=\"headerlink\" title=\"tip\"></a>tip</h2><p>1，各级标题要注意<br>2，图片，表格，公式<br>一般要居中，要记得编号，并且有格式：如图1所示<br>关于图片数字：一般第n章，第i个图片命名为图片n-i<br>公式命名为n.i<br>例如<br><img src=\"https://raw.githubusercontent.com/kengerlwl/MDimg/master/image/a30be67b5c7efb80ac6c9c123b5e02c7/5a0978e3dad91466d45d4d0e89058297.png\" alt></p>\n<p>3，字体要尽量规范<br>4，不同章节之间用分页符<br>5，不同小段之间一行空开，段首两个空格</p>\n<p>6，摘要<br>    摘要的内容不能乱写，<br>    摘要三段论<br>    - 为什么选这个题目<br>    - 论文用什么方法解决什么问题<br>    - 论文总结及展望</p>\n<p>7，文章中禁止出现我，我们，本文等这种主观性词汇</p>\n<h2 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h2><h2 id=\"绪论\"><a href=\"#绪论\" class=\"headerlink\" title=\"绪论\"></a>绪论</h2><h3 id=\"背景以及研究意义\"><a href=\"#背景以及研究意义\" class=\"headerlink\" title=\"背景以及研究意义\"></a>背景以及研究意义</h3><p>浅谈目前的社会，市场，发展，谈需求。进而引申出我们需要研究的领域</p>\n<h3 id=\"国内外研究现状\"><a href=\"#国内外研究现状\" class=\"headerlink\" title=\"国内外研究现状\"></a>国内外研究现状</h3><p>谈谈该领域各种方法的应用与研究现状，引申出目前仍有哪些不足</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>总结上文，承上启下。浅谈本文所做的改进与研究</p>\n<h2 id=\"相关技术综述\"><a href=\"#相关技术综述\" class=\"headerlink\" title=\"相关技术综述\"></a>相关技术综述</h2><h3 id=\"介绍该领域的具体概念\"><a href=\"#介绍该领域的具体概念\" class=\"headerlink\" title=\"介绍该领域的具体概念\"></a>介绍该领域的具体概念</h3><h3 id=\"介绍某个经典算法，1-2-3\"><a href=\"#介绍某个经典算法，1-2-3\" class=\"headerlink\" title=\"介绍某个经典算法，1,2,3\"></a>介绍某个经典算法，1,2,3</h3><h3 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>承上启下，归纳应用价值，总结不足，引出改进方向</p>\n<h2 id=\"我的研究方向\"><a href=\"#我的研究方向\" class=\"headerlink\" title=\"我的研究方向\"></a>我的研究方向</h2><p>讲述自己的研究内容</p>\n<h2 id=\"总结与展望\"><a href=\"#总结与展望\" class=\"headerlink\" title=\"总结与展望\"></a>总结与展望</h2>"},{"_content":"# 长连接与短连接\n\n## 轮询与连接简介\n- 轮询：客户端定时向服务器发送Ajax请求，服务器接到请求后马上返回响应信息并关闭连接。\n优点：后端程序编写比较容易。\n缺点：请求中有大半是无用，浪费带宽和服务器资源。\n实例：适于小型应用。\n\n\n- 长轮询：客户端向服务器发送Ajax请求，服务器接到请求后hold住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。\n优点：在无消息的情况下不会频繁的请求，耗费资源小。\n缺点：服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护。\n实例：WebQQ、Hi网页版、Facebook IM。\n\n\n- 长连接：在页面里嵌入一个隐蔵iframe，将这个隐蔵iframe的src属性设为对一个长连接的请求或是采用xhr请求，服务器端就能源源不断地往客户端输入数据。\n优点：消息即时到达，不发无用请求；管理起来也相对方便。\n缺点：服务器维护一个长连接会增加开销。\n实例：Gmail聊天\n\n\n## 关于长轮询\n长轮询实际上就是一个普通额的http请求，但是并不会立刻返回消息，而且等待服务器处理，这中间并不断开连接，而是保持着，直到服务器响应客户端。\n\n关于使用redis进行阻塞实现长轮询。\n```\n        @app.route('/getPic',methods = ['GET'])\n        def getPic():\n            redis = self.task.redis\n            rep ={\n                'status':'no qrcode',\n                'content':None\n            }\n            if redis.llen('taskQueue') == 0: # 一个都没有则等待并阻塞\n                item = redis.blpop('taskQueue', timeout=30) # 因为返回的是元组\n```\nredis的队列pop有阻塞作用，可以维持住请求，实现长轮询。\n","source":"_posts/综合/长连接与短连接.md","raw":"# 长连接与短连接\n\n## 轮询与连接简介\n- 轮询：客户端定时向服务器发送Ajax请求，服务器接到请求后马上返回响应信息并关闭连接。\n优点：后端程序编写比较容易。\n缺点：请求中有大半是无用，浪费带宽和服务器资源。\n实例：适于小型应用。\n\n\n- 长轮询：客户端向服务器发送Ajax请求，服务器接到请求后hold住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。\n优点：在无消息的情况下不会频繁的请求，耗费资源小。\n缺点：服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护。\n实例：WebQQ、Hi网页版、Facebook IM。\n\n\n- 长连接：在页面里嵌入一个隐蔵iframe，将这个隐蔵iframe的src属性设为对一个长连接的请求或是采用xhr请求，服务器端就能源源不断地往客户端输入数据。\n优点：消息即时到达，不发无用请求；管理起来也相对方便。\n缺点：服务器维护一个长连接会增加开销。\n实例：Gmail聊天\n\n\n## 关于长轮询\n长轮询实际上就是一个普通额的http请求，但是并不会立刻返回消息，而且等待服务器处理，这中间并不断开连接，而是保持着，直到服务器响应客户端。\n\n关于使用redis进行阻塞实现长轮询。\n```\n        @app.route('/getPic',methods = ['GET'])\n        def getPic():\n            redis = self.task.redis\n            rep ={\n                'status':'no qrcode',\n                'content':None\n            }\n            if redis.llen('taskQueue') == 0: # 一个都没有则等待并阻塞\n                item = redis.blpop('taskQueue', timeout=30) # 因为返回的是元组\n```\nredis的队列pop有阻塞作用，可以维持住请求，实现长轮询。\n","slug":"综合/长连接与短连接","published":1,"date":"2023-02-26T15:28:35.069Z","updated":"2023-02-27T11:34:33.139Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clemqsydc00270gcnu3oszp33","content":"<h1 id=\"长连接与短连接\"><a href=\"#长连接与短连接\" class=\"headerlink\" title=\"长连接与短连接\"></a>长连接与短连接</h1><h2 id=\"轮询与连接简介\"><a href=\"#轮询与连接简介\" class=\"headerlink\" title=\"轮询与连接简介\"></a>轮询与连接简介</h2><ul>\n<li>轮询：客户端定时向服务器发送Ajax请求，服务器接到请求后马上返回响应信息并关闭连接。<br>优点：后端程序编写比较容易。<br>缺点：请求中有大半是无用，浪费带宽和服务器资源。<br>实例：适于小型应用。</li>\n</ul>\n<ul>\n<li>长轮询：客户端向服务器发送Ajax请求，服务器接到请求后hold住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。<br>优点：在无消息的情况下不会频繁的请求，耗费资源小。<br>缺点：服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护。<br>实例：WebQQ、Hi网页版、Facebook IM。</li>\n</ul>\n<ul>\n<li>长连接：在页面里嵌入一个隐蔵iframe，将这个隐蔵iframe的src属性设为对一个长连接的请求或是采用xhr请求，服务器端就能源源不断地往客户端输入数据。<br>优点：消息即时到达，不发无用请求；管理起来也相对方便。<br>缺点：服务器维护一个长连接会增加开销。<br>实例：Gmail聊天</li>\n</ul>\n<h2 id=\"关于长轮询\"><a href=\"#关于长轮询\" class=\"headerlink\" title=\"关于长轮询\"></a>关于长轮询</h2><p>长轮询实际上就是一个普通额的http请求，但是并不会立刻返回消息，而且等待服务器处理，这中间并不断开连接，而是保持着，直到服务器响应客户端。</p>\n<p>关于使用redis进行阻塞实现长轮询。</p>\n<pre><code>        @app.route(&#39;/getPic&#39;,methods = [&#39;GET&#39;])\n        def getPic():\n            redis = self.task.redis\n            rep ={\n                &#39;status&#39;:&#39;no qrcode&#39;,\n                &#39;content&#39;:None\n            }\n            if redis.llen(&#39;taskQueue&#39;) == 0: # 一个都没有则等待并阻塞\n                item = redis.blpop(&#39;taskQueue&#39;, timeout=30) # 因为返回的是元组</code></pre><p>redis的队列pop有阻塞作用，可以维持住请求，实现长轮询。</p>\n","site":{"data":{"musics":[{"name":"夜曲","artist":"周杰伦","url":"/medias/music/yequ.mp3","cover":"/medias/music/avatars/yequ.jpg"},{"name":"一路向北","artist":"周杰伦","url":"/medias/music/yiluxiangbei.mp3","cover":"/medias/music/avatars/yiluxiangbei.jpg"},{"name":"来自天堂的魔鬼","artist":"邓紫棋","url":"/medias/music/tiantangdemogui.mp3","cover":"/medias/music/avatars/tiantangdemogui.jpg"},{"name":"倒数","artist":"邓紫棋","url":"/medias/music/daoshu.mp3","cover":"/medias/music/avatars/daoshu.jpg"}],"friends":[{"name":"知乎专栏","url":"https://www.zhihu.com/people/xing-zhe-55-44-13","title":"访问主页","introduction":"个人技术博客","avatar":"/medias/avatars/myzhihu.png"}]}},"excerpt":"","more":"<h1 id=\"长连接与短连接\"><a href=\"#长连接与短连接\" class=\"headerlink\" title=\"长连接与短连接\"></a>长连接与短连接</h1><h2 id=\"轮询与连接简介\"><a href=\"#轮询与连接简介\" class=\"headerlink\" title=\"轮询与连接简介\"></a>轮询与连接简介</h2><ul>\n<li>轮询：客户端定时向服务器发送Ajax请求，服务器接到请求后马上返回响应信息并关闭连接。<br>优点：后端程序编写比较容易。<br>缺点：请求中有大半是无用，浪费带宽和服务器资源。<br>实例：适于小型应用。</li>\n</ul>\n<ul>\n<li>长轮询：客户端向服务器发送Ajax请求，服务器接到请求后hold住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。<br>优点：在无消息的情况下不会频繁的请求，耗费资源小。<br>缺点：服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护。<br>实例：WebQQ、Hi网页版、Facebook IM。</li>\n</ul>\n<ul>\n<li>长连接：在页面里嵌入一个隐蔵iframe，将这个隐蔵iframe的src属性设为对一个长连接的请求或是采用xhr请求，服务器端就能源源不断地往客户端输入数据。<br>优点：消息即时到达，不发无用请求；管理起来也相对方便。<br>缺点：服务器维护一个长连接会增加开销。<br>实例：Gmail聊天</li>\n</ul>\n<h2 id=\"关于长轮询\"><a href=\"#关于长轮询\" class=\"headerlink\" title=\"关于长轮询\"></a>关于长轮询</h2><p>长轮询实际上就是一个普通额的http请求，但是并不会立刻返回消息，而且等待服务器处理，这中间并不断开连接，而是保持着，直到服务器响应客户端。</p>\n<p>关于使用redis进行阻塞实现长轮询。</p>\n<pre><code>        @app.route(&#39;/getPic&#39;,methods = [&#39;GET&#39;])\n        def getPic():\n            redis = self.task.redis\n            rep ={\n                &#39;status&#39;:&#39;no qrcode&#39;,\n                &#39;content&#39;:None\n            }\n            if redis.llen(&#39;taskQueue&#39;) == 0: # 一个都没有则等待并阻塞\n                item = redis.blpop(&#39;taskQueue&#39;, timeout=30) # 因为返回的是元组</code></pre><p>redis的队列pop有阻塞作用，可以维持住请求，实现长轮询。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}